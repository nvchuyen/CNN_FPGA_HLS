# 1 "pooling_layer2.cpp"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 395 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\etc/autopilot_ssdm_op.h" 1
# 158 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\etc/autopilot_ssdm_op.h"
extern "C" {






    void _ssdm_op_IfRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_IfWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_IfNbRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_IfNbWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_IfCanRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_IfCanWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));


    void _ssdm_StreamRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_StreamWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_StreamNbRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_StreamNbWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_StreamCanRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_StreamCanWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned _ssdm_StreamSize(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_ReadReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_Read(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_WriteReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_Write(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_NbReadReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_NbWriteReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));




    void _ssdm_op_MemShiftRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_Wait(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_Poll(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_Return(...) __attribute__ ((nothrow)) __attribute__((overloadable));


    void _ssdm_op_SpecSynModule(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecTopModule(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecProcessDecl(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecProcessDef(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecPort(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecConnection(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecChannel(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecSensitive(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecModuleInst(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecPortMap(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecReset(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecPlatform(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecClockDomain(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecPowerDomain(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    int _ssdm_op_SpecRegionBegin(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    int _ssdm_op_SpecRegionEnd(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecLoopName(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecLoopTripCount(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    int _ssdm_op_SpecStateBegin(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    int _ssdm_op_SpecStateEnd(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecInterface(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecPipeline(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecDataflowPipeline(...) __attribute__ ((nothrow)) __attribute__((overloadable));


    void _ssdm_op_SpecLatency(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecParallel(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecProtocol(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecOccurrence(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecResource(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecResourceLimit(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecCHCore(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecFUCore(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecIFCore(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecIPCore(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecKeepValue(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecMemCore(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecExt(...) __attribute__ ((nothrow)) __attribute__((overloadable));




    void _ssdm_SpecArrayDimSize(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_RegionBegin(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_RegionEnd(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_Unroll(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_UnrollRegion(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_InlineAll(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_InlineLoop(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_Inline(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_InlineSelf(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_InlineRegion(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecArrayMap(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecArrayPartition(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecArrayReshape(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecStream(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecStable(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecStableContent(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecBindPort(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecPipoDepth(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecExpr(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecExprBalance(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecDependence(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecLoopMerge(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecLoopFlatten(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecLoopRewind(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecFuncInstantiation(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecFuncBuffer(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecFuncExtract(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecConstant(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_DataPack(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecDataPack(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecBitsMap(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecLicense(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void __xilinx_ip_top(...) __attribute__ ((nothrow)) __attribute__((overloadable));


}
# 2 "<built-in>" 2
# 1 "pooling_layer2.cpp" 2

# 1 "./headers1/buffer.h" 1
# 23 "./headers1/buffer.h"
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed.h" 1
# 55 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed.h"
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_common.h" 1
# 57 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_common.h"
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_decl.h" 1
# 100 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_decl.h"
enum ap_q_mode {
  AP_RND,
  AP_RND_ZERO,
  AP_RND_MIN_INF,
  AP_RND_INF,
  AP_RND_CONV,
  AP_TRN,
  AP_TRN_ZERO,
};
# 122 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_decl.h"
enum ap_o_mode {
  AP_SAT,
  AP_SAT_ZERO,
  AP_SAT_SYM,
  AP_WRAP,
  AP_WRAP_SM,
};
# 179 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_decl.h"
template <int _AP_W, bool _AP_S>
struct ap_int_base;

template <int _AP_W>
struct ap_int;

template <int _AP_W>
struct ap_uint;

template <int _AP_W, bool _AP_S>
struct ap_range_ref;

template <int _AP_W, bool _AP_S>
struct ap_bit_ref;

template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2>
struct ap_concat_ref;

template <int _AP_W, int _AP_I, bool _AP_S = true, ap_q_mode _AP_Q = AP_TRN,
          ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>
struct ap_fixed_base;

template <int _AP_W, int _AP_I, ap_q_mode _AP_Q = AP_TRN,
          ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>
struct ap_fixed;

template <int _AP_W, int _AP_I, ap_q_mode _AP_Q = AP_TRN,
          ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>
struct ap_ufixed;

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_range_ref;

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_bit_ref;


enum BaseMode { AP_BIN = 2, AP_OCT = 8, AP_DEC = 10, AP_HEX = 16 };
# 233 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_decl.h"
typedef signed long long ap_slong;
typedef unsigned long long ap_ulong;


enum {
  _AP_SIZE_char = 8,
  _AP_SIZE_short = sizeof(short) * 8,
  _AP_SIZE_int = sizeof(int) * 8,
  _AP_SIZE_long = sizeof(long) * 8,
  _AP_SIZE_ap_slong = sizeof(ap_slong) * 8
};
# 58 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_common.h" 2
# 162 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_common.h"
enum { CHAR_IS_SIGNED = (char)-1 < 0 };


namespace _ap_type {
template <typename _Tp>
struct is_signed {
  static const bool value = _Tp(-1) < _Tp(1);
};

template <typename _Tp>
struct is_integral {
  static const bool value = false;
};





template <> struct is_integral<bool> { static const bool value = true; };
template <> struct is_integral<char> { static const bool value = true; };
template <> struct is_integral<signed char> { static const bool value = true; };
template <> struct is_integral<unsigned char> { static const bool value = true; };
template <> struct is_integral<short> { static const bool value = true; };
template <> struct is_integral<unsigned short> { static const bool value = true; };
template <> struct is_integral<int> { static const bool value = true; };
template <> struct is_integral<unsigned int> { static const bool value = true; };
template <> struct is_integral<long> { static const bool value = true; };
template <> struct is_integral<unsigned long> { static const bool value = true; };
template <> struct is_integral<ap_slong> { static const bool value = true; };
template <> struct is_integral<ap_ulong> { static const bool value = true; };


template <bool, typename _Tp = void>
struct enable_if {};

template <typename _Tp>
struct enable_if<true, _Tp> {
  typedef _Tp type;
};

template <typename _Tp>
struct remove_const {
  typedef _Tp type;
};

template <typename _Tp>
struct remove_const<_Tp const> {
  typedef _Tp type;
};
}
# 501 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_common.h"
template <int _AP_N, bool _AP_S>
struct ssdm_int;

template <int _AP_N>
struct ssdm_int<_AP_N, true> {
  int V __attribute__((bitwidth(_AP_N)));
  inline __attribute__((always_inline)) ssdm_int<_AP_N, true>(){};
};

template <int _AP_N>
struct ssdm_int<_AP_N, false> {
  unsigned V __attribute__((bitwidth(_AP_N)));
  inline __attribute__((always_inline)) ssdm_int<_AP_N, false>(){};
};
# 567 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_common.h"
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/etc/autopilot_ssdm_bits.h" 1
# 568 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_common.h" 2

extern "C" void _ssdm_string2bits(...);
# 579 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_common.h"
static inline unsigned char guess_radix(const char* s) {
  unsigned char rd = 10;
  const char* p = s;

  if (p[0] == '-' || p[0] == '+') ++p;

  if (p[0] == '0') {
    if (p[1] == 'b' || p[1] == 'B') {
      rd = 2;
    } else if (p[1] == 'o' || p[1] == 'O') {
      rd = 8;
    } else if (p[1] == 'x' || p[1] == 'X') {
      rd = 16;
    } else if (p[1] == 'd' || p[1] == 'D') {
      rd = 10;
    }
  }
  return rd;
}







typedef __fp16 half;
# 696 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_common.h"
inline __attribute__((always_inline)) ap_ulong doubleToRawBits(double pf) {
  union {
    ap_ulong __L;
    double __D;
  } LD;
  LD.__D = pf;
  return LD.__L;
}

inline __attribute__((always_inline)) unsigned int floatToRawBits(float pf) {
  union {
    unsigned int __L;
    float __D;
  } LD;
  LD.__D = pf;
  return LD.__L;
}

inline __attribute__((always_inline)) unsigned short halfToRawBits(half pf) {

  union {
    unsigned short __L;
    half __D;
  } LD;
  LD.__D = pf;
  return LD.__L;



}


inline __attribute__((always_inline)) double rawBitsToDouble(ap_ulong pi) {
  union {
    ap_ulong __L;
    double __D;
  } LD;
  LD.__L = pi;
  return LD.__D;
}


inline __attribute__((always_inline)) float rawBitsToFloat(unsigned long pi) {
  union {
    unsigned int __L;
    float __D;
  } LD;
  LD.__L = pi;
  return LD.__D;
}


inline __attribute__((always_inline)) half rawBitsToHalf(unsigned short pi) {

  union {
    unsigned short __L;
    half __D;
  } LD;
  LD.__L = pi;
  return LD.__D;






}
# 56 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed.h" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_base.h" 1
# 62 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_base.h"
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int.h" 1
# 56 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int.h"
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_base.h" 1
# 80 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_N, bool _AP_S>
struct retval;


template <int _AP_N>
struct retval<_AP_N, true> {
  typedef ap_slong Type;
};

template <int _AP_N>
struct retval<_AP_N, false> {
  typedef ap_ulong Type;
};


template <>
struct retval<1, true> {
  typedef signed char Type;
};

template <>
struct retval<1, false> {
  typedef unsigned char Type;
};


template <>
struct retval<2, true> {
  typedef short Type;
};

template <>
struct retval<2, false> {
  typedef unsigned short Type;
};


template <>
struct retval<3, true> {
  typedef long Type;
};

template <>
struct retval<3, false> {
  typedef unsigned long Type;
};

template <>
struct retval<4, true> {
  typedef long Type;
};

template <>
struct retval<4, false> {
  typedef unsigned long Type;
};




template <int _AP_W2, bool _AP_S2>
struct _ap_int_factory;
template <int _AP_W2>
struct _ap_int_factory<_AP_W2,true> { typedef ap_int<_AP_W2> type; };
template <int _AP_W2>
struct _ap_int_factory<_AP_W2,false> { typedef ap_uint<_AP_W2> type; };

template <int _AP_W, bool _AP_S>
struct ap_int_base : public ssdm_int<_AP_W, _AP_S> {
 public:
  typedef ssdm_int<_AP_W, _AP_S> Base;







  typedef typename retval<(((_AP_W + 7) / 8) > (8) ? ((_AP_W + 7) / 8) : (8)), _AP_S>::Type RetType;

  static const int width = _AP_W;

  template <int _AP_W2, bool _AP_S2>
  struct RType {
    enum {
      mult_w = _AP_W + _AP_W2,
      mult_s = _AP_S || _AP_S2,
      plus_w =
          ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))) + 1,
      plus_s = _AP_S || _AP_S2,
      minus_w =
          ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))) + 1,
      minus_s = true,
      div_w = _AP_W + _AP_S2,
      div_s = _AP_S || _AP_S2,
      mod_w = ((_AP_W) < (_AP_W2 + (!_AP_S2 && _AP_S)) ? (_AP_W) : (_AP_W2 + (!_AP_S2 && _AP_S))),
      mod_s = _AP_S,
      logic_w = ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))),
      logic_s = _AP_S || _AP_S2
    };


    typedef ap_int_base<mult_w, mult_s> mult_base;
    typedef ap_int_base<plus_w, plus_s> plus_base;
    typedef ap_int_base<minus_w, minus_s> minus_base;
    typedef ap_int_base<logic_w, logic_s> logic_base;
    typedef ap_int_base<div_w, div_s> div_base;
    typedef ap_int_base<mod_w, mod_s> mod_base;
    typedef ap_int_base<_AP_W, _AP_S> arg1_base;

    typedef typename _ap_int_factory<mult_w, mult_s>::type mult;
    typedef typename _ap_int_factory<plus_w, plus_s>::type plus;
    typedef typename _ap_int_factory<minus_w, minus_s>::type minus;
    typedef typename _ap_int_factory<logic_w, logic_s>::type logic;
    typedef typename _ap_int_factory<div_w, div_s>::type div;
    typedef typename _ap_int_factory<mod_w, mod_s>::type mod;
    typedef typename _ap_int_factory<_AP_W, _AP_S>::type arg1;
    typedef bool reduce;
  };





  inline __attribute__((always_inline)) ap_int_base() {





  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int_base(const ap_int_base<_AP_W2, _AP_S2>& op) {
    Base::V = op.V;
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int_base(const volatile ap_int_base<_AP_W2, _AP_S2>& op) {
    Base::V = op.V;
  }
# 237 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_base.h"
  inline __attribute__((always_inline)) ap_int_base(const bool op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const char op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const signed char op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const unsigned char op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const short op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const unsigned short op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const int op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const unsigned int op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const long op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const unsigned long op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const ap_slong op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const ap_ulong op) { Base::V = op; }




  inline __attribute__((always_inline)) ap_int_base(half op) {
    ap_int_base<_AP_W, _AP_S> t((float)op);
    Base::V = t.V;
  }


  inline __attribute__((always_inline)) ap_int_base(float op) {
    const int BITS = 23 + 8 + 1;
    ap_int_base<BITS, false> reg;
    reg.V = floatToRawBits(op);
    bool is_neg = ({ typeof(reg.V) __Val2__ = reg.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), BITS - 1); __Result__; });

    ap_int_base<8 + 1, true> exp = 0;
    exp.V = ({ typename _ap_type::remove_const<typeof(reg.V)>::type __Result__ = 0; typeof(reg.V) __Val2__ = reg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 23, BITS - 2); __Result__; });
    exp = exp - ((1L << (8 - 1L)) - 1L);

    ap_int_base<23 + 2, true> man;
    man.V = ({ typename _ap_type::remove_const<typeof(reg.V)>::type __Result__ = 0; typeof(reg.V) __Val2__ = reg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, 23 - 1); __Result__; });

    (static_cast<void>(0));


    man.V = ({ typename _ap_type::remove_const<typeof(man.V)>::type __Result__ = 0; typeof(man.V) __Val2__ = man.V; typeof(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 23, 23); __Result__; });


    if ((reg.V & 0x7ffffffful) == 0) {
      Base::V = 0;
    } else {
      int sh_amt = 23 - exp.V;
      if (sh_amt == 0) {
        Base::V = man.V;
      } else if (sh_amt > 0) {
        if (sh_amt < 23 + 2) {
          Base::V = man.V >> sh_amt;
        } else {
            Base::V = 0;
        }
      } else {
        sh_amt = -sh_amt;
        if (sh_amt < _AP_W) {
          Base::V = man.V;
          Base::V <<= sh_amt;
        } else {
          Base::V = 0;
        }
      }
    }
    if (is_neg) *this = -(*this);
  }


  inline __attribute__((always_inline)) ap_int_base(double op) {
    const int BITS = 52 + 11 + 1;
    ap_int_base<BITS, false> reg;
    reg.V = doubleToRawBits(op);
    bool is_neg = ({ typeof(reg.V) __Val2__ = reg.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), BITS - 1); __Result__; });

    ap_int_base<11 + 1, true> exp = 0;
    exp.V = ({ typename _ap_type::remove_const<typeof(reg.V)>::type __Result__ = 0; typeof(reg.V) __Val2__ = reg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 52, BITS - 2); __Result__; });
    exp = exp - ((1L << (11 - 1L)) - 1L);

    ap_int_base<52 + 2, true> man;
    man.V = ({ typename _ap_type::remove_const<typeof(reg.V)>::type __Result__ = 0; typeof(reg.V) __Val2__ = reg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, 52 - 1); __Result__; });

    (static_cast<void>(0));


    man.V = ({ typename _ap_type::remove_const<typeof(man.V)>::type __Result__ = 0; typeof(man.V) __Val2__ = man.V; typeof(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 52, 52); __Result__; });


    if ((reg.V & 0x7fffffffffffffffull) == 0) {
      Base::V = 0;
    } else {
      int sh_amt = 52 - exp.V;
      if (sh_amt == 0) {
        Base::V = man.V;
      } else if (sh_amt > 0) {
        if (sh_amt < 52 + 2) {
          Base::V = man.V >> sh_amt;
        } else {
           Base::V = 0;
        }
      } else {
        sh_amt = -sh_amt;
        if (sh_amt < _AP_W) {
          Base::V = man.V;
          Base::V <<= sh_amt;
        } else {
          Base::V = 0;
        }
      }
    }
    if (is_neg) *this = -(*this);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_int_base(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    Base::V = op.to_ap_int_base().V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int_base(const ap_range_ref<_AP_W2, _AP_S2>& ref) {
    Base::V = (ref.get()).V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int_base(const ap_bit_ref<_AP_W2, _AP_S2>& ref) {
    Base::V = ref.operator bool();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_int_base(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref) {
    const ap_int_base<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>::_AP_WR,
                      false>
        tmp = ref.get();
    Base::V = tmp.V;
  }
# 385 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_base.h"
  inline __attribute__((always_inline)) ap_int_base(const char* s) {
    typeof(Base::V) t;
    _ssdm_string2bits((void*)(&t), (const char*)(s), 10, _AP_W, _AP_S,
                      AP_TRN, AP_WRAP, 0, true);
    Base::V = t;
  }
  inline __attribute__((always_inline)) ap_int_base(const char* s, signed char rd) {
    typeof(Base::V) t;
    _ssdm_string2bits((void*)(&t), (const char*)(s), rd, _AP_W, _AP_S,
                      AP_TRN, AP_WRAP, 0, true);
    Base::V = t;
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_int_base(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    Base::V = (val.get()).V;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_int_base(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    Base::V = val.operator bool();
  }

  inline __attribute__((always_inline)) ap_int_base read() volatile {

    ap_int_base ret;
    ret.V = Base::V;
    return ret;
  }

  inline __attribute__((always_inline)) void write(const ap_int_base<_AP_W, _AP_S>& op2) volatile {

    Base::V = op2.V;
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) void operator=(
      const volatile ap_int_base<_AP_W2, _AP_S2>& op2) volatile {
    Base::V = op2.V;
  }

  inline __attribute__((always_inline)) void operator=(
      const volatile ap_int_base<_AP_W, _AP_S>& op2) volatile {
    Base::V = op2.V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) void operator=(const ap_int_base<_AP_W2, _AP_S2>& op2) volatile {
    Base::V = op2.V;
  }

  inline __attribute__((always_inline)) void operator=(const ap_int_base<_AP_W, _AP_S>& op2) volatile {
    Base::V = op2.V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int_base& operator=(
      const volatile ap_int_base<_AP_W2, _AP_S2>& op2) {
    Base::V = op2.V;
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int_base& operator=(const ap_int_base<_AP_W2, _AP_S2>& op2) {
    Base::V = op2.V;
    return *this;
  }

  inline __attribute__((always_inline)) ap_int_base& operator=(const volatile ap_int_base<_AP_W, _AP_S>& op2) {
    Base::V = op2.V;
    return *this;
  }

  ap_int_base& operator=(const ap_int_base<_AP_W, _AP_S>& op2) = default;







  inline __attribute__((always_inline)) ap_int_base& operator=(bool op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(char op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(signed char op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(unsigned char op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(short op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(unsigned short op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(int op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(unsigned int op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(long op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(unsigned long op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(ap_slong op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(ap_ulong op) { Base::V = op; return *this; }



  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int_base& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& op2) {
    Base::V = (bool)op2;
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int_base& operator=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    Base::V = (ap_int_base<_AP_W2, false>(op2)).V;
    return *this;
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_int_base& operator=(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op2) {
    Base::V = op2.get().V;
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_int_base& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    Base::V = op.to_ap_int_base().V;
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_int_base& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    Base::V = (bool)op;
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_int_base& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    Base::V = ((const ap_int_base<_AP_W2, false>)(op)).V;
    return *this;
  }





  inline __attribute__((always_inline)) operator RetType() const { return (RetType)(Base::V); }




  inline __attribute__((always_inline)) bool to_bool() const { return (bool)(Base::V); }
  inline __attribute__((always_inline)) char to_char() const { return (char)(Base::V); }
  inline __attribute__((always_inline)) signed char to_schar() const { return (signed char)(Base::V); }
  inline __attribute__((always_inline)) unsigned char to_uchar() const { return (unsigned char)(Base::V); }
  inline __attribute__((always_inline)) short to_short() const { return (short)(Base::V); }
  inline __attribute__((always_inline)) unsigned short to_ushort() const { return (unsigned short)(Base::V); }
  inline __attribute__((always_inline)) int to_int() const { return (int)(Base::V); }
  inline __attribute__((always_inline)) unsigned to_uint() const { return (unsigned)(Base::V); }
  inline __attribute__((always_inline)) long to_long() const { return (long)(Base::V); }
  inline __attribute__((always_inline)) unsigned long to_ulong() const { return (unsigned long)(Base::V); }
  inline __attribute__((always_inline)) ap_slong to_int64() const { return (ap_slong)(Base::V); }
  inline __attribute__((always_inline)) ap_ulong to_uint64() const { return (ap_ulong)(Base::V); }
  inline __attribute__((always_inline)) half to_half() const { return (float)(Base::V); }
  inline __attribute__((always_inline)) float to_float() const { return (float)(Base::V); }
  inline __attribute__((always_inline)) double to_double() const { return (double)(Base::V); }
# 577 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_base.h"
  inline __attribute__((always_inline)) int length() const volatile { return _AP_W; }


  inline __attribute__((always_inline)) bool iszero() const { return Base::V == 0; }


  inline __attribute__((always_inline)) bool is_zero() const { return Base::V == 0; }


  inline __attribute__((always_inline)) bool sign() const {
    if (_AP_S &&
        ({ typeof(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; }))
      return true;
    else
      return false;
  }


  inline __attribute__((always_inline)) void clear(int i) {
                                                           ;
    Base::V = ({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(0) __Repl2__ = !!0; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
  }


  inline __attribute__((always_inline)) void invert(int i) {
                                                           ;
    bool val = ({ typeof(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
    if (val)
      Base::V = ({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(0) __Repl2__ = !!0; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
    else
      Base::V = ({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
  }

  inline __attribute__((always_inline)) bool test(int i) const {
                                                           ;
    return ({ typeof(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
  }


  inline __attribute__((always_inline)) ap_int_base& get() { return *this; }


  inline __attribute__((always_inline)) void set(int i) {
                                                           ;
    Base::V = ({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
  }


  inline __attribute__((always_inline)) void set(int i, bool v) {
                                                           ;
    Base::V = ({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(v) __Repl2__ = !!v; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
  }



  inline __attribute__((always_inline)) ap_int_base& lrotate(int n) {
                                                              ;


    typeof(Base::V) l_p = Base::V << n;
    typeof(Base::V) r_p = Base::V >> (_AP_W - n);
    Base::V = l_p | r_p;



    return *this;
  }



  inline __attribute__((always_inline)) ap_int_base& rrotate(int n) {
                                                              ;


    typeof(Base::V) l_p = Base::V << (_AP_W - n);
    typeof(Base::V) r_p = Base::V >> n;
    Base::V = l_p | r_p;



    return *this;
  }



  inline __attribute__((always_inline)) ap_int_base& reverse() {
    Base::V = ({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - 1, 0); __Result__; });
    return *this;
  }


  inline __attribute__((always_inline)) void set_bit(int i, bool v) {
    Base::V = ({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(v) __Repl2__ = !!v; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
  }


  inline __attribute__((always_inline)) bool get_bit(int i) const {
    return (bool)({ typeof(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
  }


  inline __attribute__((always_inline)) void b_not() { Base::V = ~Base::V; }
# 690 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_base.h"
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator *=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V *= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator +=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V += op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator -=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V -= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator /=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V /= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator %=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V %= op2.V; return *this; }
# 708 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_base.h"
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator &=(const ap_int_base<_AP_W2, _AP_S2>& op2) { (static_cast<void>(0)); Base::V &= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator |=(const ap_int_base<_AP_W2, _AP_S2>& op2) { (static_cast<void>(0)); Base::V |= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator ^=(const ap_int_base<_AP_W2, _AP_S2>& op2) { (static_cast<void>(0)); Base::V ^= op2.V; return *this; }





  inline __attribute__((always_inline)) ap_int_base& operator++() {
    operator+=((ap_int_base<1, false>)1);
    return *this;
  }
  inline __attribute__((always_inline)) ap_int_base& operator--() {
    operator-=((ap_int_base<1, false>)1);
    return *this;
  }




  inline __attribute__((always_inline)) const typename RType<_AP_W,_AP_S>::arg1 operator++(int) {
    ap_int_base t = *this;
    operator+=((ap_int_base<1, false>)1);
    return t;
  }
  inline __attribute__((always_inline)) const typename RType<_AP_W,_AP_S>::arg1 operator--(int) {
    ap_int_base t = *this;
    operator-=((ap_int_base<1, false>)1);
    return t;
  }




  inline __attribute__((always_inline)) typename RType<_AP_W,_AP_S>::arg1 operator+() const { return *this; }


  inline __attribute__((always_inline)) typename RType<1, false>::minus operator-() const {
    return ap_int_base<1, false>(0) - *this;
  }




  inline __attribute__((always_inline)) bool operator!() const { return Base::V == 0; }





  inline __attribute__((always_inline)) typename RType<_AP_W,_AP_S>::arg1 operator~() const {
    ap_int_base<_AP_W, _AP_S> r;
    r.V = ~Base::V;
    return r;
  }




  template <int _AP_W2>
  inline __attribute__((always_inline)) typename RType<_AP_W,_AP_S>::arg1 operator<<(const ap_int_base<_AP_W2, true>& op2) const {
    bool isNeg = ({ typeof(op2.V) __Val2__ = op2.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W2 - 1); __Result__; });
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator>>(sh);
    } else
      return operator<<(sh);
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) typename RType<_AP_W,_AP_S>::arg1 operator<<(const ap_int_base<_AP_W2, false>& op2) const {
    ap_int_base r;
    r.V = Base::V << op2.to_uint();
    return r;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) typename RType<_AP_W,_AP_S>::arg1 operator>>(const ap_int_base<_AP_W2, true>& op2) const {
    bool isNeg = ({ typeof(op2.V) __Val2__ = op2.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W2 - 1); __Result__; });
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator<<(sh);
    }
    return operator>>(sh);
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) typename RType<_AP_W,_AP_S>::arg1 operator>>(const ap_int_base<_AP_W2, false>& op2) const {
    ap_int_base r;
    r.V = Base::V >> op2.to_uint();
    return r;
  }
# 819 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_base.h"
  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_int_base& operator<<=(const ap_int_base<_AP_W2, true>& op2) {
    bool isNeg = ({ typeof(op2.V) __Val2__ = op2.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W2 - 1); __Result__; });
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator>>=(sh);
    } else
      return operator<<=(sh);
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_int_base& operator<<=(const ap_int_base<_AP_W2, false>& op2) {
    Base::V <<= op2.to_uint();
    return *this;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_int_base& operator>>=(const ap_int_base<_AP_W2, true>& op2) {
    bool isNeg = ({ typeof(op2.V) __Val2__ = op2.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W2 - 1); __Result__; });
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator<<=(sh);
    }
    return operator>>=(sh);
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_int_base& operator>>=(const ap_int_base<_AP_W2, false>& op2) {
    Base::V >>= op2.to_uint();
    return *this;
  }
# 868 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_base.h"
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator==(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V == op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator!=(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return !(Base::V == op2.V);
  }
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator<(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V < op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator>=(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V >= op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator>(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V > op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator<=(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V <= op2.V;
  }




  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return ap_range_ref<_AP_W, _AP_S>(this, Hi, Lo);
  }


  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) const {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return ap_range_ref<_AP_W, _AP_S>(const_cast<ap_int_base*>(this), Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> range() {
    return this->range(_AP_W - 1, 0);
  }

  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> range() const {
    return this->range(_AP_W - 1, 0);
  }

  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) {
    return this->range(Hi, Lo);
  }

  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) const {
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }
# 977 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_base.h"
  inline __attribute__((always_inline)) ap_bit_ref<_AP_W, _AP_S> operator[](int index) {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index);
    return bvh;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_bit_ref<_AP_W, _AP_S> operator[](
      const ap_int_base<_AP_W2, _AP_S2>& index) {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index.to_int());
    return bvh;
  }

  inline __attribute__((always_inline)) bool operator[](int index) const {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> br(this, index);
    return br.to_bool();
  }
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator[](const ap_int_base<_AP_W2, _AP_S2>& index) const {
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> br(this, index.to_int());
    return br.to_bool();
  }

  inline __attribute__((always_inline)) ap_bit_ref<_AP_W, _AP_S> bit(int index) {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index);
    return bvh;
  }
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_bit_ref<_AP_W, _AP_S> bit(
      const ap_int_base<_AP_W2, _AP_S2>& index) {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index.to_int());
    return bvh;
  }

  inline __attribute__((always_inline)) bool bit(int index) const {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> br(this, index);
    return br.to_bool();
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool bit(const ap_int_base<_AP_W2, _AP_S2>& index) const {
    return bit(index.to_int());
  }
# 1044 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_base.h"
  inline __attribute__((always_inline)) int countLeadingZeros() {

    if (_AP_W <= 32) {
      ap_int_base<32, false> t(-1UL), x;
      x.V = ({ typename _ap_type::remove_const<typeof(this->V)>::type __Result__ = 0; typeof(this->V) __Val2__ = this->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - 1, 0); __Result__; });
      t.V = ({ typename _ap_type::remove_const<typeof(t.V)>::type __Result__ = 0; typeof(t.V) __Val2__ = t.V; typeof(x.V) __Repl2__ = x.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 0, _AP_W - 1); __Result__; });
      return __builtin_ctz(t.V);
    } else if (_AP_W <= 64) {
      ap_int_base<64, false> t(-1ULL);
      ap_int_base<64, false> x;
      x.V = ({ typename _ap_type::remove_const<typeof(this->V)>::type __Result__ = 0; typeof(this->V) __Val2__ = this->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - 1, 0); __Result__; });
      t.V = ({ typename _ap_type::remove_const<typeof(t.V)>::type __Result__ = 0; typeof(t.V) __Val2__ = t.V; typeof(x.V) __Repl2__ = x.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 0, _AP_W - 1); __Result__; });
      return __builtin_ctzll(t.V);
    } else {
      enum { __N = (_AP_W + 63) / 64 };
      int NZeros = 0;
      int i = 0;
      bool hitNonZero = false;
      VITIS_LOOP_1062_1: for (i = 0; i < __N - 1; ++i) {
        ap_int_base<64, false> t;
        t.V = ({ typename _ap_type::remove_const<typeof(this->V)>::type __Result__ = 0; typeof(this->V) __Val2__ = this->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - i * 64 - 64, _AP_W - i * 64 - 1); __Result__; });
        NZeros += hitNonZero ? 0 : __builtin_clzll(t.V);
        hitNonZero |= (t.V != 0);
      }
      if (!hitNonZero) {
        ap_int_base<64, false> t(-1ULL);
        enum { REST = (_AP_W - 1) % 64 };
        ap_int_base<64, false> x;
        x.V = ({ typename _ap_type::remove_const<typeof(this->V)>::type __Result__ = 0; typeof(this->V) __Val2__ = this->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, REST); __Result__; });
        t.V = ({ typename _ap_type::remove_const<typeof(t.V)>::type __Result__ = 0; typeof(t.V) __Val2__ = t.V; typeof(x.V) __Repl2__ = x.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 63 - REST, 63); __Result__; });
        NZeros += __builtin_clzll(t.V);
      }
      return NZeros;
    }



  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  concat(const ap_int_base<_AP_W2, _AP_S2>& a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  concat(ap_int_base<_AP_W2, _AP_S2>& a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
      operator,(const ap_range_ref<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
      operator,(ap_range_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this), a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(const ap_bit_ref<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(ap_bit_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, a2);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(a2));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,
                                                                         a2);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_concat_ref<
      _AP_W, ap_int_base, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                &a2) const {
    return ap_concat_ref<
        _AP_W, ap_int_base, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<
            af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_concat_ref<
      _AP_W, ap_int_base, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<
        _AP_W, ap_int_base, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                                                                       a2);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_int_base, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                    &a2) const {
    return ap_concat_ref<
        _AP_W, ap_int_base, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_int_base, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(
          af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<
        _AP_W, ap_int_base, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this, a2);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_int_base<((_AP_W2 + _AP_W3) > (_AP_W) ? (_AP_W2 + _AP_W3) : (_AP_W)), _AP_S> operator&(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
    return *this & a2.get();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_int_base<((_AP_W2 + _AP_W3) > (_AP_W) ? (_AP_W2 + _AP_W3) : (_AP_W)), _AP_S> operator|(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
    return *this | a2.get();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_int_base<((_AP_W2 + _AP_W3) > (_AP_W) ? (_AP_W2 + _AP_W3) : (_AP_W)), _AP_S> operator^(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
    return *this ^ a2.get();
  }

  template <int _AP_W3>
  inline __attribute__((always_inline)) void set(const ap_int_base<_AP_W3, false>& val) {
    Base::V = val.V;
  }





  inline __attribute__((always_inline)) bool and_reduce() const { return ({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_and_reduce((void*)(&__what2__)); }); }
  inline __attribute__((always_inline)) bool nand_reduce() const { return ({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_nand_reduce((void*)(&__what2__)); }); }
  inline __attribute__((always_inline)) bool or_reduce() const { return ({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_or_reduce((void*)(&__what2__)); }); }
  inline __attribute__((always_inline)) bool nor_reduce() const { return !(({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_or_reduce((void*)(&__what2__)); })); }
  inline __attribute__((always_inline)) bool xor_reduce() const { return ({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_xor_reduce((void*)(&__what2__)); }); }
  inline __attribute__((always_inline)) bool xnor_reduce() const {
    return !(({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_xor_reduce((void*)(&__what2__)); }));
  }
# 1284 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_base.h"
  inline __attribute__((always_inline)) char* to_string(signed char rd = 2, bool sign = _AP_S) const {
    (void)(rd);
    (void)(sign);
    return 0;
  }

};
# 1345 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::mult_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::mult_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::mult_base ret; ret.V = lhs.V * rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::plus_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::plus_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::plus_base ret; ret.V = lhs.V + rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::minus_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::minus_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::minus_base ret; ret.V = lhs.V - rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base ret; ret.V = lhs.V & rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base ret; ret.V = lhs.V | rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base ret; ret.V = lhs.V ^ rhs.V; return ret; }
# 1364 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::div_base ret; ret.V = op.V / op2.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::mod_base ret; ret.V = op.V % op2.V; return ret; }
# 1392 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_base.h"
template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline __attribute__((always_inline)) PTR_TYPE* operator +(PTR_TYPE* i_op, const ap_int_base<_AP_W, _AP_S>& op) { ap_slong op2 = op.to_int64(); return i_op + op2; } template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline __attribute__((always_inline)) PTR_TYPE* operator +(const ap_int_base<_AP_W, _AP_S>& op, PTR_TYPE* i_op) { ap_slong op2 = op.to_int64(); return op2 + i_op; }
template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline __attribute__((always_inline)) PTR_TYPE* operator -(PTR_TYPE* i_op, const ap_int_base<_AP_W, _AP_S>& op) { ap_slong op2 = op.to_int64(); return i_op - op2; } template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline __attribute__((always_inline)) PTR_TYPE* operator -(const ap_int_base<_AP_W, _AP_S>& op, PTR_TYPE* i_op) { ap_slong op2 = op.to_int64(); return op2 - i_op; }
# 1421 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator *(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op * op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator *(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 * i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator /(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op / op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator /(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 / i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator +(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op + op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator +(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 + i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator -(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op - op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator -(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 - i_op; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator *(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op * op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator *(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 * i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator /(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op / op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator /(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 / i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator +(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op + op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator +(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 + i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator -(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op - op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator -(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 - i_op; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator *(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op * op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator *(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 * i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator /(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op / op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator /(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 / i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator +(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op + op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator +(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 + i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator -(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op - op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator -(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 - i_op; }
# 1455 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mult operator *(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op * ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::plus operator +(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op + ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::minus operator -(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op - ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::div operator /(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op / ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mod operator %(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op % ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator &(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op & ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator |(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op | ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator ^(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op ^ ap_int_base<1, false>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mult operator *(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op * ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::plus operator +(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op + ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::minus operator -(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op - ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::div operator /(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op / ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mod operator %(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op % ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator &(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op & ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator |(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op | ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator ^(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op ^ ap_int_base<8, CHAR_IS_SIGNED>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mult operator *(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op * ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::plus operator +(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op + ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::minus operator -(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op - ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::div operator /(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op / ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mod operator %(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op % ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator &(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op & ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator |(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op | ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator ^(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op ^ ap_int_base<8, true>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mult operator *(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op * ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::plus operator +(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op + ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::minus operator -(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op - ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::div operator /(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op / ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mod operator %(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op % ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator &(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op & ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator |(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op | ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator ^(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op ^ ap_int_base<8, false>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mult operator *(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op * ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::plus operator +(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op + ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::minus operator -(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op - ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::div operator /(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op / ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mod operator %(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op % ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator &(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op & ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator |(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op | ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator ^(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op ^ ap_int_base<_AP_SIZE_short, true>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mult operator *(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op * ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::plus operator +(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op + ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::minus operator -(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op - ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::div operator /(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op / ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mod operator %(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op % ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator &(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op & ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator |(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op | ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator ^(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op ^ ap_int_base<_AP_SIZE_short, false>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mult operator *(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op * ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::plus operator +(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op + ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::minus operator -(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op - ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::div operator /(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op / ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mod operator %(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op % ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator &(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op & ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator |(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op | ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator ^(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op ^ ap_int_base<_AP_SIZE_int, true>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mult operator *(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op * ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::plus operator +(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op + ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::minus operator -(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op - ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::div operator /(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op / ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mod operator %(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op % ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator &(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op & ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator |(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op | ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator ^(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op ^ ap_int_base<_AP_SIZE_int, false>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mult operator *(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op * ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::plus operator +(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op + ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::minus operator -(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op - ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::div operator /(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op / ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mod operator %(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op % ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator &(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op & ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator |(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op | ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator ^(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op ^ ap_int_base<_AP_SIZE_long, true>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mult operator *(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op * ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::plus operator +(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op + ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::minus operator -(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op - ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::div operator /(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op / ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mod operator %(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op % ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator &(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op & ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator |(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op | ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator ^(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op ^ ap_int_base<_AP_SIZE_long, false>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mult operator *(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op * ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::plus operator +(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op + ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::minus operator -(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op - ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::div operator /(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op / ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mod operator %(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op % ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator &(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op & ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator |(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op | ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator ^(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op ^ ap_int_base<_AP_SIZE_ap_slong, true>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mult operator *(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op * ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::plus operator +(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op + ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::minus operator -(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op - ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::div operator /(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op / ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mod operator %(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op % ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator &(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op & ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator |(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op | ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator ^(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op ^ ap_int_base<_AP_SIZE_ap_slong, false>(i_op); }
# 1494 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, char op2) { ap_int_base<_AP_W, _AP_S> r; if (CHAR_IS_SIGNED) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, char op2) { ap_int_base<_AP_W, _AP_S> r; if (CHAR_IS_SIGNED) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, short op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, short op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, int op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, int op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, long op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, long op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
# 1518 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, bool op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, bool op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V >> op2; return r; }
# 1549 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op += ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op -= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op *= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op /= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op %= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op &= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op |= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op ^= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op >>= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op <<= ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op += ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op -= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op *= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op /= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op %= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op &= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op |= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op ^= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op >>= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op <<= ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op += ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op -= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op *= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op /= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op %= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op &= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op |= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op ^= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op >>= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op <<= ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op += ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op -= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op *= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op /= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op %= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op &= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op |= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op ^= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op >>= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op <<= ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op += ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op -= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op *= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op /= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op %= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op &= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op |= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op ^= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op >>= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op <<= ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op += ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op -= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op *= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op /= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op %= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op &= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op |= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op ^= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op >>= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op <<= ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op += ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op -= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op *= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op /= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op %= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op &= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op |= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op ^= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op >>= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op <<= ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op += ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op -= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op *= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op /= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op %= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op &= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op |= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op ^= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op >>= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op <<= ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op += ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op -= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op *= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op /= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op %= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op &= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op |= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op ^= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op >>= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op <<= ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op += ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op -= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op *= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op /= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op %= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op &= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op |= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op ^= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op >>= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op <<= ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op += ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op -= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op *= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op /= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op %= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op &= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op |= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op ^= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op >>= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op <<= ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op += ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op -= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op *= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op /= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op %= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op &= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op |= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op ^= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op >>= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op <<= ap_int_base<_AP_SIZE_ap_slong, false>(op2); }
# 1582 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half& operator +=( half& op2, ap_int_base<_AP_W, _AP_S>& op) { half op_rt = op.to_half(); return op2 += op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half& operator -=( half& op2, ap_int_base<_AP_W, _AP_S>& op) { half op_rt = op.to_half(); return op2 -= op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half& operator *=( half& op2, ap_int_base<_AP_W, _AP_S>& op) { half op_rt = op.to_half(); return op2 *= op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half& operator /=( half& op2, ap_int_base<_AP_W, _AP_S>& op) { half op_rt = op.to_half(); return op2 /= op_rt; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float& operator +=( float& op2, ap_int_base<_AP_W, _AP_S>& op) { float op_rt = op.to_float(); return op2 += op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float& operator -=( float& op2, ap_int_base<_AP_W, _AP_S>& op) { float op_rt = op.to_float(); return op2 -= op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float& operator *=( float& op2, ap_int_base<_AP_W, _AP_S>& op) { float op_rt = op.to_float(); return op2 *= op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float& operator /=( float& op2, ap_int_base<_AP_W, _AP_S>& op) { float op_rt = op.to_float(); return op2 /= op_rt; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double& operator +=( double& op2, ap_int_base<_AP_W, _AP_S>& op) { double op_rt = op.to_double(); return op2 += op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double& operator -=( double& op2, ap_int_base<_AP_W, _AP_S>& op) { double op_rt = op.to_double(); return op2 -= op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double& operator *=( double& op2, ap_int_base<_AP_W, _AP_S>& op) { double op_rt = op.to_double(); return op2 *= op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double& operator /=( double& op2, ap_int_base<_AP_W, _AP_S>& op) { double op_rt = op.to_double(); return op2 /= op_rt; }
# 1610 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op > ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op < ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op >= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op <= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op == ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op != ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op > ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op < ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op >= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op <= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op == ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op != ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op > ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op < ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op >= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op <= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op == ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op != ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op > ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op < ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op >= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op <= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op == ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op != ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op > ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op < ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op >= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op <= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op == ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op != ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op > ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op < ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op >= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op <= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op == ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op != ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op > ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op < ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op >= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op <= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op == ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op != ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op > ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op < ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op >= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op <= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op == ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op != ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op > ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op < ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op >= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op <= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op == ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op != ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op > ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op < ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op >= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op <= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op == ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op != ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op > ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op < ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op >= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op <= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op == ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op != ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op > ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op < ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op >= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op <= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op == ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op != ap_int_base<_AP_SIZE_ap_slong, false>(op2); }
# 1647 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_base.h"
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() > op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 > op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() > op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 > op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() < op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 < op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() < op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 < op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() >= op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 >= op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() >= op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 >= op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() <= op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 <= op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() <= op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 <= op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() == op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 == op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() == op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 == op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() != op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 != op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() != op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 != op2.to_double() ; }
# 1677 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) + op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 + ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) - op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 - ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) * op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 * ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) / op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 / ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) % op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 % ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) & op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 & ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) | op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 | ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) ^ op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 ^ ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) >> op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 >> ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) << op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 << ap_int_base<_AP_W2, false>(op2); }
# 1708 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator +=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 += ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator +=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp += op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator -=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 -= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator -=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp -= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator *=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 *= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator *=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp *= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator /=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 /= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator /=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp /= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator %=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 %= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator %=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp %= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator >>=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 >>= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator >>=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp >>= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator <<=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 <<= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator <<=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp <<= op2; op1 = tmp; return op1; }
# 1740 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator &=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W2, false> tmp(op2); op1.V &= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator &=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.V &= op2.V; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator |=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W2, false> tmp(op2); op1.V |= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator |=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.V |= op2.V; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator ^=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W2, false> tmp(op2); op1.V ^= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator ^=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.V ^= op2.V; op1 = tmp; return op1; }
# 1759 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator ==(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator ==(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator !=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator !=(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator >(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator >=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >=(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator <(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator <=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <=(op2.operator ap_int_base<_AP_W2, false>()); }
# 1786 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::plus operator +(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 + ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) + op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::minus operator -(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 - ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) - op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::mult operator *(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 * ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) * op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::div operator /(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 / ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) / op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::mod operator %(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 % ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) % op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::logic operator &(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 & ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) & op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::logic operator |(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 | ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) | op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::logic operator ^(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 ^ ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) ^ op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::arg1 operator >>(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 >> ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) >> op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::arg1 operator <<(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 << ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) << op2; }
# 1817 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator +=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 += ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator +=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp += op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator -=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 -= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator -=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp -= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator *=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 *= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator *=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp *= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator /=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 /= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator /=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp /= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator %=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 %= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator %=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp %= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator >>=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 >>= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator >>=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp >>= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator <<=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 <<= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator <<=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp <<= op2; op1 = tmp; return op1; }
# 1849 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator &=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op2); op1.V &= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator &=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.V &= op2.V; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator |=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op2); op1.V |= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator |=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.V |= op2.V; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator ^=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op2); op1.V ^= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator ^=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.V ^= op2.V; op1 = tmp; return op1; }
# 1868 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 == ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) == op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 != ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) != op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 > ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) > op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 >= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) >= op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 < ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) < op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 <= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) <= op2; }
# 1976 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator ==( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 == op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() == op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator !=( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 != op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() != op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator >( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 > op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() > op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator >=( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 >= op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() >= op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator <( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 < op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() < op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator <=( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 <= op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() <= op2; }
# 57 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int.h" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_ref.h" 1
# 73 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_ref.h"
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2>
struct ap_concat_ref {
  enum {
    _AP_WR = _AP_W1 + _AP_W2,
  };

  _AP_T1& mbv1;
  _AP_T2& mbv2;

  inline __attribute__((always_inline)) ap_concat_ref(const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& ref)
      : mbv1(ref.mbv1), mbv2(ref.mbv2) {}

  inline __attribute__((always_inline)) ap_concat_ref(_AP_T1& bv1, _AP_T2& bv2) : mbv1(bv1), mbv2(bv2) {}

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_concat_ref& operator=(const ap_int_base<_AP_W3, _AP_S3>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> vval(val);
    int W_ref1 = mbv1.length();
    int W_ref2 = mbv2.length();
    ap_int_base<_AP_W1, false> Part1;
    Part1.V = ({ typename _ap_type::remove_const<typeof(vval.V)>::type __Result__ = 0; typeof(vval.V) __Val2__ = vval.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), W_ref2, W_ref1 + W_ref2 - 1); __Result__; });
    mbv1.set(Part1);
    ap_int_base<_AP_W2, false> Part2;
    Part2.V = ({ typename _ap_type::remove_const<typeof(vval.V)>::type __Result__ = 0; typeof(vval.V) __Val2__ = vval.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, W_ref2 - 1); __Result__; });
    mbv2.set(Part2);
    return *this;
  }
# 116 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_ref.h"
  inline __attribute__((always_inline)) ap_concat_ref& operator=(bool val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(char val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(signed char val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(unsigned char val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(short val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(unsigned short val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(int val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(unsigned int val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(long val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(unsigned long val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(ap_slong val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(ap_ulong val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(half val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(float val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(double val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }





  inline __attribute__((always_inline)) ap_concat_ref& operator=(
      const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }

  template <int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>
  inline __attribute__((always_inline)) ap_concat_ref& operator=(
      const ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_concat_ref& operator=(const ap_bit_ref<_AP_W3, _AP_S3>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }
  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_concat_ref& operator=(const ap_range_ref<_AP_W3, _AP_S3>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline __attribute__((always_inline)) ap_concat_ref& operator=(
      const af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>& val) {
    return operator=((const ap_int_base<_AP_W3, false>)(val));
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline __attribute__((always_inline)) ap_concat_ref& operator=(
      const ap_fixed_base<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>&
          val) {
    return operator=(val.to_ap_int_base());
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline __attribute__((always_inline)) ap_concat_ref& operator=(
      const af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>& val) {
    return operator=((ap_ulong)(bool)(val));
  }

  inline __attribute__((always_inline)) operator ap_int_base<_AP_WR, false>() const { return get(); }

  inline __attribute__((always_inline)) operator ap_ulong() const { return get().to_uint64(); }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                       ap_range_ref<_AP_W3, _AP_S3> >
  operator,(const ap_range_ref<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_range_ref<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_range_ref<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(ap_int_base<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(*this, a2);
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(volatile ap_int_base<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_int_base<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(const ap_int_base<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_int_base<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(const volatile ap_int_base<_AP_W3, _AP_S3> &a2) {

    ap_int_base<_AP_W3, _AP_S3> op(a2);
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_int_base<_AP_W3, _AP_S3>&>(op));
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_WR, ap_concat_ref, 1, ap_bit_ref<_AP_W3, _AP_S3> >
  operator,(const ap_bit_ref<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, 1, ap_bit_ref<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_bit_ref<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3 + _AP_W4,
                       ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4> >
  operator,(const ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3 + _AP_W4,
                         ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4> >(
        *this, const_cast<ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4>&>(a2));
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline __attribute__((always_inline)) ap_concat_ref<
      _AP_WR, ap_concat_ref, _AP_W3,
      af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >
  operator,(
      const af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> &a2) {
    return ap_concat_ref<
        _AP_WR, ap_concat_ref, _AP_W3,
        af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >(
        *this,
        const_cast<
            af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>&>(a2));
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_WR, ap_concat_ref, 1,
                    af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >
      operator,(const af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>
                    &a2) {
    return ap_concat_ref<
        _AP_WR, ap_concat_ref, 1,
        af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >(
        *this,
        const_cast<af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>&>(
            a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_int_base<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3> operator&(
      const ap_int_base<_AP_W3, _AP_S3>& a2) {
    return get() & a2;
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_int_base<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3> operator|(
      const ap_int_base<_AP_W3, _AP_S3>& a2) {
    return get() | a2;
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_int_base<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3> operator^(
      const ap_int_base<_AP_W3, _AP_S3>& a2) {
    return get() ^ a2;
  }
# 304 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_ref.h"
  inline __attribute__((always_inline)) ap_int_base<_AP_WR, false> get() const {
    ap_int_base<_AP_WR, false> tmpVal(0);
    int W_ref1 = mbv1.length();
    int W_ref2 = mbv2.length();
    ap_int_base<_AP_W2, false> v2(mbv2);
    ap_int_base<_AP_W1, false> v1(mbv1);
    tmpVal.V = ({ typename _ap_type::remove_const<typeof(tmpVal.V)>::type __Result__ = 0; typeof(tmpVal.V) __Val2__ = tmpVal.V; typeof(v2.V) __Repl2__ = v2.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 0, W_ref2 - 1); __Result__; });
    tmpVal.V =
        ({ typename _ap_type::remove_const<typeof(tmpVal.V)>::type __Result__ = 0; typeof(tmpVal.V) __Val2__ = tmpVal.V; typeof(v1.V) __Repl2__ = v1.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), W_ref2, W_ref1 + W_ref2 - 1); __Result__; });
    return tmpVal;
  }

  template <int _AP_W3>
  inline __attribute__((always_inline)) void set(const ap_int_base<_AP_W3, false>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> vval(val);
    int W_ref1 = mbv1.length();
    int W_ref2 = mbv2.length();
    ap_int_base<_AP_W1, false> tmpVal1;
    tmpVal1.V = ({ typename _ap_type::remove_const<typeof(vval.V)>::type __Result__ = 0; typeof(vval.V) __Val2__ = vval.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), W_ref2, W_ref1 + W_ref2 - 1); __Result__; });
    mbv1.set(tmpVal1);
    ap_int_base<_AP_W2, false> tmpVal2;
    tmpVal2.V = ({ typename _ap_type::remove_const<typeof(vval.V)>::type __Result__ = 0; typeof(vval.V) __Val2__ = vval.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, W_ref2 - 1); __Result__; });
    mbv2.set(tmpVal2);
  }

  inline __attribute__((always_inline)) int length() const { return mbv1.length() + mbv2.length(); }
};




template <int _AP_W, bool _AP_S>
struct ap_range_ref {



  typedef ap_int_base<_AP_W, _AP_S> ref_type;
  ref_type& d_bv;
  int l_index;
  int h_index;

 public:
  inline __attribute__((always_inline)) ap_range_ref(const ap_range_ref<_AP_W, _AP_S>& ref)
      : d_bv(ref.d_bv), l_index(ref.l_index), h_index(ref.h_index) {}

  inline __attribute__((always_inline)) ap_range_ref(ref_type* bv, int h, int l)
      : d_bv(*bv), l_index(l), h_index(h) {}

  inline __attribute__((always_inline)) ap_range_ref(const ref_type* bv, int h, int l)
      : d_bv(*const_cast<ref_type*>(bv)), l_index(l), h_index(h) {}

  inline __attribute__((always_inline)) operator ap_int_base<_AP_W, false>() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }

  inline __attribute__((always_inline)) operator ap_ulong() const { return to_uint64(); }
# 385 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_ref.h"
  inline __attribute__((always_inline)) ap_range_ref& operator=(bool val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(char val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(signed char val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(unsigned char val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(short val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(unsigned short val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(int val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(unsigned int val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(long val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(unsigned long val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(ap_slong val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(ap_ulong val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(half val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(float val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(double val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }




  inline __attribute__((always_inline)) ap_range_ref& operator=(const char* val) {
    const ap_int_base<_AP_W, false> tmp(val);
    d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
    return *this;
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref& operator=(const ap_int_base<_AP_W2, _AP_S2>& val) {
    ap_int_base<_AP_W, false> tmp(val);
    d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
    return *this;
  }




  inline __attribute__((always_inline)) ap_range_ref& operator=(const ap_range_ref& val) {
    return operator=((const ap_int_base<_AP_W, false>)val);
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    return operator=((const ap_int_base<_AP_W2, false>)val);
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    return operator=((ap_ulong)(bool)(val));
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_range_ref& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          val) {
    return operator=(val.to_ap_int_base());
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_range_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((const ap_int_base<_AP_W2, false>)val);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_range_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((ap_ulong)(bool)(val));
  }


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_range_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& val) {
    return operator=((const ap_int_base<_AP_W2 + _AP_W3, false>)(val));
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
      operator,(const ap_range_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, a2);
  }

  inline __attribute__((always_inline))
  ap_concat_ref<_AP_W, ap_range_ref, _AP_W, ap_int_base<_AP_W, _AP_S> >
  operator,(ap_int_base<_AP_W, _AP_S>& a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W,
                         ap_int_base<_AP_W, _AP_S> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(const volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(const ap_bit_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_range_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        *this, const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_concat_ref<
      _AP_W, ap_range_ref, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> a2) {
    return ap_concat_ref<
        _AP_W, ap_range_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<
            af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_range_ref, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                    &a2) {
    return ap_concat_ref<
        _AP_W, ap_range_ref, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator==(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> hop(op2);
    return lop == hop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator!=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator==(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator<(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> hop(op2);
    return lop < hop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator<=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> hop(op2);
    return lop <= hop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator>(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator<=(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator>=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator<(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S>& operator|=(
      const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V |= (op2.d_bv).V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S>& operator|=(
      const ap_int_base<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V |= op2.V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S>& operator&=(
      const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V &= (op2.d_bv).V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S>& operator&=(
      const ap_int_base<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V &= op2.V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S>& operator^=(
      const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V ^= (op2.d_bv).V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S>& operator^=(
      const ap_int_base<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V ^= op2.V;
    return *this;
  };



  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> operator~() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return (~ret);
  }

  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> operator!() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return (!ret);
  }

  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> operator+() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }

  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> operator-() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return (-ret);
  }


  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> get() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) void set(const ap_int_base<_AP_W2, false>& val) {
    d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val.V) __Repl2__ = val.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
  }

  inline __attribute__((always_inline)) int length() const {
    return h_index >= l_index ? h_index - l_index + 1 : l_index - h_index + 1;
  }

  inline __attribute__((always_inline)) int to_int() const {
    return (int)(({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) unsigned to_uint() const {
    return (unsigned)(({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) long to_long() const {
    return (long)(({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) unsigned long to_ulong() const {
    return (unsigned long)(({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) ap_slong to_int64() const {
    return (ap_slong)(({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) ap_ulong to_uint64() const {
    return (ap_ulong)(({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) bool and_reduce() const {
    bool ret = true;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    VITIS_LOOP_716_1: for (unsigned i = low; i != high; ++i) {

#pragma HLS unroll

 ret &= ({ typeof(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
    }
    return ret;
  }

  inline __attribute__((always_inline)) bool or_reduce() const {
    bool ret = false;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    VITIS_LOOP_730_1: for (unsigned i = low; i != high; ++i) {

#pragma HLS unroll

 ret |= ({ typeof(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
    }
    return ret;
  }

  inline __attribute__((always_inline)) bool xor_reduce() const {
    bool ret = false;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    VITIS_LOOP_744_1: for (unsigned i = low; i != high; ++i) {

#pragma HLS unroll

 ret ^= ({ typeof(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
    }
    return ret;
  }
# 760 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_ref.h"
  inline __attribute__((always_inline)) char* to_string(signed char radix = 2) const {
    (void)(radix);
    return 0;
  }

};
# 800 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_ref.h"
template <int _AP_W, bool _AP_S>
struct ap_bit_ref {



  typedef ap_int_base<_AP_W, _AP_S> ref_type;
  ref_type& d_bv;
  int d_index;

 public:

  inline __attribute__((always_inline)) ap_bit_ref(const ap_bit_ref<_AP_W, _AP_S>& ref)
      : d_bv(ref.d_bv), d_index(ref.d_index) {}

  inline __attribute__((always_inline)) ap_bit_ref(ref_type* bv, int index = 0) : d_bv(*bv), d_index(index) {}

  inline __attribute__((always_inline)) ap_bit_ref(const ref_type* bv, int index = 0)
      : d_bv(*const_cast<ref_type*>(bv)), d_index(index) {}

  inline __attribute__((always_inline)) operator bool() const { return ({ typeof(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }
  inline __attribute__((always_inline)) bool to_bool() const { return ({ typeof(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }
# 838 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_ref.h"
  inline __attribute__((always_inline)) ap_bit_ref& operator=(bool val) { d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(char val) { d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(signed char val) { d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(unsigned char val) { d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(short val) { d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(unsigned short val) { d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(int val) { d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(unsigned int val) { d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(long val) { d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(unsigned long val) { d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(ap_slong val) { d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(ap_ulong val) { d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
# 860 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_ref.h"
  inline __attribute__((always_inline)) ap_bit_ref& operator=(half val) { bool tmp_val = val; d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp_val) __Repl2__ = !!tmp_val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(float val) { bool tmp_val = val; d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp_val) __Repl2__ = !!tmp_val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(double val) { bool tmp_val = val; d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp_val) __Repl2__ = !!tmp_val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }




  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_bit_ref& operator=(const ap_int_base<_AP_W2, _AP_S2>& val) {
    return operator=((ap_ulong)(val.V != 0));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_bit_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    return operator=((ap_int_base<_AP_W2, false>)val);
  }



  inline __attribute__((always_inline)) ap_bit_ref& operator=(const ap_bit_ref& val) {
    return operator=((ap_ulong)(bool)val);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_bit_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    return operator=((ap_ulong)(bool)val);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_bit_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((const ap_int_base<_AP_W2, false>)val);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_bit_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((ap_ulong)(bool)val);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_bit_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
    return operator=((const ap_int_base<_AP_W2 + _AP_W3, false>)val);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) {
    ap_int_base<_AP_W2, _AP_S2> op(a2);
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(op));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    ap_int_base<_AP_W2, _AP_S2> op(a2);
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(op));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
  operator,(const ap_range_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> > operator,(
      const ap_bit_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        *this, const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_concat_ref<
      1, ap_bit_ref, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<
        1, ap_bit_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<
            af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                    _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                      _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator==(const ap_bit_ref<_AP_W2, _AP_S2>& op) {
    return get() == op.get();
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator!=(const ap_bit_ref<_AP_W2, _AP_S2>& op) {
    return get() != op.get();
  }

  inline __attribute__((always_inline)) bool get() const { return ({ typeof(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }

  inline __attribute__((always_inline)) bool get() { return ({ typeof(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }

  template <int _AP_W3>
  inline __attribute__((always_inline)) void set(const ap_int_base<_AP_W3, false>& val) {
    operator=(val);
  }

  inline __attribute__((always_inline)) bool operator~() const {
    bool bit = ({ typeof(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; });
    return bit ? false : true;
  }

  inline __attribute__((always_inline)) int length() const { return 1; }





  inline __attribute__((always_inline)) char* to_string() const { return 0; }

};
# 1058 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, false>(op2); }






template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_ap_slong, false>(op2); }
# 1117 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::plus operator +(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::minus operator -(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::mult operator *(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::div operator /(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::mod operator %(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::plus operator +(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::minus operator -(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::mult operator *(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::div operator /(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::mod operator %(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::plus operator +(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::minus operator -(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::mult operator *(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::div operator /(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::mod operator %(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::plus operator +(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::minus operator -(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::mult operator *(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::div operator /(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::mod operator %(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::plus operator +(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::minus operator -(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::mult operator *(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::div operator /(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::mod operator %(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::plus operator +(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::minus operator -(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::mult operator *(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::div operator /(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::mod operator %(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::plus operator +(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::minus operator -(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::mult operator *(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::div operator /(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::mod operator %(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::plus operator +(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::minus operator -(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::mult operator *(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::div operator /(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::mod operator %(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::plus operator +(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::minus operator -(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::mult operator *(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::div operator /(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::mod operator %(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::plus operator +(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::minus operator -(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::mult operator *(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::div operator /(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::mod operator %(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::plus operator +(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::minus operator -(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::mult operator *(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::div operator /(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::mod operator %(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::plus operator +(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::minus operator -(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::mult operator *(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::div operator /(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::mod operator %(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
# 1140 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::logic operator &(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::logic operator |(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::logic operator ^(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::arg1 operator >>(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::arg1 operator <<(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator &(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator |(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator ^(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::arg1 operator >>(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::arg1 operator <<(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::logic operator &(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::logic operator |(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::logic operator ^(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::arg1 operator >>(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::arg1 operator <<(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::logic operator &(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::logic operator |(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::logic operator &(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::logic operator |(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::logic operator ^(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::arg1 operator >>(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::arg1 operator <<(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::logic operator &(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::logic operator |(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::logic operator &(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::logic operator |(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::logic operator ^(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::arg1 operator >>(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::arg1 operator <<(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::logic operator &(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::logic operator |(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::logic operator &(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::logic operator |(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::logic operator ^(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::arg1 operator >>(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::arg1 operator <<(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::logic operator &(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::logic operator |(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::logic operator &(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::logic operator |(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::logic operator ^(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::arg1 operator >>(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::arg1 operator <<(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::logic operator &(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::logic operator |(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::logic operator ^(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::arg1 operator >>(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::arg1 operator <<(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
# 1168 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_ref.h"
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())+( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())-( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())*( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::div operator /(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())/( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())%( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())&( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())|( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())^( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())>>( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())<<( rhs.operator ap_int_base<_AP_W2, false>()); }
# 1217 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_ref.h"
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::plus operator +( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() + rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::minus operator -( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() - rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::mult operator *( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() * rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::div operator /( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() / rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::mod operator %( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() % rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::logic operator &( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() & rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::logic operator |( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() | rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::logic operator ^( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() ^ rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::arg1 operator >>( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() >> rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::arg1 operator <<( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() << rhs.get(); }
# 1364 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 1, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, bool op2) { ap_int_base<1 + _AP_W, false> val(op2); ap_int_base<1 + _AP_W, false> ret(op1); ret <<= 1; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 1, false> operator,( bool op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<1 + _AP_W, false> val(op1); ap_int_base<1 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 1; ret >>= 1; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 1, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, bool op2) { ap_int_base<1 + _AP_W, false> val(op2); ap_int_base<1 + _AP_W, false> ret(op1); ret <<= 1; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 1, false> operator,( bool op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<1 + _AP_W, false> val(op1); ap_int_base<1 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<1 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, bool op2) { ap_int_base<1 + 1, false> val(op2); val[1] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<1 + 1, false> operator,( bool op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<1 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 1, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, bool op2) { ap_int_base<1 + _AP_W + _AP_W2, false> val(op2); ap_int_base<1 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 1; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 1, false> operator,( bool op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<1 + _AP_W + _AP_W2, false> val(op1); ap_int_base<1 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + 1, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, bool op2) { ap_int_base<1 + _AP_W, false> val(op2); ap_int_base<1 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 1; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + 1, false> operator,( bool op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<1 + _AP_W, false> val(op1); ap_int_base<1 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + 1, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, bool op2) { ap_int_base<1 + 1, false> val(op2); val[1] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + 1, false> operator,( bool op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<1 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (CHAR_IS_SIGNED) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( char op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (CHAR_IS_SIGNED) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<8 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<8 + 1, false> operator,( char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, char op2) { ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> val(op2); ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> ret(op1); if (CHAR_IS_SIGNED) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> val(op1); ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); if (CHAR_IS_SIGNED) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + 8, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, char op2) { ap_int_base<8 + 1, CHAR_IS_SIGNED> val(op2); val[8] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + 8, false> operator,( char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + 1, CHAR_IS_SIGNED> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, signed char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( signed char op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, signed char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( signed char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<8 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, signed char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<8 + 1, false> operator,( signed char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, signed char op2) { ap_int_base<8 + _AP_W + _AP_W2, true> val(op2); ap_int_base<8 + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( signed char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<8 + _AP_W + _AP_W2, true> val(op1); ap_int_base<8 + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, signed char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( signed char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + 8, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, signed char op2) { ap_int_base<8 + 1, true> val(op2); val[8] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + 8, false> operator,( signed char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( unsigned char op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( unsigned char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<8 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<8 + 1, false> operator,( unsigned char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned char op2) { ap_int_base<8 + _AP_W + _AP_W2, false> val(op2); ap_int_base<8 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( unsigned char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<8 + _AP_W + _AP_W2, false> val(op1); ap_int_base<8 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( unsigned char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + 8, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + 8, false> operator,( unsigned char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( short op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_short; ret >>= _AP_SIZE_short; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( short op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_short + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, short op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_short + 1, false> operator,( short op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( short op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( short op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_short, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, short op2) { ap_int_base<_AP_SIZE_short + 1, true> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_short, false> operator,( short op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( unsigned short op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_short; ret >>= _AP_SIZE_short; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( unsigned short op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_short + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_short + 1, false> operator,( unsigned short op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( unsigned short op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( unsigned short op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_short, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_short, false> operator,( unsigned short op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( int op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_int; ret >>= _AP_SIZE_int; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( int op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_int + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, int op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_int + 1, false> operator,( int op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( int op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( int op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_int, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, int op2) { ap_int_base<_AP_SIZE_int + 1, true> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_int, false> operator,( int op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( unsigned int op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_int; ret >>= _AP_SIZE_int; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( unsigned int op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_int + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_int + 1, false> operator,( unsigned int op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( unsigned int op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( unsigned int op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_int, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_int, false> operator,( unsigned int op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( long op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_long; ret >>= _AP_SIZE_long; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( long op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_long + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, long op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_long + 1, false> operator,( long op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( long op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( long op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_long, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, long op2) { ap_int_base<_AP_SIZE_long + 1, true> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_long, false> operator,( long op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( unsigned long op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_long; ret >>= _AP_SIZE_long; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( unsigned long op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_long + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_long + 1, false> operator,( unsigned long op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( unsigned long op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( unsigned long op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_long, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_long, false> operator,( unsigned long op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_ap_slong; ret >>= _AP_SIZE_ap_slong; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( ap_slong op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, true> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_ap_slong; ret >>= _AP_SIZE_ap_slong; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( ap_ulong op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
# 1388 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_ref.h"
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_slong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_ulong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }

template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_slong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_ulong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
# 58 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int.h" 2




template <int _AP_W>
struct ap_int : ap_int_base<_AP_W, true> {
  typedef ap_int_base<_AP_W, true> Base;

  inline __attribute__((always_inline)) ap_int() : Base() {}
  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_int(const ap_int<_AP_W2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_int(const volatile ap_int<_AP_W2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_int(const ap_uint<_AP_W2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_int(const volatile ap_uint<_AP_W2>& op) {
    Base::V = op.V;
  }




  inline __attribute__((always_inline)) ap_int(unsigned V __attribute__((bitwidth(_AP_W))), bool raw) {
    Base::V = V;
    (void)(raw);
  }



  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int(const ap_range_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int(const ap_bit_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_int(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref)
      : Base(ref) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) ap_int(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) ap_int(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) ap_int(
      const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) ap_int(
      const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int(const ap_int_base<_AP_W2, _AP_S2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_int(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_int(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_int(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}



  inline __attribute__((always_inline)) ap_int(bool val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_int(char val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_int(signed char val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_int(unsigned char val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_int(short val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_int(unsigned short val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_int(int val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_int(unsigned int val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_int(long val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_int(unsigned long val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_int(ap_slong val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_int(ap_ulong val) { Base::V = val; }

  ap_int(double val) : Base(val) {}
  ap_int(float val) : Base(val) {}
  ap_int(half val) : Base(val) {}


  inline __attribute__((always_inline)) ap_int(const char* s) : Base(s) {}

  inline __attribute__((always_inline)) ap_int(const char* s, signed char rd) : Base(s, rd) {}




  ap_int &operator=(const ap_int<_AP_W> &op2) = default;


  inline __attribute__((always_inline)) ap_int& operator=(const volatile ap_int<_AP_W>& op2) {
    Base::V = op2.V;
    return *this;
  }


  inline __attribute__((always_inline)) void operator=(const ap_int<_AP_W>& op2) volatile { Base::V = op2.V; }

  inline __attribute__((always_inline)) void operator=(const volatile ap_int<_AP_W>& op2) volatile {
    Base::V = op2.V;
  }

};




template <int _AP_W>
struct ap_uint : ap_int_base<_AP_W, false> {
  typedef ap_int_base<_AP_W, false> Base;

  inline __attribute__((always_inline)) ap_uint() : Base() {}
  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_uint(const ap_uint<_AP_W2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_uint(const ap_int<_AP_W2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_uint(const volatile ap_uint<_AP_W2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_uint(const volatile ap_int<_AP_W2>& op) {
    Base::V = op.V;
  }




  inline __attribute__((always_inline)) ap_uint(unsigned V __attribute__((bitwidth(_AP_W))), bool raw) {
    Base::V = V;
    (void)(raw);
  }



  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_uint(const ap_range_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_uint(const ap_bit_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_uint(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref)
      : Base(ref) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) ap_uint(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) ap_uint(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) ap_uint(
      const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) ap_uint(
      const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_uint(const ap_int_base<_AP_W2, _AP_S2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_uint(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_uint(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_uint(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}



  inline __attribute__((always_inline)) ap_uint(bool val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_uint(char val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_uint(signed char val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_uint(unsigned char val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_uint(short val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_uint(unsigned short val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_uint(int val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_uint(unsigned int val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_uint(long val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_uint(unsigned long val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_uint(ap_slong val) { Base::V = val; }
  inline __attribute__((always_inline)) ap_uint(ap_ulong val) { Base::V = val; }

  ap_uint(double val) : Base(val) {}
  ap_uint(float val) : Base(val) {}
  ap_uint(half val) : Base(val) {}


  inline __attribute__((always_inline)) ap_uint(const char* s) : Base(s) {}

  inline __attribute__((always_inline)) ap_uint(const char* s, signed char rd) : Base(s, rd) {}




  ap_uint &operator=(const ap_uint<_AP_W> &op2) = default;


  inline __attribute__((always_inline)) ap_uint& operator=(const volatile ap_uint<_AP_W>& op2) {
    Base::V = op2.V;
    return *this;
  }


  inline __attribute__((always_inline)) void operator=(const ap_uint<_AP_W>& op2) volatile { Base::V = op2.V; }

  inline __attribute__((always_inline)) void operator=(const volatile ap_uint<_AP_W>& op2) volatile {
    Base::V = op2.V;
  }

};
# 356 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int.h"
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_special.h" 1
# 61 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_special.h"
namespace std {
template<typename _Tp> class complex;
}







namespace std {
# 89 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_special.h"
template <int _AP_W>
class complex<ap_int<_AP_W> > {
 public:
  typedef ap_int<_AP_W> _Tp;
  typedef _Tp value_type;




  complex() : _M_real(_Tp()), _M_imag(_Tp()) {}


  complex(const _Tp &__r, const _Tp &__i = _Tp(0))
      : _M_real(__r), _M_imag(__i) {}


  template <typename _Up>
  complex(const complex<_Up> &__z) : _M_real(__z.real()), _M_imag(__z.imag()) {}


  const _Tp& real() const { return _M_real; }
  const _Tp& imag() const { return _M_imag; }







  void real(_Tp __val) { _M_real = __val; }

  void imag(_Tp __val) { _M_imag = __val; }



  complex<_Tp> &operator=(const _Tp __t) {
    _M_real = __t;
    _M_imag = _Tp(0);
    return *this;
  }



  complex<_Tp> &operator+=(const _Tp &__t) {
    _M_real += __t;
    return *this;
  }



  complex<_Tp> &operator-=(const _Tp &__t) {
    _M_real -= __t;
    return *this;
  }



  complex<_Tp> &operator*=(const _Tp &__t) {
    _M_real *= __t;
    _M_imag *= __t;
    return *this;
  }



  complex<_Tp> &operator/=(const _Tp &__t) {
    _M_real /= __t;
    _M_imag /= __t;
    return *this;
  }


  template <typename _Up>
  complex<_Tp> &operator=(const complex<_Up> &__z) {
    _M_real = __z.real();
    _M_imag = __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator+=(const complex<_Up> &__z) {
    _M_real += __z.real();
    _M_imag += __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator-=(const complex<_Up> &__z) {
    _M_real -= __z.real();
    _M_imag -= __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator*=(const complex<_Up> &__z) {
    const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();
    _M_imag = _M_real * __z.imag() + _M_imag * __z.real();
    _M_real = __r;
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator/=(const complex<_Up> &__z) {
    complex<_Tp> cj (__z.real(), -__z.imag());
    complex<_Tp> a = (*this) * cj;
    complex<_Tp> b = cj * __z;
    _M_real = a.real() / b.real();
    _M_imag = a.imag() / b.real();
    return *this;
  }

 private:
  _Tp _M_real;
  _Tp _M_imag;

};
# 222 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int_special.h"
template <int _AP_W>
inline bool operator==(const complex<ap_int<_AP_W> > &__x, const ap_int<_AP_W> &__y) {
  return __x.real() == __y &&
         __x.imag() == 0;
}


template <int _AP_W>
inline bool operator==(const ap_int<_AP_W> &__x, const complex<ap_int<_AP_W> > &__y) {
  return __x == __y.real() &&
         0 == __y.imag();
}


template <int _AP_W>
inline bool operator!=(const complex<ap_int<_AP_W> > &__x, const ap_int<_AP_W> &__y) {
  return __x.real() != __y ||
         __x.imag() != 0;
}


template <int _AP_W>
inline bool operator!=(const ap_int<_AP_W> &__x, const complex<ap_int<_AP_W> > &__y) {
  return __x != __y.real() ||
         0 != __y.imag();
}

}
# 357 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_int.h" 2
# 63 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_base.h" 2
# 133 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_base.h"
template <int _AP_W2, int _AP_I2, bool _AP_S2>
struct _ap_fixed_factory;
template <int _AP_W2, int _AP_I2>
struct _ap_fixed_factory<_AP_W2, _AP_I2, true> {
  typedef ap_fixed<_AP_W2, _AP_I2> type;
};
template <int _AP_W2, int _AP_I2>
struct _ap_fixed_factory<_AP_W2, _AP_I2, false> {
  typedef ap_ufixed<_AP_W2, _AP_I2> type;
};
# 154 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_base.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct ap_fixed_base : ssdm_int<_AP_W, _AP_S> {
 public:
  typedef ssdm_int<_AP_W, _AP_S> Base;
  static const int width = _AP_W;
  static const int iwidth = _AP_I;
  static const ap_q_mode qmode = _AP_Q;
  static const ap_o_mode omode = _AP_O;


  template <int _AP_W2, int _AP_I2, bool _AP_S2>
  struct RType {
    enum {
      _AP_F = _AP_W - _AP_I,
      F2 = _AP_W2 - _AP_I2,
      mult_w = _AP_W + _AP_W2,
      mult_i = _AP_I + _AP_I2,
      mult_s = _AP_S || _AP_S2,
      plus_w = ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) +
               1 + ((_AP_F) > (F2) ? (_AP_F) : (F2)),
      plus_i =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) + 1,
      plus_s = _AP_S || _AP_S2,
      minus_w =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) + 1 +
          ((_AP_F) > (F2) ? (_AP_F) : (F2)),
      minus_i =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) + 1,
      minus_s = true,

      div_w = _AP_S2 + _AP_W + ((F2) > (0) ? (F2) : (0)),



      div_i = _AP_S2 + _AP_I + F2,
      div_s = _AP_S || _AP_S2,
      logic_w =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) +
          ((_AP_F) > (F2) ? (_AP_F) : (F2)),
      logic_i = ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))),
      logic_s = _AP_S || _AP_S2
    };

    typedef ap_fixed_base<_AP_W, _AP_I, _AP_S> lhs;
    typedef ap_fixed_base<_AP_W2, _AP_I2, _AP_S2> rhs;

    typedef ap_fixed_base<mult_w, mult_i, mult_s> mult_base;
    typedef ap_fixed_base<plus_w, plus_i, plus_s> plus_base;
    typedef ap_fixed_base<minus_w, minus_i, minus_s> minus_base;
    typedef ap_fixed_base<logic_w, logic_i, logic_s> logic_base;
    typedef ap_fixed_base<div_w, div_i, div_s> div_base;
    typedef ap_fixed_base<_AP_W, _AP_I, _AP_S> arg1_base;

    typedef typename _ap_fixed_factory<mult_w, mult_i, mult_s>::type mult;
    typedef typename _ap_fixed_factory<plus_w, plus_i, plus_s>::type plus;
    typedef typename _ap_fixed_factory<minus_w, minus_i, minus_s>::type minus;
    typedef typename _ap_fixed_factory<logic_w, logic_i, logic_s>::type logic;
    typedef typename _ap_fixed_factory<div_w, div_i, div_s>::type div;
    typedef typename _ap_fixed_factory<_AP_W, _AP_I, _AP_S>::type arg1;
  };

 private:
# 333 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_base.h"
  inline __attribute__((always_inline)) void report() {}




  inline __attribute__((always_inline)) void overflow_adjust(bool underflow, bool overflow, bool lD,
                              bool sign) {
    if (!underflow && !overflow) return;
    if (_AP_O == AP_WRAP) {
      if (_AP_N == 0) return;
      if (_AP_S) {


        Base::V = ({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(sign) __Repl2__ = !!sign; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - 1, _AP_W - 1); __Result__; });
        if (_AP_N > 1) {

          ap_int_base<_AP_W, false> mask(-1);
          if (sign) mask.V = 0;
          Base::V =
              ({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(mask.V) __Repl2__ = mask.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - _AP_N, _AP_W - 2); __Result__; });
        }
      } else {

        ap_int_base<_AP_W, false> mask(-1);
        Base::V =
            ({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(mask.V) __Repl2__ = mask.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - _AP_N, _AP_W - 1); __Result__; });
      }
    } else if (_AP_O == AP_SAT_ZERO) {
      Base::V = 0;
    } else if (_AP_O == AP_WRAP_SM && _AP_S) {
      bool Ro = ({ typeof(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
      if (_AP_N == 0) {
        if (lD != Ro) {
          Base::V = ~Base::V;
          Base::V = ({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(lD) __Repl2__ = !!lD; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - 1, _AP_W - 1); __Result__; });
        }
      } else {
        if (_AP_N == 1 && sign != Ro) {
          Base::V = ~Base::V;
        } else if (_AP_N > 1) {
          bool lNo = ({ typeof(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - _AP_N); __Result__; });
          if (lNo == sign) Base::V = ~Base::V;
          ap_int_base<_AP_W, false> mask(-1);
          if (sign) mask.V = 0;
          Base::V =
              ({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(mask.V) __Repl2__ = mask.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - _AP_N, _AP_W - 2); __Result__; });
        }
        Base::V = ({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(sign) __Repl2__ = !!sign; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - 1, _AP_W - 1); __Result__; });
      }
    } else {
      if (_AP_S) {
        if (overflow) {
          Base::V = 1;
          Base::V <<= _AP_W - 1;
          Base::V = ~Base::V;
        } else if (underflow) {
          Base::V = 1;
          Base::V <<= _AP_W - 1;
          if (_AP_O == AP_SAT_SYM) Base::V |= 1;
        }
      } else {
        if (overflow)
          Base::V = ~(ap_int_base<_AP_W, false>(0).V);
        else if (underflow)
          Base::V = 0;
      }
    }
  }

  inline __attribute__((always_inline)) bool quantization_adjust(bool qb, bool r, bool s) {
    bool carry = (bool)({ typeof(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
    if (_AP_Q == AP_TRN) return false;
    if (_AP_Q == AP_RND_ZERO)
      qb &= s || r;
    else if (_AP_Q == AP_RND_MIN_INF)
      qb &= r;
    else if (_AP_Q == AP_RND_INF)
      qb &= !s || r;
    else if (_AP_Q == AP_RND_CONV)
      qb &= ({ typeof(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), 0); __Result__; }) || r;
    else if (_AP_Q == AP_TRN_ZERO)
      qb = s && (qb || r);
    Base::V += qb;
    return carry && (!(bool)({ typeof(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; }));
  }


 public:



  inline __attribute__((always_inline)) ap_fixed_base() {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed_base(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    operator=(op);
    report();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed_base(
      const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    operator=(op);
    report();
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_fixed_base(const ap_int_base<_AP_W2, _AP_S2>& op) {
    ap_fixed_base<_AP_W2, _AP_W2, _AP_S2> tmp;
    tmp.V = op.V;
    operator=(tmp);
    report();
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_fixed_base(const volatile ap_int_base<_AP_W2, _AP_S2>& op) {
    ap_fixed_base<_AP_W2, _AP_W2, _AP_S2> tmp;
    tmp.V = op.V;
    operator=(tmp);
    report();
  }
# 477 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_base.h"
  inline __attribute__((always_inline)) ap_fixed_base(const char* s) {
    typeof(Base::V) t;
    _ssdm_string2bits((void*)(&t), (const char*)(s), 10, _AP_I, _AP_S, _AP_Q,
                      _AP_O, _AP_N, true);
    Base::V = t;
  }
  inline __attribute__((always_inline)) ap_fixed_base(const char* s, signed char rd) {
    typeof(Base::V) t;
    _ssdm_string2bits((void*)(&t), (const char*)(s), rd, _AP_I, _AP_S, _AP_Q,
                      _AP_O, _AP_N, true);
    Base::V = t;
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_fixed_base(const ap_bit_ref<_AP_W2, _AP_S2>& op) {
    *this = ((bool)op);
    report();
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_fixed_base(const ap_range_ref<_AP_W2, _AP_S2>& op) {
    *this = (ap_int_base<_AP_W2, false>(op));
    report();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_fixed_base(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op) {
    *this = (ap_int_base<_AP_W2 + _AP_W3, false>(op));
    report();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed_base(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    *this = (bool(op));
    report();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed_base(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    *this = (ap_int_base<_AP_W2, false>(op));
    report();
  }
# 535 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_base.h"
  inline __attribute__((always_inline)) ap_fixed_base(const bool x) { ap_fixed_base<(1), (1), (false)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const char x) { ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const signed char x) { ap_fixed_base<(8), (8), (true)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const unsigned char x) { ap_fixed_base<(8), (8), (false)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const short x) { ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const unsigned short x) { ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const int x) { ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const unsigned int x) { ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const long x) { ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const unsigned long x) { ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const ap_slong x) { ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const ap_ulong x) { ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)> tmp; tmp.V = x; *this = tmp; }







          ap_fixed_base(double d) {
    ap_int_base<64, false> ireg;
    ireg.V = doubleToRawBits(d);
    bool isneg = ({ typeof(ireg.V) __Val2__ = ireg.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), 63); __Result__; });

    ap_int_base<11 + 1, true> exp;
    ap_int_base<11, false> exp_tmp;
    exp_tmp.V =
        ({ typename _ap_type::remove_const<typeof(ireg.V)>::type __Result__ = 0; typeof(ireg.V) __Val2__ = ireg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 52, 52 + 11 - 1); __Result__; });
    exp = exp_tmp - ((1L << (11 - 1L)) - 1L);
    ap_int_base<52 + 2, true> man;
    man.V = ({ typename _ap_type::remove_const<typeof(ireg.V)>::type __Result__ = 0; typeof(ireg.V) __Val2__ = ireg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, 52 - 1); __Result__; });

    (static_cast<void>(0));

    man.V = ({ typename _ap_type::remove_const<typeof(man.V)>::type __Result__ = 0; typeof(man.V) __Val2__ = man.V; typeof(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 52, 52); __Result__; });
    if (isneg) man = -man;
    if ((ireg.V & 0x7fffffffffffffffLL) == 0) {
      Base::V = 0;
    } else {
      int _AP_W2 = 52 + 2, _AP_I2 = exp.V + 2, _AP_F = _AP_W - _AP_I,
          F2 = _AP_W2 - _AP_I2;
      bool _AP_S2 = true,
           QUAN_INC = F2 > _AP_F &&
                      !(_AP_Q == AP_TRN || (_AP_Q == AP_TRN_ZERO && !_AP_S2));
      bool carry = false;

      unsigned sh_amt = (F2 > _AP_F) ? F2 - _AP_F : _AP_F - F2;
      if (F2 == _AP_F)
        Base::V = man.V;
      else if (F2 > _AP_F) {
        if (sh_amt < 52 + 2)
          Base::V = man.V >> sh_amt;
        else {
          Base::V = isneg ? -1 : 0;
        }
        if ((_AP_Q != AP_TRN) && !((_AP_Q == AP_TRN_ZERO) && !_AP_S2)) {
          bool qb = (F2 - _AP_F > _AP_W2) ? isneg : (bool)({ typeof(man.V) __Val2__ = man.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), F2 - _AP_F - 1); __Result__; });

          bool r =
              (F2 > _AP_F + 1)
                  ? ({ typename _ap_type::remove_const<typeof(man.V)>::type __Result__ = 0; typeof(man.V) __Val2__ = man.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, (F2 - _AP_F - 2 < _AP_W2) ? (F2 - _AP_F - 2) : (_AP_W2 - 1)); __Result__; }) != 0


                  : false;
          carry = quantization_adjust(qb, r, isneg);
        }
      } else {
        Base::V = man.V;
        if (sh_amt < _AP_W)
          Base::V = Base::V << sh_amt;
        else
          Base::V = 0;
      }

      if ((_AP_O != AP_WRAP || _AP_N != 0) &&
          ((!_AP_S && _AP_S2) ||
           _AP_I - _AP_S <
               _AP_I2 - _AP_S2 +
                   (QUAN_INC ||
                    (_AP_S2 && (_AP_O == AP_SAT_SYM))))) {
        bool deleted_zeros = _AP_S2 ? true : !carry, deleted_ones = true;
        bool neg_src = isneg;
        bool lD = false;
        int pos1 = F2 - _AP_F + _AP_W;
        int pos2 = F2 - _AP_F + _AP_W + 1;
        bool newsignbit = ({ typeof(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
        if (pos1 < _AP_W2 && pos1 >= 0)

          lD = (man.V >> pos1) & 1;
        if (pos1 < _AP_W2) {
          bool Range1_all_ones = true;
          bool Range1_all_zeros = true;
          bool Range2_all_ones = true;
          ap_int_base<52 + 2, false> Range2;
          ap_int_base<52 + 2, false> all_ones(-1);

          if (pos2 >= 0 && pos2 < _AP_W2) {


            Range2.V = man.V;
            Range2.V >>= pos2;
            Range2_all_ones = Range2 == (all_ones >> pos2);
          } else if (pos2 < 0)
            Range2_all_ones = false;
          if (pos1 >= 0 && pos2 < _AP_W2) {
            Range1_all_ones = Range2_all_ones && lD;
            Range1_all_zeros = !Range2.V && !lD;
          } else if (pos2 == _AP_W2) {
            Range1_all_ones = lD;
            Range1_all_zeros = !lD;
          } else if (pos1 < 0) {
            Range1_all_zeros = !man.V;
            Range1_all_ones = false;
          }

          deleted_zeros =
              deleted_zeros && (carry ? Range1_all_ones : Range1_all_zeros);
          deleted_ones =
              carry ? Range2_all_ones && (pos1 < 0 || !lD) : Range1_all_ones;
          neg_src = isneg && !(carry && Range1_all_ones);
        } else
          neg_src = isneg && newsignbit;
        bool neg_trg = _AP_S && newsignbit;
        bool overflow = (neg_trg || !deleted_zeros) && !isneg;
        bool underflow = (!neg_trg || !deleted_ones) && neg_src;
        if ((_AP_O == AP_SAT_SYM) && _AP_S2 && _AP_S)
          underflow |=
              neg_src &&
              (_AP_W > 1 ? ({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, _AP_W - 2); __Result__; }) == 0
                         : true);
        overflow_adjust(underflow, overflow, lD, neg_src);
      }
    }
    report();
  }


  inline __attribute__((always_inline)) ap_fixed_base(float d) { *this = ap_fixed_base(double(d)); }


  inline __attribute__((always_inline)) ap_fixed_base(half d) { *this = ap_fixed_base(double(d)); }
# 688 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed_base& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {

    const int _AP_F = _AP_W - _AP_I;
    const int F2 = _AP_W2 - _AP_I2;
    const int QUAN_INC =
          F2 > _AP_F && !(_AP_Q == AP_TRN || (_AP_Q == AP_TRN_ZERO && !_AP_S2));

    if (!op) Base::V = 0;
    bool carry = false;
    bool signbit = ({ typeof(op.V) __Val2__ = op.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W2 - 1); __Result__; });
    bool isneg = signbit && _AP_S2;
    if (F2 == _AP_F)
      Base::V = op.V;
    else if (F2 > _AP_F) {
      unsigned int sh_amt = F2 - _AP_F;

      if (sh_amt < _AP_W2) {
        Base::V = op.V >> sh_amt;
      } else {
        Base::V = isneg ? -1 : 0;
      }
      if (_AP_Q != AP_TRN && !(_AP_Q == AP_TRN_ZERO && !_AP_S2)) {
        bool qbit = ({ typeof(op.V) __Val2__ = op.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), F2 - _AP_F - 1); __Result__; });

        bool qb = (F2 - _AP_F > _AP_W2) ? _AP_S2 && signbit : qbit;
        enum { hi = ((F2 - _AP_F - 2) < _AP_W2) ? (F2 - _AP_F - 2) : (_AP_W2 - 1) };

        bool r = (F2 > _AP_F + 1) ? (({ typename _ap_type::remove_const<typeof(op.V)>::type __Result__ = 0; typeof(op.V) __Val2__ = op.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, hi); __Result__; }) != 0) : false;
        carry = quantization_adjust(qb, r, isneg);
      }
    } else {
      unsigned sh_amt = _AP_F - F2;

      if (sh_amt < _AP_W) {
        if (_AP_W > _AP_W2) {

          Base::V = op.V;
          Base::V <<= sh_amt;
        } else {

          Base::V = op.V << sh_amt;
        }
      } else {
        Base::V = 0;
      }
    }

    if ((_AP_O != AP_WRAP || _AP_N != 0) &&
        ((!_AP_S && _AP_S2) ||
         _AP_I - _AP_S <
             _AP_I2 - _AP_S2 +
                 (QUAN_INC || (_AP_S2 && _AP_O == AP_SAT_SYM)))) {
      bool deleted_zeros = _AP_S2 ? true : !carry;
      bool deleted_ones = true;
      bool neg_src = isneg;
      bool newsignbit = ({ typeof(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
      enum { pos1 = F2 - _AP_F + _AP_W, pos2 = F2 - _AP_F + _AP_W + 1 };
      bool lD = (pos1 < _AP_W2 && pos1 >= 0) ? ({ typeof(op.V) __Val2__ = op.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), pos1); __Result__; })
                                             : false;
      if (pos1 < _AP_W2) {
        bool Range1_all_ones = true;
        bool Range1_all_zeros = true;
        bool Range2_all_ones = true;
        ap_int_base<_AP_W2, false> all_ones(-1);

        if (pos2 < _AP_W2 && pos2 >= 0) {
          ap_int_base<_AP_W2, false> Range2;
          Range2.V = ({ typename _ap_type::remove_const<typeof(op.V)>::type __Result__ = 0; typeof(op.V) __Val2__ = op.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), pos2, _AP_W2 - 1); __Result__; });
          Range2_all_ones = Range2 == (all_ones >> pos2);
        } else if (pos2 < 0) {
          Range2_all_ones = false;
        }

        if (pos1 >= 0 && pos2 < _AP_W2) {
          ap_int_base<_AP_W2, false> Range1;
          Range1.V = ({ typename _ap_type::remove_const<typeof(op.V)>::type __Result__ = 0; typeof(op.V) __Val2__ = op.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), pos1, _AP_W2 - 1); __Result__; });
          Range1_all_ones = Range1 == (all_ones >> pos1);
          Range1_all_zeros = !Range1.V;
        } else if (pos2 == _AP_W2) {
          Range1_all_ones = lD;
          Range1_all_zeros = !lD;
        } else if (pos1 < 0) {
          Range1_all_zeros = !op.V;
          Range1_all_ones = false;
        }

        deleted_zeros =
            deleted_zeros && (carry ? Range1_all_ones : Range1_all_zeros);
        deleted_ones =
            carry ? Range2_all_ones && (pos1 < 0 || !lD) : Range1_all_ones;
        neg_src = isneg && !(carry && Range1_all_ones);
      } else
        neg_src = isneg && newsignbit;
      bool neg_trg = _AP_S && newsignbit;
      bool overflow = (neg_trg || !deleted_zeros) && !isneg;
      bool underflow = (!neg_trg || !deleted_ones) && neg_src;
      if ((_AP_O == AP_SAT_SYM) && _AP_S2 && _AP_S)
        underflow |=
            neg_src &&
            (_AP_W > 1 ? ({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, _AP_W - 2); __Result__; }) == 0
                       : true);

      overflow_adjust(underflow, overflow, lD, neg_src);
    }
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed_base& operator=(
      const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    operator=(const_cast<const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(op));
    return *this;
  }


  inline __attribute__((always_inline)) ap_fixed_base& setBits(ap_ulong bv) {

    Base::V = bv;
    return *this;
  }


  static inline __attribute__((always_inline)) ap_fixed_base bitsToFixed(ap_ulong bv) {

    ap_fixed_base t;

    t.V = bv;



    return t;
  }





  inline __attribute__((always_inline)) ap_int_base<((_AP_I) > (1) ? (_AP_I) : (1)), _AP_S> to_ap_int_base(
      bool Cnative = true) const {
    ap_int_base<((_AP_I) > (1) ? (_AP_I) : (1)), _AP_S> ret;
    if (_AP_I == 0) {
      ret.V = 0;
    } else if (_AP_I > 0 && _AP_I <= _AP_W) {
      ret.V = ({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - _AP_I, _AP_W - 1); __Result__; });
    } else if (_AP_I > _AP_W) {
      ret.V = ({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, _AP_W - 1); __Result__; });
      ret.V <<= (_AP_I - _AP_W);
    }
# 848 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_base.h"
    if (Cnative && _AP_I < _AP_W) {

      if (_AP_S && ({ typeof(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; }) && (_AP_I < _AP_W) &&
          (({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, _AP_I < 0 ? _AP_W - 1 : _AP_W - _AP_I - 1); __Result__; }) != 0))

        ++ret;
    } else {

    }
    return ret;
  };

 public:
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) operator ap_int_base<_AP_W2, _AP_S2>() const {
    return ap_int_base<_AP_W2, _AP_S2>(to_ap_int_base());
  }


  inline __attribute__((always_inline)) char to_char() const { return to_ap_int_base().to_char(); }

  inline __attribute__((always_inline)) int to_int() const { return to_ap_int_base().to_int(); }

  inline __attribute__((always_inline)) unsigned to_uint() const { return to_ap_int_base().to_uint(); }

  inline __attribute__((always_inline)) ap_slong to_int64() const { return to_ap_int_base().to_int64(); }

  inline __attribute__((always_inline)) ap_ulong to_uint64() const { return to_ap_int_base().to_uint64(); }



  inline __attribute__((always_inline)) double to_double() const {




    enum { BITS = 52 + 11 + 1 };
    if (!Base::V) return 0.0f;
    bool s = _AP_S && ({ typeof(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
    ap_int_base<_AP_W, false> tmp;
    if (s)
      tmp.V = -Base::V;
    else
      tmp.V = Base::V;
    int l = tmp.countLeadingZeros();
    int e = _AP_I - l - 1 + ((1L << (11 - 1L)) - 1L);
    int lsb_index = _AP_W - l - 1 - 52;

    bool a = (lsb_index >=2) ?
        (({ typename _ap_type::remove_const<typeof(tmp.V)>::type __Result__ = 0; typeof(tmp.V) __Val2__ = tmp.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, lsb_index - 2); __Result__; }) != 0) : 0;

    a |= (lsb_index >=0) ? ({ typeof(tmp.V) __Val2__ = tmp.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), lsb_index); __Result__; }) : 0;

    ap_ulong m;

    if (_AP_W > BITS) {
      m = (lsb_index >= 1) ? (ap_ulong)(tmp.V >> (lsb_index - 1))
                           : (ap_ulong)(tmp.V << (1 - lsb_index));
    } else {
      m = (ap_ulong)tmp.V;
      m = (lsb_index >= 1) ? (m >> (lsb_index - 1))
                           : (m << (1 - lsb_index));
    }
    m += a;
    m >>= 1;


    if (({ typeof(m) __Val2__ = m; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), 52 + 1); __Result__; })) {
      e += 1;
    }

    m = ({ typename _ap_type::remove_const<typeof(m)>::type __Result__ = 0; typeof(m) __Val2__ = m; typeof(s) __Repl2__ = !!s; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), BITS - 1, BITS - 1); __Result__; });

    m = ({ typename _ap_type::remove_const<typeof(m)>::type __Result__ = 0; typeof(m) __Val2__ = m; typeof(e) __Repl2__ = e; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 52, 52 + 11 - 1); __Result__; });


    return rawBitsToDouble(m);
  }



  inline __attribute__((always_inline)) float to_float() const {




    enum { BITS = 23 + 8 + 1 };
    if (!Base::V) return 0.0f;
    bool s = _AP_S && ({ typeof(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
    ap_int_base<_AP_W, false> tmp;
    if (s)
      tmp.V = -Base::V;
    else
      tmp.V = Base::V;
    int l = tmp.countLeadingZeros();
    int e = _AP_I - l - 1 + ((1L << (8 - 1L)) - 1L);
    int lsb_index = _AP_W - l - 1 - 23;

    bool a = (lsb_index >=2) ?
        (({ typename _ap_type::remove_const<typeof(tmp.V)>::type __Result__ = 0; typeof(tmp.V) __Val2__ = tmp.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, lsb_index - 2); __Result__; }) != 0) : 0;

    a |= (lsb_index >=0) ? ({ typeof(tmp.V) __Val2__ = tmp.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), lsb_index); __Result__; }) : 0;

    unsigned long m;

    if (_AP_W > BITS) {
      m = (lsb_index >= 1) ? (unsigned long)(tmp.V >> (lsb_index - 1))
                           : (unsigned long)(tmp.V << (1 - lsb_index));
    } else {
      m = (unsigned long)tmp.V;
      m = (lsb_index >= 1) ? (m >> (lsb_index - 1))
                           : (m << (1 - lsb_index));
    }
    m += a;
    m >>= 1;

    if (({ typeof(m) __Val2__ = m; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), 23 + 1); __Result__; })) {
      e += 1;
    }

    m = ({ typename _ap_type::remove_const<typeof(m)>::type __Result__ = 0; typeof(m) __Val2__ = m; typeof(s) __Repl2__ = !!s; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), BITS - 1, BITS - 1); __Result__; });
    m = ({ typename _ap_type::remove_const<typeof(m)>::type __Result__ = 0; typeof(m) __Val2__ = m; typeof(e) __Repl2__ = e; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 23, 23 + 8 - 1); __Result__; });

    return rawBitsToFloat(m);
  }



  inline __attribute__((always_inline)) half to_half() const {




    enum { BITS = 10 + 5 + 1 };
    if (!Base::V) return 0.0f;
    bool s = _AP_S && ({ typeof(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
    ap_int_base<_AP_W, false> tmp;
    if (s)
      tmp.V = -Base::V;
    else
      tmp.V = Base::V;
    int l = tmp.countLeadingZeros();
    int e = _AP_I - l - 1 + ((1L << (5 - 1L)) - 1L);
    int lsb_index = _AP_W - l - 1 - 10;

    bool a = (lsb_index >=2) ?
        (({ typename _ap_type::remove_const<typeof(tmp.V)>::type __Result__ = 0; typeof(tmp.V) __Val2__ = tmp.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, lsb_index - 2); __Result__; }) != 0) : 0;

    a |= (lsb_index >=0) ? ({ typeof(tmp.V) __Val2__ = tmp.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), lsb_index); __Result__; }) : 0;

    unsigned short m;

    if (_AP_W > BITS) {
      m = (lsb_index >= 1) ? (unsigned short)(tmp.V >> (lsb_index - 1))
                           : (unsigned short)(tmp.V << (1 - lsb_index));
    } else {
      m = (unsigned short)tmp.V;
      m = (lsb_index >= 1) ? (m >> (lsb_index - 1))
                           : (m << (1 - lsb_index));
    }
    m += a;
    m >>= 1;

    if (({ typeof(m) __Val2__ = m; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), 10 + 1); __Result__; })) {
      e += 1;
    }

    m = ({ typename _ap_type::remove_const<typeof(m)>::type __Result__ = 0; typeof(m) __Val2__ = m; typeof(s) __Repl2__ = !!s; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), BITS - 1, BITS - 1); __Result__; });
    m = ({ typename _ap_type::remove_const<typeof(m)>::type __Result__ = 0; typeof(m) __Val2__ = m; typeof(e) __Repl2__ = e; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 10, 10 + 5 - 1); __Result__; });

    return rawBitsToHalf(m);
  }


  inline __attribute__((always_inline)) operator long double() const { return (long double)to_double(); }

  inline __attribute__((always_inline)) operator double() const { return to_double(); }

  inline __attribute__((always_inline)) operator float() const { return to_float(); }

  inline __attribute__((always_inline)) operator half() const { return to_half(); }

  inline __attribute__((always_inline)) operator bool() const { return (bool)Base::V != 0; }

  inline __attribute__((always_inline)) operator char() const { return (char)to_int(); }

  inline __attribute__((always_inline)) operator signed char() const { return (signed char)to_int(); }

  inline __attribute__((always_inline)) operator unsigned char() const { return (unsigned char)to_uint(); }

  inline __attribute__((always_inline)) operator short() const { return (short)to_int(); }

  inline __attribute__((always_inline)) operator unsigned short() const { return (unsigned short)to_uint(); }

  inline __attribute__((always_inline)) operator int() const { return to_int(); }

  inline __attribute__((always_inline)) operator unsigned int() const { return to_uint(); }



  inline __attribute__((always_inline)) operator long() const { return (long)to_int64(); }

  inline __attribute__((always_inline)) operator unsigned long() const { return (unsigned long)to_uint64(); }






  inline __attribute__((always_inline)) operator ap_ulong() const { return to_uint64(); }

  inline __attribute__((always_inline)) operator ap_slong() const { return to_int64(); }

  inline __attribute__((always_inline)) int length() const { return _AP_W; };
# 1074 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_base.h"
  inline __attribute__((always_inline)) int countLeadingZeros() {


    if (_AP_W <= 32) {
      ap_int_base<32, false> t(-1ULL);
      t.range(_AP_W - 1, 0) = this->range(0, _AP_W - 1);
      return __builtin_ctz(t.V);
    } else if (_AP_W <= 64) {
      ap_int_base<64, false> t(-1ULL);
      t.range(_AP_W - 1, 0) = this->range(0, _AP_W - 1);
      return __builtin_ctzll(t.V);
    } else {
      enum {__N = (_AP_W + 63) / 64};
      int NZeros = 0;
      int i = 0;
      bool hitNonZero = false;
      VITIS_LOOP_1090_1: for (i = 0; i < __N - 1; ++i) {
        ap_int_base<64, false> t;
        t.range(0, 63) = this->range(_AP_W - i * 64 - 64, _AP_W - i * 64 - 1);
        NZeros += hitNonZero ? 0 : __builtin_clzll(t.V);
        hitNonZero |= (t != 0);
      }
      if (!hitNonZero) {
        ap_int_base<64, false> t(-1ULL);
        t.range(63 - (_AP_W - 1) % 64, 63) = this->range(0, (_AP_W - 1) % 64);
        NZeros += __builtin_clzll(t.V);
      }
      return NZeros;
    }



  }



  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) typename RType<_AP_W2, _AP_I2, _AP_S2>::mult operator*(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2)
      const {
    typename RType<_AP_W2, _AP_I2, _AP_S2>::mult_base r, t;
    r.V = Base::V;
    t.V = op2.V;
    r.V *= op2.V;
    return r;
  }



  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) typename RType<_AP_W2, _AP_I2, _AP_S2>::div operator/(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2)
      const {
    typename RType<_AP_W2, _AP_I2, _AP_S2>::div_base r;
# 1144 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_base.h"
        ap_fixed_base<_AP_W + ((_AP_W2 - _AP_I2) > (0) ? (_AP_W2 - _AP_I2) : (0)),_AP_I, _AP_S> t(*this);



        r.V = t.V / op2.V;
# 1177 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_base.h"
    return r;
  }
# 1192 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) typename RType<_AP_W2, _AP_I2, _AP_S2>::plus operator +( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::plus_base ret, lhs(*this), rhs(op2); ret.V = lhs.V + rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) typename RType<_AP_W2, _AP_I2, _AP_S2>::minus operator -( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::minus_base ret, lhs(*this), rhs(op2); ret.V = lhs.V - rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) typename RType<_AP_W2, _AP_I2, _AP_S2>::logic operator &( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::logic_base ret, lhs(*this), rhs(op2); ret.V = lhs.V & rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) typename RType<_AP_W2, _AP_I2, _AP_S2>::logic operator |( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::logic_base ret, lhs(*this), rhs(op2); ret.V = lhs.V | rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) typename RType<_AP_W2, _AP_I2, _AP_S2>::logic operator ^( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::logic_base ret, lhs(*this), rhs(op2); ret.V = lhs.V ^ rhs.V; return ret; }
# 1210 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator *=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator *(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator /=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator /(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator +=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator +(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator -=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator -(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator &=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator &(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator |=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator |(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator ^=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator ^(op2); return *this; }





  inline __attribute__((always_inline)) ap_fixed_base& operator++() {
    operator+=(ap_fixed_base<_AP_W - _AP_I + 1, 1, false>(1));
    return *this;
  }


  inline __attribute__((always_inline)) ap_fixed_base& operator--() {
    operator-=(ap_fixed_base<_AP_W - _AP_I + 1, 1, false>(1));
    return *this;
  }


  inline __attribute__((always_inline)) const ap_fixed_base operator++(int) {
    ap_fixed_base r(*this);
    operator++();
    return r;
  }


  inline __attribute__((always_inline)) const ap_fixed_base operator--(int) {
    ap_fixed_base r(*this);
    operator--();
    return r;
  }



  inline __attribute__((always_inline)) ap_fixed_base operator+() { return *this; }

  inline __attribute__((always_inline)) ap_fixed_base<_AP_W + 1, _AP_I + 1, true> operator-() const {
    ap_fixed_base<_AP_W + 1, _AP_I + 1, true> r(*this);
    r.V = -r.V;
    return r;
  }

  inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> getNeg() {
    ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> r(*this);
    r.V = -r.V;
    return r;
  }



  inline __attribute__((always_inline)) bool operator!() const { return Base::V == 0; }




  inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S> operator~() const {
    ap_fixed_base<_AP_W, _AP_I, _AP_S> r;
    r.V = ~Base::V;
    return r;
  }




  template <int _AP_SHIFT>
  inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I + _AP_SHIFT, _AP_S> lshift() const {
    ap_fixed_base<_AP_W, _AP_I + _AP_SHIFT, _AP_S> r;
    r.V = Base::V;
    return r;
  }

  template <int _AP_SHIFT>
  inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I - _AP_SHIFT, _AP_S> rshift() const {
    ap_fixed_base<_AP_W, _AP_I - _AP_SHIFT, _AP_S> r;
    r.V = Base::V;
    return r;
  }





  inline __attribute__((always_inline)) ap_fixed_base operator<<(unsigned int sh) const {
    ap_fixed_base r;
    r.V = Base::V << sh;
# 1328 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_base.h"
    return r;
  }

  inline __attribute__((always_inline)) ap_fixed_base operator>>(unsigned int sh) const {
    ap_fixed_base r;
    r.V = Base::V >> sh;
# 1350 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_base.h"
    return r;
  }


  inline __attribute__((always_inline)) ap_fixed_base operator<<(int sh) const {
    ap_fixed_base r;
    bool isNeg = sh < 0;
    unsigned int ush = isNeg ? -sh : sh;
    if (isNeg) {
      return operator>>(ush);
    } else {
      return operator<<(ush);
    }
  }

  inline __attribute__((always_inline)) ap_fixed_base operator>>(int sh) const {
    bool isNeg = sh < 0;
    unsigned int ush = isNeg ? -sh : sh;
    if (isNeg) {
      return operator<<(ush);
    } else {
      return operator>>(ush);
    }
  }


  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_fixed_base operator<<(const ap_int_base<_AP_W2, true>& op2) const {


    int sh = op2.to_int();
    return operator<<(sh);
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_fixed_base operator>>(const ap_int_base<_AP_W2, true>& op2) const {
    int sh = op2.to_int();
    return operator>>(sh);
  }


  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_fixed_base operator<<(const ap_int_base<_AP_W2, false>& op2) const {
    unsigned int sh = op2.to_uint();
    return operator<<(sh);
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) ap_fixed_base operator>>(const ap_int_base<_AP_W2, false>& op2) const {
    unsigned int sh = op2.to_uint();
    return operator>>(sh);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed_base operator<<(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          op2) {
    return operator<<(op2.to_ap_int_base());
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed_base operator>>(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          op2) {
    return operator>>(op2.to_ap_int_base());
  }





  inline __attribute__((always_inline)) ap_fixed_base& operator<<=(const int sh) {
    *this = operator<<(sh);
    return *this;
  }

  inline __attribute__((always_inline)) ap_fixed_base& operator<<=(const unsigned int sh) {
    *this = operator<<(sh);
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_fixed_base& operator<<=(const ap_int_base<_AP_W2, _AP_S2>& sh) {
    *this = operator<<(sh.to_int());
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed_base& operator<<=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          sh) {
    *this = operator<<(sh.to_int());
    return *this;
  }


  inline __attribute__((always_inline)) ap_fixed_base& operator>>=(const int sh) {
    *this = operator>>(sh);
    return *this;
  }

  inline __attribute__((always_inline)) ap_fixed_base& operator>>=(const unsigned int sh) {
    *this = operator>>(sh);
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_fixed_base& operator>>=(const ap_int_base<_AP_W2, _AP_S2>& sh) {
    *this = operator>>(sh.to_int());
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed_base& operator>>=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          sh) {
    *this = operator>>(sh.to_int());
    return *this;
  }
# 1494 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator >(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V > op2.V; else if (_AP_F > F2) return Base::V > ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V > op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator <(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V < op2.V; else if (_AP_F > F2) return Base::V < ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V < op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator >=(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V >= op2.V; else if (_AP_F > F2) return Base::V >= ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V >= op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator <=(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V <= op2.V; else if (_AP_F > F2) return Base::V <= ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V <= op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator ==(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V == op2.V; else if (_AP_F > F2) return Base::V == ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V == op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator !=(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V != op2.V; else if (_AP_F > F2) return Base::V != ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V != op2.V; return false; }





  inline __attribute__((always_inline)) bool operator >(double d) const { return to_double() > d; }
  inline __attribute__((always_inline)) bool operator <(double d) const { return to_double() < d; }
  inline __attribute__((always_inline)) bool operator >=(double d) const { return to_double() >= d; }
  inline __attribute__((always_inline)) bool operator <=(double d) const { return to_double() <= d; }
  inline __attribute__((always_inline)) bool operator ==(double d) const { return to_double() == d; }
  inline __attribute__((always_inline)) bool operator !=(double d) const { return to_double() != d; }


  inline __attribute__((always_inline)) af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator[](
      unsigned index) {
    (static_cast<void>(0));
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator[](
      const ap_int_base<_AP_W2, _AP_S2>& index) {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this,
                                                                index.to_int());
  }

  inline __attribute__((always_inline)) bool operator[](unsigned index) const {
    (static_cast<void>(0));
    return ({ typeof(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), index); __Result__; });
  }

  inline __attribute__((always_inline)) af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> bit(
      unsigned index) {
    (static_cast<void>(0));
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> bit(
      const ap_int_base<_AP_W2, _AP_S2>& index) {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this,
                                                                index.to_int());
  }

  inline __attribute__((always_inline)) bool bit(unsigned index) const {
    (static_cast<void>(0));
    return ({ typeof(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), index); __Result__; });
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> get_bit(
      const ap_int_base<_AP_W2, true>& index) {
    (static_cast<void>(0));

    (static_cast<void>(0));
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(
        this, index.to_int() + _AP_W - _AP_I);
  }

  inline __attribute__((always_inline)) bool get_bit(int index) const {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return ({ typeof(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), index + _AP_W - _AP_I); __Result__; });

  }
# 1580 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_base.h"
  template <int _AP_W2>
  inline __attribute__((always_inline)) bool get_bit(const ap_int_base<_AP_W2, true>& index) const {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return ({ typeof(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), index.to_int() + _AP_W - _AP_I); __Result__; });

  }

  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(int Hi,
                                                                      int Lo) {
    (static_cast<void>(0));
    return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, Hi, Lo);
  }


  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(
      int Hi, int Lo) const {
    (static_cast<void>(0));
    return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(
        const_cast<ap_fixed_base*>(this), Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range() {
    return this->range(_AP_W - 1, 0);
  }

  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range() const {
    return this->range(_AP_W - 1, 0);
  }

  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      int Hi, int Lo) {
    return this->range(Hi, Lo);
  }

  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      int Hi, int Lo) const {
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  inline __attribute__((always_inline)) bool is_zero() const { return Base::V == 0; }

  inline __attribute__((always_inline)) bool is_neg() const {
    if (_AP_S && ({ typeof(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; })) return true;
    return false;
  }

  inline __attribute__((always_inline)) int wl() const { return _AP_W; }

  inline __attribute__((always_inline)) int iwl() const { return _AP_I; }

  inline __attribute__((always_inline)) ap_q_mode q_mode() const { return _AP_Q; }

  inline __attribute__((always_inline)) ap_o_mode o_mode() const { return _AP_O; }

  inline __attribute__((always_inline)) int n_bits() const { return _AP_N; }
# 1763 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_base.h"
  inline __attribute__((always_inline)) char* to_string(unsigned char radix = 2, bool sign = _AP_S) const {
    (void)(radix);
    (void)(sign);
    return 0;
  }

};

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline __attribute__((always_inline)) void b_not(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) {
  ret.V = ~op.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline __attribute__((always_inline)) void b_and(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  ret.V = op1.V & op2.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline __attribute__((always_inline)) void b_or(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  ret.V = op1.V | op2.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline __attribute__((always_inline)) void b_xor(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  ret.V = op1.V ^ op2.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
          ap_o_mode _AP_O2, int _AP_N2>
inline __attribute__((always_inline)) void neg(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
  ap_fixed_base<_AP_W2 + !_AP_S2, _AP_I2 + !_AP_S2, true, _AP_Q2, _AP_O2,
                _AP_N2>
      t;
  t.V = -op.V;
  ret = t;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
          ap_o_mode _AP_O2, int _AP_N2>
inline __attribute__((always_inline)) void lshift(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op,
    int i) {
  enum {
    F2 = _AP_W2 - _AP_I2,
    _AP_I3 = ((_AP_I) > (_AP_I2) ? (_AP_I) : (_AP_I2)),
    _AP_W3 = _AP_I3 + F2,
  };

  ap_fixed_base<_AP_W3, _AP_I3, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> t;
  t.V = op.V;
  t.V <<= i;

  ret = t;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
          ap_o_mode _AP_O2, int _AP_N2>
inline __attribute__((always_inline)) void rshift(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op,
    int i) {
  enum {
    F = _AP_W - _AP_I,
    F2 = _AP_W2 - _AP_I2,
    F3 = ((F) > (F2) ? (F) : (F2)),
    _AP_W3 = _AP_I2 + F3,
    sh = F - F2,
  };

  ap_fixed_base<_AP_W3, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> t;
  t.V = op.V;
  if (sh >= 0)
    t.V <<= (int) sh;
  t.V >>= i;

  ret = t;
}
# 2215 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_base.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator +(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::plus operator +( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator -(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::minus operator -( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator *(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::mult operator *( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator /(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::div operator /( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator &(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator &( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator |(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator |( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator ^(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator ^( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >>(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <<(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator +=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator -=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator *=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator /=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator &=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator |=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator ^=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >>=(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <<=(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator ==(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator !=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator +(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::plus operator +( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator -(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::minus operator -( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator *(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::mult operator *( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator /(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::div operator /( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator &(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator &( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator |(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator |( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator ^(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator ^( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >>(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <<(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator +=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator -=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator *=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator /=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator &=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator |=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator ^=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >>=(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <<=(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator ==(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator !=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator +(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::plus operator +( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator -(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::minus operator -( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator *(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::mult operator *( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator /(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::div operator /( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator &(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator &( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator |(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator |( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator ^(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator ^( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >>(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <<(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator +=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator -=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator *=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator /=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator &=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator |=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator ^=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >>=(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <<=(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator ==(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator !=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator +(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::plus operator +( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator -(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::minus operator -( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator *(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::mult operator *( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator /(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::div operator /( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator &(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator &( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator |(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator |( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ^(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator ^( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >>(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <<(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator +=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator -=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator *=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator /=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator &=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator |=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ^=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >>=(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <<=(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ==(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator !=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::plus operator +( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::minus operator -( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::mult operator *( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::div operator /( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator &( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator |( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator ^( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::plus operator +( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::minus operator -( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::mult operator *( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::div operator /( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator &( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator |( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator ^( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::plus operator +( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::minus operator -( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::mult operator *( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::div operator /( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator &( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator |( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator ^( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::plus operator +( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::minus operator -( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::mult operator *( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::div operator /( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator &( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator |( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator ^( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::plus operator +( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::minus operator -( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::mult operator *( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::div operator /( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator &( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator |( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator ^( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::plus operator +( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::minus operator -( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::mult operator *( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::div operator /( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator &( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator |( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator ^( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::plus operator +( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::minus operator -( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::mult operator *( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::div operator /( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator &( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator |( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator ^( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::plus operator +( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::minus operator -( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::mult operator *( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::div operator /( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator &( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator |( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator ^( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator !=(op); }
# 2303 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_base.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::plus operator +( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator +(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::minus operator -( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator -(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::mult operator *( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator *(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::div operator /( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator /(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::logic operator &( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator &(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::logic operator |( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator |(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::logic operator ^( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator ^(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }



template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator +=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2, _AP_S2>& operator +=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator +=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator -=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2, _AP_S2>& operator -=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator -=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator *=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2, _AP_S2>& operator *=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator *=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator /=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2, _AP_S2>& operator /=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator /=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator &=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2, _AP_S2>& operator &=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator &=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator |=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2, _AP_S2>& operator |=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator |=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator ^=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2, _AP_S2>& operator ^=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator ^=(op.to_ap_int_base()); }



template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator ==(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator ==(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator !=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator >(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator >(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator >=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator >=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator <(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator <(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator <=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator <=(op); }




template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline __attribute__((always_inline)) bool operator==(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator==(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline __attribute__((always_inline)) bool operator!=(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator!=(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline __attribute__((always_inline)) bool operator>(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator<(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline __attribute__((always_inline)) bool operator>=(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator<=(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline __attribute__((always_inline)) bool operator<(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator>(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline __attribute__((always_inline)) bool operator<=(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator>=(op1);
}
# 57 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed.h" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_ref.h" 1
# 71 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_ref.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_bit_ref {



  typedef ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> ref_type;
  ref_type& d_bv;
  int d_index;

 public:
  inline __attribute__((always_inline)) af_bit_ref(
      const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ref)
      : d_bv(ref.d_bv), d_index(ref.d_index) {






  }

  inline __attribute__((always_inline)) af_bit_ref(ref_type* bv, int index = 0) : d_bv(*bv), d_index(index) {}

  inline __attribute__((always_inline)) af_bit_ref(const ref_type* bv, int index = 0)
      : d_bv(*const_cast<ref_type*>(bv)), d_index(index) {}


  inline __attribute__((always_inline)) operator bool() const { return ({ typeof(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }



  inline __attribute__((always_inline)) af_bit_ref& operator=(bool val) {
    d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; });
    return *this;
  }



  inline __attribute__((always_inline)) af_bit_ref& operator=(const af_bit_ref& val) {
    return operator=(bool(val));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) af_bit_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=(bool(val));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) af_bit_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    return operator=(bool(val));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) af_bit_ref& operator=(const ap_int_base<_AP_W2, _AP_S2>& val) {
    return operator=(val != 0);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) af_bit_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    return operator=(ap_int_base<_AP_W2, false>(val));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) af_bit_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=(ap_int_base<_AP_W2, false>(val));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) af_bit_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
    return operator=(ap_int_base<_AP_W2 + _AP_W3, false>(val));
  }




  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<1, af_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, op);
  }

  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> > operator,(
      const ap_bit_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<1, af_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(*this,
                                                                        op);
  }

  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
  operator,(const ap_range_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<1, af_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >(
        *this, op);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &op) {
    return ap_concat_ref<1, af_bit_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,
                                                                         op);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_concat_ref<
      1, af_bit_ref, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &op) {
    return ap_concat_ref<
        1, af_bit_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                                                                       op);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                    _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &op) {
    return ap_concat_ref<1, af_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                      _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            op));
  }




  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) bool operator==(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    return get() == op.get();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) bool operator!=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    return get() != op.get();
  }


  inline __attribute__((always_inline)) bool operator~() const {
    bool bit = ({ typeof(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; });
    return bit ? false : true;
  }

  inline __attribute__((always_inline)) bool get() const { return ({ typeof(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }

  inline __attribute__((always_inline)) int length() const { return 1; }





  inline __attribute__((always_inline)) char* to_string() const { return 0; }

};
# 258 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_ref.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_range_ref {



  typedef ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> ref_type;
  ref_type& d_bv;
  int l_index;
  int h_index;

 public:

  inline __attribute__((always_inline)) af_range_ref(
      const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ref)
      : d_bv(ref.d_bv), l_index(ref.l_index), h_index(ref.h_index) {}




  inline __attribute__((always_inline)) af_range_ref(ref_type* bv, int h, int l)
      : d_bv(*bv), l_index(l), h_index(h) {
# 288 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_ref.h"
  }

  inline __attribute__((always_inline)) af_range_ref(const ref_type* bv, int h, int l)
      : d_bv(*const_cast<ref_type*>(bv)), l_index(l), h_index(h) {
# 300 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_ref.h"
  }
# 312 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_ref.h"
  inline __attribute__((always_inline)) af_range_ref& operator=(const bool val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const char val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const signed char val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const unsigned char val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const short val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const unsigned short val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const int val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const unsigned int val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const long val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const unsigned long val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const ap_slong val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const ap_ulong val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const half val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const float val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const double val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }



  inline __attribute__((always_inline)) af_range_ref& operator=(const char* val) {
    const ap_int_base<_AP_W, false> tmp(val);
    d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
    return *this;
  }



  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) af_range_ref& operator=(const ap_int_base<_AP_W3, _AP_S3>& val) {
    d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val.V) __Repl2__ = val.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
    return *this;
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) af_range_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    const ap_int_base<_AP_W2, false> tmp(val);
    return operator=(tmp);
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) af_range_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    const ap_int_base<1, false> tmp((bool)val);
    return operator=(tmp);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) af_range_ref& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          val) {
    d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val.V) __Repl2__ = val.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
    return *this;
  }




  inline __attribute__((always_inline)) af_range_ref& operator=(const af_range_ref& val) {
    ap_int_base<_AP_W, false> tmp(val);
    return operator=(tmp);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) af_range_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    ap_int_base<_AP_W2, false> tmp(val);
    return operator=(tmp);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) af_range_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    ap_int_base<1, false> tmp((bool)val);
    return operator=(tmp);
  }


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) af_range_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
    const ap_int_base<_AP_W2 + _AP_W3, false> tmp(val);
    return operator=(tmp);
  }




  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator==(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop == rop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator!=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator==(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator<(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop < rop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator>(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop > rop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator<=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator>(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator>=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator<(op2));
  }




  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) bool operator==(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop == rop;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) bool operator!=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    return !(operator==(op2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) bool operator<(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop < rop;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) bool operator>(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop > rop;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) bool operator<=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    return !(operator>(op2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) bool operator>=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    return !(operator<(op2));
  }





  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, af_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(ap_int_base<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, op);
  }


  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(const ap_bit_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(op));
  }


  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
  operator,(const ap_range_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(op));
  }


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        *this, const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(op));
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
                    af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                    &op) {
    return ap_concat_ref<
        _AP_W, af_range_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            op));
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, af_range_ref, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(
          const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &op) {
    return ap_concat_ref<
        _AP_W, af_range_ref, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            op));
  }


  inline __attribute__((always_inline)) operator ap_ulong() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret.to_uint64();
  }

  inline __attribute__((always_inline)) operator ap_int_base<_AP_W, false>() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }

  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> to_ap_int_base() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }


  inline __attribute__((always_inline)) char to_char() const {
    return (char)(({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) int to_int() const {
    return (int)(({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) unsigned to_uint() const {
    return (unsigned)(({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) long to_long() const {
    return (long)(({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) unsigned long to_ulong() const {
    return (unsigned long)(({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) ap_slong to_int64() const {
    return (ap_slong)(({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) ap_ulong to_uint64() const {
    return (ap_ulong)(({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }



  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> operator~() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return (~ret);
  }

  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> operator!() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return (!ret);
  }

  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> operator+() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }

  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> operator-() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return (-ret);
  }


  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> get() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) void set(const ap_int_base<_AP_W2, false>& val) {
    d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val.V) __Repl2__ = val.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
  }

  inline __attribute__((always_inline)) int length() const {
    return h_index >= l_index ? h_index - l_index + 1 : l_index - h_index + 1;
  }
# 661 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_ref.h"
  inline __attribute__((always_inline)) char* to_string(signed char rd = 2) const {
     (void)(rd);
    return 0;
  }

};
# 725 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_ref.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
# 771 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_ref.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != ap_int_base<1, false>(op); }
# 58 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed.h" 2





template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
struct ap_fixed : ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> {
  typedef ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> Base;


  inline __attribute__((always_inline)) ap_fixed() : Base() {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                      _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed(const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                               _AP_O2, _AP_N2>& op)
      : Base(op) {}
# 112 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_fixed(const ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_fixed(const volatile ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}




  inline __attribute__((always_inline)) ap_fixed(unsigned V __attribute__((bitwidth(_AP_W))), bool raw) {
    Base::V = V;
    (void)(raw);
  }
# 147 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_fixed(const ap_bit_ref<_AP_W2, _AP_S2>& op) : Base(op) {}


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_fixed(const ap_range_ref<_AP_W2, _AP_S2>& op) : Base(op) {}


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_fixed(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op)
      : Base(op) {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}





  inline __attribute__((always_inline)) ap_fixed(bool v) : Base(v) {}
  inline __attribute__((always_inline)) ap_fixed(char v) : Base(v) {}
  inline __attribute__((always_inline)) ap_fixed(signed char v) : Base(v) {}
  inline __attribute__((always_inline)) ap_fixed(unsigned char v) : Base(v) {}
  inline __attribute__((always_inline)) ap_fixed(short v) : Base(v) {}
  inline __attribute__((always_inline)) ap_fixed(unsigned short v) : Base(v) {}
  inline __attribute__((always_inline)) ap_fixed(int v) : Base(v) {}
  inline __attribute__((always_inline)) ap_fixed(unsigned int v) : Base(v) {}
  inline __attribute__((always_inline)) ap_fixed(long v) : Base(v) {}
  inline __attribute__((always_inline)) ap_fixed(unsigned long v) : Base(v) {}
  inline __attribute__((always_inline)) ap_fixed(ap_slong v) : Base(v) {}
  inline __attribute__((always_inline)) ap_fixed(ap_ulong v) : Base(v) {}
  inline __attribute__((always_inline)) ap_fixed(half v) : Base(v) {}
  inline __attribute__((always_inline)) ap_fixed(float v) : Base(v) {}
  inline __attribute__((always_inline)) ap_fixed(double v) : Base(v) {}


  inline __attribute__((always_inline)) ap_fixed(const char* s) : Base(s) {}

  inline __attribute__((always_inline)) ap_fixed(const char* s, signed char rd) : Base(s, rd) {}






  ap_fixed &
  operator=(const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &op) = default;

  inline __attribute__((always_inline)) void operator=(
      const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) volatile {
    Base::V = op.V;
  }

  inline __attribute__((always_inline)) ap_fixed& operator=(
      const volatile ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) {
    Base::V = op.V;
    return *this;
  }

  inline __attribute__((always_inline)) void operator=(
      const volatile ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) volatile {
    Base::V = op.V;
  }
};





template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
struct ap_ufixed : ap_fixed_base<_AP_W, _AP_I, false, _AP_Q, _AP_O, _AP_N> {
  typedef ap_fixed_base<_AP_W, _AP_I, false, _AP_Q, _AP_O, _AP_N> Base;


  inline __attribute__((always_inline)) ap_ufixed() : Base() {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_ufixed(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                       _AP_O2, _AP_N2>& op)
      : Base(op) {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_ufixed(const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                                _AP_O2, _AP_N2>& op)
      : Base(op) {}
# 275 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_ufixed(const ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_ufixed(const volatile ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}




  inline __attribute__((always_inline)) ap_ufixed(unsigned V __attribute__((bitwidth(_AP_W))), bool raw) {
    Base::V = V;
    (void)(raw);
  }
# 307 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_ufixed(const ap_bit_ref<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_ufixed(const ap_range_ref<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_ufixed(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_ufixed(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_ufixed(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}




  inline __attribute__((always_inline)) ap_ufixed(bool v) : Base(v) {}
  inline __attribute__((always_inline)) ap_ufixed(char v) : Base(v) {}
  inline __attribute__((always_inline)) ap_ufixed(signed char v) : Base(v) {}
  inline __attribute__((always_inline)) ap_ufixed(unsigned char v) : Base(v) {}
  inline __attribute__((always_inline)) ap_ufixed(short v) : Base(v) {}
  inline __attribute__((always_inline)) ap_ufixed(unsigned short v) : Base(v) {}
  inline __attribute__((always_inline)) ap_ufixed(int v) : Base(v) {}
  inline __attribute__((always_inline)) ap_ufixed(unsigned int v) : Base(v) {}
  inline __attribute__((always_inline)) ap_ufixed(long v) : Base(v) {}
  inline __attribute__((always_inline)) ap_ufixed(unsigned long v) : Base(v) {}
  inline __attribute__((always_inline)) ap_ufixed(ap_slong v) : Base(v) {}
  inline __attribute__((always_inline)) ap_ufixed(ap_ulong v) : Base(v) {}
  inline __attribute__((always_inline)) ap_ufixed(half v) : Base(v) {}
  inline __attribute__((always_inline)) ap_ufixed(float v) : Base(v) {}
  inline __attribute__((always_inline)) ap_ufixed(double v) : Base(v) {}


  inline __attribute__((always_inline)) ap_ufixed(const char* s) : Base(s) {}

  inline __attribute__((always_inline)) ap_ufixed(const char* s, signed char rd) : Base(s, rd) {}


  ap_ufixed &
  operator=(const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &op) = default;

  inline __attribute__((always_inline)) void operator=(
      const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) volatile {
    Base::V = op.V;
  }

  inline __attribute__((always_inline)) ap_ufixed& operator=(
      const volatile ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) {
    Base::V = op.V;
    return *this;
  }

  inline __attribute__((always_inline)) void operator=(const volatile ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O,
                                                 _AP_N>& op) volatile {
    Base::V = op.V;
  }
};
# 395 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed.h"
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_special.h" 1
# 61 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_special.h"
namespace std {
template<typename _Tp> class complex;
}







namespace std {
# 89 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_special.h"
template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
class complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > {
 public:
  typedef ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> _Tp;
  typedef _Tp value_type;




  complex() : _M_real(_Tp()), _M_imag(_Tp()) {}


  complex(const _Tp &__r, const _Tp &__i = _Tp(0))
      : _M_real(__r), _M_imag(__i) {}


  template <typename _Up>
  complex(const complex<_Up> &__z) : _M_real(__z.real()), _M_imag(__z.imag()) {}


  const _Tp& real() const { return _M_real; }
  const _Tp& imag() const { return _M_imag; }







  void real(_Tp __val) { _M_real = __val; }

  void imag(_Tp __val) { _M_imag = __val; }



  complex<_Tp> &operator=(const _Tp __t) {
    _M_real = __t;
    _M_imag = _Tp(0);
    return *this;
  }



  complex<_Tp> &operator+=(const _Tp &__t) {
    _M_real += __t;
    return *this;
  }



  complex<_Tp> &operator-=(const _Tp &__t) {
    _M_real -= __t;
    return *this;
  }



  complex<_Tp> &operator*=(const _Tp &__t) {
    _M_real *= __t;
    _M_imag *= __t;
    return *this;
  }



  complex<_Tp> &operator/=(const _Tp &__t) {
    _M_real /= __t;
    _M_imag /= __t;
    return *this;
  }


  template <typename _Up>
  complex<_Tp> &operator=(const complex<_Up> &__z) {
    _M_real = __z.real();
    _M_imag = __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator+=(const complex<_Up> &__z) {
    _M_real += __z.real();
    _M_imag += __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator-=(const complex<_Up> &__z) {
    _M_real -= __z.real();
    _M_imag -= __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator*=(const complex<_Up> &__z) {
    const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();
    _M_imag = _M_real * __z.imag() + _M_imag * __z.real();
    _M_real = __r;
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator/=(const complex<_Up> &__z) {
    complex<_Tp> cj (__z.real(), -__z.imag());
    complex<_Tp> a = (*this) * cj;
    complex<_Tp> b = cj * __z;
    _M_real = a.real() / b.real();
    _M_imag = a.imag() / b.real();
    return *this;
  }

 private:
  _Tp _M_real;
  _Tp _M_imag;

};
# 230 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_special.h"
template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
class complex<ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > {
 public:
  typedef ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> _Tp;
  typedef _Tp value_type;




  complex() : _M_real(_Tp()), _M_imag(_Tp()) {}


  complex(const _Tp &__r, const _Tp &__i = _Tp(0))
      : _M_real(__r), _M_imag(__i) {}


  template <typename _Up>
  complex(const complex<_Up> &__z) : _M_real(__z.real()), _M_imag(__z.imag()) {}


  const _Tp& real() const { return _M_real; }
  const _Tp& imag() const { return _M_imag; }







  void real(_Tp __val) { _M_real = __val; }

  void imag(_Tp __val) { _M_imag = __val; }



  complex<_Tp> &operator=(const _Tp __t) {
    _M_real = __t;
    _M_imag = _Tp(0);
    return *this;
  }



  complex<_Tp> &operator+=(const _Tp &__t) {
    _M_real += __t;
    return *this;
  }



  complex<_Tp> &operator-=(const _Tp &__t) {
    _M_real -= __t;
    return *this;
  }



  complex<_Tp> &operator*=(const _Tp &__t) {
    _M_real *= __t;
    _M_imag *= __t;
    return *this;
  }



  complex<_Tp> &operator/=(const _Tp &__t) {
    _M_real /= __t;
    _M_imag /= __t;
    return *this;
  }


  template <typename _Up>
  complex<_Tp> &operator=(const complex<_Up> &__z) {
    _M_real = __z.real();
    _M_imag = __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator+=(const complex<_Up> &__z) {
    _M_real += __z.real();
    _M_imag += __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator-=(const complex<_Up> &__z) {
    _M_real -= __z.real();
    _M_imag -= __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator*=(const complex<_Up> &__z) {
    const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();
    _M_imag = _M_real * __z.imag() + _M_imag * __z.real();
    _M_real = __r;
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator/=(const complex<_Up> &__z) {
    complex<_Tp> cj (__z.real(), -__z.imag());
    complex<_Tp> a = (*this) * cj;
    complex<_Tp> b = cj * __z;
    _M_real = a.real() / b.real();
    _M_imag = a.imag() / b.real();
    return *this;
  }

 private:
  _Tp _M_real;
  _Tp _M_imag;

};
# 362 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed_special.h"
template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator==(
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__x,
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__y) {
  return __x.real() == __y &&
         __x.imag() == 0;
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator==(
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__x,
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__y) {
  return __x == __y.real() &&
         0 == __y.imag();
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator!=(
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__x,
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__y) {
  return __x.real() != __y ||
         __x.imag() != 0;
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator!=(
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__x,
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__y) {
  return __x != __y.real() ||
         0 != __y.imag();
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator==(
    const complex<ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__x,
    const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__y) {
  return __x.real() == __y &&
         __x.imag() == 0;
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator==(
    const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__x,
    const complex<ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__y) {
  return __x == __y.real() &&
         0 == __y.imag();
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator!=(
    const complex<ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__x,
    const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__y) {
  return __x.real() != __y ||
         __x.imag() != 0;
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator!=(
    const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__x,
    const complex<ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__y) {
  return __x != __y.real() ||
         0 != __y.imag();
}

}
# 396 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_fixed.h" 2
# 24 "./headers1/buffer.h" 2
# 1 "./headers1/defines.h" 1
# 31 "./headers1/defines.h"
typedef float float24_t;
# 25 "./headers1/buffer.h" 2






template<int SIZE>
class buffer
{
public:
 buffer();
 void SetValue(float24_t val, int pos);
 void InsertFront(float24_t val);
 void InsertBack(float24_t val);
 float24_t GetValue(int pos);
private:
 float24_t array[SIZE];
};






template<int SIZE>
buffer<SIZE>::buffer()
{
 VITIS_LOOP_52_1: for(int i = 0; i < SIZE; i++)
  array[i] = 0;
}


template<int SIZE>
void buffer<SIZE>::SetValue(float24_t val, int pos)
{
 array[pos] = val;
}

template<int SIZE>
void buffer<SIZE>::InsertFront(float24_t val)
{
 int i;
 VITIS_LOOP_67_1: for(i = SIZE-1; i > 0 ; i--)
  array[i] = array[i - 1];
 array[0] = val;
}


template<int SIZE>
void buffer<SIZE>::InsertBack(float24_t val)
{
 int i;
 VITIS_LOOP_77_1: for(i = 0; i < SIZE - 1; i++)
  array[i] = array[i + 1];
 array[SIZE - 1] = val;
}


template<int SIZE>
float24_t buffer<SIZE>::GetValue(int pos)
{
 return array[pos];
}
# 3 "pooling_layer2.cpp" 2
# 1 "./headers1/weights.h" 1
# 62 "./headers1/weights.h"
float24_t fc_layer1_bias[10] = { 0.0713, 0.0251, -0.0268, 0.0084, 0.1894, -0.0430, -0.0014, -0.0038, -0.0266, -0.0245};

float24_t fc_layer1_weights[1568][10] =
  {{ 0.008779,-0.061029,-0.015258,0.003607,-0.053119,0.058209,-0.006215,0.002880,-0.006976,0.030267},
  { 0.020322,0.071295,-0.073217,-0.036181,0.032066,0.015042,0.000146,-0.036428,-0.007998,0.005735},
  { 0.030434,0.061900,-0.076159,-0.010286,0.034039,0.026730,0.004313,0.029622,-0.014614,0.058567},
  { 0.043981,0.083340,0.011712,-0.007244,0.097140,-0.108425,-0.009042,-0.007949,-0.000881,0.050965},
  { -0.003685,-0.001851,0.015084,-0.024225,-0.018137,0.002111,0.011337,0.019480,0.005214,0.021083},
  { 0.010536,0.006300,0.018397,0.013705,-0.003224,0.011399,0.013104,-0.003535,0.005080,0.001663},
  { 0.019809,0.031959,0.008499,-0.004475,0.027446,-0.126660,0.008372,0.005605,-0.006966,-0.060871},
  { 0.014429,0.085865,0.059936,-0.063925,0.061325,-0.160801,0.008147,-0.006428,0.003563,-0.101055},
  { 0.009991,0.087755,-0.071319,-0.038673,0.072522,-0.022626,0.022220,-0.023646,0.022218,0.002477},
  { 0.018300,0.019413,-0.052691,-0.053346,-0.018712,0.020927,0.020755,0.005194,-0.001883,0.000285},
  { -0.014663,0.015823,0.041506,-0.055830,-0.027692,-0.026202,0.019142,0.020013,-0.016978,0.028180},
  { -0.007206,0.027747,-0.011855,0.031650,-0.049827,0.104426,0.000647,0.005353,0.016420,-0.069597},
  { -0.024217,0.027595,-0.097081,-0.016080,-0.020525,0.014264,-0.014447,-0.013150,-0.000956,0.055158},
  { 0.004255,0.015153,-0.034976,0.020421,0.032168,-0.045490,-0.002837,0.010079,0.004999,0.084488},
  { 0.024052,-0.022587,0.125450,-0.057399,0.025093,-0.027559,-0.015099,-0.018393,0.003684,0.036682},
  { 0.020858,0.014691,0.086546,0.020634,-0.037986,-0.062044,0.000327,-0.030103,-0.001865,0.032897},
  { 0.026541,0.061020,-0.023717,-0.076758,0.135528,-0.089934,-0.008249,-0.002947,0.014197,-0.019622},
  { 0.074896,0.109142,0.029003,-0.066378,0.207318,-0.167320,0.002917,-0.041440,0.005143,-0.053995},
  { 0.029836,0.094448,0.078178,-0.093634,0.128573,-0.189178,-0.021693,-0.018248,0.009236,-0.018701},
  { 0.030460,0.066435,0.018210,-0.110141,0.151110,-0.142955,-0.018070,-0.023394,-0.002902,0.038477},
  { 0.011298,0.052789,0.091964,0.002508,0.107478,-0.155063,0.012030,0.014980,0.010003,-0.121092},
  { 0.007597,0.074586,0.089181,-0.033460,-0.027046,-0.066298,-0.001771,-0.020666,0.014596,-0.028638},
  { 0.004859,0.133803,0.045303,-0.041113,0.027777,-0.128696,0.018132,-0.033324,0.010794,-0.008068},
  { 0.020600,0.043769,-0.045185,-0.075477,0.000305,-0.032721,-0.015814,-0.006446,-0.013402,-0.039645},
  { 0.021084,0.038898,0.004966,-0.042575,-0.002286,-0.009615,-0.025845,0.018463,0.010252,-0.051562},
  { -0.022413,0.010850,-0.009468,0.053976,-0.064660,0.106956,0.014306,-0.000329,0.002246,-0.031731},
  { -0.010726,0.021628,-0.041622,-0.017696,-0.069200,0.056974,0.010757,0.010996,0.012729,0.032452},
  { 0.009392,0.010619,0.019931,0.027510,-0.019126,-0.044704,-0.018699,0.005670,0.016697,0.078134},
  { 0.032024,0.013987,0.044997,-0.035288,-0.028693,-0.035224,0.015516,0.003903,0.001262,0.008525},
  { 0.022413,0.002978,0.118550,-0.020146,-0.000634,-0.079553,-0.006285,-0.054443,-0.013587,0.037222},
  { 0.052078,0.022832,-0.047856,-0.087508,0.147824,-0.051217,-0.008208,0.012083,0.005342,0.082198},
  { 0.039350,0.046419,-0.069661,-0.032720,0.135702,-0.089365,-0.025504,-0.014854,-0.015258,-0.045688},
  { 0.031169,0.047666,0.090679,-0.061791,-0.024820,-0.103512,0.008651,0.019884,-0.008222,-0.034858},
  { 0.035545,0.029965,0.076470,-0.111171,0.040390,-0.155141,-0.011623,0.025069,0.012518,-0.008970},
  { 0.010326,-0.014837,0.034124,-0.020740,0.000697,-0.073495,-0.025093,0.034041,-0.011894,-0.093654},
  { 0.014100,0.045669,0.007371,-0.035686,0.012193,-0.002410,-0.007466,0.001293,0.007712,-0.027787},
  { 0.000389,0.130498,-0.033093,-0.000783,-0.026813,-0.035278,0.018463,-0.014701,0.012297,-0.030130},
  { 0.028437,0.067910,-0.102513,-0.046611,0.004848,0.034276,-0.023527,-0.001453,-0.005114,0.047296},
  { 0.020034,0.022865,-0.046104,-0.011623,-0.028810,0.037269,0.002110,-0.012271,-0.002827,-0.044561},
  { 0.017088,0.044398,-0.014785,0.056160,0.017366,0.030308,0.008119,0.010320,-0.015272,-0.031459},
  { -0.026259,0.043036,-0.035529,0.053464,-0.068495,0.070063,-0.019013,0.042137,0.009778,-0.048100},
  { -0.005664,0.029252,-0.008891,0.003350,-0.045595,0.023238,0.011745,0.009293,0.017854,0.069862},
  { -0.030706,0.002568,-0.099367,-0.004981,-0.007340,0.069839,-0.019339,0.010119,-0.025182,0.058258},
  { 0.058938,0.060949,0.109074,-0.070120,0.117048,-0.148415,0.002546,0.011657,-0.025530,-0.022798},
  { 0.029880,0.085599,-0.055008,-0.055259,0.104024,-0.107370,0.007973,0.037238,0.021305,0.027500},
  { 0.002536,0.054293,-0.023995,0.002958,0.120190,-0.092476,-0.006941,-0.016913,0.019193,0.017999},
  { 0.003856,0.097825,-0.042110,-0.030928,-0.045321,0.054259,-0.017524,0.052498,0.007253,-0.005231},
  { 0.020267,-0.043962,-0.053042,-0.009391,-0.045306,0.013365,-0.024781,0.021822,-0.016998,-0.027674},
  { 0.009374,0.033869,0.047536,-0.067372,0.109109,-0.143752,0.006066,0.020912,-0.021789,-0.043781},
  { -0.002958,-0.013637,-0.065816,0.007698,-0.035701,0.149357,0.018981,0.083040,-0.022811,0.046215},
  { -0.040531,0.022719,-0.063874,0.054184,-0.065928,0.065242,0.007435,-0.024921,0.001248,-0.032597},
  { 0.026179,0.043483,-0.095921,-0.020979,-0.045666,-0.005952,-0.017319,-0.016306,-0.023016,0.123875},
  { 0.001488,0.063636,-0.044575,-0.020906,-0.097795,0.071308,0.013853,0.008293,-0.012050,-0.006651},
  { -0.018742,-0.012075,-0.077191,0.107358,0.005510,0.080686,0.007207,-0.016918,0.010625,-0.017527},
  { -0.008597,0.062084,-0.107388,0.021657,0.075640,0.013660,-0.022598,-0.010162,-0.022440,-0.015546},
  { 0.004530,0.074849,-0.000102,0.001745,-0.000006,0.003112,-0.017525,0.015598,0.017421,0.010831},
  { -0.038353,0.026049,-0.059547,0.071387,-0.059408,0.096922,0.005691,0.008441,0.017320,0.030215},
  { 0.005770,0.010345,0.019702,-0.033132,0.045765,-0.033815,0.002840,0.019047,-0.021875,0.012865},
  { -0.008259,0.061114,-0.087003,-0.027837,-0.087174,0.053058,-0.004605,0.033776,-0.007424,0.117784},
  { 0.001215,0.029126,0.004772,0.010076,-0.020392,0.016940,-0.017982,0.003767,-0.020194,0.035104},
  { -0.021592,0.034750,-0.048347,-0.055589,0.079690,0.033749,0.021688,0.026295,0.002079,0.078698},
  { -0.013995,-0.047819,-0.087873,0.003305,-0.083378,0.081829,-0.002613,0.032311,-0.015366,-0.047353},
  { -0.015735,-0.078894,0.009243,0.009195,-0.034726,0.078156,-0.017065,-0.008098,0.000527,0.034152},
  { -0.001771,-0.025063,-0.003582,-0.007844,-0.016687,0.082125,-0.006998,0.062872,0.019224,0.055604},
  { -0.010824,0.045428,-0.027527,0.029470,-0.019691,0.066825,0.003503,0.012677,0.020569,-0.032115},
  { 0.015704,0.026014,-0.080827,0.016434,0.024356,-0.004536,0.016220,0.011765,-0.011279,0.056874},
  { 0.003367,-0.005037,0.040684,-0.029776,-0.015207,-0.014871,0.010725,-0.011333,-0.015168,0.044961},
  { 0.010456,0.009410,0.017085,-0.017230,0.008193,-0.043847,-0.016288,-0.036050,-0.011106,-0.090475},
  { -0.015634,-0.008747,-0.119033,0.007446,-0.007526,0.036273,-0.018458,-0.025683,-0.018338,-0.032397},
  { -0.010848,0.040522,0.045018,-0.015494,-0.051486,-0.032186,-0.020773,-0.016882,-0.005110,-0.005605},
  { -0.006422,-0.023070,-0.070419,0.059770,-0.005351,0.012142,-0.022434,-0.002962,-0.005671,0.042917},
  { -0.004765,0.002063,-0.013265,-0.014344,0.042398,-0.009717,-0.013699,0.001859,-0.023204,0.084760},
  { 0.052028,0.042638,0.005235,-0.089936,-0.010431,-0.042385,0.012162,0.025712,0.020645,0.026623},
  { -0.007109,0.049578,-0.058967,-0.008489,-0.039886,0.035460,0.000887,0.032244,-0.002492,-0.004148},
  { -0.003315,0.016328,-0.034021,-0.054967,0.013342,0.014345,0.013070,0.024650,0.006845,0.026410},
  { 0.013229,0.057906,-0.081812,0.000910,-0.016100,0.011355,-0.024824,-0.014598,0.008364,-0.077775},
  { 0.016290,-0.019343,0.094050,-0.016690,0.010447,-0.022088,0.022470,0.022615,-0.005730,-0.010963},
  { -0.017666,-0.050920,-0.006683,-0.029743,0.061456,0.068560,0.001347,0.013516,0.014809,0.056035},
  { -0.040986,0.067818,-0.137486,0.053061,-0.017375,0.089556,0.016345,0.033854,0.020497,-0.013831},
  { 0.006972,0.052484,-0.138732,0.044080,-0.020124,0.054146,0.024969,-0.031563,0.000315,-0.029326},
  { -0.004816,0.017552,-0.012896,-0.051958,0.077745,-0.006284,0.002908,0.012844,-0.018231,0.022652},
  { -0.012895,-0.107717,0.020904,0.018035,-0.093900,0.047522,-0.009750,-0.016122,-0.023682,0.034319},
  { -0.008136,-0.006846,-0.057420,0.040577,-0.024009,-0.015295,-0.016828,0.001245,-0.017711,-0.055530},
  { 0.005256,0.006395,0.024075,0.009067,-0.063436,0.008358,0.008334,0.017566,-0.026155,-0.009617},
  { 0.026052,-0.032420,0.138569,0.008781,0.068328,-0.138164,0.001707,-0.057361,-0.016778,-0.023246},
  { -0.008377,-0.047877,-0.006611,-0.013031,0.048162,-0.064326,-0.009196,-0.013850,-0.011916,0.025619},
  { -0.008871,0.007612,0.022678,0.027480,-0.133733,-0.027772,0.006466,0.001797,0.023379,0.010216},
  { 0.009076,0.016199,-0.024871,0.004493,-0.093820,0.069353,-0.010522,-0.020844,0.022070,0.009269},
  { -0.033227,-0.036799,-0.105303,-0.023466,-0.102949,0.142725,-0.019362,0.057188,-0.013367,0.109754},
  { -0.005021,0.086599,-0.085264,0.019542,-0.021071,0.068181,0.017925,-0.015395,0.007460,-0.033588},
  { 0.021882,0.039932,0.004307,0.069862,-0.023247,0.026845,0.021738,0.012419,0.002898,-0.050103},
  { 0.044019,-0.079629,0.138037,-0.040903,0.136976,-0.081042,-0.008100,-0.034838,0.012693,-0.048303},
  { 0.008706,0.026818,-0.082220,-0.055299,0.093995,-0.051835,-0.004766,0.031151,0.008110,-0.002442},
  { 0.019050,-0.014834,-0.109775,0.039863,0.025023,0.035539,-0.004926,-0.021839,-0.026219,-0.032488},
  { 0.031174,-0.059426,0.008984,-0.022678,0.004208,-0.011659,-0.010006,-0.021827,0.009403,-0.027224},
  { 0.008790,-0.023755,-0.013951,0.059443,-0.019398,-0.054401,0.018862,-0.016810,-0.001224,0.031141},
  { -0.004969,-0.015297,-0.048383,0.082508,-0.081810,0.001610,-0.016724,0.012176,0.021033,0.010331},
  { 0.046584,0.001391,0.177363,-0.086070,0.052468,-0.127439,-0.003062,0.013115,0.009107,-0.095634},
  { 0.015476,-0.018274,0.064433,0.002434,0.053944,-0.114470,-0.012222,-0.007011,-0.004676,-0.026261},
  { -0.010321,0.002215,0.001813,0.010493,-0.003007,-0.017730,0.010146,0.019348,0.012081,0.068858},
  { -0.000008,0.069932,0.059625,0.026731,-0.031227,-0.095863,-0.014219,-0.020467,-0.023496,-0.065863},
  { -0.009843,0.033978,-0.031418,-0.000945,-0.149408,0.049749,-0.008664,0.009567,-0.010914,0.021234},
  { -0.028079,-0.029197,-0.050620,-0.011576,-0.070168,0.050528,-0.005144,0.025325,-0.011295,0.032895},
  { 0.024995,0.073005,-0.027747,-0.053113,0.071164,-0.026040,-0.011981,-0.014077,0.013627,0.009961},
  { -0.028587,-0.019954,-0.022150,0.066622,0.037455,0.013736,0.000126,0.005476,0.008975,-0.042515},
  { -0.021077,-0.065605,-0.032233,0.059988,-0.038472,0.079539,0.019621,-0.021005,0.011982,0.059867},
  { 0.032721,0.017899,-0.053389,-0.053344,0.139011,-0.029745,0.026838,-0.007525,-0.007820,0.055670},
  { 0.037471,0.004509,-0.034879,-0.049222,0.128616,-0.021629,0.001955,0.006165,0.017283,-0.005258},
  { 0.007181,-0.037723,-0.056390,-0.038973,-0.000259,-0.010718,-0.005595,0.007574,0.005357,0.006117},
  { 0.021593,0.019967,-0.039356,-0.005250,-0.045925,-0.015276,-0.005857,-0.046238,-0.017822,-0.014028},
  { 0.016138,0.039385,0.015168,0.078358,-0.020533,-0.068014,-0.022338,-0.054212,0.015640,-0.023431},
  { 0.030943,0.033305,0.143150,-0.019168,0.088637,-0.147015,0.003108,0.009162,-0.011826,-0.013988},
  { 0.007215,-0.019711,0.100431,-0.062460,0.059088,-0.102526,-0.008748,-0.023891,0.001763,-0.038114},
  { -0.020790,-0.016711,-0.009266,0.022209,0.005666,0.051687,-0.014540,0.047285,0.004097,0.034583},
  { -0.011407,0.027893,-0.030524,0.079409,-0.117113,0.069960,-0.001850,-0.000461,0.006913,-0.043367},
  { 0.004250,0.015987,0.130684,0.000079,-0.113694,-0.069766,-0.012137,-0.006430,-0.006891,-0.001712},
  { -0.020407,-0.060795,0.021393,0.048814,-0.107219,0.011369,0.024896,-0.022063,0.004937,0.037693},
  { 0.035845,0.015125,-0.022828,-0.089300,0.037131,-0.041625,-0.018717,0.026449,0.003438,0.015550},
  { -0.020711,-0.031837,-0.013411,-0.002387,0.009351,0.091704,-0.013543,0.009285,-0.003808,0.044035},
  { 0.019211,-0.000469,0.018412,-0.038581,0.009494,0.004646,0.013118,0.007863,0.011195,-0.023205},
  { -0.008503,0.045284,-0.087782,0.018244,0.010477,0.033739,0.021476,-0.055599,0.014557,0.041254},
  { -0.009114,-0.065731,0.019433,0.086697,-0.033979,0.133815,-0.001966,0.008891,-0.015426,0.022117},
  { 0.025031,-0.055916,-0.082804,0.010272,-0.028474,0.016830,0.000393,-0.017532,-0.024132,0.005868},
  { 0.002784,-0.043825,-0.008146,0.008681,-0.087441,0.084430,0.010406,-0.031181,-0.006106,0.033012},
  { 0.019574,0.042098,0.061321,0.008939,-0.021821,-0.095976,0.019626,-0.043460,-0.025462,-0.099545},
  { 0.044868,-0.013662,0.069176,0.019305,0.080513,-0.053108,-0.009035,0.018805,-0.002838,-0.028818},
  { -0.020427,-0.088546,0.104771,-0.030749,-0.026935,-0.025337,0.010832,-0.018133,-0.008940,0.031747},
  { -0.008481,0.001812,0.023253,-0.010951,-0.025317,0.012308,-0.026199,-0.014170,0.004841,0.000295},
  { -0.045000,-0.043902,-0.036635,0.031970,-0.110221,0.110095,-0.005165,-0.015005,0.010681,0.003942},
  { -0.052855,-0.048994,-0.004920,0.065733,-0.155591,0.113312,-0.009255,0.032202,0.022598,0.054079},
  { 0.004983,-0.020396,-0.033287,0.058123,-0.138700,0.011068,0.011388,-0.018933,-0.023099,0.021227},
  { -0.007755,-0.023701,-0.068469,0.039170,-0.091128,0.110385,0.025748,0.019250,-0.005946,0.087083},
  { -0.000853,-0.048826,0.027698,-0.024341,0.003185,0.038765,0.024192,-0.006471,0.003992,-0.016763},
  { 0.017734,-0.032020,-0.029780,0.013319,-0.038336,0.037934,-0.016892,0.004042,-0.007741,-0.048833},
  { -0.032711,-0.006734,-0.035537,0.029419,-0.094162,0.122903,0.007956,0.039760,-0.005996,-0.029541},
  { -0.003898,-0.070151,0.002610,0.042604,-0.079117,0.112457,-0.003307,-0.005947,-0.002198,0.019954},
  { -0.018014,-0.046798,0.006797,0.009576,-0.091562,0.074810,-0.019206,0.010413,-0.007006,0.023324},
  { -0.002178,-0.057833,-0.004472,-0.009086,-0.086785,0.045728,-0.007141,-0.014098,-0.014201,0.102412},
  { 0.012181,0.019480,0.050259,-0.048988,-0.051807,-0.090850,-0.018833,-0.046752,-0.014659,-0.011977},
  { 0.003888,-0.012577,0.010881,0.001634,0.046310,-0.013133,-0.005866,0.015193,0.021794,-0.070929},
  { -0.024189,-0.044277,0.020763,0.063912,0.009157,0.013584,0.007012,-0.007292,-0.021357,0.014015},
  { 0.000127,0.021569,-0.015542,0.035143,0.041124,0.031812,-0.026828,0.004337,0.016701,-0.015755},
  { 0.005379,-0.015965,-0.032757,-0.003137,-0.044246,-0.012210,-0.012122,-0.012376,0.016370,-0.043457},
  { -0.039322,-0.061760,-0.008728,0.101378,-0.079968,0.068831,-0.012661,-0.043639,-0.016938,-0.030402},
  { 0.008408,-0.021000,0.015891,0.004764,-0.123200,0.009040,0.003519,0.018068,0.021822,0.061786},
  { -0.022010,0.002834,-0.054276,0.061758,0.019193,0.050757,0.004117,0.042280,0.021893,0.116051},
  { -0.021038,-0.101523,-0.063161,-0.049067,-0.091126,0.129720,0.001456,0.026028,-0.010822,0.137557},
  { -0.025918,-0.044453,-0.049157,0.017638,-0.127992,0.132557,-0.003935,0.005037,0.005441,0.047985},
  { 0.010765,0.040082,-0.065808,0.062139,0.003093,0.062703,-0.016708,0.014970,0.011296,-0.052802},
  { -0.027617,0.012625,-0.095711,0.136810,-0.077356,0.144986,0.019180,-0.026651,-0.015688,-0.005918},
  { -0.046474,-0.023456,-0.097209,0.103644,-0.147008,0.177986,-0.014907,0.028086,0.002344,0.024675},
  { -0.015861,0.011177,-0.009799,0.017348,-0.041795,0.000262,-0.024238,-0.046392,0.008322,-0.002527},
  { 0.022930,-0.009802,-0.013573,0.024034,-0.132235,-0.057339,-0.021101,-0.014676,0.015583,-0.036023},
  { 0.044096,0.021634,0.005737,-0.014243,-0.016638,-0.036715,0.015875,0.008490,-0.008290,-0.074021},
  { -0.010286,-0.013103,0.023208,-0.023512,0.049174,0.023868,-0.019385,-0.022167,-0.027831,0.052926},
  { 0.023827,0.030418,0.068853,0.062501,0.068584,-0.069195,-0.005512,-0.061850,0.023374,-0.085248},
  { 0.017528,0.011330,-0.040121,-0.068853,-0.079400,-0.006171,-0.005712,-0.005892,-0.005440,-0.047757},
  { -0.014481,-0.030880,0.056512,0.062156,-0.036427,0.009028,0.011142,-0.010445,-0.002649,-0.089072},
  { -0.040211,-0.093298,-0.007207,0.109633,-0.176404,0.110540,-0.005565,0.023763,0.009596,0.020940},
  { -0.033264,-0.136542,0.029890,0.092823,-0.149368,0.148584,-0.022230,0.073961,-0.004954,0.124589},
  { 0.009348,-0.027095,-0.005956,-0.061466,-0.038854,-0.004051,0.024270,-0.025792,0.004114,0.095049},
  { -0.022555,-0.088105,0.008369,-0.000044,-0.171197,0.120244,-0.008360,0.003053,-0.006494,-0.006046},
  { -0.058856,-0.054215,-0.138820,0.031807,-0.080965,0.206542,-0.017921,0.068694,-0.012345,0.059095},
  { -0.007716,-0.012840,-0.048423,0.036787,-0.053098,0.046072,0.001651,0.004834,-0.018671,-0.039270},
  { 0.003806,0.053248,0.025403,0.031263,0.025214,0.016331,0.020632,0.020916,-0.022276,-0.002987},
  { -0.001932,0.036227,0.064158,-0.055205,0.022519,0.035721,-0.019030,-0.030961,0.022153,0.029806},
  { -0.010364,0.012505,-0.004635,0.016703,-0.111334,0.045292,-0.008199,0.027183,-0.018460,-0.017755},
  { 0.035528,0.019305,0.000051,-0.054504,0.044525,-0.052583,-0.014966,-0.032415,-0.025664,-0.027808},
  { 0.021191,-0.004005,-0.018078,-0.016146,-0.015020,0.043247,0.016357,0.044970,-0.002346,0.050827},
  { 0.020656,-0.002142,0.035667,0.085346,0.039997,0.025751,0.021685,-0.028062,0.020310,-0.102071},
  { -0.005472,0.003025,-0.006318,0.066299,0.032706,-0.074694,0.011183,-0.019229,0.001211,-0.158294},
  { -0.002502,0.018757,0.049489,0.009706,0.009830,0.009367,-0.027821,0.020639,-0.024811,-0.015008},
  { -0.010612,-0.048793,0.032814,0.049935,-0.015881,0.025031,-0.018165,-0.019157,-0.010616,-0.013749},
  { -0.020726,0.024414,0.000845,0.010901,-0.010253,-0.004462,0.010584,0.013969,0.003472,0.027749},
  { 0.022843,0.038187,-0.037453,-0.053312,0.026640,0.004898,-0.009464,0.029092,0.014345,0.043255},
  { 0.001735,0.060294,0.075053,-0.069190,0.013942,-0.102617,-0.023847,0.030764,0.001757,-0.017300},
  { -0.023784,-0.038397,-0.056312,-0.002175,-0.093825,0.045709,-0.019748,0.008208,0.011534,-0.016654},
  { -0.014896,-0.073557,0.018306,-0.050345,-0.049652,0.014640,-0.011158,-0.024158,0.007892,0.011660},
  { -0.015496,-0.004489,0.078523,0.053860,-0.090645,0.018372,-0.003818,-0.004773,-0.018527,-0.074854},
  { -0.007901,-0.026895,0.050759,0.011771,-0.075693,0.090674,-0.025288,-0.020308,0.019720,0.008669},
  { -0.017523,-0.021560,-0.047659,0.003368,-0.068017,0.122220,-0.019085,-0.012144,0.002273,0.032848},
  { 0.027418,0.075897,-0.051690,-0.029067,0.133038,-0.092175,0.018470,-0.017167,0.010511,-0.046808},
  { 0.000931,-0.049016,0.041653,-0.026224,0.009905,-0.010323,-0.007487,0.038315,-0.006449,-0.015552},
  { 0.002129,-0.020394,-0.034596,-0.007890,0.001206,-0.024412,0.018311,-0.014071,-0.015046,0.015989},
  { -0.001534,0.015027,-0.056380,0.063193,0.084110,0.004554,0.002553,-0.035542,0.011371,-0.079997},
  { 0.022930,-0.039400,0.041525,0.016966,0.004020,0.024336,0.016485,-0.012554,0.004277,-0.053490},
  { 0.000434,-0.064317,-0.025787,0.018256,-0.052214,0.119508,-0.010335,0.022088,-0.022527,0.046522},
  { -0.024096,0.017202,-0.112607,0.061815,-0.083311,0.104423,0.010913,0.041728,0.014045,0.045930},
  { -0.001471,0.077945,-0.044331,-0.030113,0.062166,0.005473,-0.003644,0.037207,-0.000612,0.036565},
  { -0.007667,0.017551,-0.035772,-0.018707,-0.077048,0.109539,-0.023273,0.021895,-0.017191,0.067971},
  { -0.026391,-0.018521,-0.017709,0.054187,-0.251226,0.171128,0.012315,0.063713,-0.001913,0.037047},
  { 0.002236,-0.078752,0.014085,-0.002305,-0.019699,0.030397,0.019277,-0.022363,0.012618,0.008375},
  { 0.028487,0.015856,0.049649,-0.003751,-0.030773,0.055716,-0.006320,-0.001051,-0.014754,-0.015602},
  { -0.040130,-0.101095,-0.065177,0.073153,-0.178978,0.155385,0.005353,-0.012419,-0.007411,0.038226},
  { 0.006238,0.019997,-0.009053,-0.018023,0.058294,-0.102258,-0.015744,-0.045843,-0.012530,-0.038156},
  { 0.016431,0.008217,-0.081811,0.025579,0.064710,0.027627,-0.004974,0.010092,-0.014347,-0.090521},
  { 0.016206,-0.029403,0.038902,0.020709,0.184048,-0.052857,0.010306,-0.039897,0.019881,0.004478},
  { 0.006963,-0.015808,-0.116233,0.013896,0.080119,0.097271,-0.026448,0.010242,0.017590,0.074972},
  { 0.000697,-0.013852,-0.043242,0.030897,0.081583,0.005944,0.010530,0.004232,0.002853,0.029865},
  { 0.005993,-0.008954,-0.040695,0.094400,-0.008395,0.089729,0.021993,-0.000831,-0.008617,0.003285},
  { -0.045565,0.020388,-0.116520,0.054733,-0.014431,0.154190,-0.019500,0.016565,-0.015308,-0.001940},
  { -0.024049,-0.003069,-0.046689,-0.044029,0.040540,0.082694,-0.015320,0.014194,-0.004781,-0.031600},
  { -0.047777,-0.047564,-0.052783,0.024856,-0.078953,0.176619,0.016859,0.074566,-0.000161,-0.052955},
  { -0.032325,0.039899,-0.017460,-0.008587,-0.001967,0.080662,-0.002597,0.000754,0.002713,0.033690},
  { -0.019397,0.040185,-0.034005,-0.015500,0.010438,0.097794,-0.007312,0.019207,-0.017579,0.026816},
  { -0.010646,0.070372,0.046514,-0.046048,0.090401,-0.002187,-0.004589,0.008386,-0.009162,0.069682},
  { -0.021408,0.036556,-0.017380,-0.078088,0.019851,0.044868,0.021453,-0.016316,0.018501,0.054309},
  { 0.002051,0.103693,-0.060872,-0.063980,-0.010479,0.036617,-0.023533,0.007182,0.022411,0.075670},
  { -0.010187,0.047240,-0.025651,-0.074539,-0.022954,0.055321,0.007112,-0.017813,0.019297,0.145591},
  { -0.039853,-0.004223,-0.037323,-0.036211,-0.034572,0.096726,-0.013217,0.034441,0.022066,0.133185},
  { -0.018658,-0.057083,-0.008653,0.012365,0.038282,0.021450,0.006490,-0.007476,0.005229,0.034718},
  { 0.018621,-0.045152,-0.053579,0.002773,0.093314,0.037335,0.011920,-0.003707,-0.006996,0.017743},
  { 0.005359,-0.036159,-0.062916,0.091158,-0.059868,0.088693,0.016577,-0.012936,0.028925,-0.093705},
  { -0.032314,0.005421,-0.039196,0.079689,-0.049322,0.059967,-0.020624,-0.009174,0.001543,-0.095210},
  { -0.028094,-0.028196,-0.099186,0.074068,0.019651,0.031765,0.012017,-0.029498,0.001381,0.002521},
  { -0.010078,0.000106,-0.057046,-0.007929,0.076511,-0.007320,0.020431,0.033037,0.007573,-0.048105},
  { 0.002109,-0.007399,-0.004890,0.063249,0.026628,0.091094,-0.003392,0.015521,0.001777,-0.053126},
  { 0.021799,0.061890,-0.019792,0.028931,0.052954,0.014141,0.008663,-0.031586,0.019457,0.013419},
  { 0.023035,0.091363,0.075177,-0.030738,-0.034673,-0.034461,0.024124,0.015792,0.008872,-0.007685},
  { 0.034316,0.095044,-0.009430,-0.050489,-0.036051,-0.048797,0.001919,-0.036098,-0.008870,0.047868},
  { 0.016438,0.124147,0.024544,-0.041326,0.025184,-0.082457,-0.013336,-0.026886,0.004605,-0.007120},
  { -0.011056,0.067309,-0.080760,0.015847,0.037381,0.014399,-0.005444,-0.018650,0.020030,0.034891},
  { -0.011208,0.004334,-0.007127,-0.072343,0.048891,-0.027829,-0.010632,-0.009336,-0.024868,0.034189},
  { 0.009250,0.048556,0.012708,-0.102373,0.121560,-0.061200,0.018369,-0.010502,-0.020486,0.029533},
  { 0.021234,0.058804,-0.013716,-0.023478,-0.018533,-0.063244,-0.014268,0.002073,-0.001345,-0.044899},
  { 0.012159,-0.006773,-0.017520,-0.022046,-0.074213,0.033511,-0.015098,-0.014621,0.004541,-0.004084},
  { -0.011818,-0.038779,-0.025941,0.110188,-0.126371,0.095895,-0.017826,0.019943,0.029764,-0.031873},
  { -0.008451,0.061195,-0.009497,-0.025406,-0.077529,-0.024422,0.001066,0.015462,0.022467,-0.041757},
  { -0.026449,-0.013045,-0.087821,0.020385,-0.088370,0.084292,-0.015929,0.005640,0.013588,-0.013477},
  { 0.022353,0.008653,-0.134328,0.001957,0.027353,-0.008410,0.006106,0.004846,-0.004557,-0.035597},
  { -0.024549,0.024884,-0.132839,-0.016895,-0.002268,0.067872,-0.023142,0.002461,-0.007475,0.016036},
  { 0.032511,0.063037,0.020265,-0.017493,0.102159,-0.033969,0.006651,-0.018575,0.023786,-0.018206},
  { -0.000890,0.005667,-0.062876,0.045025,0.025861,0.050782,-0.000711,0.001479,-0.014205,0.014812},
  { -0.006713,0.129136,-0.107177,-0.008914,0.038552,-0.005112,0.014574,0.029044,0.001707,0.047575},
  { 0.011938,0.112073,-0.037596,-0.058952,0.079879,0.006524,0.016411,-0.039159,-0.005247,0.003024},
  { 0.002645,0.091295,-0.060125,-0.031619,0.064498,-0.032197,-0.018476,-0.009856,0.003599,0.015925},
  { 0.004939,0.019821,-0.033069,-0.012659,0.062085,0.021622,0.002739,0.020335,0.010949,0.080140},
  { 0.024589,0.039838,-0.051467,-0.022559,0.066514,-0.035074,0.012563,0.003896,0.017872,0.049550},
  { 0.024375,0.115188,-0.077783,-0.027232,0.009991,-0.037125,-0.024542,0.032169,0.005568,-0.001476},
  { 0.009138,0.018051,-0.086117,-0.020299,-0.067876,0.080535,0.009140,0.021840,0.011840,0.022622},
  { -0.004312,0.020493,-0.059986,-0.034471,-0.019306,0.098448,-0.022151,0.025856,-0.020664,0.030259},
  { -0.037508,-0.011680,-0.083019,0.018447,-0.060041,0.085080,-0.009028,0.027185,0.005491,0.011555},
  { -0.012368,-0.014319,-0.115416,0.062088,-0.078493,0.081366,-0.009611,0.038421,-0.002672,-0.025356},
  { -0.016668,-0.039333,-0.108035,0.029420,-0.036499,0.100522,0.004970,0.054532,0.003126,-0.002387},
  { 0.021294,0.032088,-0.031986,0.013141,0.103145,-0.076834,0.001229,-0.016406,-0.022833,-0.039962},
  { 0.002578,-0.033401,0.045606,0.044305,0.001321,-0.033326,-0.007999,0.013989,-0.009358,-0.034995},
  { -0.018085,-0.039334,-0.062482,0.003529,-0.047077,0.071207,0.005270,0.040994,0.019267,0.148939},
  { 0.058989,0.062465,0.082023,-0.121927,0.066466,-0.105585,-0.016728,0.009618,0.014292,0.030181},
  { 0.036533,-0.000234,0.122292,-0.073055,-0.017836,-0.105595,-0.008606,0.018864,-0.014789,-0.049007},
  { 0.044121,-0.027459,0.151688,-0.081832,0.065106,-0.130132,0.006745,-0.032424,-0.014968,0.019605},
  { 0.013474,0.028775,0.000154,0.044502,-0.005113,0.017391,0.016286,-0.044377,-0.026578,0.085098},
  { -0.001627,0.067261,-0.042541,-0.018181,0.018408,0.010962,0.020153,-0.039016,0.014193,0.088525},
  { 0.020671,0.030468,0.001200,-0.038785,0.036476,-0.119870,0.000877,-0.029312,0.020004,0.006162},
  { 0.024803,0.036358,-0.014080,-0.033702,0.009161,0.030858,-0.023513,0.013841,-0.013324,0.022223},
  { 0.003652,0.044467,-0.055650,-0.011026,0.026793,0.052598,-0.016218,-0.003769,0.005100,0.020552},
  { -0.023745,-0.029863,-0.025415,0.010061,0.021209,0.064114,0.000387,-0.019686,-0.010824,0.016052},
  { -0.022758,0.049004,-0.023197,0.032130,0.020293,0.032423,0.014470,-0.012659,-0.006776,0.046952},
  { -0.009683,-0.004123,-0.027055,-0.008531,-0.074708,0.088640,0.001842,0.014047,-0.021864,0.095579},
  { 0.015111,-0.075086,0.006489,-0.054476,-0.049101,0.031763,-0.016507,0.024947,0.007293,0.031110},
  { -0.037612,0.002900,-0.151803,0.002235,-0.044659,0.102071,-0.023359,0.017725,-0.014977,0.033909},
  { 0.022089,0.061617,-0.110195,-0.078964,0.073068,0.051496,0.016215,0.041342,-0.019976,0.093823},
  { 0.012134,-0.015549,-0.022619,-0.079511,-0.079230,0.057079,-0.005817,0.060536,-0.025071,0.137297},
  { 0.003514,-0.025732,0.027375,-0.072299,-0.024335,-0.021417,0.013934,0.041077,0.008962,0.014488},
  { -0.005280,-0.003147,-0.002150,0.047734,-0.060941,0.017282,0.013722,-0.009114,-0.022565,-0.023673},
  { -0.026168,0.004395,-0.082208,0.059098,-0.086299,0.088763,-0.000796,-0.014296,-0.025432,0.062014},
  { -0.011023,0.040681,-0.050047,0.014871,0.017244,-0.035303,0.015441,-0.043587,0.010856,0.056339},
  { 0.009856,0.026600,0.002127,-0.000933,-0.070057,-0.021402,-0.020650,-0.028259,0.009867,0.001463},
  { 0.001450,0.001093,0.038302,0.024936,-0.103742,0.042809,-0.021687,-0.027205,-0.019874,-0.042592},
  { 0.017460,0.021417,-0.025980,0.019995,0.055106,-0.003597,-0.007954,-0.012448,-0.002053,-0.006852},
  { -0.027510,-0.072038,-0.043114,0.022511,-0.120316,0.124475,0.015112,0.029756,-0.002546,0.035061},
  { -0.001316,-0.017610,0.010341,0.042827,-0.003265,0.008729,0.019519,-0.014186,0.016143,-0.016443},
  { -0.017959,-0.012648,0.011197,0.038251,-0.029771,0.006670,0.022432,0.019614,0.006382,-0.061896},
  { 0.023220,0.035572,0.044287,-0.011608,0.031888,-0.003637,-0.009327,0.006151,0.004802,-0.095390},
  { -0.008984,0.019517,-0.082221,-0.062568,-0.114012,0.076354,-0.016263,-0.012210,-0.008678,0.032775},
  { -0.009795,-0.030677,-0.053580,-0.087524,0.018810,-0.020614,0.014391,-0.004850,0.019108,0.030560},
  { -0.005592,-0.020121,-0.039548,-0.008894,-0.076467,0.017961,-0.025915,-0.004853,0.005322,0.036675},
  { 0.013195,0.086789,-0.051371,0.023333,-0.005664,-0.000633,0.017036,0.015342,-0.018546,0.056143},
  { 0.011118,0.030105,-0.051233,0.007036,0.015673,-0.016266,-0.019133,-0.011302,0.011189,0.070882},
  { 0.025829,0.003565,0.041836,-0.037007,0.077210,-0.079380,-0.010572,-0.010571,-0.023956,-0.006340},
  { -0.022311,-0.053266,-0.037068,-0.044548,-0.041194,0.057500,-0.001162,-0.006128,0.014136,0.044693},
  { 0.020682,0.012706,0.093857,-0.048951,0.036201,-0.110396,0.021800,-0.031051,-0.009319,-0.046347},
  { 0.001495,-0.024257,0.016361,0.086965,-0.077182,0.042471,0.009664,-0.028536,-0.015428,-0.051750},
  { -0.031154,-0.023347,-0.006312,0.046930,-0.090994,0.092553,0.009106,-0.000978,0.001485,0.012983},
  { 0.004317,-0.021721,-0.053056,0.006469,-0.034257,0.068371,-0.007047,0.005781,-0.015793,0.040371},
  { 0.007222,0.016054,0.003028,-0.037753,-0.015111,0.016159,0.005688,0.014012,-0.026361,0.036743},
  { -0.007577,-0.061695,0.008664,0.043469,-0.012299,0.035245,0.001492,-0.024594,0.011024,-0.097535},
  { -0.031591,-0.106702,-0.010677,0.061049,-0.092089,0.059785,-0.023809,-0.027352,0.009032,-0.022246},
  { -0.015481,-0.064431,-0.055371,0.017305,-0.025096,0.043828,-0.024802,-0.018379,-0.027775,0.022390},
  { -0.008692,-0.109618,0.005142,-0.017115,-0.136502,0.079693,-0.018499,0.026803,-0.000337,-0.011732},
  { -0.023428,-0.040992,-0.088495,-0.016764,-0.118630,0.167713,-0.006463,0.018494,0.020822,0.074323},
  { -0.045034,-0.021915,-0.140478,0.057017,-0.085107,0.203552,0.017285,0.021758,-0.018691,0.018833},
  { -0.044980,-0.042852,-0.111312,0.131931,-0.035385,0.093583,-0.005875,-0.030585,-0.011826,0.006393},
  { -0.014987,-0.041128,0.007918,0.020215,-0.077728,0.025688,0.014780,0.002708,0.017376,0.024980},
  { -0.005849,-0.067158,-0.077342,0.064973,-0.236209,0.071741,0.024334,0.048446,-0.019032,0.042253},
  { 0.051909,0.049490,-0.025946,-0.058987,0.132411,-0.114089,-0.001476,-0.012052,0.020226,-0.025050},
  { 0.008163,-0.046951,-0.084143,0.010395,-0.118627,0.069101,-0.017417,-0.013804,0.006405,0.100982},
  { -0.032682,-0.074695,0.004892,-0.021667,-0.113933,0.157306,-0.024585,-0.000898,0.013448,0.094528},
  { -0.018049,-0.087187,-0.002986,0.011251,-0.111140,0.116532,0.005793,0.050935,-0.004918,0.046882},
  { -0.021529,-0.012666,-0.022328,-0.049109,0.022120,0.010296,0.010193,0.028581,-0.009108,-0.006162},
  { -0.028008,-0.002995,-0.084304,-0.052580,0.002246,0.067207,-0.000226,0.022396,-0.021769,0.009937},
  { 0.008945,-0.054958,-0.123701,0.011904,-0.007601,0.035750,0.007884,-0.026639,0.009666,-0.026921},
  { -0.001360,-0.008365,-0.148985,0.044058,-0.017279,0.083798,0.007569,-0.004458,0.013174,-0.046623},
  { -0.041755,-0.132183,-0.031556,0.020033,-0.067658,0.133023,-0.024572,0.034456,-0.024444,-0.003348},
  { 0.003199,-0.048715,-0.020316,-0.058842,0.066017,0.009124,0.014709,0.015017,0.009520,0.023019},
  { -0.009234,-0.044498,0.014031,-0.003020,-0.046756,0.121023,0.025302,0.016228,-0.010981,0.013864},
  { 0.004585,-0.032895,0.009229,0.004976,0.021824,0.074450,0.008381,-0.013740,0.019983,-0.014129},
  { -0.022320,-0.038912,0.008815,0.003722,-0.023320,-0.000492,0.016269,-0.021798,-0.014018,-0.005398},
  { 0.005690,0.018334,0.074252,-0.032206,0.002239,-0.151994,-0.010005,-0.022073,-0.009445,0.025280},
  { 0.041943,0.010271,0.066190,-0.031296,0.085874,-0.082707,-0.023548,-0.044066,0.015918,-0.048794},
  { 0.003410,-0.093058,-0.014690,0.001114,-0.094527,0.092040,0.009021,-0.001241,0.019874,-0.006818},
  { -0.042011,-0.043783,-0.069397,0.044528,-0.082288,0.206695,0.010446,-0.004023,-0.014952,0.085448},
  { 0.010144,0.005247,0.065179,0.033089,-0.016348,-0.028548,0.021223,-0.004860,0.011485,0.032483},
  { -0.009878,0.005890,-0.055368,0.068352,0.024087,-0.005090,-0.023940,-0.026145,0.003910,0.019031},
  { -0.007328,0.075698,-0.046012,-0.044342,0.059880,-0.028865,-0.002126,-0.001343,-0.020122,-0.024899},
  { -0.026702,-0.030447,-0.155218,0.061494,-0.198131,0.234384,-0.016569,-0.012743,-0.018560,-0.030301},
  { -0.040913,-0.049942,-0.034704,-0.036152,-0.107031,0.190064,-0.014851,0.020658,-0.006121,-0.018464},
  { -0.048865,-0.029964,-0.035139,-0.043947,-0.018119,0.099283,0.000953,-0.021255,-0.008942,0.038884},
  { -0.011229,-0.009081,-0.008116,-0.035875,0.032860,0.048959,0.022452,-0.012678,-0.020364,0.073542},
  { -0.006573,-0.000978,-0.048084,-0.023538,0.074744,0.025234,0.002152,-0.053638,0.011177,0.046361},
  { -0.034657,0.006992,-0.088951,-0.082958,-0.010395,0.060992,-0.010849,0.015771,-0.007339,0.071951},
  { 0.011865,0.019343,0.011198,-0.096339,-0.043074,0.026671,0.003432,-0.018036,0.016069,0.095847},
  { 0.001365,-0.008058,0.046036,-0.043970,0.106976,-0.089170,0.024708,-0.023456,-0.015575,0.035379},
  { 0.059122,0.017092,0.191559,-0.053197,0.106543,-0.185393,-0.022349,-0.037190,-0.007856,-0.074479},
  { -0.010814,-0.047588,0.039732,0.026916,-0.002589,0.026252,0.017760,-0.016172,0.015834,-0.047155},
  { -0.017968,-0.076836,0.025922,0.043093,-0.006387,0.075823,0.018024,0.041748,0.000271,-0.000174},
  { 0.009374,-0.074982,0.006864,0.033525,-0.058676,0.034135,-0.006030,0.067587,-0.019673,-0.029245},
  { 0.014560,-0.083821,-0.022941,0.005244,-0.042231,0.014186,0.018714,0.029470,0.009494,-0.011122},
  { -0.006468,-0.029904,0.091225,-0.023565,0.011855,-0.044416,-0.014133,-0.014891,0.000799,-0.020316},
  { -0.022305,-0.090470,-0.040177,0.065046,-0.037942,0.096787,-0.023211,-0.014315,0.022358,-0.131163},
  { -0.018405,-0.054413,-0.006092,0.004551,0.105969,0.056977,-0.012455,-0.005535,-0.015500,-0.021193},
  { -0.006973,-0.020247,0.023748,-0.024262,0.120274,-0.030900,-0.008325,-0.017723,0.000481,0.080050},
  { -0.042686,-0.065801,-0.017643,0.049498,-0.094785,0.037786,-0.009358,-0.019500,-0.011457,0.090124},
  { -0.010618,0.035137,0.050402,0.002050,-0.003061,-0.025373,-0.022749,-0.078701,0.012642,0.016823},
  { -0.006038,0.102840,-0.009435,-0.035129,-0.063413,-0.041339,-0.001679,-0.053792,-0.001848,0.001229},
  { 0.005469,0.080338,-0.076502,-0.034932,-0.022819,-0.006685,-0.010613,-0.052414,-0.022960,0.033173},
  { 0.027194,0.010743,0.011318,0.033633,0.086119,-0.031807,0.002395,-0.041457,-0.020517,0.023181},
  { -0.012717,0.013530,0.039874,-0.002743,0.041959,-0.031485,-0.020345,0.025455,0.002885,-0.054617},
  { -0.018203,-0.025359,-0.036100,0.020567,-0.128831,0.177663,0.003538,0.051123,-0.013239,0.059168},
  { -0.016026,-0.047640,0.005090,0.040903,0.010757,0.105621,-0.016917,0.011011,0.015623,0.025516},
  { 0.001221,-0.069966,0.059780,-0.007051,-0.031530,0.088999,0.007602,0.018294,-0.005811,-0.043182},
  { -0.026028,-0.070947,0.085681,-0.048153,-0.077584,0.036771,-0.009422,0.029565,-0.010063,-0.020214},
  { -0.000308,-0.037777,0.042937,0.015473,-0.083384,-0.023271,-0.018687,-0.034697,0.023498,-0.030056},
  { -0.021779,0.042702,-0.134820,-0.022571,-0.035388,0.050856,-0.006045,0.024836,-0.007735,-0.027743},
  { -0.022101,0.010610,-0.045145,-0.048143,0.016453,0.057335,-0.023421,-0.000199,-0.016290,0.083214},
  { 0.018386,0.058590,0.001348,-0.066395,0.101680,-0.103330,0.003859,-0.034506,-0.011646,0.089652},
  { -0.010823,0.100503,0.030516,-0.018827,0.038285,-0.008656,0.003744,-0.029400,0.024733,0.050187},
  { 0.028187,0.178350,0.091408,-0.060822,0.158032,-0.122817,0.020277,-0.052617,0.016562,-0.038300},
  { 0.016061,0.091535,0.020447,-0.005918,0.114241,-0.132174,0.013243,0.004375,0.012361,-0.102098},
  { 0.026957,0.029125,0.002235,0.049787,-0.004478,-0.063157,-0.001063,0.024222,-0.008984,-0.065386},
  { -0.009324,0.029334,0.066599,0.003227,-0.020924,-0.051692,-0.028366,0.036859,-0.022323,-0.084921},
  { 0.001418,0.069182,0.034990,0.030348,0.047820,0.027921,-0.005612,-0.023193,0.001610,0.012460},
  { 0.011202,0.056941,0.020127,0.025640,0.115369,-0.021616,-0.008979,-0.041653,0.006995,0.017603},
  { -0.013914,-0.024995,0.031481,0.005934,0.010229,0.021503,0.009162,0.006468,-0.011288,0.034019},
  { 0.005239,-0.080819,0.080624,0.020274,-0.090503,0.118226,0.000938,0.037126,0.004651,0.010115},
  { 0.027228,-0.001150,0.129419,-0.091061,0.012674,-0.125422,0.016694,-0.006936,0.011893,-0.086962},
  { 0.027506,-0.056528,0.091794,0.001650,-0.097917,-0.075185,-0.006335,-0.023226,0.005944,-0.069830},
  { 0.005574,-0.030148,0.028163,0.060017,-0.069261,-0.038529,-0.015862,-0.020311,0.000861,-0.083516},
  { 0.015698,0.069359,-0.011572,-0.065869,0.101690,-0.092413,0.014579,-0.005289,0.020998,0.021197},
  { 0.007769,-0.018431,-0.028494,-0.068119,0.010519,0.002778,-0.018608,-0.009028,-0.025732,0.008569},
  { 0.019691,0.031744,0.083342,0.006575,-0.018819,-0.060746,-0.001950,-0.046761,0.010569,-0.072206},
  { 0.036978,0.019638,0.028388,0.010266,0.037169,-0.079051,0.014731,-0.017982,0.017352,-0.017790},
  { -0.010177,0.005682,-0.015310,0.002569,0.065817,0.001795,0.022938,0.045692,0.003668,-0.054989},
  { -0.001867,0.011142,0.006946,0.055922,0.075545,-0.048418,0.010652,0.025153,0.005666,-0.077551},
  { 0.031722,0.013239,0.138491,-0.087319,0.002319,-0.148057,0.019604,0.004890,0.014589,-0.028646},
  { 0.018283,0.034751,-0.014187,0.013082,0.082415,0.000685,-0.013832,-0.028591,-0.002341,-0.033860},
  { -0.027423,-0.047888,-0.049961,0.059042,0.053493,0.126618,-0.021845,0.001356,0.022196,-0.015590},
  { 0.013092,-0.024185,0.011416,0.018867,0.119426,-0.011959,0.003663,-0.022567,0.020749,-0.035225},
  { 0.018310,0.003357,0.021187,-0.015893,0.052074,-0.039375,0.022356,-0.008239,-0.001446,0.020672},
  { 0.020414,0.087505,-0.023226,0.004831,-0.010321,-0.154652,-0.010996,-0.023784,-0.019261,-0.014095},
  { 0.010196,0.087609,0.005593,-0.031211,0.033361,-0.105980,-0.021687,-0.045293,0.001087,-0.009834},
  { 0.026995,-0.034318,0.039010,0.002214,-0.106260,0.005626,0.002086,-0.037115,0.001666,-0.018767},
  { 0.025338,0.014682,0.078469,0.008484,-0.136889,-0.036369,0.004796,-0.010005,-0.022378,-0.016157},
  { 0.038924,0.015527,0.129427,0.026832,-0.072990,-0.137953,0.018355,-0.012033,0.007984,-0.073680},
  { 0.009591,0.021630,-0.016237,-0.041118,-0.101252,-0.036891,0.009074,0.025536,0.008233,-0.015675},
  { 0.019418,0.015318,-0.022811,-0.071714,0.021861,-0.081055,-0.003442,0.017709,0.010752,-0.018721},
  { 0.026449,-0.040589,-0.001429,0.007840,0.015526,0.000275,-0.014819,-0.016821,0.014182,0.054968},
  { 0.001157,0.007254,0.085960,-0.063267,0.037259,-0.054325,0.023374,-0.003705,-0.002414,0.033928},
  { 0.048698,-0.021949,0.058160,-0.084756,0.043746,-0.084606,0.000227,-0.050603,0.002358,0.048178},
  { 0.028904,0.037686,0.076990,-0.017757,0.116452,-0.059821,-0.015695,0.001946,-0.028329,-0.040066},
  { 0.017187,0.027720,0.018961,-0.041477,0.055385,0.013486,0.021058,-0.000336,0.018745,0.061035},
  { 0.022474,0.013910,0.007183,-0.040039,-0.031813,0.074144,-0.010701,0.026163,-0.018803,0.069772},
  { 0.026856,-0.008205,0.029431,-0.104279,0.034704,-0.045610,-0.002131,0.027563,0.001490,-0.006644},
  { 0.016459,-0.043371,0.050910,-0.020312,-0.154336,0.053849,0.009227,-0.012183,-0.003915,-0.044976},
  { 0.042555,0.016413,0.052765,-0.054523,0.021310,0.000017,0.013570,-0.029274,0.015155,-0.033302},
  { 0.010237,0.083681,-0.018890,-0.025606,0.050334,0.005551,0.002759,-0.020640,0.008178,0.057433},
  { 0.025304,0.088829,0.066161,-0.014665,0.009677,-0.079373,-0.003073,-0.020362,-0.001252,-0.046893},
  { 0.043729,0.092375,0.057559,0.006332,0.083698,-0.093152,0.012974,0.009255,0.001677,-0.091308},
  { 0.048942,-0.012531,-0.043666,-0.027560,0.153100,-0.010951,0.012174,-0.002614,0.011469,0.019564},
  { 0.073041,-0.001325,0.112242,-0.093437,0.154370,-0.160368,-0.011966,-0.031238,-0.029236,-0.022996},
  { 0.049658,0.129445,0.130063,-0.101738,0.105730,-0.171783,-0.008381,0.007851,-0.008827,-0.055933},
  { 0.003744,0.038844,0.075878,-0.075571,-0.007839,-0.028192,0.014770,0.000484,0.012158,0.043696},
  { 0.014866,0.030177,0.004957,-0.058392,-0.017751,0.037340,-0.013205,-0.014658,0.011614,0.066035},
  { -0.018552,-0.057606,0.045461,-0.049028,-0.002270,0.003025,0.019296,0.024086,0.006469,-0.008491},
  { 0.018738,-0.003919,0.000399,0.019775,0.057208,0.054327,0.016790,0.017788,0.005121,0.010797},
  { -0.015053,0.039623,-0.062043,-0.033355,0.055231,0.029724,-0.024396,-0.008389,0.017343,0.023183},
  { 0.001810,0.064766,-0.063703,0.017005,0.092728,-0.006980,0.011751,-0.027998,-0.004647,0.000891},
  { 0.019221,0.070557,-0.027405,0.026158,0.042714,0.017036,-0.003921,-0.025045,0.009239,0.023704},
  { -0.014552,0.032280,-0.063998,-0.016334,0.026812,0.041016,0.018248,0.015078,-0.002909,0.009131},
  { 0.024570,0.013277,0.021802,-0.032224,0.025152,-0.024758,-0.000651,0.025635,-0.004746,-0.062935},
  { -0.007382,-0.006203,0.015388,-0.003848,-0.065609,0.007718,0.018769,-0.009488,-0.001116,0.017108},
  { 0.001593,0.044583,0.000803,-0.014009,-0.017609,0.004576,0.018569,-0.002150,0.015096,-0.003616},
  { 0.000263,0.022354,-0.054946,-0.001204,-0.075342,0.085977,-0.020871,-0.012233,0.005582,-0.052554},
  { -0.018684,0.027004,-0.008062,0.005466,-0.058399,0.057774,0.016183,0.006563,-0.004904,0.022404},
  { -0.009582,0.073326,-0.061380,-0.017647,0.006442,0.042542,0.020497,-0.006708,0.005421,-0.018206},
  { -0.015098,0.029643,-0.080168,-0.026983,-0.017685,0.069039,-0.014494,0.040880,0.018725,0.067851},
  { -0.031376,-0.014154,-0.045227,-0.005798,-0.039905,0.078613,-0.016310,0.024861,0.016380,0.089650},
  { -0.005884,0.028493,0.016518,-0.069144,-0.007587,-0.024736,0.004979,-0.005157,-0.018554,-0.001315},
  { 0.031455,-0.014127,0.039260,-0.014298,0.033330,-0.065865,0.001670,-0.004741,0.015835,0.011583},
  { 0.009613,-0.014657,-0.009776,-0.024815,0.082463,-0.055631,-0.007340,-0.014387,0.004508,0.035753},
  { -0.010616,0.015089,-0.060363,0.006937,0.018560,0.031734,0.016135,-0.014281,-0.003346,0.015698},
  { 0.006791,0.053647,0.057314,0.009187,0.061241,-0.054124,-0.011929,-0.002209,0.021714,-0.055135},
  { 0.010379,0.016150,-0.008263,-0.048716,0.005220,-0.026119,-0.010755,0.005166,0.003747,0.002018},
  { 0.024054,-0.006333,-0.006434,0.002095,-0.002805,0.000153,0.023246,0.027257,0.008248,0.020398},
  { -0.015655,-0.016970,-0.051349,0.053839,-0.133325,0.145481,-0.017412,0.005577,0.016757,0.036232},
  { -0.003222,0.027772,-0.047816,0.028130,-0.040319,-0.002657,0.005969,0.019006,0.016178,0.023400},
  { -0.024307,0.029528,-0.016615,-0.032768,-0.061249,0.089882,0.007897,0.015724,0.002283,0.023329},
  { -0.007975,0.069780,-0.038555,-0.021695,-0.044815,0.061401,-0.009218,0.019623,0.007449,0.024521},
  { 0.014622,0.023627,-0.002859,-0.012965,-0.032007,0.038732,0.008093,0.037576,0.015589,0.047326},
  { -0.008082,0.011064,-0.063884,0.047288,-0.055632,0.110970,0.010226,0.033851,-0.008209,0.017473},
  { -0.015191,0.001077,-0.060941,0.000799,-0.026731,0.070215,0.015655,0.005386,0.009694,0.032909},
  { -0.002200,0.011140,0.015192,-0.040579,0.019731,-0.048174,0.019824,0.006571,0.013393,-0.019583},
  { 0.032992,0.016527,0.061374,-0.051202,0.041587,-0.075395,-0.023911,-0.029909,-0.006180,0.002597},
  { -0.001987,0.003922,0.010493,-0.010019,0.083626,-0.056595,-0.014206,-0.013082,-0.021920,0.028980},
  { -0.016851,-0.024752,-0.029515,-0.004133,-0.033197,0.023834,-0.005422,-0.010860,-0.021819,0.009450},
  { -0.016780,0.008385,-0.009623,-0.041556,0.017347,-0.014609,-0.006467,0.002539,0.020865,0.020155},
  { -0.011718,-0.006753,0.015415,-0.049082,-0.048722,-0.004607,0.011620,0.034677,0.022005,-0.011478},
  { 0.020198,-0.045631,-0.027540,-0.031376,0.028795,-0.027501,-0.015447,-0.006009,-0.017304,-0.021782},
  { -0.025331,-0.037442,-0.059813,0.016283,-0.043243,0.129800,0.005360,0.062566,0.007511,0.011082},
  { -0.003859,0.034302,-0.044713,0.030744,0.039116,0.019308,-0.000991,-0.008965,-0.027896,0.014770},
  { -0.025685,0.014756,-0.079294,0.019416,-0.075552,0.119896,-0.021656,0.011647,-0.008351,0.076715},
  { -0.027563,0.009250,-0.074235,0.044591,-0.132207,0.143188,0.014688,-0.007085,-0.016850,0.023522},
  { 0.004995,-0.007713,-0.001582,-0.008689,-0.058954,0.055517,0.016206,-0.026177,-0.014713,0.018575},
  { -0.005924,0.011935,-0.069598,0.034971,-0.058018,0.100628,-0.025855,-0.014993,-0.000348,0.047690},
  { -0.031518,0.014409,-0.027447,0.018951,-0.095399,0.072485,0.007900,0.015425,0.016855,0.015171},
  { 0.003286,0.028851,-0.030473,0.006285,-0.029956,0.070223,-0.018568,0.010426,-0.017505,0.031901},
  { -0.020530,0.012088,-0.047750,-0.034799,-0.001675,0.057543,0.006811,0.022977,-0.025978,0.022745},
  { -0.005026,0.040296,-0.014411,-0.063514,-0.023260,-0.019096,-0.012568,0.012724,-0.002967,0.040555},
  { 0.020793,0.033353,0.040007,-0.011671,0.022033,-0.064880,-0.011356,-0.006671,-0.013431,0.032156},
  { 0.027870,0.057032,-0.022997,-0.006045,0.055760,-0.006184,-0.023888,-0.023521,-0.009227,-0.002050},
  { 0.003643,-0.039033,-0.002435,-0.051021,-0.037708,0.048799,0.023741,0.035899,0.011180,-0.012050},
  { 0.030360,-0.012026,0.025638,0.007060,0.032022,-0.024781,0.020106,0.035219,-0.020608,-0.048101},
  { -0.021049,-0.044244,-0.041464,0.042745,-0.038072,0.062985,-0.001452,0.013054,0.019251,0.001878},
  { -0.036123,-0.032112,-0.006173,0.047944,-0.069204,0.104140,0.019890,0.000975,0.018349,-0.020706},
  { -0.034288,-0.072371,-0.085497,0.023386,-0.112599,0.104602,0.007717,0.046266,0.008662,0.087628},
  { -0.012837,-0.042097,0.014217,0.006862,-0.100471,0.034400,0.003621,0.026681,-0.002479,0.016762},
  { -0.011110,-0.013701,-0.034118,0.044267,-0.075784,0.040575,-0.017602,-0.029757,-0.017561,-0.030236},
  { -0.014566,0.016068,-0.035708,0.011063,-0.010495,0.022262,0.009887,-0.003099,-0.019217,0.051570},
  { 0.014729,0.021069,-0.068427,0.021948,-0.044997,0.056690,0.019779,-0.024569,-0.010803,0.051040},
  { -0.013708,0.003779,-0.015355,-0.007851,-0.029671,0.013184,-0.009045,0.020399,-0.011859,0.026803},
  { 0.000240,0.001532,-0.001680,-0.020504,0.061345,-0.011341,0.005260,0.005442,-0.015990,0.025806},
  { 0.003166,0.010494,-0.006484,-0.011540,-0.003559,0.027481,-0.012643,-0.005048,0.019849,0.004364},
  { 0.017245,0.010665,-0.002126,-0.024057,-0.026568,0.009785,-0.003058,0.016668,0.022332,0.032042},
  { 0.031985,0.003375,0.038990,-0.000962,0.009641,-0.040008,0.022644,-0.018236,-0.020264,0.035704},
  { 0.002776,0.027478,0.002650,-0.005039,0.030722,-0.028191,0.018303,0.001340,-0.022367,-0.040480},
  { 0.002048,-0.028830,-0.015758,0.037698,-0.077317,0.093158,0.004616,0.008761,0.007335,0.032950},
  { -0.024875,-0.057634,-0.039167,-0.026652,0.003821,0.084477,0.008895,0.006623,0.011054,-0.000764},
  { -0.034185,0.022450,-0.034298,0.025169,-0.074686,0.078192,-0.018191,0.032180,0.012125,0.008429},
  { 0.031072,0.026496,-0.014855,-0.052699,0.031453,-0.046227,-0.002567,0.032856,0.018681,-0.000840},
  { 0.011814,-0.055663,-0.039229,0.007010,-0.081278,0.060451,-0.001395,0.030920,0.005093,0.064906},
  { 0.005325,-0.022732,0.036688,-0.013072,-0.035657,-0.017889,0.000127,-0.002073,0.007080,-0.011556},
  { -0.032315,-0.018404,-0.035409,0.015832,-0.068895,0.072119,0.013368,0.010370,-0.008448,0.040144},
  { -0.013211,0.003198,-0.052279,0.000771,-0.046824,0.041432,-0.003261,0.003276,-0.021308,0.058595},
  { 0.018086,0.014799,0.046172,-0.007520,0.046369,-0.012797,-0.011556,-0.046788,0.023759,-0.019834},
  { 0.031837,-0.044708,0.030793,0.002878,0.014039,0.008105,-0.019263,0.014804,-0.020606,-0.015369},
  { 0.013558,-0.050857,0.035160,0.023930,-0.047113,0.025151,-0.011080,0.004328,-0.011539,0.000541},
  { 0.025386,0.050822,-0.027591,-0.016485,-0.026208,0.034150,-0.021146,-0.016074,0.004261,-0.035990},
  { 0.010257,0.023542,0.048088,-0.045742,-0.031297,-0.009752,-0.009574,0.012250,-0.024638,0.003749},
  { 0.033904,0.011799,-0.006006,0.010970,0.010070,0.007553,-0.014213,-0.012785,0.006690,-0.010875},
  { -0.010440,-0.001482,0.078043,-0.006148,-0.043417,0.012460,-0.011499,-0.004844,-0.003990,-0.088655},
  { 0.024846,-0.038463,0.044391,0.010570,-0.013572,-0.026593,-0.017476,-0.033808,0.005114,-0.056762},
  { 0.021422,-0.002971,-0.050662,-0.013339,0.025373,0.007656,0.008947,0.018300,-0.021914,0.011271},
  { 0.009255,-0.017357,-0.027578,0.011253,-0.026348,0.006110,0.003457,-0.026004,0.008146,-0.048544},
  { -0.004842,0.011033,-0.047381,0.019737,0.022040,0.002983,-0.008746,-0.018663,-0.012943,-0.022535},
  { 0.006376,-0.038555,-0.035012,0.025159,-0.035793,0.011275,-0.024507,0.000338,-0.019688,0.024544},
  { 0.017449,0.035067,0.004309,0.007062,-0.001239,-0.069394,0.011501,0.008821,0.018306,-0.028830},
  { 0.006169,-0.022607,0.007944,0.027802,-0.085778,0.054875,-0.008901,0.030829,0.003882,0.033711},
  { 0.026448,-0.002894,0.020006,-0.013176,0.013370,-0.010277,-0.003294,-0.016985,0.020927,0.029643},
  { 0.018444,-0.023876,-0.007546,-0.022287,0.006765,0.015447,0.001575,-0.006510,0.009904,0.023718},
  { -0.005453,-0.028829,0.050771,0.015898,0.029034,-0.042705,-0.003322,-0.004205,0.003096,-0.010088},
  { -0.011058,0.021061,0.016604,-0.019728,-0.038874,0.030738,-0.008958,0.014366,-0.013726,-0.021052},
  { -0.003570,0.018472,-0.045338,-0.005826,-0.031746,0.056420,0.022936,0.025494,0.007563,0.048790},
  { 0.028967,0.024763,-0.005977,0.002339,0.046804,-0.043294,-0.012126,0.011918,-0.008862,-0.028595},
  { -0.006756,-0.017267,-0.052061,0.038104,-0.031831,0.068449,-0.001619,-0.010358,0.000204,-0.037218},
  { 0.009753,-0.071303,0.016837,0.004075,-0.031572,0.029768,-0.001277,0.020599,-0.006836,-0.044614},
  { 0.014874,-0.037762,-0.007192,0.000886,-0.011778,0.061449,0.006968,0.041543,0.006487,0.035974},
  { 0.015924,-0.013388,-0.034439,-0.004704,-0.016916,0.055658,-0.024104,0.021748,0.003956,-0.013203},
  { -0.023719,-0.033112,-0.011327,0.011861,-0.068110,0.046317,0.000053,-0.028763,0.020839,-0.017294},
  { -0.027200,-0.072850,-0.019713,0.011678,-0.054297,0.028052,-0.024031,0.002366,0.009565,0.002966},
  { 0.012725,-0.056084,-0.052700,0.107065,-0.021682,0.008916,0.016161,-0.002346,0.014650,-0.023172},
  { 0.047630,-0.001694,0.077137,-0.012658,0.025877,-0.111222,0.018460,-0.021151,0.006757,-0.040870},
  { 0.027252,0.017795,-0.026014,-0.005445,-0.018233,0.014403,0.001190,-0.014846,0.003135,0.038532},
  { -0.020385,-0.047702,-0.018095,0.001813,-0.036121,0.101640,-0.007603,0.025705,-0.011772,0.054238},
  { 0.004434,0.023744,-0.017473,-0.016403,0.008884,-0.013491,0.007088,-0.015147,0.003414,0.051439},
  { 0.010644,-0.018959,0.036867,-0.022860,-0.034226,0.009050,-0.005740,0.015511,0.013818,-0.001161},
  { 0.004506,-0.020696,-0.059194,0.042656,-0.010221,0.044341,-0.014160,-0.007960,0.007516,-0.012152},
  { 0.031467,0.030368,-0.008877,-0.040633,0.056596,-0.036362,-0.021511,0.033391,-0.001617,-0.046074},
  { -0.056066,-0.055259,-0.105130,0.072110,-0.104566,0.199824,-0.021442,0.031051,0.005974,0.055508},
  { -0.002249,-0.028758,-0.009989,0.017674,0.030337,0.016777,-0.020462,0.028405,0.010226,-0.009084},
  { -0.005817,0.011642,0.039346,-0.035661,0.064918,-0.040708,0.009018,-0.007453,0.002977,-0.053195},
  { -0.005308,-0.056571,0.033337,0.039877,-0.058458,0.082695,-0.019762,0.005507,-0.013305,-0.008774},
  { -0.020067,0.016458,-0.080806,0.035312,-0.008408,0.059629,0.022273,0.012380,0.006992,-0.005919},
  { -0.016725,-0.058987,-0.009076,-0.022469,-0.042076,0.060613,-0.018890,-0.013016,-0.018420,0.020773},
  { 0.025900,-0.010457,-0.003982,0.049621,-0.018940,-0.031785,-0.019421,-0.051599,-0.015922,-0.014288},
  { -0.003313,-0.015943,0.029023,0.044180,-0.016375,-0.019764,-0.010446,-0.024169,-0.015057,-0.001732},
  { 0.000435,0.003856,0.036122,-0.016881,0.013571,-0.052669,0.008097,-0.027720,0.009049,0.016078},
  { 0.015938,-0.027876,0.028850,0.006812,0.001955,-0.006830,0.021706,0.002335,0.006762,-0.007621},
  { 0.008651,-0.023388,-0.046601,0.002681,-0.022995,0.083322,-0.000686,0.006340,0.012040,0.031424},
  { 0.006693,0.002095,-0.038807,0.046065,-0.039160,0.024821,0.016883,0.005731,0.006089,0.038827},
  { 0.004124,-0.003504,-0.007582,0.041823,-0.017697,-0.052217,-0.010716,-0.014166,0.005198,-0.043904},
  { 0.017515,0.012128,0.060286,-0.011845,0.054661,-0.045960,0.020708,0.009597,-0.008604,-0.017992},
  { 0.002483,-0.067949,-0.001202,0.036974,-0.050128,0.107078,0.009414,-0.017628,-0.025145,0.015660},
  { 0.010786,-0.036485,-0.023890,0.033212,0.011842,0.023616,0.016989,-0.018156,-0.017391,-0.040098},
  { -0.020682,0.003541,-0.022902,0.027683,-0.032290,0.041363,-0.019017,0.015091,-0.006807,0.000723},
  { -0.015302,-0.018762,0.002614,0.004187,-0.061091,0.069624,0.002984,0.022597,-0.013994,0.030481},
  { 0.006800,-0.022130,-0.022999,0.022848,-0.059075,0.053413,0.019605,0.014671,-0.011973,0.014837},
  { -0.010043,-0.052955,-0.065808,0.005647,-0.084429,0.138100,-0.011518,-0.013059,0.014875,0.084095},
  { -0.020373,-0.034924,0.005752,-0.037477,-0.086322,0.003342,-0.001132,-0.020795,0.021326,0.022540},
  { 0.002531,0.022041,-0.050676,0.028532,-0.017743,0.078365,0.008457,-0.011119,0.008808,0.016517},
  { 0.016228,-0.006502,0.021229,-0.007475,-0.012018,-0.006274,-0.007580,0.023594,-0.019297,0.015089},
  { 0.008516,-0.005246,0.020605,-0.018326,0.078545,-0.031859,0.005550,-0.016919,-0.016752,-0.011106},
  { 0.013199,-0.005294,0.053066,-0.069495,0.041678,-0.017430,-0.015691,0.002291,0.010319,-0.005873},
  { 0.015972,-0.018596,0.005777,0.013852,-0.053186,0.046345,0.022005,0.023439,0.021640,-0.007070},
  { 0.009942,-0.005177,0.003441,0.020865,-0.061407,0.010797,-0.006231,-0.013361,-0.008277,0.028925},
  { -0.001205,0.002207,-0.032417,0.034507,0.040548,0.022855,0.022336,0.012564,0.005144,0.034053},
  { -0.029329,-0.014391,-0.061775,0.007740,-0.082364,0.091353,0.000926,-0.003778,0.011954,0.028901},
  { -0.033064,-0.038491,-0.062644,0.047122,-0.015238,0.047572,-0.005535,0.005450,-0.013422,-0.033262},
  { 0.000551,0.004117,0.006569,0.060192,-0.025450,0.073163,-0.015431,-0.009884,-0.011323,-0.054417},
  { 0.012442,0.000287,0.027114,0.044312,-0.043242,0.055971,-0.009415,-0.032614,0.004705,0.014961},
  { -0.007077,-0.041564,0.012123,0.007685,-0.065679,-0.002430,0.011086,0.010080,-0.020102,-0.003326},
  { -0.010399,-0.018299,-0.018408,0.020865,-0.067943,0.048195,-0.021860,-0.020054,-0.012334,0.054244},
  { -0.018364,0.013832,-0.030515,-0.003702,-0.105348,0.045003,0.021818,-0.037902,0.010600,0.003927},
  { 0.016195,-0.010016,-0.044061,-0.005293,-0.084272,0.066613,-0.005453,0.014148,-0.016019,0.004940},
  { 0.018907,-0.008909,0.027762,-0.019472,-0.037851,0.015675,-0.002138,0.002327,0.017839,0.005801},
  { 0.011457,0.010384,0.018932,0.001637,0.038915,-0.039719,0.009455,-0.026247,-0.000710,-0.014946},
  { 0.021846,0.025118,0.018263,-0.029932,0.021501,-0.029281,-0.021064,0.001041,0.000930,-0.003871},
  { -0.005790,-0.023823,0.047472,0.033479,0.003554,-0.018983,0.002736,0.004414,-0.010135,-0.054411},
  { 0.014698,0.030242,0.008671,-0.007988,-0.047800,0.022963,0.010746,0.007623,0.017364,0.018130},
  { 0.008379,-0.037722,0.010423,0.010359,-0.034800,0.022437,-0.015090,-0.001461,-0.012350,0.069618},
  { -0.020277,-0.058878,-0.041244,-0.013513,-0.049650,0.058874,-0.013681,0.002744,-0.025014,0.044736},
  { -0.043000,-0.065259,-0.063622,0.038695,-0.114660,0.158294,0.020117,0.031846,-0.010817,0.028066},
  { -0.018957,-0.010602,0.030161,-0.007887,0.041325,0.003961,-0.020938,-0.014417,-0.007570,-0.046553},
  { -0.020364,-0.020994,0.017061,0.029827,-0.024285,0.025588,0.019520,0.009470,0.001044,0.003728},
  { 0.007598,-0.019390,0.044022,0.036726,-0.066957,0.028798,0.015955,-0.012988,-0.019177,0.016574},
  { -0.006297,0.015460,0.055572,-0.018016,-0.049936,0.001573,0.021364,-0.011822,-0.010742,0.004390},
  { 0.025396,0.003774,-0.004442,0.010268,-0.009881,-0.006247,0.015813,0.007412,-0.025222,0.018395},
  { 0.006376,-0.005140,-0.007578,0.018870,-0.041139,0.034443,0.009724,-0.001894,-0.002478,-0.020226},
  { 0.010115,0.020411,0.054876,-0.025504,0.073827,-0.068667,0.020420,0.012229,-0.017146,-0.010008},
  { 0.015278,-0.018617,0.013878,0.063320,0.005886,0.008794,0.005711,-0.020737,-0.015902,-0.028066},
  { 0.037772,0.051017,-0.022454,-0.031309,0.074137,-0.040908,0.007120,-0.028632,-0.009541,-0.041802},
  { -0.007602,0.026327,0.012559,0.008999,0.033579,0.011697,0.003265,-0.005955,0.005558,-0.006074},
  { -0.004328,-0.043072,0.028464,0.085473,-0.072612,0.067458,-0.004732,0.000449,-0.017499,-0.009526},
  { 0.003202,-0.018185,0.016022,0.021922,-0.041030,0.030149,0.019816,0.035418,-0.012450,-0.009699},
  { -0.008637,-0.019345,-0.000928,-0.014881,-0.035344,-0.047807,-0.017606,-0.003654,-0.021162,0.001838},
  { 0.022411,0.031167,0.037640,-0.010001,-0.004602,0.004064,0.013089,-0.027691,0.022067,-0.054693},
  { -0.016224,-0.062090,-0.049217,-0.021507,-0.044304,0.075132,0.013470,0.009720,-0.022781,0.028415},
  { 0.008642,-0.012644,-0.061906,0.033528,-0.062870,0.030412,-0.007286,-0.019467,0.001358,0.020307},
  { 0.005383,0.017278,0.027157,0.074241,-0.069160,0.010379,-0.008520,0.004311,-0.017956,-0.043565},
  { 0.006210,-0.018456,-0.044870,0.010686,-0.043305,0.055194,0.005964,-0.011822,-0.017845,0.040126},
  { -0.008512,-0.029941,-0.003865,0.024020,-0.014529,0.063372,0.011211,-0.001358,-0.025441,0.029383},
  { 0.015055,0.012622,-0.059254,-0.015726,0.082762,-0.025291,0.004696,-0.019687,0.018081,0.035748},
  { -0.004472,-0.005983,0.002734,-0.041194,0.046392,-0.013859,0.008515,0.003065,0.006276,-0.005833},
  { 0.002613,-0.004835,-0.046559,-0.006673,-0.004920,0.108906,-0.023997,0.016629,-0.021415,0.017164},
  { 0.003145,0.010291,-0.001327,0.018049,0.102362,-0.024380,-0.010084,-0.018477,-0.010715,-0.067876},
  { 0.012229,-0.040990,0.002248,0.002369,0.042786,-0.020174,-0.021495,-0.018472,-0.004343,0.005055},
  { 0.027272,0.033521,-0.009746,0.000173,0.048670,-0.031867,-0.024215,-0.032141,-0.005504,0.034877},
  { -0.013236,0.042640,-0.005731,0.036743,0.015425,-0.022830,-0.013446,-0.001171,-0.021908,-0.051006},
  { -0.025988,0.010803,-0.072176,0.008223,-0.002753,0.101052,-0.001592,0.025282,-0.015705,0.056382},
  { 0.021855,0.039922,0.015413,-0.011529,-0.077431,0.037527,0.015281,-0.003641,-0.009973,0.010754},
  { 0.007933,-0.021487,-0.031557,0.011366,-0.095893,0.084781,-0.007972,0.023197,0.020602,0.026715},
  { 0.000999,-0.056955,0.068094,-0.023073,-0.031654,-0.014578,-0.013564,-0.007277,-0.015592,0.019392},
  { 0.016226,-0.003360,0.022187,0.005599,-0.111192,0.059642,0.018497,0.031145,0.004535,-0.018587},
  { -0.008144,-0.045230,0.004403,0.006454,-0.078028,0.028775,0.011114,-0.030721,0.002943,0.002718},
  { -0.022451,-0.016840,0.027645,0.011091,-0.060825,0.073806,0.014403,-0.024815,0.006153,0.000042},
  { -0.005415,0.001098,-0.009172,0.031036,0.065897,-0.023173,-0.018280,-0.019995,-0.002070,-0.014073},
  { 0.011919,0.015618,0.075532,-0.038498,0.031609,-0.073884,-0.017784,-0.014469,-0.018768,0.001695},
  { 0.015752,0.083190,-0.022050,-0.029492,0.106466,-0.017283,0.014475,-0.027751,0.011227,0.020438},
  { 0.014157,0.026299,-0.015228,-0.011764,0.025732,-0.001735,-0.012717,-0.017934,0.000634,0.005723},
  { 0.012898,0.004772,0.063045,-0.029286,0.101750,-0.036388,0.004885,-0.004006,-0.004037,-0.024572},
  { -0.001316,-0.013578,0.059834,-0.022252,0.060445,0.003130,-0.015601,0.027959,0.011587,-0.031848},
  { 0.011598,-0.011723,0.020256,0.011317,0.047353,-0.031249,0.003164,-0.034254,0.022231,0.014363},
  { 0.042673,0.029059,0.058755,-0.014802,0.037419,-0.032242,-0.025981,0.005495,-0.013502,-0.056311},
  { 0.013825,-0.047684,-0.042938,0.000325,-0.015378,0.060402,0.010956,-0.010769,-0.017496,0.043920},
  { 0.009480,0.014881,0.029066,0.023782,-0.097092,0.071009,-0.024380,0.033713,0.007377,0.004143},
  { 0.033975,0.002707,0.049162,0.004052,0.009143,-0.045517,0.015173,-0.017631,0.004054,-0.022985},
  { -0.009407,-0.046257,0.044388,0.022116,0.002592,0.032770,-0.019027,0.012502,-0.025857,0.012910},
  { -0.015629,-0.044731,0.017456,0.015721,-0.043258,0.030837,0.018411,-0.009540,-0.021926,0.018105},
  { 0.018392,0.030446,0.028259,-0.002888,0.074333,-0.031033,0.019038,-0.020042,-0.002973,-0.027230},
  { -0.003130,0.007820,0.026969,0.026807,0.030688,0.013865,0.001202,0.004539,0.008359,-0.026344},
  { 0.002871,0.040559,-0.074695,0.022961,-0.038573,0.011104,-0.004823,0.010420,-0.008518,-0.096229},
  { 0.027073,0.037477,-0.043985,0.008527,0.007288,0.038845,0.005413,-0.013837,0.016106,-0.081464},
  { -0.025997,0.028523,-0.060703,0.036339,-0.040784,0.055115,0.018428,-0.015862,-0.023237,-0.054451},
  { -0.024232,0.058949,-0.073452,0.000491,-0.079974,0.056074,-0.000749,0.025669,-0.021415,-0.053340},
  { -0.008373,0.016871,-0.126892,0.012872,-0.037160,0.043091,-0.007795,0.026621,0.019062,-0.020657},
  { -0.022660,-0.030302,-0.111686,0.046272,-0.032114,0.047977,0.011522,0.010105,-0.008862,0.021889},
  { -0.011107,0.009910,-0.136211,0.032557,-0.035300,0.057309,0.017105,0.022406,-0.026292,0.045649},
  { -0.008348,0.065966,-0.111055,0.014101,0.010521,-0.035879,-0.016936,-0.005417,-0.022551,0.038658},
  { 0.005565,0.081913,-0.079763,0.022665,0.010631,-0.056948,-0.006980,-0.012687,0.002848,-0.045024},
  { -0.011966,0.079624,-0.140959,0.084457,-0.013718,0.002787,-0.009617,-0.005619,-0.007446,0.001344},
  { -0.030688,0.075383,-0.121796,0.083529,-0.085220,0.013150,0.008210,-0.024296,0.006796,-0.048114},
  { -0.001139,0.050003,-0.084795,0.040750,-0.093206,-0.003957,0.003958,-0.001005,-0.023043,-0.049811},
  { 0.009440,0.024916,-0.068676,0.045854,-0.038971,0.075473,-0.011164,0.019716,0.020288,-0.057985},
  { 0.019596,0.013435,-0.066602,0.058650,0.018125,0.062704,-0.003990,-0.000930,-0.014413,-0.129750},
  { -0.015941,0.102483,-0.113644,0.029469,-0.025641,0.016037,-0.018520,-0.014747,0.001974,-0.034715},
  { 0.002009,0.053361,-0.002474,-0.005593,0.054835,-0.034409,0.008821,-0.047368,-0.001194,-0.061213},
  { 0.015477,0.033460,0.006947,-0.009558,0.010117,-0.017513,-0.018459,-0.002568,0.016597,-0.035544},
  { 0.020102,0.030092,-0.045952,-0.012129,-0.025193,0.033914,0.007242,0.001263,-0.018743,0.036575},
  { 0.004457,0.030771,-0.052173,0.005760,-0.002540,0.023311,0.008052,-0.023603,-0.013784,0.004279},
  { -0.020238,0.041230,-0.081995,0.066659,-0.002152,0.013346,-0.011374,-0.030871,-0.023538,0.011857},
  { 0.009682,0.011859,-0.101517,0.037928,0.035734,-0.052534,-0.003899,-0.016471,0.006390,0.047841},
  { 0.028544,0.017005,-0.067207,-0.024342,0.074479,-0.073611,0.011854,-0.007529,0.003250,-0.011934},
  { 0.019411,0.034568,-0.106327,0.059447,-0.031236,0.009435,0.010028,0.014559,0.020695,0.008019},
  { 0.000342,0.019042,-0.054984,0.017674,-0.020856,0.007603,0.018451,-0.031068,-0.023101,-0.008143},
  { -0.001213,0.014689,-0.000987,0.015274,-0.076079,0.008767,-0.015814,-0.015383,-0.017890,-0.000456},
  { -0.001279,0.043863,0.051294,-0.036814,-0.031891,-0.015597,-0.019916,-0.021507,-0.012868,-0.010805},
  { 0.019126,0.029240,0.020053,0.012083,-0.010345,0.023206,-0.007728,0.002911,-0.010533,-0.028339},
  { -0.006510,0.037587,-0.034626,0.058235,0.053648,0.055818,-0.016869,0.014632,-0.013943,-0.069395},
  { 0.000638,0.092548,-0.022233,-0.012558,0.018376,-0.052020,-0.008501,-0.015902,-0.011792,-0.088483},
  { 0.040010,0.065160,0.002446,-0.002660,0.038159,-0.061675,0.006617,-0.024262,-0.011998,-0.100548},
  { 0.003975,0.061739,0.066629,-0.026092,0.076984,-0.101613,-0.024625,-0.047095,0.010986,-0.044428},
  { -0.007159,0.063031,-0.061210,0.008722,0.026017,0.036772,0.005126,-0.027279,0.022134,0.013339},
  { 0.008217,0.012028,-0.097348,-0.009846,0.092022,0.005445,-0.003711,-0.031226,0.014116,-0.043596},
  { 0.030087,0.031641,-0.019912,0.019553,0.125461,-0.065982,0.019651,-0.015173,0.004730,-0.070322},
  { 0.014131,-0.006231,-0.043496,0.021750,0.077565,-0.036674,-0.020961,-0.041285,-0.006662,-0.008251},
  { 0.002490,-0.039307,-0.039362,0.058761,0.066055,-0.064500,-0.018957,-0.029001,-0.002209,-0.038804},
  { -0.005612,-0.010292,-0.061298,0.005421,0.026288,-0.043614,0.000666,-0.023781,0.010208,-0.005177},
  { 0.014565,0.023251,0.001271,0.031494,0.044541,-0.062483,-0.020783,-0.023950,-0.029531,-0.032899},
  { -0.014038,-0.067675,0.051230,0.051154,-0.080768,0.031515,0.015560,-0.002394,0.000697,0.003636},
  { -0.007464,0.007839,0.023221,0.052872,-0.056792,0.034518,0.017437,-0.013628,0.001895,0.035661},
  { -0.002247,0.023768,-0.041838,0.048799,-0.052005,0.082663,0.014007,-0.011042,0.015723,0.002332},
  { -0.021564,0.017907,-0.058450,0.105171,0.016231,0.029248,-0.005191,-0.009700,-0.027199,-0.065040},
  { 0.027261,0.071188,0.045817,0.039444,-0.025209,-0.048899,-0.013803,-0.042945,-0.014673,-0.129531},
  { 0.025503,0.047549,0.019756,0.009126,-0.009556,-0.033108,-0.009057,-0.009763,-0.021287,-0.114958},
  { 0.042611,0.063242,0.056664,-0.028872,0.051092,-0.049315,-0.003810,-0.057833,-0.013008,-0.055642},
  { 0.000671,0.038906,0.008773,-0.010201,0.002288,-0.037740,-0.002997,-0.038265,-0.000845,0.015911},
  { 0.008931,0.052266,-0.022784,0.007241,0.053497,-0.082925,-0.011449,-0.016018,0.014849,-0.014552},
  { -0.002096,0.069237,-0.072921,0.028143,-0.011938,0.045397,-0.010271,-0.005192,-0.026719,0.036006},
  { 0.013131,0.042092,-0.093577,0.019627,0.032486,-0.009752,-0.024041,-0.012809,0.000801,0.021956},
  { 0.026054,0.024368,-0.128233,0.055721,0.048816,-0.022421,-0.023627,-0.028036,-0.010115,0.032372},
  { 0.036568,0.023718,-0.026512,0.014591,0.054761,-0.081102,0.006488,-0.009348,-0.019538,0.021985},
  { 0.043158,0.019808,0.005939,0.017214,0.097649,-0.124618,0.001468,-0.009206,0.006765,0.039320},
  { 0.024811,0.004874,-0.027843,0.015905,0.012104,-0.048347,-0.007326,-0.023912,0.019132,0.052745},
  { 0.014695,0.044107,-0.050294,0.019367,0.007737,-0.039960,0.011773,-0.041383,0.014735,0.024494},
  { -0.025321,0.032157,-0.027126,0.042485,-0.036229,0.001873,0.017919,0.000913,-0.009974,-0.026778},
  { -0.012412,0.020079,-0.008754,0.028939,0.010067,-0.008311,-0.013298,-0.018816,0.004294,-0.052052},
  { 0.008380,-0.024542,0.099277,0.046230,-0.077190,-0.027135,-0.001933,-0.022776,-0.000190,-0.118074},
  { -0.000591,-0.030231,0.082297,0.030266,-0.091335,-0.030566,0.006623,-0.010372,-0.022243,-0.094575},
  { 0.029543,0.007758,0.068413,-0.007048,0.025739,-0.120047,0.007293,-0.035325,0.004611,-0.065226},
  { 0.018401,0.003280,-0.016532,-0.000648,-0.044887,-0.016602,-0.001751,-0.018539,0.015633,-0.012124},
  { 0.035811,0.030517,0.059193,0.024350,-0.022731,-0.072637,-0.011694,0.007516,0.013220,-0.032895},
  { 0.048930,0.034500,0.058729,0.016518,0.009335,-0.103188,-0.012526,-0.022110,0.008241,-0.039319},
  { 0.015366,0.037677,0.007352,0.042019,-0.003065,-0.084658,-0.006761,-0.050056,0.017162,-0.036657},
  { 0.008504,-0.000204,-0.033879,-0.013945,0.013129,-0.023295,0.006697,-0.038412,0.014289,0.047421},
  { 0.042070,0.035397,0.027135,-0.028900,0.136415,-0.100184,0.000476,-0.023810,-0.025000,0.070170},
  { 0.037071,0.022286,0.014859,-0.011072,0.085160,-0.004092,-0.007594,-0.013487,-0.019802,0.012677},
  { -0.014498,0.029403,-0.089731,-0.014536,0.098594,-0.030130,0.020844,-0.040078,-0.004036,0.030110},
  { 0.016633,0.050594,0.006524,-0.001087,0.104455,-0.054050,-0.012987,-0.052153,0.004615,0.028935},
  { 0.026754,-0.018299,0.026814,0.009919,-0.016234,-0.028297,-0.010621,0.007180,-0.022401,-0.030207},
  { 0.015358,-0.018866,-0.013147,0.032320,-0.022347,-0.004189,-0.004613,-0.024913,-0.009408,-0.067731},
  { 0.000998,0.036592,0.132743,-0.006806,-0.023406,-0.050880,-0.020251,-0.022721,0.007311,-0.126171},
  { -0.002018,-0.027662,0.094386,0.038583,-0.016798,0.029597,-0.022605,-0.015078,-0.024389,-0.058687},
  { 0.004425,-0.054429,0.080102,0.013492,0.011715,-0.003870,-0.025608,-0.016896,0.010498,-0.026100},
  { 0.023794,-0.059834,-0.022438,0.008576,-0.019781,0.061940,-0.022768,0.025798,-0.018111,0.014322},
  { 0.011421,-0.010719,-0.008544,-0.033187,0.002489,-0.024525,-0.005409,0.017287,0.010523,-0.037607},
  { 0.010523,0.031652,-0.010541,-0.001629,0.007751,-0.074781,-0.022205,-0.009068,-0.020403,-0.017485},
  { 0.013637,0.015833,0.010671,-0.009297,0.012716,-0.093523,0.007937,-0.030231,0.012511,0.004039},
  { 0.046870,-0.004501,0.053888,-0.017666,0.022897,-0.065965,-0.016376,-0.013339,-0.007997,0.055449},
  { 0.058249,0.042709,0.104117,-0.091902,0.114780,-0.162578,-0.008997,-0.028649,0.006627,-0.009913},
  { 0.038577,-0.013352,0.050768,0.001715,0.028387,-0.046925,0.019149,-0.042067,-0.027436,0.028915},
  { 0.010779,-0.031773,-0.017139,0.012178,0.049135,0.031199,-0.013090,-0.048252,0.012000,0.027412},
  { 0.029472,0.008593,0.009621,0.014207,0.043853,0.010510,-0.025137,-0.040488,-0.026409,-0.004752},
  { 0.011162,0.013423,0.036780,0.031189,0.025060,-0.058301,0.010745,-0.057862,-0.000776,-0.089706},
  { 0.008655,-0.009365,0.031473,0.080040,-0.010569,-0.013798,-0.018036,-0.041155,0.000060,-0.103954},
  { 0.022812,0.012516,0.067464,-0.019030,0.078853,-0.074896,0.017290,-0.015261,0.016438,-0.059212},
  { 0.028804,-0.010609,0.049940,0.000744,0.074339,0.008258,-0.016891,-0.000925,-0.022113,-0.005562},
  { 0.013041,-0.037825,0.040747,-0.007137,0.058505,0.017329,-0.015052,0.025479,0.001150,-0.002233},
  { -0.020205,-0.034658,-0.017204,-0.022078,0.026064,0.025309,-0.020690,0.002744,-0.010501,0.001699},
  { 0.023964,0.036393,-0.016730,-0.014565,-0.020312,-0.036288,-0.016762,-0.019469,0.016565,-0.014343},
  { 0.022473,0.002743,-0.021287,-0.004021,-0.083565,-0.043673,0.018792,-0.000903,-0.012530,0.003301},
  { -0.015781,0.023718,-0.080498,-0.001396,-0.050304,0.014924,-0.015837,-0.030316,0.020737,0.073486},
  { 0.039670,0.063010,-0.011429,-0.035063,0.030757,-0.032123,0.023228,-0.014996,-0.000218,0.060442},
  { 0.019073,0.036697,0.013129,-0.019916,0.044056,-0.002448,0.000603,-0.017817,-0.008879,0.079168},
  { 0.000513,-0.014350,-0.030944,-0.014089,-0.003640,0.053396,-0.024228,0.014073,0.014267,0.066293},
  { 0.012767,-0.023352,-0.023237,0.010611,-0.011231,0.039754,-0.025249,-0.029178,0.019402,0.039452},
  { -0.010981,-0.030164,0.066748,-0.019798,0.007876,0.003017,-0.012088,-0.027950,-0.006340,-0.007970},
  { 0.008331,-0.004127,0.034432,-0.033056,0.050735,-0.032967,-0.000429,-0.047553,-0.003947,-0.064224},
  { -0.001382,0.006106,0.049381,0.027802,0.043040,-0.053649,0.010474,-0.010198,-0.004567,-0.077366},
  { 0.028977,0.037383,0.103016,-0.023113,0.133338,-0.090331,-0.019444,-0.019285,-0.019732,-0.074301},
  { 0.030545,-0.031202,0.086354,0.015579,0.061311,0.014881,0.015187,0.010853,-0.010511,-0.062434},
  { -0.008683,-0.019158,0.023048,-0.015435,0.096222,0.028270,-0.027210,0.019486,-0.006583,0.007666},
  { 0.002783,0.038404,-0.059872,0.022177,0.074310,0.000535,0.000044,0.024916,-0.012694,0.006166},
  { 0.005868,0.053859,-0.033427,-0.033261,-0.011072,-0.059338,-0.007898,-0.016813,-0.014973,-0.007703},
  { -0.004529,0.011706,0.001861,-0.025383,-0.100202,-0.062436,-0.023459,-0.029078,-0.007386,0.032588},
  { 0.023861,-0.020010,-0.025287,-0.044017,-0.102314,0.016552,-0.010839,0.013362,-0.020763,0.057102},
  { 0.036222,0.045295,-0.000954,-0.051238,0.019631,0.014868,-0.006369,-0.005191,0.001437,0.053374},
  { 0.023035,0.050402,0.069021,0.003635,0.031769,-0.045582,-0.016035,-0.001075,0.008200,0.043156},
  { -0.022312,0.015423,-0.040024,0.005074,0.006633,0.038621,-0.022609,-0.032794,0.006562,0.028549},
  { -0.012973,0.013925,-0.108010,0.011957,0.010001,0.067797,-0.005046,0.000555,0.016416,0.090250},
  { -0.009313,-0.034854,-0.017195,0.051660,-0.058939,0.049762,0.006395,-0.009369,-0.011815,-0.021465},
  { 0.023074,0.010814,0.009843,0.002692,0.055121,-0.042087,-0.021432,-0.029817,-0.023563,-0.048363},
  { 0.004728,0.036686,0.004824,0.014588,0.066159,0.003991,0.003268,-0.018265,-0.024650,-0.047880},
  { 0.028360,0.009368,0.040050,0.030737,0.083109,0.022074,0.024162,0.010441,0.015646,-0.086397},
  { 0.007286,-0.056122,0.044025,0.035686,0.017055,0.061999,-0.022108,0.005685,-0.003838,-0.054770},
  { -0.011198,-0.019963,-0.006254,0.007819,0.037986,0.057323,-0.019891,0.030908,-0.007630,-0.036875},
  { 0.017362,0.008265,-0.035103,0.048043,0.072982,0.048068,-0.023058,0.030142,-0.016664,-0.008311},
  { -0.017346,-0.014875,-0.031233,0.053920,-0.013990,0.000674,-0.020173,0.007647,0.002768,-0.025063},
  { 0.003907,-0.028781,0.002669,-0.005637,-0.035306,-0.020310,0.018841,0.010962,-0.015065,0.023022},
  { -0.003392,-0.028769,0.075095,0.001047,-0.045321,-0.049574,0.018943,-0.009956,0.011944,0.057497},
  { 0.009498,-0.025314,-0.000275,0.011948,-0.031342,0.028323,0.022544,0.011680,0.013126,0.073261},
  { 0.007741,0.017584,0.005567,0.004568,-0.000595,-0.012416,-0.017457,0.004285,0.021183,0.053705},
  { -0.010806,-0.006582,-0.058461,0.033011,-0.033101,0.078214,-0.014415,-0.008554,-0.022852,0.060775},
  { 0.005422,0.015230,-0.093214,0.003254,0.001286,0.051215,-0.008966,-0.028955,-0.027554,0.036980},
  { -0.005971,-0.027297,-0.046663,0.088578,-0.090943,0.097948,0.014963,-0.014174,-0.016434,-0.024878},
  { 0.025194,-0.030719,-0.017754,0.024122,-0.014277,0.037714,-0.015390,-0.021020,0.014344,-0.051911},
  { 0.046047,0.040889,0.063693,0.034827,0.023522,-0.031561,-0.001033,-0.035033,0.000648,-0.074697},
  { 0.010138,0.013824,0.009456,0.027659,0.092246,-0.014505,-0.024672,-0.006645,-0.000334,-0.051928},
  { 0.016460,-0.059726,0.019449,0.031858,-0.050485,0.112302,-0.012231,0.040792,0.009310,-0.026877},
  { -0.015996,-0.037158,0.038923,0.008270,-0.022015,0.051161,0.008153,0.025853,-0.007642,-0.033856},
  { -0.013776,-0.050303,0.051265,-0.028854,-0.037904,0.030664,-0.011296,0.017569,-0.000924,-0.033612},
  { -0.001461,-0.040529,-0.020054,0.039210,-0.102019,0.080986,0.011825,-0.010588,-0.018529,-0.002726},
  { -0.016307,-0.007874,-0.038616,0.067378,-0.143959,0.057888,0.021465,-0.008806,-0.019992,0.013453},
  { 0.001611,0.034838,0.009022,-0.008114,-0.044367,-0.062963,-0.002230,-0.026171,0.013306,0.055622},
  { 0.033632,0.042203,0.064402,0.022316,0.006163,-0.057087,-0.005552,0.005086,0.015409,0.071694},
  { -0.013322,0.033662,0.002798,0.008908,0.019712,-0.008836,-0.005014,0.009516,0.013648,0.058047},
  { -0.001535,-0.030726,-0.078442,0.071267,-0.089947,0.087553,0.002228,0.005170,0.014907,0.058122},
  { -0.023911,0.017070,-0.036493,0.042267,-0.016642,0.036437,-0.002077,0.019217,0.002329,0.003580},
  { 0.008780,-0.006013,0.017354,0.059787,0.028733,0.043366,0.003429,-0.015243,-0.020104,-0.032123},
  { 0.006631,-0.041725,0.043335,0.082635,0.011056,0.013627,-0.001335,-0.026168,-0.006996,-0.060993},
  { 0.029961,0.019714,0.122973,0.024785,0.057883,-0.085832,-0.024385,-0.001092,0.011986,-0.081104},
  { 0.020002,-0.003268,-0.043003,0.004906,0.167373,0.011252,-0.002403,-0.023636,-0.019181,-0.020963},
  { -0.000412,-0.026810,0.011079,0.041405,-0.004223,0.080206,0.012753,-0.021301,-0.022890,-0.052622},
  { 0.019573,-0.076643,0.016890,0.063571,-0.043212,0.064260,0.012658,-0.003112,0.016196,-0.016554},
  { 0.031732,-0.019732,0.026474,0.007916,0.025962,-0.027856,0.006250,-0.004923,-0.008613,-0.015326},
  { 0.026347,-0.010607,-0.001472,0.010812,0.037948,-0.044771,-0.015023,-0.035829,0.012258,-0.034958},
  { 0.012237,-0.010264,-0.016394,0.087336,-0.081180,0.025900,0.012961,-0.010757,-0.020886,-0.008489},
  { 0.013455,0.002745,0.040172,0.055180,-0.048543,-0.042389,-0.004216,-0.034420,0.012259,0.005826},
  { 0.000963,0.004861,0.035494,0.028676,-0.029418,-0.095393,0.016243,0.016168,0.004224,-0.010787},
  { 0.003967,-0.016038,0.033981,-0.007108,-0.003555,-0.043482,-0.002288,-0.007846,0.015886,-0.009941},
  { 0.031686,0.013841,0.024233,0.041987,0.005464,-0.034492,-0.024672,-0.004034,0.003642,-0.039861},
  { 0.011363,-0.021093,0.001044,0.043451,0.003786,-0.039234,-0.010949,-0.001650,-0.006739,-0.065262},
  { -0.021014,-0.045636,0.013101,0.091610,0.052274,0.003229,-0.007867,-0.032234,-0.000653,-0.092164},
  { -0.003180,-0.026681,0.034266,0.070467,0.064964,0.036395,0.000448,-0.033535,-0.003690,-0.035359},
  { 0.038975,-0.034433,0.056580,0.050973,0.087239,-0.069589,-0.027040,-0.013876,-0.012301,-0.059265},
  { 0.037395,0.008394,-0.043997,0.059567,0.186430,-0.039156,-0.013803,-0.024928,-0.024130,-0.030448},
  { 0.007205,-0.013645,-0.021849,0.037447,0.058978,0.011587,0.002498,0.022251,0.000479,-0.052292},
  { -0.014135,-0.042617,0.015232,0.048553,0.005466,0.018790,-0.016098,0.006344,0.003176,-0.028125},
  { 0.016805,-0.048267,0.019651,0.046205,0.006058,-0.055717,-0.009027,-0.019567,0.019889,-0.078244},
  { 0.007349,0.005154,0.029201,0.043528,0.038048,-0.053827,0.015783,-0.019736,-0.014813,-0.049291},
  { 0.000337,-0.051826,-0.028328,0.090189,-0.067277,0.043205,-0.001944,-0.026776,0.006632,-0.024799},
  { 0.002651,-0.018609,0.014497,0.107645,-0.022105,0.015423,-0.022747,-0.018254,-0.025003,-0.029549},
  { -0.008393,-0.050459,0.026016,0.065461,-0.041118,-0.060965,-0.003781,-0.038619,-0.020458,-0.021876},
  { -0.016026,-0.018211,0.010701,0.061569,-0.055403,-0.020166,-0.015440,-0.025705,0.009239,-0.006995},
  { -0.006495,-0.020279,0.012928,0.016497,-0.074895,-0.033238,-0.003947,0.021683,-0.007164,-0.009305},
  { -0.002051,-0.014823,0.009411,0.003435,-0.013174,-0.005734,-0.004751,0.007472,-0.002474,-0.028215},
  { 0.025042,-0.007320,0.034846,0.048990,-0.029253,0.028491,0.000281,0.007010,-0.005005,-0.028262},
  { 0.016257,-0.017074,0.098662,0.019499,0.074674,-0.076897,0.005681,-0.029211,-0.007185,-0.065437},
  { 0.048993,-0.006235,0.053883,0.027448,0.104319,-0.086951,0.010541,-0.034661,-0.007851,-0.052404},
  { -0.001714,0.035832,-0.006011,0.074942,0.076232,-0.084445,-0.007955,-0.006598,-0.009335,-0.046144},
  { -0.014365,-0.021077,0.048121,0.030518,0.070714,-0.027530,0.020075,0.017597,0.024748,0.006721},
  { 0.019715,-0.017090,0.010793,0.025750,-0.007096,-0.009891,0.001286,-0.022685,0.022765,0.019616},
  { 0.005153,0.009444,0.019561,-0.001510,0.080070,-0.126916,-0.014024,-0.045054,-0.023283,-0.026944},
  { 0.051620,-0.011014,0.039550,-0.008587,0.086718,-0.139261,0.000000,-0.019265,0.003984,-0.064551},
  { 0.014723,-0.049591,0.018403,0.078226,0.024641,-0.032374,0.008891,-0.040465,-0.010036,-0.034263},
  { 0.021525,-0.037051,0.032995,0.060950,0.087205,-0.087547,0.022330,-0.029353,-0.011052,-0.038038},
  { 0.005544,-0.040883,0.021095,0.071122,0.000535,-0.033750,0.012310,-0.053734,-0.022820,-0.063404},
  { 0.021135,0.029108,0.018926,0.054636,-0.029324,-0.018179,-0.006770,-0.047005,0.003066,-0.080356},
  { 0.002337,-0.015110,0.057251,0.047229,-0.055518,-0.012083,0.011063,-0.014829,0.001271,-0.029800},
  { 0.040960,0.015066,0.072270,-0.031662,0.041668,-0.042548,-0.001238,-0.030419,-0.011011,-0.030950},
  { 0.025283,-0.003648,0.147992,0.007052,0.021969,-0.073302,0.021855,-0.007096,0.006338,-0.066840},
  { 0.016288,-0.012423,0.077626,-0.003074,0.057684,-0.036003,-0.005417,-0.033497,0.016788,-0.086804},
  { 0.055668,0.027838,0.058160,0.000862,0.150186,-0.126882,-0.014130,-0.049224,0.000396,-0.120575},
  { 0.051193,0.060825,0.038964,0.013728,0.102103,-0.133805,-0.004967,-0.024114,-0.009596,-0.073312},
  { 0.005841,0.043499,0.047143,0.035782,0.074875,-0.137504,0.013170,-0.038393,0.020606,-0.039179},
  { 0.002905,0.035404,0.068129,0.039884,-0.013543,-0.085102,0.018136,-0.014099,-0.007540,-0.010417},
  { -0.006304,0.011715,0.064455,0.013533,0.036922,-0.123544,0.006179,-0.011855,-0.026204,-0.047124},
  { 0.002435,0.002030,0.060443,0.022543,0.073653,-0.141714,0.019902,-0.037071,0.016755,-0.098397},
  { 0.015199,-0.048300,0.056645,0.015336,0.094236,-0.067026,0.016962,-0.025670,-0.005914,-0.004140},
  { -0.018347,-0.101526,0.066663,0.049670,0.030966,-0.081687,-0.001996,-0.008907,-0.004802,-0.058508},
  { 0.028649,-0.053422,0.072696,0.056021,0.068622,-0.130834,0.004959,-0.066867,0.019234,-0.094710},
  { 0.011434,-0.039029,0.046993,0.049066,0.079819,-0.145571,-0.014567,-0.049570,0.017753,-0.091812},
  { 0.018055,-0.007356,0.040524,0.079018,-0.022407,-0.035469,0.012753,-0.040247,0.010971,-0.079141},
  { 0.026368,-0.025025,0.113018,0.033663,0.000421,-0.056996,0.016176,-0.021041,0.001819,-0.057469},
  { 0.034916,-0.053022,0.149013,0.012004,-0.006484,-0.066254,-0.010437,0.001744,0.020399,-0.069087},
  { 0.008975,-0.071326,0.139258,-0.016372,0.047416,-0.054754,0.012620,0.007602,0.012285,-0.083859},
  { 0.020913,0.010358,0.136964,-0.014144,0.152782,-0.188869,-0.004932,-0.011322,-0.003756,-0.147412},
  { 0.028202,0.064555,-0.011122,-0.120076,0.080520,-0.083284,0.013112,-0.020852,0.016802,0.018918},
  { 0.021423,0.015349,0.041674,-0.013086,-0.009707,-0.047540,-0.005258,-0.034182,-0.016463,0.007527},
  { 0.001606,-0.064296,0.077975,-0.033432,-0.058393,-0.028656,-0.016163,-0.021560,0.012953,0.067764},
  { 0.020852,-0.071706,0.120748,0.014845,-0.013095,-0.026469,-0.020799,-0.007945,-0.030840,0.045695},
  { 0.021623,-0.073204,0.073363,-0.003160,-0.015647,-0.022159,-0.012473,0.007210,-0.021414,0.072988},
  { 0.028094,-0.035807,-0.014094,0.019398,0.043749,-0.024231,-0.006149,0.022736,-0.012270,0.020588},
  { 0.022409,-0.024568,-0.029036,-0.006725,-0.027404,0.037146,-0.024088,-0.003086,0.012914,-0.017239},
  { 0.031402,-0.005435,-0.003045,0.004767,0.007714,0.033082,-0.016861,0.014347,0.019061,0.010980},
  { -0.033275,-0.076257,-0.057441,0.043135,-0.029781,0.119975,-0.024313,0.040905,-0.029000,0.049123},
  { 0.023250,-0.075321,-0.042790,0.005478,-0.018405,0.068579,-0.019860,0.012759,-0.008397,0.107252},
  { 0.024198,-0.068807,0.063665,0.049834,0.059182,-0.036053,-0.009243,-0.038407,0.020329,0.031392},
  { 0.037877,-0.036704,0.040363,0.016410,0.091979,-0.068573,0.010293,-0.030763,-0.023462,0.058624},
  { 0.007407,-0.035172,0.043467,0.003149,0.048526,-0.038763,0.011772,-0.026146,0.006930,0.100959},
  { 0.018040,-0.052388,0.025675,0.021769,-0.152354,0.073223,0.005202,-0.033716,-0.021660,0.097711},
  { 0.042795,0.000546,-0.004771,0.005252,-0.018178,0.006091,0.007217,-0.028636,0.016833,0.043722},
  { 0.023110,0.016277,0.000785,0.009929,-0.066977,-0.018448,0.000489,-0.045589,0.005277,0.044103},
  { -0.015225,-0.014631,0.031600,0.039480,0.003863,-0.014620,-0.015065,0.002926,0.015561,0.042643},
  { -0.023048,-0.094762,-0.013364,0.071435,-0.046048,0.031178,0.004863,0.002203,0.017410,0.097154},
  { 0.009644,-0.098306,0.005665,0.069407,-0.026096,0.030982,-0.028482,0.026274,0.001155,0.021941},
  { -0.004803,-0.126597,0.021943,0.068245,-0.084947,0.070790,-0.032484,0.022655,-0.021125,-0.107595},
  { -0.007849,-0.096663,0.092266,0.025215,-0.116317,0.093093,0.001382,0.043673,0.008786,-0.132315},
  { -0.005672,-0.116641,0.147364,0.016437,0.002818,0.020031,0.010810,0.037751,-0.006678,-0.139383},
  { 0.016381,-0.085844,0.060845,0.078787,0.022566,0.057735,-0.008577,-0.003427,0.023312,-0.063040},
  { -0.012383,-0.095822,-0.014910,0.033194,0.028104,0.122287,-0.016013,0.023153,-0.023437,0.011296},
  { -0.002997,-0.137050,-0.013907,0.054860,0.000112,0.105030,-0.014275,0.003113,0.021558,0.068200},
  { -0.008325,-0.078923,-0.033899,0.017545,0.013200,0.089314,0.011199,-0.018463,-0.026006,0.165010},
  { 0.029095,-0.030365,-0.026090,-0.014187,0.043558,0.023552,-0.000661,0.005693,-0.004813,0.154371},
  { 0.001596,-0.058441,0.031861,-0.016508,-0.053649,0.027576,-0.031742,0.001298,-0.005826,0.073617},
  { 0.030258,-0.054940,-0.029016,0.001455,-0.059603,0.045352,-0.000655,-0.023338,0.009111,0.077034},
  { -0.004546,-0.023478,-0.017035,0.050922,0.012469,0.113528,0.002115,-0.027063,-0.011056,0.056637},
  { -0.015386,-0.029640,0.022497,0.027859,-0.036731,0.094649,-0.010461,0.032130,0.001835,0.005967},
  { -0.006613,-0.121349,0.022635,0.051075,-0.121159,0.110047,-0.022396,0.050944,0.009723,-0.014436},
  { -0.019214,-0.124631,0.063415,0.041887,-0.148312,0.085750,0.004482,0.008278,-0.003653,-0.091093},
  { -0.020041,-0.148440,0.031318,0.069557,-0.157090,0.109524,-0.017454,0.020672,0.019730,-0.110077},
  { -0.005244,-0.088978,0.015143,0.050119,-0.095953,0.086614,-0.014978,0.006907,-0.010026,-0.089484},
  { 0.013062,-0.117079,0.097593,-0.024995,-0.045254,-0.029826,0.018215,-0.020789,-0.012852,-0.078386},
  { 0.017640,-0.102110,0.075000,0.015277,-0.049194,0.012674,0.017885,-0.029771,-0.002204,-0.043988},
  { 0.019086,-0.101437,0.049954,0.053287,-0.098269,0.078706,-0.005568,-0.012468,0.012180,0.036587},
  { 0.008167,-0.072822,0.059530,0.014933,-0.061488,0.006159,-0.009721,0.025459,-0.010262,0.039681},
  { 0.006146,-0.073130,0.099596,-0.042980,0.039661,-0.059441,0.008540,-0.014396,-0.013210,0.042198},
  { 0.021973,-0.053905,0.045650,-0.076946,0.113409,-0.120616,-0.001536,0.009930,-0.013781,0.072320},
  { 0.028291,-0.065519,0.056984,-0.054975,0.130881,-0.090957,-0.017272,-0.028441,-0.015146,0.024846},
  { 0.011568,0.017052,0.025524,-0.026974,-0.022892,-0.028158,0.014505,-0.020060,0.013973,0.036821},
  { 0.033167,-0.002380,-0.003401,0.030442,0.008352,-0.031418,0.018668,-0.022269,-0.001248,0.000887},
  { -0.009117,-0.025062,0.043398,0.067859,-0.028006,-0.008617,-0.026278,0.000548,-0.018302,-0.037246},
  { -0.033503,-0.072213,0.019210,0.052568,-0.119896,0.112420,-0.012405,0.039996,-0.013638,-0.000044},
  { 0.006387,-0.080202,0.049273,-0.002541,-0.147330,0.056421,-0.024787,-0.005856,-0.004854,-0.031167},
  { -0.017812,-0.068999,0.077794,0.003479,-0.113492,-0.012957,-0.027139,-0.015424,0.023176,-0.073258},
  { -0.045769,-0.092332,-0.005973,0.054058,-0.145063,0.105550,-0.006615,0.045112,0.010019,-0.063628},
  { -0.019500,-0.042008,0.057967,-0.045892,-0.140410,0.029756,0.017383,0.018680,0.010910,-0.066078},
  { 0.004785,-0.073491,0.056579,-0.006947,-0.095590,0.070199,0.013859,0.035212,0.024206,-0.015943},
  { 0.015547,-0.010847,0.096962,-0.044631,-0.005423,-0.008508,-0.016258,-0.011870,0.002519,-0.007005},
  { 0.008702,-0.034249,0.029852,0.012909,-0.057846,0.089508,0.004992,0.019730,0.017170,0.053353},
  { 0.006464,-0.034820,0.041188,-0.042278,0.004845,0.022163,0.012531,0.037502,0.018000,0.086240},
  { 0.009429,-0.091565,0.030340,-0.061382,0.101371,-0.011787,0.004219,0.002308,-0.005355,0.138072},
  { -0.018558,-0.125117,-0.004589,-0.027185,0.039858,0.033965,-0.026382,-0.004857,-0.004499,0.115632},
  { 0.035005,0.060014,-0.058023,0.011324,0.075990,-0.026436,-0.011111,-0.008200,-0.004938,0.012570},
  { 0.026156,0.089975,-0.029522,-0.006218,0.116701,-0.152678,-0.004019,-0.017419,0.001463,-0.017488},
  { 0.016467,-0.002182,-0.013421,-0.006291,0.009837,0.002215,-0.004704,0.002427,-0.004718,0.017370},
  { -0.027546,-0.053853,-0.002198,0.071366,-0.057885,0.075093,0.015266,0.030161,0.016853,-0.029080},
  { -0.003816,-0.025578,0.035657,-0.005585,-0.082200,0.012348,0.010489,0.017993,-0.008613,-0.058349},
  { -0.035253,-0.042431,0.050290,0.014381,-0.168251,0.068017,-0.003379,0.015680,-0.019896,-0.086566},
  { -0.037734,-0.056963,0.032409,0.010697,-0.216648,0.108604,0.018156,0.026954,0.029385,-0.048150},
  { -0.018969,-0.005054,0.053606,0.032278,-0.100112,0.057842,-0.004162,-0.001804,-0.021177,-0.031568},
  { 0.021774,-0.049012,0.033246,0.003077,-0.119148,0.006173,-0.009854,0.013835,0.013760,0.010992},
  { 0.024170,-0.027307,0.037913,0.015352,-0.077430,-0.008477,0.021488,-0.031644,0.015606,-0.019759},
  { -0.019610,-0.022003,0.041665,0.012212,-0.109909,0.095370,-0.000884,-0.006488,-0.007469,0.018304},
  { 0.017828,-0.021193,0.080589,-0.045634,0.073857,-0.031269,0.004201,0.017229,-0.023113,-0.012818},
  { 0.024896,-0.040112,0.040599,-0.029776,0.087024,0.038816,-0.020490,-0.005177,-0.005010,0.098966},
  { 0.002617,-0.064905,0.007472,-0.012641,0.146910,-0.002852,-0.019247,-0.010170,0.003519,0.115855},
  { -0.008103,-0.007215,-0.072262,-0.019889,-0.025958,-0.038817,-0.002522,0.056550,-0.023711,0.048390},
  { 0.058349,0.004207,0.007890,-0.075370,-0.048185,-0.107571,-0.002690,0.050691,-0.027953,0.071617},
  { 0.037032,0.001115,0.022918,-0.063527,-0.023181,-0.025141,-0.022305,0.048088,-0.002554,0.056143},
  { 0.026470,-0.012477,-0.010810,-0.021491,-0.002458,0.011052,0.009184,0.030617,0.017195,0.040113},
  { -0.010299,-0.007554,-0.022318,-0.015827,0.036055,0.015259,0.016787,-0.005707,-0.015653,-0.026804},
  { 0.033779,-0.028814,0.088147,-0.021861,0.000584,-0.034986,-0.014124,-0.003428,0.002909,-0.080917},
  { 0.010892,-0.055301,0.084392,0.026120,-0.097661,0.023643,-0.011351,0.032988,0.026661,0.008570},
  { -0.021984,-0.043860,0.072524,0.026636,-0.103531,0.060432,-0.018061,0.069761,0.012647,0.050323},
  { 0.020490,0.005405,0.064331,0.012944,-0.007312,-0.018385,-0.010107,0.036623,0.024869,0.011636},
  { 0.002469,-0.063971,0.028676,0.014431,-0.030229,0.031229,-0.026755,0.000030,-0.017810,0.037592},
  { 0.016357,-0.044868,0.075376,0.013494,-0.055757,0.047018,0.007420,-0.009693,0.013637,0.015549},
  { 0.034481,0.004276,0.005029,0.013465,0.090141,-0.004412,-0.017830,0.021807,0.001194,-0.024402},
  { 0.009637,-0.023188,0.014235,-0.003742,0.056402,-0.001401,-0.011429,-0.012950,0.021330,0.016053},
  { 0.016693,0.031194,0.015279,-0.002913,0.133179,-0.055370,-0.020934,-0.029381,0.018677,-0.020650},
  { 0.065329,0.012078,0.087214,-0.089300,-0.028980,-0.151822,0.008116,0.012637,-0.013004,0.006083},
  { 0.051081,0.032540,0.070293,-0.101328,-0.054506,-0.067306,-0.004312,0.057550,0.000393,0.033468},
  { 0.048925,0.043721,0.002606,-0.084108,0.054634,-0.059243,-0.029139,0.038901,0.019964,0.052784},
  { -0.004425,0.006781,-0.040281,-0.054604,-0.006527,-0.030614,-0.002689,0.044649,-0.018302,0.022580},
  { 0.025631,-0.029922,-0.001301,-0.029133,0.002059,0.002864,-0.023447,-0.000722,-0.004501,-0.010554},
  { 0.043359,0.008325,0.053695,-0.035538,0.017286,-0.044924,-0.015078,0.030078,-0.014766,-0.041900},
  { -0.004526,-0.022590,-0.013564,-0.016389,-0.054508,0.114246,-0.006655,0.072214,0.005597,0.048779},
  { 0.001011,0.044435,0.011175,-0.033594,-0.016959,0.024840,-0.022958,0.044344,0.015098,0.053506},
  { 0.030457,0.088313,0.008766,-0.014434,0.008081,-0.007125,0.004068,0.015129,-0.000902,0.027537},
  { 0.025883,0.013075,0.022838,0.029733,-0.018983,-0.004071,0.014898,0.026893,0.014979,0.010482},
  { 0.013822,0.057401,0.007811,-0.018640,0.122693,-0.066146,-0.026352,0.008278,-0.006857,0.072621},
  { 0.011073,0.113049,0.014782,-0.047937,0.234642,-0.079186,-0.016285,-0.007845,-0.015033,0.009566},
  { 0.038431,0.046312,0.014302,-0.046434,0.174354,-0.037219,-0.005783,0.030676,-0.023178,-0.024989},
  { 0.034453,-0.007862,0.030485,0.008413,0.082938,0.055050,-0.016147,-0.004435,-0.010518,0.001036},
  { 0.046260,-0.011282,0.077777,-0.090630,-0.022837,-0.109473,-0.023054,0.015194,-0.011172,-0.029147},
  { 0.010333,0.006840,0.020407,-0.058690,-0.036854,-0.045276,0.006742,0.025239,0.004955,-0.003612},
  { 0.037658,0.002034,-0.059186,-0.040879,0.007938,-0.016763,-0.002424,-0.014893,-0.009150,-0.050902},
  { 0.011854,0.016971,-0.115390,-0.017691,0.002195,0.049797,-0.005210,0.029994,0.018830,0.007644},
  { 0.016602,0.046156,-0.048647,-0.024186,0.025751,0.053344,-0.017372,0.001276,0.020560,-0.018846},
  { -0.011699,-0.001050,-0.052571,-0.069221,-0.012205,0.068281,-0.005475,0.040454,-0.016451,0.037204},
  { -0.003276,0.027315,-0.049606,-0.055508,-0.026361,0.056603,-0.011291,0.030828,0.002541,0.027680},
  { 0.043242,0.061535,-0.010989,-0.085541,0.045279,-0.044961,-0.011085,0.012884,-0.002752,0.034285},
  { 0.050769,0.048529,-0.002068,-0.061873,0.082876,-0.082483,-0.016335,0.002586,0.014065,0.007303},
  { 0.012997,0.027746,-0.038290,-0.039148,0.072509,-0.046646,0.002236,0.020810,-0.001395,0.053458},
  { 0.045973,0.004859,-0.010926,-0.079100,0.129280,-0.075805,-0.009060,-0.016500,-0.007217,0.035306},
  { 0.018648,0.003229,-0.053929,-0.052785,0.064493,0.097940,0.008480,0.029304,0.003288,0.120786},
  { 0.012456,-0.008156,0.011651,-0.057996,0.025713,0.089066,-0.001301,0.042261,0.008000,0.061478},
  { 0.014416,-0.031955,0.023326,-0.060053,-0.019819,0.049005,0.024862,0.003197,0.022242,0.024351},
  { 0.001677,-0.006961,0.049764,-0.040667,-0.072913,-0.020634,0.005858,0.030089,0.017915,0.019591},
  { 0.026476,0.024316,-0.056567,-0.045832,-0.068112,0.013264,-0.001084,0.026130,0.015773,0.013039},
  { 0.014091,0.041482,-0.043523,-0.022676,0.023401,-0.050136,0.021116,0.025252,0.000309,-0.017306},
  { 0.013467,-0.009264,-0.010579,-0.071752,0.080320,-0.036083,-0.001906,0.005541,0.001883,0.030932},
  { 0.014148,0.023450,-0.034937,-0.096754,0.117295,0.016752,-0.018314,0.066113,0.003954,0.026460},
  { -0.005553,0.071900,-0.047328,-0.081552,0.056163,0.002745,-0.027471,0.038812,0.006245,0.020621},
  { 0.019674,0.051393,-0.069274,-0.053647,0.064035,0.022187,-0.000761,0.027171,0.008139,0.047682},
  { 0.020730,0.037491,-0.062542,-0.054717,0.132388,-0.077183,0.013522,-0.013085,0.000615,0.017255},
  { 0.033342,0.040400,-0.094076,-0.075957,0.079663,0.018574,0.009461,0.010151,0.005183,0.072620},
  { -0.001030,-0.032995,-0.114439,-0.058655,0.009287,0.052649,-0.021627,0.053977,-0.002703,0.059197},
  { 0.035968,-0.018865,-0.005964,-0.098802,0.069051,-0.033184,-0.025219,0.013083,-0.020625,0.040962},
  { 0.009363,0.036769,0.050043,-0.065193,0.086451,-0.050660,0.007845,-0.010256,-0.012334,-0.023089},
  { -0.013272,0.004828,0.013744,-0.035044,0.010205,0.055914,-0.004928,0.006387,0.008895,0.039680},
  { 0.018373,-0.013325,0.013840,-0.073140,0.026908,-0.047887,-0.008635,0.033122,-0.021637,-0.004342},
  { -0.011003,-0.019834,0.006343,-0.083057,-0.090333,0.068533,0.003618,0.012770,-0.022504,0.027673},
  { 0.034497,0.078721,-0.025424,-0.082220,-0.024624,0.020293,0.000957,0.015512,-0.001370,-0.003335},
  { 0.058843,0.108226,0.066254,-0.136666,0.090201,-0.146647,-0.015350,-0.027620,0.018880,-0.057598},
  { 0.041349,0.031819,0.077189,-0.066089,0.110753,-0.131720,-0.015894,0.009792,0.010456,-0.053956},
  { 0.038730,0.039529,0.038575,-0.031808,0.163959,-0.125566,0.005363,0.023630,-0.025880,0.005203},
  { 0.022509,0.116050,-0.018712,-0.059118,0.160797,-0.089677,-0.018035,-0.002169,0.008982,-0.026506},
  { 0.017728,0.070674,-0.080719,-0.039584,0.071877,-0.043058,-0.023611,0.041735,0.013471,-0.030565},
  { 0.036180,0.038991,-0.098155,-0.066851,-0.008289,0.032789,0.018207,0.045933,0.004131,-0.006093},
  { 0.017956,0.071237,-0.059477,-0.072429,0.160999,-0.077112,-0.005896,0.010226,-0.011564,-0.050908},
  { 0.021146,-0.037756,-0.021557,-0.080586,0.131054,-0.005830,-0.008128,0.007948,-0.028984,0.000354},
  { 0.055373,-0.050986,0.085267,-0.086936,0.110992,-0.098538,-0.008083,-0.026753,-0.022179,-0.020582},
  { 0.041423,-0.048140,0.103817,-0.039111,0.045365,-0.017793,-0.023571,0.031298,0.010786,-0.000318},
  { 0.014752,-0.007020,0.027533,-0.067711,-0.000561,0.090620,0.018537,0.001473,-0.010080,-0.024946},
  { -0.000916,-0.062912,0.062628,-0.107159,-0.029616,0.014980,0.012118,0.024287,0.006516,0.029945},
  { -0.006159,-0.056751,-0.008306,-0.044457,-0.055625,0.053689,-0.018591,0.035018,0.012337,0.068160},
  { 0.015631,-0.015079,-0.034023,-0.097722,-0.049460,0.013176,-0.025463,-0.000393,-0.014166,0.014583},
  { 0.041901,0.002559,0.038835,-0.101750,-0.020446,-0.051681,-0.001965,-0.001174,-0.000463,-0.029706},
  { 0.013131,-0.020259,0.067295,-0.056973,0.029590,-0.019682,0.011707,0.025702,0.023547,0.000516},
  { 0.016743,-0.051851,0.034491,-0.018123,0.096429,-0.039498,-0.003640,0.062583,0.010415,-0.057329},
  { 0.027575,-0.053783,0.004861,0.002363,0.117139,-0.009908,-0.001427,0.068877,0.011566,-0.093021},
  { 0.033566,0.022557,0.021878,-0.026050,0.102906,-0.032029,-0.012109,0.021561,-0.020924,-0.121072},
  { 0.036419,0.024740,-0.024698,-0.048458,0.107348,0.007984,-0.009687,0.053213,-0.021466,-0.144204},
  { 0.062158,0.036470,-0.093845,-0.071395,0.191729,-0.064099,0.006711,0.031094,0.005011,-0.035914},
  { -0.004919,0.003389,-0.100541,-0.044467,0.109037,0.038810,0.018644,0.001425,-0.009615,-0.020189},
  { 0.017509,-0.055607,0.014088,-0.014543,-0.005012,-0.001941,0.013880,-0.025243,-0.014554,-0.001060},
  { -0.013522,-0.025762,0.064224,-0.009977,-0.000680,0.017565,0.014639,0.007657,-0.019072,0.020858},
  { 0.035590,0.018072,0.018189,-0.043827,0.018898,0.009865,-0.016763,-0.003195,-0.022772,0.038700},
  { 0.024034,-0.027233,0.083737,-0.110123,0.009328,-0.020742,-0.021987,0.025137,-0.012730,0.021604},
  { 0.013432,-0.037064,-0.012812,-0.079622,0.024194,-0.007513,0.002647,0.028884,-0.021111,0.026241},
  { 0.020175,-0.020269,-0.002274,-0.082732,-0.050308,-0.013639,0.012825,0.023245,-0.001104,-0.028607},
  { 0.020056,-0.009302,-0.000112,-0.081189,-0.070838,0.004050,0.010646,0.014259,-0.007656,-0.001528},
  { -0.003888,-0.043684,0.049172,-0.059143,0.004578,-0.010051,0.019517,0.046933,0.018527,-0.012801},
  { 0.012184,-0.017579,0.126105,-0.057305,0.113005,-0.079591,0.012593,0.037562,0.011887,-0.074186},
  { 0.050060,-0.024588,0.029019,-0.030628,0.068646,0.004341,0.018263,0.037582,-0.018917,-0.122871},
  { 0.003002,-0.049120,0.015776,-0.018794,0.020295,-0.019952,0.001629,0.067023,-0.003328,-0.119424},
  { 0.006158,-0.012389,-0.025274,-0.007162,0.067809,0.009904,-0.004526,0.044730,-0.006805,-0.054956},
  { 0.013331,0.005349,-0.065318,0.010644,0.121798,0.043312,0.018163,0.028579,0.006538,0.024923},
  { 0.022377,0.041307,-0.094596,-0.024555,0.106196,-0.000288,-0.014787,-0.006152,0.012185,0.079943},
  { 0.034601,0.028351,0.021360,0.010361,0.047662,0.010236,0.002693,-0.002707,0.012378,0.014916},
  { -0.008056,0.002521,-0.027521,-0.008124,0.034144,0.011005,-0.020347,-0.003784,0.020734,0.023474},
  { -0.000657,0.032371,0.028227,-0.034284,-0.019958,-0.021608,0.020563,0.027539,-0.016191,-0.018087},
  { -0.000158,-0.026137,0.045857,-0.068549,-0.068970,0.049230,-0.012941,0.020133,0.011014,0.032537},
  { 0.011103,-0.036024,0.096116,-0.099884,-0.094754,0.043648,-0.033349,0.055573,-0.025524,-0.009527},
  { 0.015940,0.016408,0.078170,-0.087840,-0.045626,-0.020022,0.013718,0.045781,0.016204,-0.027052},
  { 0.054725,0.100999,0.029827,-0.054615,0.027010,-0.074743,0.015119,-0.007763,-0.021750,-0.051995},
  { 0.049235,0.040423,0.139154,-0.079847,0.131600,-0.146777,-0.027684,0.014054,0.021259,-0.043692},
  { 0.032433,-0.000717,0.074759,-0.035245,0.081451,-0.076826,-0.020571,0.038519,0.009522,-0.067587},
  { 0.013561,-0.009442,0.013589,-0.028381,0.098055,-0.032942,-0.026266,0.022115,-0.007462,-0.033916},
  { 0.037325,-0.003210,0.010242,-0.002801,0.078285,-0.055926,-0.004342,0.018283,0.020421,-0.101633},
  { 0.063404,-0.002534,0.023425,-0.021870,0.143487,-0.088703,-0.026452,0.039653,-0.018932,-0.153318},
  { 0.043649,-0.030738,-0.013942,-0.048310,0.081565,0.009496,-0.013986,0.039282,-0.028646,-0.003056},
  { 0.016827,0.021417,0.001848,-0.024249,0.041680,0.012809,0.002463,-0.013226,-0.002395,-0.009221},
  { 0.030751,0.042724,0.011965,-0.009276,0.025269,0.016716,0.000067,-0.001036,-0.020454,0.025211},
  { 0.009324,0.034444,-0.061586,-0.029986,0.023788,0.028247,0.002553,0.000654,0.020358,0.022616},
  { 0.021197,0.085703,-0.023334,-0.027701,0.037374,-0.036500,0.011324,-0.003931,-0.018663,0.014288},
  { 0.011442,0.063323,0.024445,-0.071147,-0.050203,-0.057841,-0.002640,0.026108,-0.009682,0.023752},
  { 0.020819,-0.044794,0.036125,-0.098164,-0.043487,0.080128,-0.001798,0.047349,-0.030150,0.024790},
  { 0.033406,0.029410,0.014917,-0.038590,0.054420,0.080603,-0.014019,0.008501,0.017054,-0.029586},
  { -0.003056,0.037109,0.016732,-0.074149,0.066897,0.036292,0.011402,0.022849,-0.022859,0.003644},
  { 0.025443,-0.022631,0.057636,-0.037736,0.031093,0.015725,0.006725,0.037201,0.012741,0.031323},
  { 0.040036,0.004820,0.020462,-0.043334,0.065024,-0.049765,0.006333,0.002072,-0.006777,-0.027360},
  { 0.016826,0.035155,0.007663,0.000875,-0.026201,-0.036842,-0.013118,0.043153,-0.002890,-0.074853},
  { 0.044334,-0.004984,-0.046342,-0.046273,-0.019224,0.022178,-0.005764,0.063322,-0.007550,-0.089921},
  { 0.062631,0.084953,-0.149347,-0.053846,0.133368,-0.050765,-0.013015,0.027437,-0.011736,-0.006966},
  { 0.063184,0.081220,-0.068665,-0.021687,0.121607,-0.075945,0.008452,-0.010284,0.010138,-0.051486},
  { 0.026726,0.072009,-0.024276,-0.018967,0.139247,-0.134361,0.014604,0.014689,-0.015524,-0.042778},
  { 0.031644,0.120829,0.015498,-0.016562,0.116421,-0.130354,-0.003214,0.019674,-0.026398,-0.044917},
  { 0.048143,0.051380,-0.013540,0.007799,0.046568,-0.017243,-0.014439,-0.031089,-0.010869,0.017819},
  { 0.018485,0.041253,-0.070405,-0.006160,-0.023615,0.065934,0.007160,0.029216,-0.023205,0.097495},
  { 0.045385,0.042055,0.036033,-0.070179,-0.087979,0.008441,-0.008878,0.002309,0.002414,0.065453},
  { -0.013055,-0.019020,-0.025209,0.005438,0.051081,0.006391,-0.001761,-0.011798,0.005888,0.040331},
  { -0.008022,0.010377,-0.074624,-0.025949,0.052327,0.037275,0.017779,0.003360,0.012549,0.043053},
  { 0.005421,0.081294,-0.066952,-0.030114,0.123089,-0.025673,-0.009326,0.003861,0.003009,0.031233},
  { -0.003113,0.026371,-0.064930,0.019307,0.067775,0.065145,-0.009656,0.030768,-0.020548,0.039800},
  { 0.003110,0.008986,-0.038674,-0.008237,-0.007850,0.053838,0.005076,0.045094,-0.025500,0.047268},
  { 0.005620,0.047496,-0.000438,-0.035486,0.071366,0.015779,0.003823,0.030470,-0.024620,-0.033929},
  { -0.016754,0.025546,0.021697,0.003898,-0.010675,0.044785,0.006756,0.012025,-0.000588,-0.057630},
  { -0.023984,-0.000652,-0.016456,-0.025469,-0.028748,0.043492,0.017643,0.006120,0.017955,-0.000774},
  { -0.006427,0.050982,-0.065276,0.013454,0.006775,0.028009,-0.013209,0.032271,0.013665,-0.007858},
  { -0.002585,0.060832,-0.096013,0.035534,-0.046567,0.091062,0.005059,0.006554,0.011738,-0.008998},
  { -0.037507,-0.036945,-0.036419,0.006051,-0.085217,0.139785,-0.001418,-0.008326,-0.020971,0.052187},
  { -0.042578,0.005011,-0.044458,0.021144,-0.099499,0.132303,-0.008360,0.019805,0.011862,0.085371},
  { -0.017362,0.011107,-0.075683,-0.007762,-0.043003,0.093850,-0.017681,0.037535,-0.007842,0.116293},
  { -0.033134,0.004372,-0.040281,-0.011280,-0.034951,0.077600,-0.007198,0.007552,0.009559,0.091053},
  { -0.011490,-0.014694,0.034537,-0.047847,0.057051,0.022255,-0.000146,-0.017624,-0.002797,0.047316},
  { -0.003340,0.006653,0.002048,-0.030319,0.094520,-0.026486,0.001847,-0.015723,-0.004137,0.017003},
  { 0.002303,0.033481,-0.021160,-0.024110,0.059450,-0.005854,0.013649,-0.019997,0.018799,-0.032935},
  { 0.009339,0.046704,-0.010562,0.004594,0.085826,-0.053414,0.010187,-0.004656,0.004166,-0.020657},
  { 0.004891,0.013136,-0.056227,0.033551,0.082875,-0.041914,0.008491,-0.029973,0.007821,0.018881},
  { 0.012209,0.007853,-0.050983,-0.027760,0.072179,0.031940,-0.020242,0.038564,-0.010883,0.059170},
  { -0.025510,0.005679,-0.014849,0.010681,-0.001309,0.070362,-0.006700,-0.015843,0.002415,-0.020640},
  { 0.001334,0.045363,-0.038509,0.058377,-0.026000,0.051674,-0.009737,-0.025751,0.022214,-0.001547},
  { -0.013046,0.062437,0.031844,-0.007695,-0.028820,0.016757,-0.000604,-0.023251,-0.026574,0.011392},
  { -0.007233,0.044527,-0.081310,0.011216,-0.111010,0.082776,-0.017550,-0.020028,0.010294,0.036081},
  { -0.027366,0.013772,-0.064599,0.011854,-0.075063,0.097977,0.015675,-0.001618,0.007987,-0.006574},
  { 0.002173,-0.000490,-0.028961,0.060387,-0.067741,0.121700,0.011579,0.010193,-0.003987,0.007931},
  { -0.010119,-0.004594,-0.054787,-0.034805,-0.040257,0.092978,0.004452,0.015911,0.008383,0.051753},
  { -0.015883,0.004169,-0.050231,-0.038336,0.007573,0.025708,-0.020695,0.036828,-0.023803,0.091288},
  { -0.003542,0.029472,-0.015364,-0.013692,0.015906,-0.026021,-0.009620,0.003031,-0.000655,-0.003065},
  { 0.032350,0.037040,-0.006719,-0.047820,0.062478,-0.029634,0.002929,-0.029952,-0.004605,0.031503},
  { 0.013753,0.013012,-0.017625,0.010922,0.035579,-0.015001,0.011555,-0.002307,0.022512,0.047120},
  { 0.014897,0.039442,-0.038248,-0.019415,0.040669,-0.029007,0.003030,-0.005379,-0.005625,0.004852},
  { -0.002455,0.038573,-0.044806,-0.022373,-0.021347,-0.014984,0.010873,0.020554,0.018083,0.002806},
  { -0.004193,-0.020833,-0.002079,-0.032780,0.032326,-0.016331,0.011357,0.008099,-0.003268,-0.005369},
  { -0.018438,-0.051453,-0.086867,0.013452,-0.038572,0.045477,-0.006244,0.049016,-0.020251,0.038690},
  { -0.013821,-0.014366,-0.081203,-0.001354,0.016671,0.055177,0.005887,0.021371,-0.016507,-0.023675},
  { 0.000827,0.036200,-0.008155,0.013963,0.013011,-0.000791,-0.003008,0.005551,0.011624,-0.017664},
  { -0.028129,0.036131,-0.046655,0.014092,-0.046808,0.064350,-0.013919,0.020943,0.001774,0.026179},
  { -0.041526,-0.018153,-0.131702,0.045063,-0.100993,0.158523,-0.019876,0.001080,-0.025943,0.046363},
  { -0.041621,0.000066,-0.058429,0.042094,-0.087378,0.134433,-0.008211,-0.023652,-0.007958,0.047750},
  { -0.012799,0.032982,-0.042261,0.032334,-0.063795,0.108227,-0.022403,0.035903,-0.011789,0.058928},
  { -0.037383,-0.019733,-0.060969,0.025857,-0.043058,0.110127,0.004816,0.041839,0.010781,0.051958},
  { 0.005469,0.050276,-0.095411,0.013960,0.006640,0.022718,-0.021316,-0.009440,-0.021419,0.007777},
  { 0.014031,0.032545,-0.026169,-0.005771,0.010537,-0.043930,-0.020434,-0.016822,0.013151,0.019722},
  { 0.016026,0.014115,-0.037621,-0.044240,-0.038976,0.057379,-0.018666,0.030331,-0.022896,0.038074},
  { 0.003991,0.024394,-0.049571,-0.023796,0.031122,-0.038777,0.019871,-0.004702,0.006599,0.034960},
  { 0.010823,0.047527,-0.040408,0.028543,0.020583,0.015700,-0.004011,0.012529,-0.002991,0.033554},
  { 0.016796,-0.019923,-0.050279,0.009994,-0.090985,0.055754,0.014775,0.028969,-0.004659,0.059816},
  { 0.011325,-0.000615,0.002486,-0.020069,0.095546,-0.078752,-0.002976,-0.005226,-0.025731,-0.045946},
  { -0.000230,-0.026736,-0.006272,0.063695,-0.023763,0.042616,-0.015139,0.037635,0.015410,-0.022677},
  { 0.009655,-0.050965,0.005357,0.020443,-0.047202,0.041670,0.007701,0.042998,-0.002499,-0.001047},
  { 0.015478,0.011863,-0.012214,0.002070,0.000852,0.009087,-0.000057,-0.000992,-0.016549,0.073516},
  { 0.006367,-0.050713,-0.033277,0.051189,-0.119833,0.099428,0.009432,0.036446,0.021266,0.020253},
  { -0.004132,-0.043173,-0.021871,0.049065,-0.065827,0.080029,-0.002925,0.009002,-0.017574,0.020988},
  { -0.000002,-0.000611,-0.049959,0.019189,-0.026424,0.030506,-0.014869,-0.042831,0.002130,0.042994},
  { -0.022058,0.027874,-0.056646,0.067603,-0.051866,0.065513,-0.001260,-0.016823,0.021210,0.034476},
  { -0.020482,-0.027181,-0.052906,0.020209,-0.048777,0.061957,0.020711,-0.027178,0.000500,0.048578},
  { 0.020589,0.012317,-0.008550,-0.000128,0.030880,-0.023887,0.006819,0.010196,-0.025740,0.047577},
  { 0.006679,0.009402,-0.042966,0.016676,0.007966,0.043417,-0.019874,-0.007613,-0.004502,0.033388},
  { 0.012332,-0.004094,-0.030090,0.036020,-0.052756,0.053611,-0.008054,0.001641,-0.006206,0.067111},
  { 0.016368,0.026621,-0.016033,0.005766,0.028758,-0.016791,-0.006273,0.014122,-0.020244,0.028230},
  { 0.007530,0.030337,0.000163,-0.004509,0.099329,-0.059259,0.003659,-0.001825,-0.004862,0.001218},
  { -0.015153,-0.062270,0.060467,-0.011670,0.005612,0.034699,-0.026018,-0.001434,0.021568,0.029777},
  { -0.024526,-0.030649,-0.042196,-0.030039,-0.073161,0.067409,-0.022369,0.030880,0.022355,0.070114},
  { -0.010099,0.022221,-0.035635,0.020026,0.001246,0.063121,-0.003828,0.021750,0.010509,0.005570},
  { 0.004342,-0.034098,0.006581,-0.030791,0.013059,-0.006381,-0.005563,0.007013,0.017134,0.012860},
  { -0.006110,-0.053253,0.006547,-0.046171,-0.021012,0.024028,0.012407,0.036145,-0.007028,0.000386},
  { -0.013554,-0.016532,-0.031581,-0.039396,-0.084118,0.048823,-0.000734,0.029135,0.005825,-0.036103},
  { -0.007197,-0.022540,-0.070556,0.033939,-0.079864,0.056783,0.004911,-0.034796,0.014400,-0.000636},
  { 0.003071,-0.016458,-0.099497,0.030216,-0.113841,0.081646,0.021577,0.009199,0.021893,0.049556},
  { 0.045134,0.037999,0.016315,0.015576,0.008994,-0.069178,-0.017532,-0.009523,-0.000523,0.002889},
  { 0.002997,0.019748,-0.047317,0.026835,0.004817,-0.000771,0.001467,-0.025810,-0.005700,0.002925},
  { 0.035664,-0.004055,-0.009930,-0.005808,-0.022565,0.006762,-0.000353,-0.024999,-0.015279,-0.013032},
  { -0.002743,-0.020746,-0.003752,-0.033646,-0.068707,0.035414,-0.014416,-0.004645,-0.021779,-0.009656},
  { -0.002293,-0.038299,0.053140,-0.009859,0.007220,-0.019203,0.009574,0.005513,0.014131,-0.058554},
  { 0.010366,0.034869,0.046105,0.014931,0.096337,-0.079566,-0.022689,-0.020768,-0.024986,-0.072019},
  { 0.020127,-0.038926,0.015579,0.004374,-0.006415,0.053754,0.013145,0.005286,-0.014695,-0.033713},
  { -0.025535,-0.037223,0.009841,-0.028512,-0.057082,0.049794,0.008554,0.016805,-0.023650,0.059409},
  { 0.003861,0.017954,-0.035739,-0.058339,0.003061,0.025914,0.012195,0.019507,-0.015161,0.028379},
  { -0.002258,-0.042547,0.014159,0.032082,-0.024571,0.036854,-0.025619,0.017845,0.013641,0.022256},
  { 0.011023,-0.037281,-0.023265,0.030934,-0.008168,0.008379,0.017275,0.007650,0.007842,0.038323},
  { -0.012250,-0.039164,0.023957,0.020787,0.000619,0.008486,0.011185,-0.002181,-0.013383,0.009444},
  { 0.014543,0.026043,-0.006374,-0.030064,0.037913,-0.066090,-0.015285,-0.013974,-0.002626,-0.024659},
  { 0.006103,-0.037767,-0.055323,0.017183,-0.102665,0.101225,-0.007023,0.011239,0.015471,0.029805},
  { 0.026541,0.027361,0.083272,-0.001114,0.035323,-0.059706,-0.011986,-0.046776,0.023746,-0.014259},
  { -0.007317,-0.011956,-0.023368,0.018997,-0.026748,-0.002492,0.008255,-0.000382,-0.004826,0.025191},
  { -0.014398,-0.010480,-0.027752,0.052514,-0.070149,0.066167,0.000609,-0.017280,-0.023210,0.043305},
  { -0.011770,-0.006355,-0.022631,0.014478,0.023748,0.002534,0.009087,-0.040478,0.018383,-0.017762},
  { 0.019882,0.036933,0.017038,-0.052848,-0.049964,0.012276,0.003674,-0.015843,0.017581,0.024919},
  { 0.029839,-0.021811,0.018602,0.008797,-0.010298,0.034065,0.000880,-0.019353,0.003024,-0.003745},
  { -0.034214,-0.032857,-0.077802,0.091831,-0.073449,0.109349,-0.003949,0.013257,-0.007178,-0.030494},
  { 0.000764,-0.061499,0.044756,-0.005835,0.014212,0.003191,0.019516,-0.001361,0.013189,-0.038778},
  { -0.021183,-0.069091,-0.021346,-0.048557,0.005210,0.041569,0.009032,0.055412,0.022753,0.038638},
  { -0.004445,-0.046947,-0.061913,-0.061934,0.010301,0.033749,-0.004714,0.014958,0.016542,-0.010154},
  { 0.005837,-0.021728,-0.053590,0.022043,-0.053370,0.081300,0.017128,-0.020085,0.014505,0.028810},
  { 0.019417,-0.041399,-0.017928,0.045746,-0.017955,0.029333,-0.006668,-0.003927,-0.023598,-0.004758},
  { 0.008850,-0.027746,-0.015830,0.039754,-0.009379,-0.029608,-0.012071,-0.025389,0.015931,-0.030629},
  { -0.026716,0.024598,-0.019907,0.028666,-0.092921,0.000753,0.000241,-0.001980,0.020590,-0.007806},
  { -0.013473,0.006846,-0.003898,-0.001064,-0.033947,0.001074,-0.017743,0.006597,0.023386,0.051495},
  { 0.022855,0.019915,-0.025926,-0.047204,-0.014488,0.021393,-0.008350,0.006583,0.009422,0.056345},
  { 0.011970,-0.001175,-0.008392,-0.037334,-0.063648,0.014378,-0.017493,-0.022981,0.012613,0.057721},
  { 0.000594,-0.019569,0.033369,0.004396,-0.032030,-0.004016,-0.025346,0.025272,0.005482,0.013975},
  { -0.015597,0.008969,-0.038950,-0.024835,-0.029007,-0.004383,0.005040,0.039435,-0.010289,0.006960},
  { 0.006233,-0.005405,-0.005421,-0.038564,0.021396,0.001805,-0.016849,0.006252,-0.003751,-0.025292},
  { -0.035016,-0.021354,-0.117752,0.031608,-0.026383,0.053537,-0.016971,-0.008524,0.000195,0.016813},
  { -0.013775,-0.046752,-0.050092,0.038030,-0.059838,0.090326,0.009407,0.012834,-0.017379,-0.018680},
  { -0.015699,-0.047370,-0.036958,0.016621,0.032159,0.051965,-0.018034,0.027357,-0.023843,-0.024750},
  { 0.022361,-0.044603,-0.024251,-0.022725,0.021139,0.010527,0.006394,0.012801,0.018723,0.002410},
  { 0.016129,-0.047954,-0.058855,-0.040406,-0.018008,0.032796,-0.019086,0.022078,0.009726,0.007652},
  { 0.006029,-0.016928,-0.025641,-0.009877,-0.052621,0.036078,-0.008899,-0.003941,-0.002444,0.006438},
  { 0.022291,0.016418,0.006125,0.009874,0.050283,-0.075201,0.017483,-0.022059,0.011532,-0.032762},
  { -0.013971,0.005015,0.032913,0.042265,-0.025426,-0.042203,-0.018292,0.000555,0.017872,-0.027366},
  { 0.016157,-0.035741,0.091625,-0.032081,0.011118,-0.068345,0.012121,-0.001421,-0.017087,0.030060},
  { -0.009555,0.007552,0.036571,-0.046431,0.018947,-0.007012,-0.019208,-0.010000,-0.004236,0.007141},
  { 0.016543,0.015385,-0.051623,0.005160,-0.040020,0.062887,0.009225,0.011860,-0.019564,0.028866},
  { 0.041793,0.026002,0.045340,-0.034873,0.045557,-0.051476,-0.020453,-0.010924,-0.005702,-0.031971},
  { 0.040752,0.037232,0.034535,0.045636,0.032981,-0.065870,-0.014946,-0.026167,-0.004952,-0.004509},
  { 0.025188,0.006176,0.015816,-0.045121,0.064087,-0.067289,0.009043,0.012111,-0.004272,-0.061505},
  { -0.025535,-0.047553,-0.026344,0.049021,-0.068524,0.143658,-0.015456,0.013476,-0.019899,0.002977},
  { -0.015419,-0.003612,-0.060639,0.015533,0.015663,0.073044,-0.022337,-0.003127,0.008947,-0.042966},
  { -0.016346,-0.017621,-0.070822,0.023615,-0.008544,0.076826,0.009454,-0.006972,0.018464,0.041206},
  { -0.016579,-0.061123,0.010042,0.001610,0.007797,0.046529,-0.008938,-0.006312,-0.023122,0.024960},
  { -0.006228,-0.030396,-0.016059,-0.013695,-0.030112,0.034794,-0.006604,-0.018291,0.018775,0.013773},
  { -0.035138,-0.039952,-0.040537,-0.041422,-0.042582,0.059447,-0.021925,0.001556,-0.013294,0.070217},
  { -0.009682,-0.015735,0.000916,-0.045908,-0.050100,0.073174,-0.002025,0.009381,-0.007720,0.005046},
  { 0.001322,-0.018158,-0.014090,-0.008373,0.016991,0.028059,0.014643,-0.020393,0.022386,-0.010354},
  { 0.018501,-0.033312,0.021938,-0.043546,0.041852,-0.030220,0.008344,-0.031383,0.015910,0.039452},
  { -0.009961,-0.031301,0.055497,-0.038568,0.033941,-0.040171,0.020367,-0.003728,-0.005437,0.024378},
  { 0.012548,-0.020986,0.057515,-0.010581,0.040941,-0.031406,-0.013262,-0.007238,0.014594,0.005158},
  { -0.018882,0.007064,0.045972,-0.028660,-0.013808,-0.019152,-0.021520,-0.000953,-0.019000,-0.027307},
  { 0.025759,0.018566,-0.034051,0.021606,0.025193,-0.012158,-0.009179,-0.028535,-0.006844,-0.001823},
  { -0.014710,-0.034868,0.005229,0.019052,0.056606,-0.028977,-0.001362,-0.037863,-0.010163,0.008204},
  { -0.023353,-0.028009,-0.000244,0.042285,-0.014105,0.072719,-0.018730,0.016034,0.019535,-0.029791},
  { -0.031724,-0.050630,0.016512,0.058634,0.006962,0.059162,-0.000137,-0.020919,-0.000551,-0.036968},
  { 0.019153,0.036442,-0.035601,0.025436,0.069895,0.010697,0.000592,0.001742,0.024335,-0.039674},
  { -0.015750,-0.036381,-0.006221,-0.003258,0.004905,0.041939,-0.026353,-0.035527,-0.009866,-0.002789},
  { 0.000347,-0.029218,0.000969,0.007581,-0.083236,0.015916,0.005808,-0.030504,-0.011817,0.049103},
  { -0.001485,-0.029986,-0.009186,0.015733,-0.043557,0.011160,0.020811,-0.025178,-0.013231,0.059925},
  { -0.004218,-0.002083,-0.026518,-0.029977,-0.063226,0.011759,0.020303,0.003765,-0.001755,0.059283},
  { 0.014776,-0.000503,-0.027201,0.016969,-0.017560,0.071143,-0.007125,0.013708,-0.015367,0.053087},
  { 0.024453,-0.020232,0.031611,0.018312,0.001793,0.048804,-0.019121,-0.004416,0.004868,-0.005592},
  { 0.014671,0.005570,0.025158,0.010219,0.024916,0.019198,-0.008851,-0.019679,-0.020940,-0.016277},
  { 0.005232,-0.011098,-0.005360,-0.003670,0.047121,0.028255,0.015900,0.003230,-0.015024,0.008594},
  { -0.020504,-0.014732,0.070469,-0.010764,0.061406,-0.032860,0.005044,0.023920,-0.004789,-0.046307},
  { 0.034423,0.008285,0.072106,-0.056505,0.065517,-0.064984,-0.024359,0.028653,0.010567,0.011515},
  { 0.001714,-0.027139,0.036685,-0.019131,0.033789,-0.025313,-0.011537,0.010293,0.002549,0.061588},
  { -0.001133,0.007125,-0.077535,-0.006208,0.027005,-0.009673,0.020639,-0.006540,-0.021329,-0.003459},
  { -0.020993,-0.000984,-0.031127,-0.002082,-0.007160,0.022447,-0.023018,-0.016903,0.003938,-0.003817},
  { 0.002267,-0.003307,-0.033414,0.015823,-0.027327,0.044533,0.020003,-0.016285,-0.020588,-0.011360},
  { -0.010096,0.062729,0.001159,0.032287,-0.005916,0.043426,-0.022807,-0.014184,-0.021407,0.006073},
  { 0.009401,0.008927,0.014078,-0.008587,-0.004326,-0.001176,-0.004526,-0.019840,-0.000585,0.024895},
  { -0.000330,0.053273,0.004810,-0.038569,-0.001022,-0.017808,-0.002353,-0.019813,-0.018374,0.010445},
  { 0.030288,0.021109,0.018342,0.006468,-0.016606,-0.004636,0.014296,0.017552,-0.020299,-0.037074},
  { 0.002450,0.022210,0.022801,0.018570,-0.039912,-0.079448,-0.026803,-0.019376,-0.001732,-0.067549},
  { 0.028543,0.040515,0.019142,-0.018784,0.054728,0.004816,0.002996,0.017587,-0.004203,-0.012191},
  { 0.045446,0.005013,0.037961,0.028338,0.119902,-0.055569,-0.007685,-0.022788,-0.017795,-0.004739},
  { 0.036786,0.068259,0.026524,-0.060312,0.116870,-0.080659,-0.000717,-0.032083,0.021607,-0.036735},
  { 0.007757,-0.023715,0.074021,-0.011988,0.028902,-0.011921,0.015396,-0.027404,0.000652,-0.061719},
  { -0.008916,0.019166,0.089093,0.003243,0.062417,-0.068634,0.020125,-0.016089,-0.008440,-0.046741},
  { 0.016630,-0.049716,0.075528,-0.009188,0.007205,-0.053145,-0.002044,-0.013316,0.006068,-0.015495},
  { 0.027804,-0.040468,0.077897,0.003528,-0.040856,-0.072779,-0.025417,-0.012617,0.003443,-0.022143},
  { 0.047715,0.034282,0.081296,-0.043755,0.056149,-0.103399,-0.004154,-0.043650,0.011414,-0.060227},
  { -0.016778,-0.001826,-0.071630,-0.015301,-0.096479,0.075257,-0.015984,0.029310,-0.024250,0.040647},
  { -0.033985,0.000757,-0.033111,-0.001405,-0.056027,0.018765,-0.017859,0.010472,-0.023124,0.010296},
  { -0.018386,-0.019125,0.020815,0.064600,-0.075754,0.018118,0.014004,-0.024594,-0.023511,0.011564},
  { 0.019764,0.015968,-0.040537,-0.009133,0.054712,0.005070,-0.005602,0.018376,-0.012873,0.016683},
  { -0.024806,-0.011181,-0.034976,0.008378,-0.027919,0.014071,0.020970,0.017873,0.009366,-0.018867},
  { 0.019121,0.006861,0.050045,-0.015842,0.006866,-0.052374,-0.002527,0.008334,-0.027591,-0.008982},
  { 0.024650,-0.024817,0.035522,-0.035709,0.055187,0.020579,0.002821,0.031784,-0.005552,-0.015229},
  { 0.010395,-0.041896,-0.015738,0.030582,0.057756,0.039424,0.015679,-0.015034,0.000722,0.003139},
  { 0.039246,0.017058,0.047136,-0.021511,0.174986,-0.078598,-0.000234,-0.009773,-0.017523,-0.052921},
  { 0.054486,0.054372,0.008582,-0.035141,0.182865,-0.093279,0.019986,0.000240,0.006499,-0.010937},
  { 0.018731,0.024858,-0.015441,0.035276,0.074232,-0.088049,-0.015597,-0.005284,0.008738,-0.008064},
  { 0.025913,0.089754,0.004838,-0.016014,0.090196,-0.092321,-0.019076,-0.010256,0.001909,-0.069086},
  { -0.003679,0.029386,0.015199,-0.031302,-0.011845,-0.047868,-0.022536,0.011946,0.008244,-0.022190},
  { 0.014852,0.043784,0.058122,0.002394,-0.055731,-0.074548,-0.017301,-0.009319,-0.012132,-0.028548},
  { 0.040476,0.052146,0.058646,0.002718,-0.028165,-0.075265,-0.004995,-0.022086,-0.012373,-0.062029},
  { 0.004206,-0.007325,-0.052434,-0.080062,-0.021356,-0.017550,-0.011534,-0.013021,0.011988,0.000954},
  { 0.001110,-0.008719,-0.051469,0.051489,-0.121380,0.030600,0.009659,-0.008694,0.008137,-0.018675},
  { -0.041892,-0.067285,-0.029622,0.047644,-0.088681,0.109080,0.012923,0.014689,-0.010159,0.087820},
  { -0.021216,-0.042451,-0.013003,-0.015672,-0.057493,0.103237,0.005703,-0.028644,-0.025320,0.033867},
  { 0.019779,0.013781,-0.012394,-0.035131,0.084662,-0.037460,-0.018477,-0.030241,-0.004887,0.011457},
  { 0.022769,0.013406,0.101037,-0.083196,0.030672,-0.064041,-0.003261,0.012536,0.020104,-0.004868},
  { 0.040204,-0.003777,0.022854,-0.074117,0.045909,0.014141,-0.017827,0.012119,-0.001474,0.077133},
  { 0.011375,-0.006326,0.007059,-0.084840,0.063931,0.017333,-0.019151,0.027506,-0.024968,0.026601},
  { 0.037743,-0.032974,0.061905,-0.063231,0.119510,-0.074220,0.001266,0.011637,-0.000045,-0.028543},
  { 0.013830,-0.014069,-0.004562,0.016647,0.032862,0.021259,-0.001625,0.001674,-0.004054,0.009550},
  { 0.043141,0.033014,0.016505,-0.010729,0.047241,-0.076234,0.008083,-0.005607,-0.011845,-0.027085},
  { 0.017491,0.096917,0.009537,-0.018110,0.064737,-0.082001,-0.014022,0.016062,0.015705,-0.040034},
  { 0.028624,0.089815,0.033453,-0.030429,0.062359,-0.037137,-0.016267,-0.020705,0.018918,-0.026065},
  { 0.045996,0.079898,0.043308,-0.011739,0.013932,-0.013718,-0.022869,0.029808,0.003729,-0.032492},
  { 0.009264,0.017330,0.050855,-0.041608,0.063997,-0.011871,0.019996,0.016709,-0.027651,-0.003492},
  { 0.043395,-0.004120,0.008514,-0.021618,0.023408,-0.014764,0.019193,-0.024091,0.016414,0.009334},
  { 0.024841,0.029733,0.065772,-0.009691,0.035463,-0.036813,-0.014913,0.018524,-0.010263,0.007278},
  { 0.026192,-0.038140,0.041037,-0.012463,-0.007889,0.012218,-0.005911,0.007776,-0.005268,-0.000630},
  { 0.021357,0.008965,0.030948,-0.021246,0.035161,0.029470,-0.018328,-0.002270,-0.002960,0.024079},
  { -0.007764,-0.031172,-0.031068,-0.099570,0.027897,0.048285,-0.016190,0.033226,0.010595,0.047674},
  { 0.006230,-0.022862,-0.070067,-0.034814,-0.044924,0.084203,-0.010243,-0.008461,-0.025271,0.070499},
  { -0.028377,-0.025416,-0.049726,0.034655,-0.142999,0.050862,0.017283,0.001032,0.009222,0.001555},
  { 0.003134,-0.033727,0.012863,0.001882,-0.041112,-0.002865,0.013560,0.012026,-0.012704,-0.008782},
  { -0.025267,-0.055993,-0.042454,0.078816,-0.075850,0.055868,-0.005497,-0.012778,0.006564,0.049758},
  { -0.051459,-0.083918,-0.076626,0.120269,-0.106059,0.121834,-0.009040,0.012202,-0.022681,0.118797},
  { 0.014157,0.011869,-0.079538,0.048289,0.040094,-0.077193,-0.025069,-0.053880,-0.012927,-0.013522},
  { 0.011842,0.026915,-0.041094,-0.014752,-0.040508,-0.071830,0.012717,0.017898,-0.027062,0.016942},
  { -0.020566,0.029147,-0.006043,0.015334,-0.066091,-0.011086,0.001985,-0.036849,0.002028,-0.000390},
  { -0.004895,-0.038925,-0.040793,-0.001342,-0.069532,0.000213,-0.022360,-0.023344,0.003724,0.068617},
  { 0.025041,-0.001064,0.061322,-0.084553,0.045100,-0.091390,-0.015753,-0.055285,0.006208,-0.021531},
  { 0.010006,0.021912,0.070788,-0.007846,0.085966,-0.085819,0.010588,-0.026768,-0.000836,-0.105016},
  { 0.014817,0.005244,0.049587,0.013490,-0.022141,0.009864,0.011665,-0.031801,-0.019746,-0.036016},
  { 0.028975,0.017062,-0.020451,0.006699,-0.032542,-0.024348,-0.019538,-0.032389,-0.007705,-0.013947},
  { 0.035088,0.022563,-0.016060,-0.098052,0.043046,-0.031786,0.017480,-0.003514,-0.023238,0.022431},
  { -0.031344,-0.019308,-0.089805,0.101048,-0.166233,0.070814,-0.013166,0.002923,0.016384,0.111983},
  { -0.008602,-0.038967,0.021992,0.076565,-0.103748,0.020495,-0.027425,-0.023276,0.014913,0.064841},
  { -0.001979,-0.033741,-0.033417,0.066278,0.017362,0.023559,0.016744,0.032234,0.007094,0.014659},
  { 0.001831,-0.077556,-0.022572,0.099544,0.028815,-0.006577,0.005849,-0.007728,-0.013721,0.002232},
  { 0.014472,-0.026981,-0.015695,0.065031,0.003564,0.019179,-0.008864,-0.015969,-0.012813,-0.005254},
  { 0.010464,-0.029974,0.009955,0.051378,0.031170,-0.079380,-0.002711,-0.034582,-0.025694,-0.129918},
  { 0.044017,-0.002008,0.105641,0.003616,0.021113,-0.044304,-0.014743,0.014554,0.016077,-0.161891},
  { 0.027347,0.040846,0.082471,-0.038896,0.106432,-0.036642,-0.005882,-0.028661,-0.015358,-0.032183},
  { 0.030170,0.005184,0.083914,-0.088699,0.135495,-0.125590,-0.009451,-0.016717,0.008996,-0.024983},
  { 0.047771,0.037546,0.141828,-0.116713,0.190618,-0.110635,-0.006081,-0.024907,0.005582,0.024571},
  { 0.021766,0.024146,0.111333,-0.046530,0.082923,-0.067455,0.016087,-0.042467,-0.020197,-0.043652},
  { 0.034162,0.044913,0.047860,-0.028017,0.079200,-0.065434,0.012594,-0.016357,-0.029473,0.011382},
  { 0.035183,0.046728,-0.001225,-0.020688,-0.007586,0.016011,-0.018087,-0.023082,-0.004996,0.037994},
  { -0.015689,-0.055356,-0.048200,0.009820,-0.059227,0.036579,0.015296,0.015750,0.002450,0.037590},
  { 0.015248,-0.046746,0.044687,0.033475,-0.033484,-0.013217,-0.011613,-0.004082,0.005454,-0.007649},
  { 0.023835,-0.006998,0.016158,-0.039950,0.030069,0.060340,0.012098,0.014951,-0.011501,0.055999},
  { -0.006845,-0.021370,-0.105393,0.089431,-0.006022,0.116781,-0.009292,0.024802,0.015699,-0.006163},
  { -0.012250,-0.013692,0.009488,0.049131,-0.017666,-0.010161,-0.025934,-0.017396,0.004058,-0.073479},
  { -0.010849,-0.054998,0.034320,0.010883,-0.025406,-0.015183,-0.011884,-0.028656,-0.016278,-0.080752},
  { -0.004897,-0.042665,0.024757,0.001258,-0.048111,0.020696,-0.020457,0.028403,-0.005286,-0.076947},
  { 0.011742,-0.055549,0.087127,-0.034395,0.037969,0.002860,-0.005669,0.026566,0.004898,-0.065033},
  { 0.002234,-0.019964,0.030694,-0.043232,0.090878,-0.050408,-0.010336,0.006809,-0.012204,-0.019723},
  { 0.030175,0.018595,0.079043,-0.072448,0.093770,-0.126675,-0.024262,0.003557,0.009003,0.002175},
  { 0.019837,0.003047,0.091036,-0.071636,0.079113,-0.088347,0.011516,-0.001987,0.007635,-0.024094},
  { 0.029605,0.024964,0.046372,-0.045239,0.089998,-0.112815,-0.015703,-0.032790,0.005349,-0.074947},
  { 0.004466,0.032608,0.043258,0.008553,0.031902,-0.082406,0.001527,-0.013671,-0.021690,-0.020274},
  { 0.057035,0.042527,0.036266,-0.029193,0.060725,-0.148781,-0.025178,-0.021350,-0.009829,-0.057264},
  { 0.010492,-0.055171,0.061689,-0.004960,-0.046762,0.065793,0.002028,-0.022307,0.001542,0.009977},
  { 0.003331,-0.009975,0.030413,0.046585,-0.051707,0.080877,-0.013661,0.018327,-0.018453,0.033657},
  { -0.014898,-0.003195,-0.043538,0.028614,-0.016818,0.150053,-0.007607,0.026810,0.023160,0.043317},
  { 0.019744,-0.042203,-0.071048,0.066877,-0.108294,0.042265,-0.010367,0.001036,-0.013492,-0.005470},
  { 0.002870,0.016581,0.059362,0.018290,-0.031430,-0.086398,0.014706,-0.020707,0.018212,-0.058851},
  { -0.002320,-0.041758,-0.031215,0.034005,-0.068227,0.004509,0.008427,-0.041733,-0.003417,-0.055563},
  { -0.025166,-0.052412,-0.060477,0.057935,-0.129487,0.043914,-0.023562,0.027015,0.002868,-0.055685},
  { 0.015186,0.016167,-0.045531,-0.007089,-0.036857,0.015026,0.020447,0.034117,0.016813,-0.004969},
  { 0.016440,0.009380,0.032224,-0.054254,-0.023028,-0.012496,-0.020765,-0.025880,0.020268,0.049629},
  { 0.004870,-0.083882,0.027961,-0.081085,0.013587,-0.015585,-0.015852,-0.015636,-0.020982,0.053841},
  { 0.021299,0.061775,0.057641,-0.132372,0.112324,-0.155031,0.004661,0.012745,0.009532,0.034875},
  { 0.032915,0.086051,0.078696,-0.057050,0.070378,-0.125707,0.000169,0.006707,-0.020860,-0.010230},
  { 0.032670,0.007084,0.037893,-0.048798,0.041185,-0.066927,0.020130,-0.018215,-0.012129,-0.027458},
  { 0.011057,-0.033137,0.035725,-0.083233,0.007993,-0.039838,-0.015125,0.028593,0.023036,0.025070},
  { -0.004990,0.002741,-0.009055,0.019510,0.043338,0.059578,0.005107,-0.039044,-0.017943,-0.036896},
  { 0.011691,0.018807,0.008092,0.064837,0.120115,-0.035598,-0.017239,-0.006939,0.009010,0.002870},
  { 0.035846,-0.003106,-0.040892,-0.003623,0.085659,-0.071539,-0.005500,-0.002180,-0.004535,-0.015490},
  { -0.011069,0.011705,-0.022901,0.003215,0.015812,-0.034545,0.016319,0.000777,0.005340,-0.033445},
  { -0.011899,0.008462,0.055876,0.025412,-0.024577,-0.009906,0.005028,0.009286,0.004620,-0.058249},
  { 0.008783,-0.049245,0.019958,-0.002468,-0.101528,0.006927,-0.015056,0.008195,-0.005902,-0.077890},
  { 0.007043,-0.019619,0.053016,0.027554,-0.050433,0.020141,0.001528,-0.002856,-0.024520,-0.087508},
  { 0.008446,-0.002055,0.049047,-0.034077,-0.066350,0.037232,-0.001638,-0.006378,-0.025729,-0.078782},
  { -0.026597,-0.008476,0.003654,-0.037058,-0.027388,0.047948,0.012719,0.012445,0.012257,0.011478},
  { 0.030416,0.070163,0.024790,-0.039741,-0.013374,-0.046487,0.011507,-0.043172,-0.003619,-0.036646},
  { 0.033331,0.089791,0.027244,-0.032116,-0.028811,-0.024779,-0.012849,-0.024308,0.014261,-0.014437},
  { 0.011289,0.003670,0.054437,-0.034186,0.054314,-0.046873,0.018448,-0.022147,0.022423,-0.009798},
  { 0.024576,-0.007060,0.060882,-0.006062,0.040107,-0.059654,0.004140,-0.005560,0.006573,-0.067486},
  { -0.020888,-0.057386,-0.017679,0.007397,-0.062530,0.070360,0.022201,0.039428,0.012916,0.061669},
  { -0.015771,0.063310,-0.112686,0.070136,0.054987,0.088351,0.015803,0.004755,0.015296,0.037169},
  { -0.002993,0.027736,-0.050743,0.016419,-0.001672,0.024647,0.012693,0.021308,0.005456,0.066534},
  { -0.018201,-0.020488,-0.006771,-0.069278,-0.001296,0.037012,-0.017775,0.062853,0.008968,0.123646},
  { -0.000215,-0.002249,0.016576,0.012054,0.032556,0.010952,-0.025188,0.004129,-0.011467,0.032918},
  { -0.006037,-0.040617,-0.027187,0.044367,0.027137,0.066465,-0.001501,-0.010808,0.017384,0.010478},
  { 0.000012,-0.029215,-0.073179,0.009648,-0.042711,0.037525,-0.023368,0.020777,0.003730,-0.044844},
  { 0.001019,0.065357,0.033960,0.001776,-0.022567,-0.033974,-0.010820,-0.014518,-0.015587,-0.037119},
  { 0.011152,0.014340,0.033740,0.021276,0.000990,0.018781,-0.007043,-0.008158,-0.024406,-0.052402},
  { 0.009738,-0.030649,0.003689,0.013250,-0.041502,0.027956,0.000853,0.036749,0.013588,-0.028121},
  { 0.012264,0.035694,-0.088070,0.029471,0.025456,0.015530,-0.025719,0.014387,0.008128,-0.027162},
  { -0.013653,-0.012476,-0.016914,0.006671,-0.069297,0.065468,-0.000525,-0.001682,0.015113,-0.029567},
  { 0.028380,-0.018044,0.060505,0.005258,0.062453,-0.072311,-0.013435,0.005373,0.012378,-0.049159},
  { -0.012044,-0.018631,-0.052681,0.068055,-0.038751,0.037701,0.018514,0.010832,0.012709,-0.012688},
  { 0.012185,-0.044000,-0.044990,0.059996,-0.065062,0.043606,-0.002557,0.020773,-0.014001,0.017739},
  { 0.039703,-0.001320,0.045037,-0.010377,0.026445,-0.041853,-0.014707,-0.010123,-0.028291,0.021623},
  { -0.001862,-0.000634,0.036350,-0.058297,0.010717,0.002759,-0.007632,0.005230,0.013572,0.096823},
  { -0.000058,-0.005675,0.022070,-0.073692,0.007506,0.023339,0.000239,0.006011,-0.028186,0.083797},
  { 0.044135,0.028824,-0.012607,0.006081,0.052520,-0.085051,-0.027072,-0.014063,-0.004951,-0.029344},
  { 0.004869,-0.029532,0.000976,0.001739,-0.056144,-0.053511,-0.010767,-0.005365,-0.012511,0.017680},
  { 0.007651,-0.004962,0.047302,-0.018392,0.027966,-0.092965,0.001204,-0.006048,-0.002826,-0.064297},
  { 0.011147,-0.054109,0.067326,0.020274,-0.015713,-0.023856,-0.007056,-0.017610,-0.011291,-0.057813},
  { -0.006640,-0.048785,0.066718,0.036348,0.026847,0.028450,0.019144,-0.005003,0.003546,-0.025091},
  { 0.016879,0.014728,-0.076308,0.040065,0.020154,0.055796,0.001266,0.031684,0.009286,0.044093},
  { -0.019932,0.047477,-0.029974,-0.015153,0.047174,0.010863,0.007232,-0.003029,0.019820,-0.004291},
  { 0.025147,0.001023,0.028845,0.020377,-0.029602,0.049582,-0.017164,0.023881,0.001007,-0.004539},
  { 0.009092,0.023999,-0.032297,0.010089,0.054048,-0.024776,0.015576,0.011259,-0.021293,0.016713},
  { -0.011850,0.041750,-0.042394,0.084266,0.032717,0.014950,-0.006207,-0.037639,-0.009173,0.023876},
  { 0.019866,0.032456,-0.026075,0.061517,0.034166,-0.013393,-0.022343,-0.016561,-0.012098,0.011149},
  { 0.039697,0.001573,0.079155,0.008875,0.123351,-0.102177,0.014990,-0.036854,-0.007759,-0.030403},
  { 0.023492,-0.046650,0.045860,-0.014119,0.048148,-0.042908,-0.009580,0.006369,0.007083,-0.030242},
  { 0.016749,0.003371,0.026692,-0.016935,-0.037655,-0.008160,-0.015325,-0.030862,0.005539,-0.032833},
  { 0.033569,-0.009088,0.038953,0.024260,-0.077449,-0.067954,-0.024715,-0.009406,-0.002841,-0.029187},
  { -0.003708,-0.019574,0.027271,0.035740,-0.028962,-0.030897,-0.010432,-0.010582,0.010460,-0.021802},
  { -0.024189,-0.058321,-0.017380,0.020007,-0.015326,0.024663,0.008800,0.013997,-0.026168,-0.016199},
  { 0.010741,-0.071111,-0.000713,0.058034,-0.011075,0.108619,0.010303,0.027823,0.014516,-0.000045},
  { -0.028474,-0.079488,0.001855,0.038411,-0.061987,0.149792,0.018204,0.038909,0.019347,0.024840},
  { -0.010256,0.026929,-0.051005,0.044691,0.015435,0.065267,0.009308,-0.014591,0.006778,0.038389},
  { 0.032973,0.042668,0.020576,-0.002299,0.026392,-0.015384,0.014554,-0.016993,-0.026198,-0.010917},
  { 0.047646,0.033812,0.016968,-0.008137,0.127741,-0.078322,-0.000287,-0.050971,-0.028133,-0.022337},
  { 0.026130,0.011412,-0.013338,-0.031213,0.053785,-0.011853,0.006296,0.025584,-0.012919,-0.004890},
  { -0.005550,0.021753,-0.040647,0.039208,0.020540,0.042083,-0.002788,-0.001187,0.006216,0.037783},
  { 0.008077,-0.003623,0.059835,0.035893,0.042472,-0.013302,-0.021109,0.026431,0.016570,-0.016543},
  { 0.031966,-0.062438,0.051734,-0.000217,0.036538,-0.051771,0.002299,-0.001717,-0.025850,-0.041238},
  { -0.025590,-0.101712,-0.041271,0.052049,-0.091400,0.073477,-0.007806,0.001463,0.009192,0.038033},
  { -0.040475,-0.045015,-0.067591,0.043354,-0.120280,0.098973,-0.004299,-0.003631,0.013433,0.007832},
  { 0.010427,-0.058562,0.012060,0.044488,-0.148065,0.074814,-0.002534,-0.014289,0.011584,0.006230},
  { -0.001371,-0.073894,0.019287,-0.026099,0.006339,-0.002621,-0.018314,-0.009542,-0.023236,0.022819},
  { -0.005043,0.024681,-0.030880,-0.026124,0.042421,-0.022429,-0.005293,-0.006105,0.019990,0.011540},
  { -0.029578,0.007756,-0.034425,0.044325,0.021909,0.060771,-0.002692,0.002252,-0.020561,0.062846},
  { 0.043008,-0.027433,0.039549,-0.004126,0.078269,-0.044340,0.002697,-0.006910,-0.024507,0.022893},
  { 0.026372,0.044998,-0.079729,-0.027924,0.051343,-0.002640,0.010075,0.007321,0.004766,0.060304},
  { 0.023034,0.004387,-0.065777,-0.000210,-0.003210,0.002530,-0.005509,-0.006262,-0.005865,0.064057},
  { 0.027569,0.024347,-0.015157,-0.042586,0.111671,-0.094364,0.007918,-0.002894,0.005988,-0.011725},
  { -0.009654,0.011474,-0.018074,-0.009063,0.004600,-0.011736,0.009178,0.019884,-0.011407,-0.000796},
  { 0.001182,0.054668,0.022744,0.027076,0.028364,-0.029759,0.004154,0.007018,0.015276,0.005913},
  { 0.017307,-0.011633,0.061540,0.015394,0.026412,-0.089166,-0.015577,0.003015,0.004718,-0.038025},
  { -0.001531,-0.062327,0.056731,-0.065669,-0.020503,-0.035234,-0.028672,-0.024403,-0.000388,-0.017639},
  { -0.003224,-0.086507,-0.003664,0.029645,-0.094674,0.086615,-0.026583,0.000650,0.018841,0.046071},
  { -0.014360,-0.041994,0.006993,-0.016985,-0.078502,0.053919,0.015518,-0.019601,0.021421,0.014117},
  { -0.007932,-0.028750,0.031945,-0.033020,-0.082576,-0.008055,0.024035,0.000269,-0.006714,0.014258},
  { 0.011182,-0.036886,-0.001797,-0.026197,-0.050939,-0.016069,-0.011179,0.018783,0.006159,0.063179},
  { -0.003945,0.000835,-0.070354,0.045930,-0.069221,0.015488,0.004561,0.005523,-0.007164,0.068438},
  { -0.023732,0.018349,-0.076887,0.060696,-0.039699,0.064829,0.005487,0.004273,0.010075,0.065964},
  { 0.047317,-0.007024,-0.006357,0.017185,-0.005081,-0.034253,-0.020433,-0.046052,-0.014058,-0.009761},
  { -0.003055,0.020537,-0.028716,-0.050286,0.040953,-0.054532,-0.021386,-0.013001,0.018783,-0.021810},
  { -0.027827,-0.015622,-0.098153,0.058515,-0.025828,0.096907,-0.002086,-0.005138,0.018355,0.027066},
  { 0.004057,0.021640,0.016060,0.035466,0.052937,-0.016715,-0.017983,0.018659,0.002331,-0.015400},
  { 0.006341,0.026893,-0.020957,-0.000227,0.141989,-0.060585,-0.007771,-0.019178,-0.018658,-0.055020},
  { 0.006091,0.044580,0.003816,0.017674,0.053230,-0.088050,0.019449,-0.041325,-0.022190,-0.063325},
  { 0.015646,0.022909,-0.007629,-0.035910,0.049614,-0.090020,-0.009749,0.006030,-0.005486,-0.032140},
  { 0.011432,-0.020753,0.039750,0.013625,0.016776,-0.004001,-0.010250,-0.022833,0.013298,0.054599},
  { -0.014687,-0.035291,0.015521,0.042716,-0.021747,0.040176,0.001580,-0.019741,0.007645,0.071022},
  { -0.001147,-0.050134,-0.063606,0.002607,-0.110570,0.100378,0.019655,0.026543,-0.017885,0.046267},
  { 0.020602,-0.092939,-0.015179,0.015323,-0.088641,0.046411,-0.019459,0.024355,-0.021493,-0.001080},
  { -0.005347,-0.027582,0.020200,0.034574,-0.004661,-0.042978,-0.012628,0.000471,-0.012215,-0.014832},
  { -0.002760,-0.014046,-0.006278,0.031904,-0.002214,0.018428,-0.012905,0.033007,0.021184,0.004396},
  { -0.002620,-0.012982,-0.019749,0.041357,0.011889,0.000189,-0.000194,0.002811,0.022453,-0.083651},
  { 0.032244,-0.020885,-0.055195,-0.050018,0.017685,-0.026501,0.017667,-0.016095,-0.010761,-0.062036},
  { 0.016162,0.020927,-0.041556,-0.053658,0.106156,-0.022448,0.010213,0.030814,-0.028118,-0.026116},
  { 0.018800,-0.004958,-0.020723,-0.014310,0.124241,0.000607,-0.017362,0.020094,0.009264,-0.038729},
  { 0.018288,-0.019899,0.027686,-0.015520,0.044264,-0.032135,-0.021172,-0.022701,0.020455,-0.012355},
  { 0.014103,-0.012586,0.018513,-0.025122,0.012432,-0.026640,0.005543,0.021012,-0.019199,-0.020673},
  { 0.005740,-0.028713,-0.035105,-0.001702,0.017076,-0.006689,0.019795,-0.008615,-0.020840,0.053340},
  { 0.003844,0.020305,0.029121,-0.045450,0.059361,-0.042319,0.000612,-0.019899,0.017584,0.022952},
  { 0.008584,0.027781,0.028693,-0.003461,0.122719,-0.068726,-0.001976,-0.022320,-0.014106,0.019436},
  { 0.015510,-0.044280,0.005457,0.056138,-0.007891,-0.022490,0.007930,-0.027038,0.003951,0.035016},
  { -0.006232,-0.085320,-0.032391,0.005751,-0.127396,0.092019,0.019964,-0.011017,-0.014374,0.028973},
  { -0.024448,-0.077442,0.011720,0.032092,-0.110855,0.028362,0.006998,0.045672,-0.015659,0.004191},
  { 0.011297,-0.064184,0.028674,0.019232,-0.090749,-0.006139,0.016443,0.032779,-0.024133,0.009212},
  { 0.004678,-0.074477,0.057413,0.063058,0.000026,0.014775,0.019257,0.021613,0.001095,-0.053573},
  { 0.010543,-0.049094,-0.037085,0.044709,-0.066536,0.124809,-0.009483,0.004196,0.005138,0.017376},
  { 0.007044,-0.027484,-0.043725,0.000435,-0.006295,0.057208,0.019550,0.010615,-0.001811,-0.002320},
  { 0.057159,0.077667,0.036724,-0.023621,0.144157,-0.077029,0.014077,-0.019345,-0.003353,-0.052364},
  { 0.040996,-0.008090,0.055556,0.007538,0.152413,-0.071707,0.004955,-0.045912,0.022416,-0.047205},
  { 0.024645,0.011458,-0.000059,0.054356,-0.046527,0.102168,0.010200,-0.011064,-0.021167,-0.046965},
  { 0.006877,0.038031,0.021266,0.004802,-0.017930,0.045522,-0.024506,-0.003941,0.010831,-0.004428},
  { 0.017750,-0.021774,-0.010993,-0.007684,-0.030456,0.008150,0.001508,-0.020366,0.017351,0.008976},
  { 0.029713,0.019239,0.040312,-0.078603,0.086432,-0.065143,0.006107,-0.005420,-0.006539,-0.046833},
  { 0.044235,-0.007618,0.090954,-0.013893,0.040156,-0.104147,0.017647,-0.026968,0.006908,0.014514},
  { -0.014003,-0.038632,0.027713,0.050695,-0.056813,-0.026588,0.005240,0.019564,-0.022261,0.005894},
  { 0.014427,0.030648,0.028844,-0.003889,-0.129630,0.001781,-0.007814,-0.015025,0.022063,0.029519},
  { 0.012947,-0.024696,0.023767,0.006855,-0.086005,-0.013075,-0.003195,0.027686,-0.017420,0.004608},
  { 0.023235,-0.049603,0.085057,0.019040,-0.005834,-0.012574,0.014138,0.006292,-0.003410,-0.032981},
  { -0.007461,-0.049628,0.026519,0.032756,-0.034284,0.025553,-0.010400,0.012222,0.013150,0.008185},
  { -0.018206,-0.055526,0.020503,0.033025,-0.117555,0.063653,0.003821,-0.004475,-0.019642,-0.005446},
  { 0.003512,-0.023162,0.015371,0.068509,-0.107970,0.049872,0.000676,0.027957,-0.006239,-0.036642},
  { -0.000206,0.000863,-0.004669,0.012508,0.010286,0.057044,0.019838,0.033397,-0.025969,-0.025354},
  { 0.006988,-0.076570,0.055891,0.054006,0.010080,0.016978,-0.016957,-0.022663,0.020845,0.013533},
  { -0.005751,0.034189,0.093413,-0.002546,0.026175,-0.041540,-0.003788,0.002195,0.022129,0.014145},
  { -0.007537,-0.038693,0.098520,-0.062485,0.035793,-0.003892,-0.011311,0.010900,-0.013741,-0.036211},
  { 0.023627,-0.017522,0.015735,0.003764,-0.020860,0.043452,0.009689,0.004324,0.012584,-0.058630},
  { 0.017466,0.032347,-0.000094,-0.060708,0.088803,-0.075703,0.001332,0.001010,0.017324,-0.112303},
  { 0.028612,0.009803,0.091732,-0.016526,0.024016,-0.084056,0.003974,0.005687,-0.000314,-0.051744},
  { 0.031361,0.045000,0.051803,0.037260,-0.036831,-0.059490,0.010143,-0.026517,-0.016787,-0.077937},
  { -0.001103,0.040725,-0.002454,0.038882,-0.030556,-0.026471,0.012374,-0.032024,0.021781,-0.093181},
  { 0.000358,-0.027097,0.039606,0.044838,-0.077951,0.130427,-0.026209,0.012537,0.008641,0.001286},
  { 0.000399,-0.071723,0.113139,0.009829,-0.012581,0.018016,-0.001975,0.008090,-0.011516,-0.039823},
  { -0.022656,-0.070054,0.044417,0.032783,-0.121084,0.111460,0.008371,0.024553,-0.014745,0.035632},
  { -0.020437,-0.054966,0.031895,0.036970,-0.076417,0.044752,-0.018388,0.040079,0.005750,-0.034164},
  { 0.019147,-0.022040,0.046443,-0.035922,0.059931,-0.087658,-0.008255,-0.002656,-0.000602,-0.038475},
  { -0.004161,0.011079,0.012721,0.002191,-0.024444,-0.066464,0.021184,-0.005980,0.011448,-0.043392},
  { 0.005908,-0.038710,0.021813,0.050748,-0.055184,-0.018912,0.014239,-0.028511,0.008380,-0.036037},
  { 0.004574,0.024237,0.067875,-0.054008,0.043754,-0.103915,-0.014941,-0.005035,0.015912,-0.096320},
  { -0.001416,-0.007668,0.044096,-0.013160,-0.010032,-0.045385,-0.018847,0.002309,-0.000693,-0.095096},
  { 0.005739,-0.001023,0.037520,-0.000285,0.049737,-0.091609,-0.002300,0.020396,-0.002984,-0.050975},
  { 0.024940,0.018197,0.035233,-0.020985,0.087339,-0.178849,-0.025481,0.001627,-0.011011,-0.092832},
  { -0.007110,-0.011152,-0.007364,-0.005487,-0.109435,0.091990,-0.028962,0.011086,-0.003450,0.050788},
  { -0.011042,0.006200,0.022222,-0.042671,-0.018819,0.021463,0.011610,0.009988,-0.014656,-0.009122},
  { -0.006740,-0.057139,0.032822,0.021348,0.037927,0.028333,0.012353,-0.009666,0.014583,0.047294},
  { -0.018750,-0.033674,0.008068,0.017354,-0.015409,0.052450,-0.024337,-0.014301,-0.004838,0.020466},
  { -0.009497,-0.011850,0.031693,-0.021479,-0.033255,0.037801,-0.007451,0.007884,-0.007081,-0.058732},
  { 0.003676,0.034961,-0.031582,0.045998,-0.002632,-0.005312,0.011389,-0.042359,-0.028768,-0.068614},
  { 0.023611,0.041582,0.022908,-0.017602,0.028268,-0.065997,0.008167,0.000856,0.012242,-0.022912},
  { -0.013318,0.025382,-0.012976,0.002195,0.003752,0.003538,-0.008408,-0.018423,0.020104,-0.011543},
  { 0.005215,0.011002,-0.036986,-0.014377,0.046574,-0.023964,0.006636,0.004873,-0.010445,-0.011253},
  { 0.008733,-0.039187,-0.013837,0.000865,-0.043400,0.073776,-0.027191,0.011635,-0.015841,0.064743},
  { -0.020826,-0.043481,-0.032438,0.079867,-0.114437,0.113709,-0.028879,-0.003190,-0.015016,0.041137},
  { 0.009155,0.041881,-0.051662,0.041214,-0.072044,0.074652,0.011454,0.015440,-0.012298,0.027097},
  { -0.023133,-0.011670,0.004781,0.031841,-0.064265,0.063756,-0.015238,-0.002618,0.011354,0.042420},
  { 0.017532,0.020045,0.008552,0.000350,-0.038708,0.003909,0.018807,-0.028038,0.007793,0.057010},
  { 0.028231,-0.010261,0.052224,-0.012022,-0.028323,0.030417,-0.014393,-0.028310,0.016597,0.011955},
  { 0.033936,0.022189,0.031780,-0.037240,0.023071,-0.063186,-0.023159,0.005493,-0.005426,-0.016667},
  { 0.035804,-0.023810,0.058758,-0.040537,0.025312,-0.042455,0.003004,0.004185,-0.015317,-0.032219},
  { 0.004899,0.010334,0.092634,0.008854,0.053187,-0.103129,-0.008424,-0.033332,0.018879,-0.029165},
  { -0.007705,-0.003169,0.032300,-0.006837,0.031542,0.015565,0.003818,0.025828,0.019449,0.045337},
  { 0.006470,0.047982,0.018694,-0.010077,0.020970,-0.021153,-0.019510,0.029536,-0.003575,-0.054212},
  { 0.001853,-0.001564,0.072274,0.004233,-0.052117,0.004791,-0.005376,-0.002948,-0.023350,-0.032785},
  { -0.020574,-0.047246,-0.000896,0.020483,-0.014321,-0.008090,0.010850,0.008861,0.006096,-0.011387},
  { -0.001430,-0.051385,-0.050389,0.022886,-0.108620,0.136996,-0.022114,0.019370,0.010572,0.004428},
  { -0.035595,-0.016034,-0.080849,0.072259,-0.077028,0.100491,-0.010623,0.013047,-0.005457,0.030551},
  { -0.021400,-0.085237,-0.004746,0.069528,-0.066953,0.107022,-0.019695,0.037408,-0.002745,0.032622},
  { -0.022722,0.001528,-0.033442,0.006923,0.003121,0.051733,0.018386,-0.009899,0.015829,0.062965},
  { -0.028587,-0.008341,-0.028288,-0.020497,-0.056174,0.056900,-0.022432,0.002820,-0.021255,0.051778},
  { -0.023380,0.002545,-0.003923,0.040254,-0.078426,0.087829,-0.024220,-0.002015,0.017107,0.034553},
  { 0.044958,0.030437,0.079826,-0.041388,0.034033,-0.073752,0.008051,-0.024602,0.002002,0.016182},
  { 0.014860,-0.022317,-0.006113,0.033039,0.007225,0.016847,0.011634,-0.006169,0.010089,0.064562},
  { 0.030809,0.002248,-0.000277,0.014446,-0.029408,0.023709,-0.025597,0.003857,0.004248,-0.029569},
  { -0.009055,-0.008607,0.097646,-0.017324,-0.057241,-0.038486,-0.011291,0.002157,-0.019201,-0.000138},
  { 0.010691,-0.027435,0.090017,-0.042659,-0.035340,-0.034393,0.020459,0.001111,-0.009278,-0.047148},
  { -0.000491,-0.039978,0.028457,0.000293,-0.054108,0.040695,-0.003972,0.006798,-0.011521,-0.018079},
  { 0.011379,-0.015108,0.050800,-0.041086,-0.026836,0.035871,0.001811,0.010972,-0.020526,-0.107648},
  { 0.019761,-0.029676,0.043831,-0.011599,-0.035500,0.007215,-0.003595,-0.027548,-0.025822,-0.009086},
  { -0.027340,-0.032720,-0.022954,0.030526,-0.090213,0.083324,-0.026270,-0.009619,-0.012209,0.058579},
  { -0.019584,-0.006196,-0.125807,0.039005,-0.013390,0.135923,0.010661,0.027918,-0.000199,0.054188},
  { -0.009427,-0.030575,-0.047503,-0.008247,-0.019068,0.103463,0.015880,0.026668,0.020346,0.049056},
  { 0.013765,0.015121,-0.058059,0.032605,0.027414,0.041093,-0.015008,0.006378,-0.012113,0.069479},
  { -0.016369,-0.021906,-0.061813,0.051013,-0.059055,0.056081,0.019183,-0.009426,-0.000659,0.082674},
  { -0.006317,-0.033101,-0.003716,0.041903,-0.124129,0.079320,-0.019291,-0.010568,0.001967,0.065977},
  { 0.014621,-0.006488,0.041369,0.030543,0.054604,-0.041237,-0.003904,-0.010922,-0.019931,0.011667},
  { -0.012834,-0.029182,0.003400,0.020754,-0.096174,0.092466,-0.006351,0.000991,0.020293,0.050991},
  { -0.031040,-0.043607,-0.038160,0.075406,-0.007428,0.091030,0.020719,0.028412,0.016268,0.014739},
  { -0.010804,0.055434,-0.010853,-0.015762,-0.028917,0.006903,-0.007011,-0.009878,-0.018794,-0.037928},
  { -0.015641,-0.042646,0.080194,-0.030090,-0.167546,0.002936,-0.026501,0.045288,-0.011195,-0.028977},
  { 0.009303,0.017951,0.055333,-0.033621,0.010766,-0.059335,0.018893,-0.017421,-0.000242,0.008927},
  { -0.017008,-0.025160,-0.001865,0.040717,-0.079897,0.106880,0.008466,0.016112,0.013338,-0.027177},
  { -0.006880,-0.040080,-0.047232,-0.020415,-0.058649,0.082216,0.005553,-0.002176,0.006912,-0.023683},
  { 0.001932,-0.106677,-0.043156,0.063282,-0.178876,0.129844,-0.016874,-0.006637,0.007523,0.023306},
  { -0.006433,0.028196,-0.014028,-0.014953,-0.042534,0.112925,-0.027771,0.021292,-0.017156,0.072768},
  { -0.028200,-0.071149,-0.056735,0.062775,-0.071063,0.161849,0.012640,0.018431,-0.002495,0.041450},
  { 0.027344,-0.028019,-0.053080,0.002573,0.019447,0.015045,-0.012991,-0.020099,0.002378,0.050801},
  { 0.006522,-0.000442,-0.060850,0.007202,0.000027,-0.026606,0.012418,-0.018119,-0.026233,0.033430},
  { 0.001905,-0.004993,0.007615,0.008631,-0.074279,0.002363,-0.002218,0.006749,-0.023276,0.048257},
  { 0.041462,0.026927,-0.006655,0.008911,0.075841,-0.021047,-0.013404,-0.030482,0.010717,0.036990},
  { -0.019949,-0.031490,0.057949,-0.013017,-0.041092,0.035902,-0.013827,0.025413,0.004217,0.019870},
  { -0.032948,-0.070324,0.013686,0.104661,-0.059081,0.101419,0.012072,0.028055,0.015403,0.014910},
  { 0.007148,-0.018447,0.009864,-0.025633,0.024236,-0.017370,0.000331,-0.040682,0.001538,0.014861},
  { 0.006666,0.035563,0.015579,-0.025658,-0.047240,0.062572,-0.017803,0.036078,0.002285,-0.020039},
  { 0.012749,-0.044978,0.039169,0.001987,-0.113292,0.023962,-0.017615,-0.001831,-0.008360,0.009385},
  { 0.003228,-0.022103,0.081486,-0.019778,-0.016092,-0.052592,0.018184,0.022999,0.016203,-0.061598},
  { 0.009197,0.012238,0.071540,0.033815,0.000147,0.055126,0.003700,-0.014860,0.022294,-0.097995},
  { 0.011271,-0.051766,-0.002267,0.024433,-0.086899,0.085064,-0.024240,-0.005262,-0.010702,-0.062219},
  { 0.014538,0.020901,-0.085504,0.000312,-0.062370,0.083404,0.017082,-0.001638,-0.002731,0.013152},
  { 0.021763,0.009794,-0.023738,-0.039473,0.000374,0.044385,0.014792,0.029947,0.007706,-0.011917},
  { -0.009643,-0.011731,0.034358,-0.022608,0.064628,0.001316,-0.027100,-0.021854,-0.006249,0.015022},
  { 0.029273,-0.028630,0.006612,-0.024393,0.065425,-0.013249,0.009286,-0.019586,-0.015848,0.058158},
  { 0.029979,0.042145,0.078539,-0.060188,0.078349,-0.121686,-0.016181,-0.035300,0.013012,-0.024041},
  { 0.001680,0.005185,-0.045435,-0.003988,0.018283,0.015425,0.000947,-0.021674,0.019917,0.084431},
  { 0.031063,0.017402,0.027638,-0.032953,0.032973,-0.018184,-0.007054,0.011545,-0.018741,0.014479},
  { -0.006447,0.016544,0.017012,0.005616,0.093489,-0.030792,0.019364,-0.013145,0.017073,-0.042459},
  { 0.018567,-0.067407,0.076122,-0.020014,-0.005340,0.022122,0.003964,-0.027526,-0.001017,-0.023017},
  { 0.013843,0.001427,0.013719,-0.011530,0.047324,0.033319,-0.001389,-0.018729,0.008527,-0.040872},
  { 0.038733,0.010722,0.035022,-0.022615,0.025944,-0.062660,-0.013623,-0.000717,0.006457,-0.060744},
  { -0.016712,-0.006209,0.034195,-0.004673,-0.007270,0.011096,-0.014999,-0.004847,-0.019769,-0.056897},
  { -0.019898,0.006276,-0.023277,0.018587,-0.070839,0.011530,0.021388,-0.001511,-0.010310,-0.014244},
  { 0.014455,-0.021438,0.045485,0.036958,0.011882,0.015434,0.000925,-0.032542,0.008823,-0.065332},
  { -0.001190,-0.020739,0.040724,0.014139,0.002362,0.014225,-0.011845,-0.006402,-0.007364,0.015223},
  { 0.021842,0.004961,-0.019871,0.013874,0.045591,0.042588,0.015006,-0.010467,-0.025823,-0.042797},
  { -0.009741,-0.035733,-0.021159,0.006569,0.004191,-0.001453,0.004147,-0.038427,-0.020746,-0.053013},
  { 0.008753,-0.032523,-0.012029,0.049620,0.002281,-0.001702,0.013381,-0.041525,0.001149,-0.013124},
  { 0.017446,0.008052,0.106267,-0.031747,0.129860,-0.149486,-0.000341,-0.007683,-0.024516,-0.046052},
  { 0.004207,-0.008860,-0.060652,0.026203,0.028517,-0.030522,-0.007479,-0.036809,0.020148,-0.008366},
  { 0.001451,0.013760,-0.009790,0.000271,-0.008012,0.017414,0.007957,0.019761,0.002184,0.064542},
  { 0.001306,-0.055877,-0.010363,0.000506,-0.065743,0.105271,0.014917,0.007640,0.017583,0.084278},
  { 0.001923,0.013489,0.075305,-0.016362,0.003614,-0.008414,-0.002693,0.005664,-0.012212,0.002237},
  { 0.022321,0.001340,0.048642,-0.009701,0.042977,-0.050997,-0.014386,-0.044971,-0.000462,-0.075955},
  { 0.019801,0.032699,-0.006419,0.021553,0.024838,0.027151,0.000930,0.009240,0.006177,-0.056975},
  { 0.046560,-0.001240,0.078842,0.008746,0.063284,-0.047557,0.006681,0.000483,-0.022342,-0.097159},
  { -0.011731,-0.045630,-0.048020,0.030908,-0.012610,0.034868,-0.010529,0.015048,0.005895,-0.028317},
  { 0.012211,-0.011289,-0.026340,0.019169,0.097021,-0.005227,-0.019268,0.041618,0.008905,-0.076526},
  { -0.009408,-0.022151,0.078415,0.007185,0.023329,-0.004995,-0.024664,-0.009100,0.006483,-0.045800},
  { 0.016304,0.065551,-0.022258,0.024534,0.039374,0.026862,0.002861,0.003298,0.024072,0.018592},
  { -0.020283,-0.092954,0.008968,0.056071,-0.071187,0.060164,0.009333,0.019938,-0.006429,-0.023323},
  { -0.013892,-0.015250,-0.004490,-0.040758,-0.041025,-0.006134,0.019124,-0.033739,0.002522,-0.028039},
  { 0.025596,-0.060452,0.064878,-0.036742,-0.010089,-0.021624,0.005341,-0.028829,0.023942,-0.008731},
  { 0.028887,0.060754,-0.033848,0.003736,0.002422,-0.026140,0.012021,-0.020242,0.010700,-0.028030},
  { 0.027568,-0.010322,-0.010569,0.017767,0.009249,0.024960,-0.025173,-0.001454,0.023281,0.047899},
  { -0.014216,0.004118,0.010734,0.038725,0.047609,0.001900,-0.006648,-0.016983,0.000955,-0.004199},
  { -0.001104,0.016170,-0.036432,0.033345,0.004611,0.117441,0.016054,0.021803,-0.010174,0.068434},
  { 0.022406,0.022223,0.002700,-0.029121,0.055665,-0.005413,0.003200,-0.018516,0.010767,-0.030807},
  { 0.032269,0.066279,0.001458,0.003174,0.105380,-0.060060,-0.014731,-0.035404,-0.005011,-0.020011},
  { 0.048999,-0.021336,0.035836,0.010553,0.077488,-0.103745,0.008973,-0.026077,-0.028221,-0.052934},
  { 0.014957,-0.054164,-0.071215,0.045292,-0.004014,0.054779,-0.005578,-0.020565,0.019111,0.027105},
  { 0.021554,-0.036873,0.036488,-0.022626,0.049056,0.016387,-0.025092,0.007187,-0.012607,0.017278},
  { 0.008021,0.007339,-0.000332,-0.001161,0.019870,-0.018918,-0.012322,-0.016170,-0.026325,-0.016492},
  { 0.031860,0.013319,0.050810,-0.044146,0.045358,0.023075,0.011033,0.012551,0.006835,0.008534},
  { 0.000879,0.003747,-0.125619,0.075615,-0.020698,0.080741,-0.012532,-0.002848,-0.009952,0.056420},
  { 0.008440,-0.014132,-0.005022,0.010809,-0.025557,0.033105,-0.010744,0.008912,0.003635,0.030639},
  { 0.032158,-0.000918,0.045541,-0.057023,0.001594,-0.075730,0.025002,-0.033008,0.000135,0.007010},
  { 0.036004,0.031799,0.003240,-0.020357,0.058264,-0.091895,0.018755,0.007906,-0.003710,-0.028292},
  { 0.030082,0.020686,0.020311,-0.020534,0.031198,-0.021785,-0.013612,0.012863,-0.006521,-0.055170},
  { 0.030744,0.037650,-0.000898,-0.028928,0.021182,0.016423,0.009679,0.008011,0.012667,0.013602},
  { 0.012093,-0.003478,0.016012,0.010480,0.006588,0.015002,-0.024152,-0.011879,-0.013581,0.020614},
  { -0.012137,-0.049864,-0.008621,0.019305,-0.043117,0.083506,-0.019984,0.008996,-0.013871,-0.004674},
  { 0.007312,0.059056,-0.071061,-0.020642,0.085144,0.004726,-0.003711,-0.034865,-0.021994,-0.016721},
  { 0.019379,-0.004274,-0.050209,0.024532,0.061379,0.003495,0.019040,-0.003490,-0.007318,-0.017942},
  { 0.022533,0.007078,-0.027778,0.000621,0.065745,0.002752,-0.005372,-0.034409,-0.017218,-0.009847},
  { 0.009827,-0.028896,0.025094,-0.005621,0.069355,0.013849,0.016662,-0.000087,-0.012476,-0.000099},
  { 0.007819,-0.014048,0.002305,-0.002155,0.008718,-0.000187,0.005202,-0.015743,-0.016209,-0.000683},
  { 0.014205,-0.014799,0.000557,-0.009311,-0.040648,0.032341,0.019716,-0.015889,0.002315,0.031045},
  { 0.006787,-0.001986,-0.040403,-0.016719,-0.031401,0.039668,-0.012732,-0.011242,-0.017869,0.031207},
  { -0.016363,0.003861,-0.113903,0.022028,-0.044380,0.117288,-0.016814,-0.020714,0.012770,0.039842},
  { -0.031887,-0.083804,0.013919,-0.042664,-0.157289,0.075989,-0.007114,0.019202,0.016303,0.082965},
  { 0.007955,0.013914,-0.000631,-0.043153,0.050741,-0.040893,-0.008448,-0.036846,0.005385,0.023303},
  { -0.000372,0.013350,0.011241,0.002731,-0.007364,-0.008204,0.018414,0.027658,0.004465,0.000951},
  { -0.009382,-0.002174,-0.011402,0.025278,0.065648,0.005861,0.011293,0.009322,0.007662,-0.083866},
  { 0.013308,0.009449,0.032314,-0.010218,0.069706,-0.016703,0.001741,0.026277,-0.006206,-0.019564},
  { -0.013989,0.005205,-0.027641,0.007016,-0.063695,0.063093,-0.006440,0.004692,-0.016825,0.018886},
  { 0.012711,-0.006128,-0.001885,-0.005784,0.006807,0.009134,0.002775,-0.004184,0.017375,0.031799},
  { -0.007525,-0.003256,-0.025032,0.027284,0.031746,0.024418,-0.013659,-0.021548,-0.018922,0.003162},
  { 0.004328,0.099439,-0.073786,-0.000970,0.053000,-0.008435,-0.016736,-0.003984,-0.002488,-0.015784},
  { -0.012361,-0.049148,-0.049294,0.011305,-0.032324,0.105978,-0.015281,0.009438,-0.021622,0.051474},
  { 0.034152,-0.020753,0.038449,0.020923,-0.012188,-0.004202,-0.020573,-0.018040,-0.021873,-0.008873},
  { 0.001272,-0.015507,0.045380,-0.026596,-0.003663,-0.022409,0.000336,-0.003832,-0.017963,0.004942},
  { -0.015733,-0.031425,-0.065690,0.039391,-0.097058,0.136230,-0.008385,0.011712,-0.025791,0.082761},
  { -0.005785,0.007417,-0.019221,0.012326,0.005195,0.025733,-0.003572,-0.015717,0.018925,-0.007230},
  { -0.021793,-0.071049,-0.041371,0.002034,-0.102485,0.086616,0.023604,0.007959,-0.017693,0.054609},
  { 0.015745,-0.024818,0.006397,0.006229,0.054788,-0.050422,-0.000435,-0.009226,-0.020907,0.019253},
  { 0.007802,-0.014543,-0.036957,-0.009742,-0.042361,0.040060,-0.007495,0.008258,-0.004215,0.041240},
  { 0.015101,-0.001154,-0.016643,0.032326,0.076592,-0.033136,-0.012684,-0.041759,0.002623,-0.064703},
  { 0.032258,0.043870,0.006076,-0.019684,0.106871,-0.039972,0.013694,-0.010279,-0.018375,-0.026759},
  { 0.010234,0.008739,-0.037514,0.042511,-0.020901,0.080904,0.004534,-0.004762,0.021143,-0.033234},
  { -0.005544,0.019781,-0.041551,0.006511,0.026954,0.004697,0.008727,-0.004305,-0.002545,0.025869},
  { 0.024788,-0.058948,-0.026188,-0.013125,0.078738,0.032187,-0.019308,-0.027926,-0.004122,0.035705},
  { 0.038578,0.061915,-0.001583,0.018695,0.131772,-0.065239,0.005930,-0.012011,-0.026063,-0.062527},
  { -0.019151,0.003273,-0.085246,0.032649,-0.057914,0.122826,0.012610,0.025831,-0.017788,-0.025690},
  { -0.009760,-0.069406,-0.066164,0.019260,-0.051100,0.090795,-0.022116,0.000462,0.002082,0.000359},
  { 0.015987,0.002328,0.049777,-0.021795,-0.038488,0.018265,0.021151,-0.020018,0.006365,-0.042392},
  { -0.001786,-0.011306,0.004436,0.000552,-0.090912,0.021339,0.002298,-0.001853,-0.002032,0.055872},
  { -0.008024,0.008534,0.026954,0.005842,-0.067433,0.012686,-0.017949,0.021315,-0.018421,0.009167},
  { 0.000413,-0.037459,0.037053,0.038669,-0.062692,0.082744,-0.004436,-0.004417,0.003297,0.006980},
  { 0.027546,0.028481,0.011149,0.034154,0.067542,-0.030654,-0.009405,-0.039641,0.005537,-0.030733},
  { 0.014958,0.030140,-0.011474,-0.012971,0.046247,-0.031099,0.003352,0.021672,0.012169,0.045074},
  { -0.023135,-0.022882,-0.010643,0.051446,-0.019935,0.040928,-0.020320,-0.014210,-0.021524,0.023539},
  { 0.025697,-0.030324,-0.038031,0.060892,0.085095,-0.007448,0.011261,-0.024431,0.017907,-0.044946},
  { 0.002147,-0.012679,-0.026154,0.014287,0.061488,0.023605,-0.014484,0.005130,-0.018176,-0.006807},
  { -0.017231,-0.056798,0.006422,0.049125,-0.002841,0.035242,0.020877,-0.004894,0.015887,0.045988},
  { 0.003850,-0.036090,-0.085632,0.044281,-0.008207,0.080123,-0.024896,-0.010209,-0.006453,0.000981},
  { 0.021268,0.004860,-0.062038,0.059250,0.041079,0.046538,-0.001751,0.003197,0.007793,0.026162},
  { -0.008824,0.007120,-0.020394,0.010524,0.012355,0.038506,0.004725,-0.009849,0.022559,-0.021712},
  { -0.035788,-0.029507,-0.046414,0.034079,-0.110222,0.064939,0.014021,0.020694,-0.020390,0.013012},
  { 0.010753,-0.016701,0.031913,0.014967,-0.021389,0.032774,-0.009940,-0.040127,-0.022121,-0.015811},
  { 0.002222,-0.013643,0.006641,-0.006268,-0.116395,0.085811,-0.010831,0.018317,-0.019041,-0.007886},
  { -0.017601,-0.015991,0.008553,-0.001836,-0.085849,0.078664,0.012152,-0.005145,0.011342,0.003404},
  { 0.012339,-0.035642,0.048861,0.026873,-0.053527,0.069592,0.003813,-0.003130,0.001688,-0.016110},
  { 0.003512,0.035662,0.033131,-0.013802,0.127884,-0.060771,0.010589,-0.047992,-0.019911,-0.068949},
  { 0.027617,0.029896,-0.021544,0.012341,0.021788,-0.009628,-0.008669,0.008844,0.006985,-0.040404},
  { -0.012878,-0.012081,-0.000879,0.029621,0.049828,0.016633,0.008608,0.025291,0.018319,0.046130},
  { 0.017585,-0.014278,0.007359,0.028706,0.047605,0.015417,0.004622,-0.014052,-0.025655,0.019692},
  { 0.036641,-0.005765,-0.030549,0.007766,0.064821,0.006415,0.019615,0.039309,-0.025043,-0.032306},
  { 0.028452,0.021967,-0.018949,-0.003815,0.030463,0.037564,-0.006964,0.042651,-0.001352,0.001464},
  { -0.017495,-0.032194,-0.053250,-0.028744,0.051597,0.025901,0.003354,-0.019123,0.022912,0.043202},
  { 0.023162,-0.003041,-0.045327,0.023192,0.007112,0.015263,0.007927,0.020392,0.003293,-0.017696},
  { -0.016748,-0.063167,0.010664,0.027061,-0.019065,0.028504,0.023092,-0.006134,0.015473,0.014822},
  { -0.017627,0.016404,-0.017112,0.002401,-0.098811,0.091186,-0.018356,-0.001559,-0.016815,0.021724},
  { 0.004395,-0.024361,-0.006887,0.030029,-0.019547,0.032417,-0.017248,-0.029527,0.001549,0.031028},
  { -0.006823,-0.025098,-0.017664,0.010956,-0.057884,0.109225,-0.024041,-0.005773,-0.019711,0.027195},
  { -0.024013,-0.028295,0.018666,-0.043219,-0.065163,0.073515,0.005275,-0.007667,-0.017850,0.026367},
  { 0.008583,-0.010616,0.088014,-0.039677,-0.034554,-0.034287,-0.026280,-0.045104,-0.002695,-0.023816},
  { 0.016751,0.006431,-0.008933,-0.000887,0.084255,0.011404,-0.025014,-0.001507,-0.027899,-0.022041},
  { -0.009965,0.046343,-0.006754,0.004918,0.122499,-0.028260,-0.017709,-0.008486,-0.025302,-0.015426},
  { -0.006938,0.019302,-0.034822,0.038872,0.030468,0.030838,0.007633,-0.027178,-0.016260,0.007759},
  { 0.032280,0.015374,0.019192,0.045994,0.032791,-0.019679,-0.006033,0.014856,0.011678,-0.031252},
  { 0.027161,-0.023670,-0.057723,0.037177,0.025078,0.030938,-0.003576,0.013550,0.020313,-0.014566},
  { 0.031603,0.038198,-0.021641,0.034739,0.063018,-0.016271,-0.013106,-0.014583,0.007527,-0.040563},
  { 0.015728,0.028373,-0.084641,-0.018298,0.058533,0.049478,-0.016640,-0.010724,-0.022082,0.041191},
  { 0.006008,0.011812,0.003140,0.000605,-0.033521,0.076105,-0.017006,0.050466,0.018045,0.030632},
  { 0.040870,-0.031010,0.056847,0.043703,0.024906,-0.066642,-0.025007,-0.022660,0.016843,-0.088036},
  { 0.037483,-0.014636,0.049840,-0.006680,0.008277,-0.030911,-0.003126,-0.035307,-0.017004,-0.015808},
  { 0.010630,0.001772,0.042993,0.047852,-0.057100,0.020998,-0.006868,-0.036493,-0.002799,-0.011537},
  { 0.013439,0.021179,0.057989,0.011654,-0.030276,0.003495,0.010213,-0.002434,0.008372,0.035360},
  { -0.007354,-0.043747,-0.001862,0.019195,-0.096628,0.124083,-0.017391,0.042246,-0.001847,0.056872},
  { 0.005896,0.019565,0.018295,-0.005791,-0.017558,0.009720,-0.025032,0.026600,-0.006601,-0.031411}};
# 4857 "./headers1/weights.h"
float24_t fc_layer2_bias[2] = {0.5222, 0.3447};

float24_t fc_layer2_weights[10][2] =
    {{ 0.596400, 0.336200},
  { 0.586600, -0.610000},
  { 0.613100, -0.575600},
  { -0.446900, 0.660800},
  { 0.799100, -0.566700},
  { -0.227000, 0.791400},
  { -0.267300, 0.229600},
  { -0.259100, 0.356300},
  { -0.272600, -0.061500},
  { -0.756900, 0.552600}};
# 4 "pooling_layer2.cpp" 2

# 1 "./headers1/activations.h" 1
# 33 "./headers1/activations.h"
float24_t relu(float24_t a)
{
 return a > (float24_t)0 ? a : (float24_t)0;
}
# 6 "pooling_layer2.cpp" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_stream.h" 1
# 61 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_stream.h"
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_stream_39.h" 1
# 67 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_stream_39.h"
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/etc/autopilot_enum.h" 1
# 59 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/etc/autopilot_enum.h"
enum SsdmDataTypes {
    _ssdm_sc_int = 0,
    _ssdm_c_int = _ssdm_sc_int,
    _ssdm_sc_uint = 1,
    _ssdm_c_uint = _ssdm_sc_uint,
    _ssdm_sc_bigint = 2,
    _ssdm_sc_biguint = 3,
};



enum SsdmPortTypes {
    _ssdm_sc_in = 0,
    _ssdm_sc_out = 1,
    _ssdm_sc_inout = 2,
    _ssdm_sc_in_clk,

    _ssdm_fifo_in,
    _ssdm_sc_fifo_in = _ssdm_fifo_in,
    _ssdm_tlm_fifo_in = _ssdm_fifo_in,
    _ssdm_fifo_out,
    _ssdm_sc_fifo_out = _ssdm_fifo_out,
    _ssdm_tlm_fifo_out = _ssdm_fifo_out,
    _ssdm_fifo_inout,
    _ssdm_sc_fifo_inout = _ssdm_fifo_inout,
    _ssdm_tlm_fifo_inout = _ssdm_fifo_inout,
    _ssdm_sc_bus,
    _ssdm_hls_bus_port = _ssdm_sc_bus,
    _ssdm_AXI4M_bus_port = _ssdm_sc_bus,
    _ssdm_port_end,
};



enum SsdmProcessTypes {
    _ssdm_method = 0,
    _ssdm_sc_method = _ssdm_method,
    _ssdm_thread = 1,
    _ssdm_sc_thread = _ssdm_thread,
    _ssdm_cthread = 2,
    _ssdm_sc_cthread = _ssdm_cthread,
    _ssdm_process_end,
};



enum SsdmSensitiveTypes {
    _ssdm_sensitive = 0,
    _ssdm_sensitive_pos,
    _ssdm_sensitive_neg,
    _ssdm_sensitive_reset0,
    _ssdm_sensitive_reset1,
    _ssdm_sensitive_end,
};



enum SsdmChannelTypes {
    _ssdm_sc_sig,
    _ssdm_fifo,
    _ssdm_sc_fifo = _ssdm_fifo,
    _ssdm_mem_fifo,
    _ssdm_sc_mem_fifo = _ssdm_mem_fifo,
};


enum SsdmRegionTypes {
    _ssdm_region_reset,
    _ssdm_region_protocol,
    _ssdm_region_pipeline,
    _ssdm_region_parallel,
};
# 68 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_stream_39.h" 2





namespace hls {
# 95 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_stream_39.h"
template<typename __STREAM_T__, int DEPTH=0>
class stream;

template<typename __STREAM_T__>
class stream<__STREAM_T__, 0>
{
  public:

    inline __attribute__((always_inline)) stream() {
      __fpga_set_stream_depth(&this->V, 0);
    }

    inline __attribute__((always_inline)) stream(const char* name) {
      (void)(name);
      __fpga_set_stream_depth(&this->V, 0);
    }


  private:
    inline __attribute__((always_inline)) stream(const stream< __STREAM_T__ >& chn):V(chn.V) {
    }

    inline __attribute__((always_inline)) stream& operator= (const stream< __STREAM_T__ >& chn) {
        V = chn.V;
        return *this;
    }

  public:

    inline __attribute__((always_inline)) void operator >> (__STREAM_T__& rdata) {
        read(rdata);
    }

    inline __attribute__((always_inline)) void operator << (const __STREAM_T__& wdata) {
        write(wdata);
    }


  public:

    inline __attribute__((always_inline)) bool empty() const {
        return !__fpga_fifo_not_empty(&V);
    }

    inline __attribute__((always_inline)) bool full() const {
        return !__fpga_fifo_not_full(&V);
    }


    inline __attribute__((always_inline)) void read(__STREAM_T__& dout) {
        __fpga_fifo_pop(&V, &dout);
    }


    inline __attribute__((noinline)) bool read_dep(__STREAM_T__& dout, volatile bool flag) {
        __fpga_fifo_pop(&V, &dout);
        return flag;
    }

    inline __attribute__((always_inline)) __STREAM_T__ read() {
        __STREAM_T__ tmp;
        read(tmp);
        return tmp;
    }


    inline __attribute__((always_inline)) bool read_nb(__STREAM_T__& dout) {
        __STREAM_T__ tmp;

        if (__fpga_fifo_nb_pop(&V, &tmp)) {
            dout = tmp;
            return true;
        } else {
            return false;
        }
    }


    inline __attribute__((always_inline)) void write(const __STREAM_T__& din) {
        __fpga_fifo_push(&V, &din);
    }


    inline __attribute__((noinline)) bool write_dep(const __STREAM_T__& din, volatile bool flag) {
        __fpga_fifo_push(&V, &din);
        return flag;
    }


    inline __attribute__((always_inline)) bool write_nb(const __STREAM_T__& din) {
        return __fpga_fifo_nb_push(&V, &din);
    }

  public:
    __STREAM_T__ V __attribute__((no_ctor));
};

template<typename __STREAM_T__, int DEPTH>
class stream : public stream<__STREAM_T__, 0> {
  public:
    inline __attribute__((always_inline)) stream() {
      __fpga_set_stream_depth(&this->V, DEPTH);
    }

    inline __attribute__((always_inline)) stream(const char* name) {
      (void)(name);
      __fpga_set_stream_depth(&this->V, DEPTH);
    }
};
}
# 62 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_stream.h" 2
# 7 "pooling_layer2.cpp" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\math.h" 1 3
# 36 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\math.h" 3
# 1 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\cmath" 1 3
# 40 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\cmath" 3

# 1 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\x86_64-w64-mingw32\\bits/c++config.h" 1 3
# 196 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\x86_64-w64-mingw32\\bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}
# 218 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\x86_64-w64-mingw32\\bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# 495 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\x86_64-w64-mingw32\\bits/c++config.h" 3
# 1 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\x86_64-w64-mingw32\\bits/os_defines.h" 1 3
# 496 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\x86_64-w64-mingw32\\bits/c++config.h" 2 3


# 1 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\x86_64-w64-mingw32\\bits/cpu_defines.h" 1 3
# 499 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\x86_64-w64-mingw32\\bits/c++config.h" 2 3
# 42 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\cmath" 2 3
# 1 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\bits/cpp_type_traits.h" 1 3
# 36 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\bits/cpp_type_traits.h" 3
# 67 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\bits/cpp_type_traits.h" 3
extern "C++" {

namespace std
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };





  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 261 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\bits/cpp_type_traits.h" 3
template<> struct __is_integer<__int128> { enum { __value = 1 }; typedef __true_type __type; }; template<> struct __is_integer<unsigned __int128> { enum { __value = 1 }; typedef __true_type __type; };
# 278 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };



  template<typename _Iterator>
    inline _Iterator
    __miter_base(_Iterator __it)
    { return __it; }


}
}
# 43 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\cmath" 2 3
# 1 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\ext/type_traits.h" 1 3
# 33 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\ext/type_traits.h" 3




extern "C++" {

namespace __gnu_cxx
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }


  inline bool
  __is_null_pointer(std::nullptr_t)
  { return true; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };

  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


}
}
# 44 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\cmath" 2 3

# 1 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 1 3
# 11 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3


# 1 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\crtdefs.h" 1 3
# 10 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\crtdefs.h" 3
# 1 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 1 3
# 12 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 3
# 1 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include/_mingw_mac.h" 1 3
# 13 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 2 3
# 1 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include/_mingw_secapi.h" 1 3
# 44 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include/_mingw_secapi.h" 3
extern "C++" {
template <bool __test, typename __dsttype>
  struct __if_array;
template <typename __dsttype>
  struct __if_array <true, __dsttype> {
    typedef __dsttype __type;
};
}
# 14 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 2 3
# 275 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 3
# 1 "C:\\Xilinx\\Vitis_HLS\\2020.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\vadefs.h" 1 3
# 26 "C:\\Xilinx\\Vitis_HLS\\2020.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\vadefs.h" 3
# 1 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\vadefs.h" 1 3








# 1 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 1 3
# 565 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 3
# 1 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include/sdks/_mingw_directx.h" 1 3
# 566 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 2 3
# 1 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include/sdks/_mingw_ddk.h" 1 3
# 567 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 2 3
# 10 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\vadefs.h" 2 3




#pragma pack(push,_CRT_PACKING)



extern "C" {





  typedef __builtin_va_list __gnuc_va_list;






  typedef __gnuc_va_list va_list;
# 99 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\vadefs.h" 3
}



#pragma pack(pop)
# 27 "C:\\Xilinx\\Vitis_HLS\\2020.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\vadefs.h" 2 3
# 276 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 2 3
# 534 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 3
extern "C" {
# 548 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 3
const char *__mingw_get_crt_info (void);


}
# 11 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\crtdefs.h" 2 3




#pragma pack(push,_CRT_PACKING)
# 35 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\crtdefs.h" 3
__extension__ typedef unsigned long size_t;
# 45 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\crtdefs.h" 3
__extension__ typedef long ssize_t;






typedef size_t rsize_t;
# 62 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\crtdefs.h" 3
__extension__ typedef long intptr_t;
# 75 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\crtdefs.h" 3
__extension__ typedef unsigned long uintptr_t;
# 88 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\crtdefs.h" 3
__extension__ typedef long ptrdiff_t;
# 106 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\crtdefs.h" 3
typedef unsigned short wint_t;
typedef unsigned short wctype_t;





typedef int errno_t;




typedef long __time32_t;




__extension__ typedef long __time64_t;
# 138 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\crtdefs.h" 3
typedef __time64_t time_t;
# 422 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\crtdefs.h" 3
struct threadlocaleinfostruct;
struct threadmbcinfostruct;
typedef struct threadlocaleinfostruct *pthreadlocinfo;
typedef struct threadmbcinfostruct *pthreadmbcinfo;
struct __lc_time_data;

typedef struct localeinfo_struct {
  pthreadlocinfo locinfo;
  pthreadmbcinfo mbcinfo;
} _locale_tstruct,*_locale_t;



typedef struct tagLC_ID {
  unsigned short wLanguage;
  unsigned short wCountry;
  unsigned short wCodePage;
} LC_ID,*LPLC_ID;




typedef struct threadlocaleinfostruct {
  int refcount;
  unsigned int lc_codepage;
  unsigned int lc_collate_cp;
  unsigned long lc_handle[6];
  LC_ID lc_id[6];
  struct {
    char *locale;
    wchar_t *wlocale;
    int *refcount;
    int *wrefcount;
  } lc_category[6];
  int lc_clike;
  int mb_cur_max;
  int *lconv_intl_refcount;
  int *lconv_num_refcount;
  int *lconv_mon_refcount;
  struct lconv *lconv;
  int *ctype1_refcount;
  unsigned short *ctype1;
  const unsigned short *pctype;
  const unsigned char *pclmap;
  const unsigned char *pcumap;
  struct __lc_time_data *lc_time_curr;
} threadlocinfo;







#pragma pack(pop)
# 14 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 2 3

struct _exception;

#pragma pack(push,_CRT_PACKING)
# 77 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
extern "C++" {
template <typename type1, typename type2> struct __mingw_types_compatible_p {
  static const bool result = false;
};

template <typename type1> struct __mingw_types_compatible_p<type1, type1> {
 static const bool result = true;
};

template <typename type1> struct __mingw_types_compatible_p<const type1, type1> {
  static const bool result = true;
};

template <typename type1> struct __mingw_types_compatible_p<type1, const type1> {
  static const bool result = true;
};
}
# 111 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
extern "C" {







  typedef union __mingw_dbl_type_t {
    double x;
    unsigned long long val;
    __extension__ struct {
      unsigned int low, high;
    } lh;
  } __mingw_dbl_type_t;

  typedef union __mingw_flt_type_t {
    float x;
    unsigned int val;
  } __mingw_flt_type_t;

  typedef union __mingw_ldbl_type_t
  {
    long double x;
    __extension__ struct {
      unsigned int low, high;
      int sign_exponent : 16;
      int res1 : 16;
      int res0 : 32;
    } lh;
  } __mingw_ldbl_type_t;

  typedef union __mingw_fp_types_t
  {
    long double *ld;
    double *d;
    float *f;
    __mingw_ldbl_type_t *ldt;
    __mingw_dbl_type_t *dt;
    __mingw_flt_type_t *ft;
  } __mingw_fp_types_t;




  extern double * __imp__HUGE;
# 168 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  struct _exception {
    int type;
    const char *name;
    double arg1;
    double arg2;
    double retval;
  };

  void __mingw_raise_matherr (int typ, const char *name, double a1, double a2,
         double rslt);
  void __mingw_setusermatherr (int (__attribute__((__cdecl__)) *)(struct _exception *));
  __attribute__ ((__dllimport__)) void __setusermatherr(int (__attribute__((__cdecl__)) *)(struct _exception *));



  double __attribute__((__cdecl__)) sin(double _X);
  double __attribute__((__cdecl__)) cos(double _X);
  double __attribute__((__cdecl__)) tan(double _X);
  double __attribute__((__cdecl__)) sinh(double _X);
  double __attribute__((__cdecl__)) cosh(double _X);
  double __attribute__((__cdecl__)) tanh(double _X);
  double __attribute__((__cdecl__)) asin(double _X);
  double __attribute__((__cdecl__)) acos(double _X);
  double __attribute__((__cdecl__)) atan(double _X);
  double __attribute__((__cdecl__)) atan2(double _Y,double _X);
  double __attribute__((__cdecl__)) exp(double _X);
  double __attribute__((__cdecl__)) log(double _X);
  double __attribute__((__cdecl__)) log10(double _X);
  double __attribute__((__cdecl__)) pow(double _X,double _Y);
  double __attribute__((__cdecl__)) sqrt(double _X);
  double __attribute__((__cdecl__)) ceil(double _X);
  double __attribute__((__cdecl__)) floor(double _X);


  extern float __attribute__((__cdecl__)) fabsf (float x);
  extern long double __attribute__((__cdecl__)) fabsl (long double);
  extern double __attribute__((__cdecl__)) fabs (double _X);
# 243 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  double __attribute__((__cdecl__)) ldexp(double _X,int _Y);
  double __attribute__((__cdecl__)) frexp(double _X,int *_Y);
  double __attribute__((__cdecl__)) modf(double _X,double *_Y);
  double __attribute__((__cdecl__)) fmod(double _X,double _Y);

  void __attribute__((__cdecl__)) sincos (double __x, double *p_sin, double *p_cos);
  void __attribute__((__cdecl__)) sincosl (long double __x, long double *p_sin, long double *p_cos);
  void __attribute__((__cdecl__)) sincosf (float __x, float *p_sin, float *p_cos);



  int __attribute__((__cdecl__)) abs(int _X);
  long __attribute__((__cdecl__)) labs(long _X);



  double __attribute__((__cdecl__)) atof(const char *_String);
  double __attribute__((__cdecl__)) _atof_l(const char *_String,_locale_t _Locale);
# 270 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  struct _complex {
    double x;
    double y;
  };


  double __attribute__((__cdecl__)) _cabs(struct _complex _ComplexA);
  double __attribute__((__cdecl__)) _hypot(double _X,double _Y);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _j0(double _X);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _j1(double _X);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _jn(int _X,double _Y);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _y0(double _X);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _y1(double _X);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _yn(int _X,double _Y);


  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _matherr (struct _exception *);
# 297 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _chgsign (double _X);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _copysign (double _Number,double _Sign);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _logb (double);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _nextafter (double, double);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _scalb (double, long);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _finite (double);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fpclass (double);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isnan (double);






__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) j0 (double) ;
__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) j1 (double) ;
__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) jn (int, double) ;
__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) y0 (double) ;
__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) y1 (double) ;
__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) yn (int, double) ;

__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) chgsign (double);
# 327 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) finite (double);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) fpclass (double);
# 372 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
typedef float float_t;
typedef double double_t;
# 407 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  extern int __attribute__((__cdecl__)) __fpclassifyl (long double);
  extern int __attribute__((__cdecl__)) __fpclassifyf (float);
  extern int __attribute__((__cdecl__)) __fpclassify (double);
# 520 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  extern int __attribute__((__cdecl__)) __isnan (double);
  extern int __attribute__((__cdecl__)) __isnanf (float);
  extern int __attribute__((__cdecl__)) __isnanl (long double);
# 607 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  extern int __attribute__((__cdecl__)) __signbit (double);
  extern int __attribute__((__cdecl__)) __signbitf (float);
  extern int __attribute__((__cdecl__)) __signbitl (long double);
# 664 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  extern float __attribute__((__cdecl__)) sinf(float _X);
  extern long double __attribute__((__cdecl__)) sinl(long double);

  extern float __attribute__((__cdecl__)) cosf(float _X);
  extern long double __attribute__((__cdecl__)) cosl(long double);

  extern float __attribute__((__cdecl__)) tanf(float _X);
  extern long double __attribute__((__cdecl__)) tanl(long double);
  extern float __attribute__((__cdecl__)) asinf(float _X);
  extern long double __attribute__((__cdecl__)) asinl(long double);

  extern float __attribute__((__cdecl__)) acosf (float);
  extern long double __attribute__((__cdecl__)) acosl (long double);

  extern float __attribute__((__cdecl__)) atanf (float);
  extern long double __attribute__((__cdecl__)) atanl (long double);

  extern float __attribute__((__cdecl__)) atan2f (float, float);
  extern long double __attribute__((__cdecl__)) atan2l (long double, long double);


  extern float __attribute__((__cdecl__)) sinhf(float _X);



  extern long double __attribute__((__cdecl__)) sinhl(long double);

  extern float __attribute__((__cdecl__)) coshf(float _X);



  extern long double __attribute__((__cdecl__)) coshl(long double);

  extern float __attribute__((__cdecl__)) tanhf(float _X);



  extern long double __attribute__((__cdecl__)) tanhl(long double);



  extern double __attribute__((__cdecl__)) acosh (double);
  extern float __attribute__((__cdecl__)) acoshf (float);
  extern long double __attribute__((__cdecl__)) acoshl (long double);


  extern double __attribute__((__cdecl__)) asinh (double);
  extern float __attribute__((__cdecl__)) asinhf (float);
  extern long double __attribute__((__cdecl__)) asinhl (long double);


  extern double __attribute__((__cdecl__)) atanh (double);
  extern float __attribute__((__cdecl__)) atanhf (float);
  extern long double __attribute__((__cdecl__)) atanhl (long double);



  extern float __attribute__((__cdecl__)) expf(float _X);



  extern long double __attribute__((__cdecl__)) expl(long double);


  extern double __attribute__((__cdecl__)) exp2(double);
  extern float __attribute__((__cdecl__)) exp2f(float);
  extern long double __attribute__((__cdecl__)) exp2l(long double);



  extern double __attribute__((__cdecl__)) expm1(double);
  extern float __attribute__((__cdecl__)) expm1f(float);
  extern long double __attribute__((__cdecl__)) expm1l(long double);


  extern float frexpf(float _X,int *_Y);



  extern long double __attribute__((__cdecl__)) frexpl(long double,int *);




  extern int __attribute__((__cdecl__)) ilogb (double);
  extern int __attribute__((__cdecl__)) ilogbf (float);
  extern int __attribute__((__cdecl__)) ilogbl (long double);


  extern float __attribute__((__cdecl__)) ldexpf(float _X,int _Y);



  extern long double __attribute__((__cdecl__)) ldexpl (long double, int);


  extern float __attribute__((__cdecl__)) logf (float);
  extern long double __attribute__((__cdecl__)) logl(long double);


  extern float __attribute__((__cdecl__)) log10f (float);
  extern long double __attribute__((__cdecl__)) log10l(long double);


  extern double __attribute__((__cdecl__)) log1p(double);
  extern float __attribute__((__cdecl__)) log1pf(float);
  extern long double __attribute__((__cdecl__)) log1pl(long double);


  extern double __attribute__((__cdecl__)) log2 (double);
  extern float __attribute__((__cdecl__)) log2f (float);
  extern long double __attribute__((__cdecl__)) log2l (long double);


  extern double __attribute__((__cdecl__)) logb (double);
  extern float __attribute__((__cdecl__)) logbf (float);
  extern long double __attribute__((__cdecl__)) logbl (long double);
# 863 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  extern float __attribute__((__cdecl__)) modff (float, float*);
  extern long double __attribute__((__cdecl__)) modfl (long double, long double*);


  extern double __attribute__((__cdecl__)) scalbn (double, int);
  extern float __attribute__((__cdecl__)) scalbnf (float, int);
  extern long double __attribute__((__cdecl__)) scalbnl (long double, int);

  extern double __attribute__((__cdecl__)) scalbln (double, long);
  extern float __attribute__((__cdecl__)) scalblnf (float, long);
  extern long double __attribute__((__cdecl__)) scalblnl (long double, long);



  extern double __attribute__((__cdecl__)) cbrt (double);
  extern float __attribute__((__cdecl__)) cbrtf (float);
  extern long double __attribute__((__cdecl__)) cbrtl (long double);


  extern double __attribute__((__cdecl__)) hypot (double, double) ;
  extern float __attribute__((__cdecl__)) hypotf (float x, float y);



  extern long double __attribute__((__cdecl__)) hypotl (long double, long double);


  extern float __attribute__((__cdecl__)) powf(float _X,float _Y);



  extern long double __attribute__((__cdecl__)) powl (long double, long double);


  extern float __attribute__((__cdecl__)) sqrtf (float);
  extern long double sqrtl(long double);


  extern double __attribute__((__cdecl__)) erf (double);
  extern float __attribute__((__cdecl__)) erff (float);
  extern long double __attribute__((__cdecl__)) erfl (long double);


  extern double __attribute__((__cdecl__)) erfc (double);
  extern float __attribute__((__cdecl__)) erfcf (float);
  extern long double __attribute__((__cdecl__)) erfcl (long double);


  extern double __attribute__((__cdecl__)) lgamma (double);
  extern float __attribute__((__cdecl__)) lgammaf (float);
  extern long double __attribute__((__cdecl__)) lgammal (long double);

  extern int signgam;


  extern double __attribute__((__cdecl__)) tgamma (double);
  extern float __attribute__((__cdecl__)) tgammaf (float);
  extern long double __attribute__((__cdecl__)) tgammal (long double);


  extern float __attribute__((__cdecl__)) ceilf (float);
  extern long double __attribute__((__cdecl__)) ceill (long double);


  extern float __attribute__((__cdecl__)) floorf (float);
  extern long double __attribute__((__cdecl__)) floorl (long double);


  extern double __attribute__((__cdecl__)) nearbyint ( double);
  extern float __attribute__((__cdecl__)) nearbyintf (float);
  extern long double __attribute__((__cdecl__)) nearbyintl (long double);



extern double __attribute__((__cdecl__)) rint (double);
extern float __attribute__((__cdecl__)) rintf (float);
extern long double __attribute__((__cdecl__)) rintl (long double);


extern long __attribute__((__cdecl__)) lrint (double);
extern long __attribute__((__cdecl__)) lrintf (float);
extern long __attribute__((__cdecl__)) lrintl (long double);

__extension__ long long __attribute__((__cdecl__)) llrint (double);
__extension__ long long __attribute__((__cdecl__)) llrintf (float);
__extension__ long long __attribute__((__cdecl__)) llrintl (long double);
# 1030 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  extern double __attribute__((__cdecl__)) round (double);
  extern float __attribute__((__cdecl__)) roundf (float);
  extern long double __attribute__((__cdecl__)) roundl (long double);


  extern long __attribute__((__cdecl__)) lround (double);
  extern long __attribute__((__cdecl__)) lroundf (float);
  extern long __attribute__((__cdecl__)) lroundl (long double);
  __extension__ long long __attribute__((__cdecl__)) llround (double);
  __extension__ long long __attribute__((__cdecl__)) llroundf (float);
  __extension__ long long __attribute__((__cdecl__)) llroundl (long double);



  extern double __attribute__((__cdecl__)) trunc (double);
  extern float __attribute__((__cdecl__)) truncf (float);
  extern long double __attribute__((__cdecl__)) truncl (long double);


  extern float __attribute__((__cdecl__)) fmodf (float, float);
  extern long double __attribute__((__cdecl__)) fmodl (long double, long double);


  extern double __attribute__((__cdecl__)) remainder (double, double);
  extern float __attribute__((__cdecl__)) remainderf (float, float);
  extern long double __attribute__((__cdecl__)) remainderl (long double, long double);


  extern double __attribute__((__cdecl__)) remquo(double, double, int *);
  extern float __attribute__((__cdecl__)) remquof(float, float, int *);
  extern long double __attribute__((__cdecl__)) remquol(long double, long double, int *);


  extern double __attribute__((__cdecl__)) copysign (double, double);
  extern float __attribute__((__cdecl__)) copysignf (float, float);
  extern long double __attribute__((__cdecl__)) copysignl (long double, long double);
# 1087 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  extern double __attribute__((__cdecl__)) nan(const char *tagp);
  extern float __attribute__((__cdecl__)) nanf(const char *tagp);
  extern long double __attribute__((__cdecl__)) nanl(const char *tagp);
# 1098 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  extern double __attribute__((__cdecl__)) nextafter (double, double);
  extern float __attribute__((__cdecl__)) nextafterf (float, float);
  extern long double __attribute__((__cdecl__)) nextafterl (long double, long double);


  extern double __attribute__((__cdecl__)) nexttoward (double, long double);
  extern float __attribute__((__cdecl__)) nexttowardf (float, long double);
  extern long double __attribute__((__cdecl__)) nexttowardl (long double, long double);



  extern double __attribute__((__cdecl__)) fdim (double x, double y);
  extern float __attribute__((__cdecl__)) fdimf (float x, float y);
  extern long double __attribute__((__cdecl__)) fdiml (long double x, long double y);







  extern double __attribute__((__cdecl__)) fmax (double, double);
  extern float __attribute__((__cdecl__)) fmaxf (float, float);
  extern long double __attribute__((__cdecl__)) fmaxl (long double, long double);


  extern double __attribute__((__cdecl__)) fmin (double, double);
  extern float __attribute__((__cdecl__)) fminf (float, float);
  extern long double __attribute__((__cdecl__)) fminl (long double, long double);



  extern double __attribute__((__cdecl__)) fma (double, double, double);
  extern float __attribute__((__cdecl__)) fmaf (float, float, float);
  extern long double __attribute__((__cdecl__)) fmal (long double, long double, long double);
# 1181 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
   __attribute__ ((__dllimport__)) float __attribute__((__cdecl__)) _copysignf (float _Number,float _Sign);
   __attribute__ ((__dllimport__)) float __attribute__((__cdecl__)) _chgsignf (float _X);
   __attribute__ ((__dllimport__)) float __attribute__((__cdecl__)) _logbf(float _X);
   __attribute__ ((__dllimport__)) float __attribute__((__cdecl__)) _nextafterf(float _X,float _Y);
   __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _finitef(float _X);
   __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isnanf(float _X);
   __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fpclassf(float _X);



   extern long double __attribute__((__cdecl__)) _chgsignl (long double);
# 1576 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
}




#pragma pack(pop)
# 46 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\cmath" 2 3
# 77 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\cmath" 3
extern "C++"
{
namespace std
{



  inline constexpr double
  abs(double __x)
  { return __builtin_fabs(__x); }



  inline constexpr float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    abs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::acos;


  inline constexpr float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline constexpr long double
  acos(long double __x)
  { return __builtin_acosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;


  inline constexpr float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline constexpr long double
  asin(long double __x)
  { return __builtin_asinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;


  inline constexpr float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline constexpr long double
  atan(long double __x)
  { return __builtin_atanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;


  inline constexpr float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline constexpr long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;


  inline constexpr float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline constexpr long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;


  inline constexpr float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline constexpr long double
  cos(long double __x)
  { return __builtin_cosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;


  inline constexpr float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline constexpr long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;


  inline constexpr float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline constexpr long double
  exp(long double __x)
  { return __builtin_expl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;


  inline constexpr float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;


  inline constexpr float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline constexpr long double
  floor(long double __x)
  { return __builtin_floorl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;


  inline constexpr float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline constexpr long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmod(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmod(__type(__x), __type(__y));
    }

  using ::frexp;


  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;


  inline constexpr float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline constexpr long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ldexp(_Tp __x, int __exp)
    { return __builtin_ldexp(__x, __exp); }

  using ::log;


  inline constexpr float
  log(float __x)
  { return __builtin_logf(__x); }

  inline constexpr long double
  log(long double __x)
  { return __builtin_logl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;


  inline constexpr float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline constexpr long double
  log10(long double __x)
  { return __builtin_log10l(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;


  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }


  using ::pow;


  inline constexpr float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline constexpr long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
# 435 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\cmath" 3
  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;


  inline constexpr float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline constexpr long double
  sin(long double __x)
  { return __builtin_sinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;


  inline constexpr float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline constexpr long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;


  inline constexpr float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline constexpr long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;


  inline constexpr float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline constexpr long double
  tan(long double __x)
  { return __builtin_tanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;


  inline constexpr float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline constexpr long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }


}
# 559 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\cmath" 3
namespace std
{





  constexpr int
  fpclassify(float __x)
  { return __builtin_fpclassify(0x0100, (0x0100 | 0x0400), 0x0400,
    (0x0400 | 0x4000), 0x4000, __x); }

  constexpr int
  fpclassify(double __x)
  { return __builtin_fpclassify(0x0100, (0x0100 | 0x0400), 0x0400,
    (0x0400 | 0x4000), 0x4000, __x); }

  constexpr int
  fpclassify(long double __x)
  { return __builtin_fpclassify(0x0100, (0x0100 | 0x0400), 0x0400,
    (0x0400 | 0x4000), 0x4000, __x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              int>::__type
    fpclassify(_Tp __x)
    { return __x != 0 ? 0x0400 : 0x4000; }


  constexpr bool
  isfinite(float __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(double __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(long double __x)
  { return __builtin_isfinite(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isfinite(_Tp __x)
    { return true; }


  constexpr bool
  isinf(float __x)
  { return __builtin_isinf(__x); }





  constexpr bool
  isinf(double __x)
  { return __builtin_isinf(__x); }


  constexpr bool
  isinf(long double __x)
  { return __builtin_isinf(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isinf(_Tp __x)
    { return false; }


  constexpr bool
  isnan(float __x)
  { return __builtin_isnan(__x); }





  constexpr bool
  isnan(double __x)
  { return __builtin_isnan(__x); }


  constexpr bool
  isnan(long double __x)
  { return __builtin_isnan(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnan(_Tp __x)
    { return false; }


  constexpr bool
  isnormal(float __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(double __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(long double __x)
  { return __builtin_isnormal(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnormal(_Tp __x)
    { return __x != 0 ? true : false; }



  constexpr bool
  signbit(float __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(double __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(long double __x)
  { return __builtin_signbit(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    signbit(_Tp __x)
    { return __x < 0 ? true : false; }


  constexpr bool
  isgreater(float __x, float __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(double __x, double __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(long double __x, long double __y)
  { return __builtin_isgreater(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreater(__type(__x), __type(__y));
    }


  constexpr bool
  isgreaterequal(float __x, float __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(double __x, double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(long double __x, long double __y)
  { return __builtin_isgreaterequal(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreaterequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreaterequal(__type(__x), __type(__y));
    }


  constexpr bool
  isless(float __x, float __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(double __x, double __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(long double __x, long double __y)
  { return __builtin_isless(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isless(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isless(__type(__x), __type(__y));
    }


  constexpr bool
  islessequal(float __x, float __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(double __x, double __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(long double __x, long double __y)
  { return __builtin_islessequal(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessequal(__type(__x), __type(__y));
    }


  constexpr bool
  islessgreater(float __x, float __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(double __x, double __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(long double __x, long double __y)
  { return __builtin_islessgreater(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessgreater(__type(__x), __type(__y));
    }


  constexpr bool
  isunordered(float __x, float __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(double __x, double __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(long double __x, long double __y)
  { return __builtin_isunordered(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isunordered(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isunordered(__type(__x), __type(__y));
    }
# 957 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\cmath" 3
}
# 1072 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\cmath" 3
namespace std
{



  using ::double_t;
  using ::float_t;


  using ::acosh;
  using ::acoshf;
  using ::acoshl;

  using ::asinh;
  using ::asinhf;
  using ::asinhl;

  using ::atanh;
  using ::atanhf;
  using ::atanhl;

  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;

  using ::copysign;
  using ::copysignf;
  using ::copysignl;

  using ::erf;
  using ::erff;
  using ::erfl;

  using ::erfc;
  using ::erfcf;
  using ::erfcl;

  using ::exp2;
  using ::exp2f;
  using ::exp2l;

  using ::expm1;
  using ::expm1f;
  using ::expm1l;

  using ::fdim;
  using ::fdimf;
  using ::fdiml;

  using ::fma;
  using ::fmaf;
  using ::fmal;

  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;

  using ::fmin;
  using ::fminf;
  using ::fminl;

  using ::hypot;
  using ::hypotf;
  using ::hypotl;

  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;

  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;

  using ::llrint;
  using ::llrintf;
  using ::llrintl;

  using ::llround;
  using ::llroundf;
  using ::llroundl;

  using ::log1p;
  using ::log1pf;
  using ::log1pl;

  using ::log2;
  using ::log2f;
  using ::log2l;

  using ::logb;
  using ::logbf;
  using ::logbl;

  using ::lrint;
  using ::lrintf;
  using ::lrintl;

  using ::lround;
  using ::lroundf;
  using ::lroundl;

  using ::nan;
  using ::nanf;
  using ::nanl;

  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;

  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;

  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;

  using ::remainder;
  using ::remainderf;
  using ::remainderl;

  using ::remquo;
  using ::remquof;
  using ::remquol;

  using ::rint;
  using ::rintf;
  using ::rintl;

  using ::round;
  using ::roundf;
  using ::roundl;

  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;

  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;

  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;

  using ::trunc;
  using ::truncf;
  using ::truncl;



  constexpr float
  acosh(float __x)
  { return __builtin_acoshf(__x); }

  constexpr long double
  acosh(long double __x)
  { return __builtin_acoshl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    acosh(_Tp __x)
    { return __builtin_acosh(__x); }


  constexpr float
  asinh(float __x)
  { return __builtin_asinhf(__x); }

  constexpr long double
  asinh(long double __x)
  { return __builtin_asinhl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    asinh(_Tp __x)
    { return __builtin_asinh(__x); }


  constexpr float
  atanh(float __x)
  { return __builtin_atanhf(__x); }

  constexpr long double
  atanh(long double __x)
  { return __builtin_atanhl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    atanh(_Tp __x)
    { return __builtin_atanh(__x); }


  constexpr float
  cbrt(float __x)
  { return __builtin_cbrtf(__x); }

  constexpr long double
  cbrt(long double __x)
  { return __builtin_cbrtl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    cbrt(_Tp __x)
    { return __builtin_cbrt(__x); }


  constexpr float
  copysign(float __x, float __y)
  { return __builtin_copysignf(__x, __y); }

  constexpr long double
  copysign(long double __x, long double __y)
  { return __builtin_copysignl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    copysign(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return copysign(__type(__x), __type(__y));
    }


  constexpr float
  erf(float __x)
  { return __builtin_erff(__x); }

  constexpr long double
  erf(long double __x)
  { return __builtin_erfl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erf(_Tp __x)
    { return __builtin_erf(__x); }


  constexpr float
  erfc(float __x)
  { return __builtin_erfcf(__x); }

  constexpr long double
  erfc(long double __x)
  { return __builtin_erfcl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erfc(_Tp __x)
    { return __builtin_erfc(__x); }


  constexpr float
  exp2(float __x)
  { return __builtin_exp2f(__x); }

  constexpr long double
  exp2(long double __x)
  { return __builtin_exp2l(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    exp2(_Tp __x)
    { return __builtin_exp2(__x); }


  constexpr float
  expm1(float __x)
  { return __builtin_expm1f(__x); }

  constexpr long double
  expm1(long double __x)
  { return __builtin_expm1l(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    expm1(_Tp __x)
    { return __builtin_expm1(__x); }


  constexpr float
  fdim(float __x, float __y)
  { return __builtin_fdimf(__x, __y); }

  constexpr long double
  fdim(long double __x, long double __y)
  { return __builtin_fdiml(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fdim(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fdim(__type(__x), __type(__y));
    }


  constexpr float
  fma(float __x, float __y, float __z)
  { return __builtin_fmaf(__x, __y, __z); }

  constexpr long double
  fma(long double __x, long double __y, long double __z)
  { return __builtin_fmal(__x, __y, __z); }


  template<typename _Tp, typename _Up, typename _Vp>
    constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    fma(_Tp __x, _Up __y, _Vp __z)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
      return fma(__type(__x), __type(__y), __type(__z));
    }


  constexpr float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }

  constexpr long double
  fmax(long double __x, long double __y)
  { return __builtin_fmaxl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmax(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmax(__type(__x), __type(__y));
    }


  constexpr float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }

  constexpr long double
  fmin(long double __x, long double __y)
  { return __builtin_fminl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmin(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmin(__type(__x), __type(__y));
    }


  constexpr float
  hypot(float __x, float __y)
  { return __builtin_hypotf(__x, __y); }

  constexpr long double
  hypot(long double __x, long double __y)
  { return __builtin_hypotl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    hypot(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return hypot(__type(__x), __type(__y));
    }


  constexpr int
  ilogb(float __x)
  { return __builtin_ilogbf(__x); }

  constexpr int
  ilogb(long double __x)
  { return __builtin_ilogbl(__x); }


  template<typename _Tp>
    constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    int>::__type
    ilogb(_Tp __x)
    { return __builtin_ilogb(__x); }


  constexpr float
  lgamma(float __x)
  { return __builtin_lgammaf(__x); }

  constexpr long double
  lgamma(long double __x)
  { return __builtin_lgammal(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    lgamma(_Tp __x)
    { return __builtin_lgamma(__x); }


  constexpr long long
  llrint(float __x)
  { return __builtin_llrintf(__x); }

  constexpr long long
  llrint(long double __x)
  { return __builtin_llrintl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llrint(_Tp __x)
    { return __builtin_llrint(__x); }


  constexpr long long
  llround(float __x)
  { return __builtin_llroundf(__x); }

  constexpr long long
  llround(long double __x)
  { return __builtin_llroundl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llround(_Tp __x)
    { return __builtin_llround(__x); }


  constexpr float
  log1p(float __x)
  { return __builtin_log1pf(__x); }

  constexpr long double
  log1p(long double __x)
  { return __builtin_log1pl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log1p(_Tp __x)
    { return __builtin_log1p(__x); }



  constexpr float
  log2(float __x)
  { return __builtin_log2f(__x); }

  constexpr long double
  log2(long double __x)
  { return __builtin_log2l(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log2(_Tp __x)
    { return __builtin_log2(__x); }


  constexpr float
  logb(float __x)
  { return __builtin_logbf(__x); }

  constexpr long double
  logb(long double __x)
  { return __builtin_logbl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    logb(_Tp __x)
    { return __builtin_logb(__x); }


  constexpr long
  lrint(float __x)
  { return __builtin_lrintf(__x); }

  constexpr long
  lrint(long double __x)
  { return __builtin_lrintl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lrint(_Tp __x)
    { return __builtin_lrint(__x); }


  constexpr long
  lround(float __x)
  { return __builtin_lroundf(__x); }

  constexpr long
  lround(long double __x)
  { return __builtin_lroundl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lround(_Tp __x)
    { return __builtin_lround(__x); }


  constexpr float
  nearbyint(float __x)
  { return __builtin_nearbyintf(__x); }

  constexpr long double
  nearbyint(long double __x)
  { return __builtin_nearbyintl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nearbyint(_Tp __x)
    { return __builtin_nearbyint(__x); }


  constexpr float
  nextafter(float __x, float __y)
  { return __builtin_nextafterf(__x, __y); }

  constexpr long double
  nextafter(long double __x, long double __y)
  { return __builtin_nextafterl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    nextafter(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return nextafter(__type(__x), __type(__y));
    }


  constexpr float
  nexttoward(float __x, long double __y)
  { return __builtin_nexttowardf(__x, __y); }

  constexpr long double
  nexttoward(long double __x, long double __y)
  { return __builtin_nexttowardl(__x, __y); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nexttoward(_Tp __x, long double __y)
    { return __builtin_nexttoward(__x, __y); }


  constexpr float
  remainder(float __x, float __y)
  { return __builtin_remainderf(__x, __y); }

  constexpr long double
  remainder(long double __x, long double __y)
  { return __builtin_remainderl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remainder(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remainder(__type(__x), __type(__y));
    }


  inline float
  remquo(float __x, float __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }

  inline long double
  remquo(long double __x, long double __y, int* __pquo)
  { return __builtin_remquol(__x, __y, __pquo); }


  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remquo(_Tp __x, _Up __y, int* __pquo)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remquo(__type(__x), __type(__y), __pquo);
    }


  constexpr float
  rint(float __x)
  { return __builtin_rintf(__x); }

  constexpr long double
  rint(long double __x)
  { return __builtin_rintl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    rint(_Tp __x)
    { return __builtin_rint(__x); }


  constexpr float
  round(float __x)
  { return __builtin_roundf(__x); }

  constexpr long double
  round(long double __x)
  { return __builtin_roundl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    round(_Tp __x)
    { return __builtin_round(__x); }


  constexpr float
  scalbln(float __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }

  constexpr long double
  scalbln(long double __x, long __ex)
  { return __builtin_scalblnl(__x, __ex); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbln(_Tp __x, long __ex)
    { return __builtin_scalbln(__x, __ex); }


  constexpr float
  scalbn(float __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }

  constexpr long double
  scalbn(long double __x, int __ex)
  { return __builtin_scalbnl(__x, __ex); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbn(_Tp __x, int __ex)
    { return __builtin_scalbn(__x, __ex); }


  constexpr float
  tgamma(float __x)
  { return __builtin_tgammaf(__x); }

  constexpr long double
  tgamma(long double __x)
  { return __builtin_tgammal(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    tgamma(_Tp __x)
    { return __builtin_tgamma(__x); }


  constexpr float
  trunc(float __x)
  { return __builtin_truncf(__x); }

  constexpr long double
  trunc(long double __x)
  { return __builtin_truncl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    trunc(_Tp __x)
    { return __builtin_trunc(__x); }


}
# 1797 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\cmath" 3
}
# 37 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\math.h" 2 3

using std::abs;
using std::acos;
using std::asin;
using std::atan;
using std::atan2;
using std::cos;
using std::sin;
using std::tan;
using std::cosh;
using std::sinh;
using std::tanh;
using std::exp;
using std::frexp;
using std::ldexp;
using std::log;
using std::log10;
using std::modf;
using std::pow;
using std::sqrt;
using std::ceil;
using std::fabs;
using std::floor;
using std::fmod;


using std::fpclassify;
using std::isfinite;
using std::isinf;
using std::isnan;
using std::isnormal;
using std::signbit;
using std::isgreater;
using std::isgreaterequal;
using std::isless;
using std::islessequal;
using std::islessgreater;
using std::isunordered;



using std::acosh;
using std::asinh;
using std::atanh;
using std::cbrt;
using std::copysign;
using std::erf;
using std::erfc;
using std::exp2;
using std::expm1;
using std::fdim;
using std::fma;
using std::fmax;
using std::fmin;
using std::hypot;
using std::ilogb;
using std::lgamma;
using std::llrint;
using std::llround;
using std::log1p;
using std::log2;
using std::logb;
using std::lrint;
using std::lround;
using std::nearbyint;
using std::nextafter;
using std::nexttoward;
using std::remainder;
using std::remquo;
using std::rint;
using std::round;
using std::scalbln;
using std::scalbn;
using std::tgamma;
using std::trunc;
# 8 "pooling_layer2.cpp" 2

# 1 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src\\hls_video.h" 1
# 48 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src\\hls_video.h"
# 1 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_axi_io.h" 1
# 39 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_axi_io.h"
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_axi_sdata.h" 1
# 87 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_axi_sdata.h"
# 1 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\climits" 1 3
# 40 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\climits" 3


# 1 "C:\\Xilinx\\Vitis_HLS\\2020.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\limits.h" 1 3
# 37 "C:\\Xilinx\\Vitis_HLS\\2020.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\limits.h" 3
# 1 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\limits.h" 1 3
# 38 "C:\\Xilinx\\Vitis_HLS\\2020.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\limits.h" 2 3
# 43 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\climits" 2 3
# 88 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_axi_sdata.h" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/ap_int.h" 1
# 89 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\ap_axi_sdata.h" 2

template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
struct ap_fixed;
template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
struct ap_ufixed;

namespace hls {

template <typename T> constexpr size_t bitwidth = sizeof(T) * 8;

template <size_t W> constexpr size_t bitwidth<ap_int<W>> = W;
template <size_t W> constexpr size_t bitwidth<ap_uint<W>> = W;
template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
constexpr size_t bitwidth<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>> = _AP_W;
template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
constexpr size_t bitwidth<ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>> = _AP_W;

template <typename T>
constexpr size_t bytewidth = (bitwidth<T> + 8 - 1) / 8;

template <typename T, size_t WUser, size_t WId, size_t WDest> struct axis {
  static constexpr size_t NewWUser = (WUser == 0) ? 1 : WUser;
  static constexpr size_t NewWId = (WId == 0) ? 1 : WId;
  static constexpr size_t NewWDest = (WDest == 0) ? 1 : WDest;
  T data;
  ap_uint<bytewidth<T>> keep;
  ap_uint<bytewidth<T>> strb;
  ap_uint<NewWUser> user;
  ap_uint<1> last;
  ap_uint<NewWId> id;
  ap_uint<NewWDest> dest;

  ap_uint<NewWUser> *get_user_ptr() {
#pragma HLS inline
 return (WUser == 0) ? nullptr : &user;
  }
  ap_uint<NewWId> *get_id_ptr() {
#pragma HLS inline
 return (WId == 0) ? nullptr : &id;
  }
  ap_uint<NewWDest> *get_dest_ptr() {
#pragma HLS inline
 return (WDest == 0) ? nullptr : &dest;
  }
};

}

template <size_t WData, size_t WUser, size_t WId, size_t WDest>
using ap_axis = hls::axis<ap_int<WData>, WUser, WId, WDest>;

template <size_t WData, size_t WUser, size_t WId, size_t WDest>
using ap_axiu = hls::axis<ap_uint<WData>, WUser, WId, WDest>;


template <size_t WData, size_t WUser, size_t WId, size_t WDest>
struct qdma_axis;

template <size_t WData> struct qdma_axis<WData, 0, 0, 0> {

  static constexpr size_t kBytes = (WData + 7) / 8;

  ap_uint<WData> data;
  ap_uint<kBytes> keep;
  ap_uint<1> strb;
  ap_uint<1> user;
  ap_uint<1> last;
  ap_uint<1> id;
  ap_uint<1> dest;

  ap_uint<1> *get_strb_ptr() {
#pragma HLS inline
 return nullptr;
  }
  ap_uint<1> *get_user_ptr() {
#pragma HLS inline
 return nullptr;
  }
  ap_uint<1> *get_id_ptr() {
#pragma HLS inline
 return nullptr;
  }
  ap_uint<1> *get_dest_ptr() {
#pragma HLS inline
 return nullptr;
  }


  ap_uint<WData> get_data() const {
#pragma HLS inline
 return data;
  }
  ap_uint<kBytes> get_keep() const {
#pragma HLS inline
 return keep;
  }
  ap_uint<1> get_last() const {
#pragma HLS inline
 return last;
  }

  void set_data(const ap_uint<WData> &d) {
#pragma HLS inline
 data = d;
  }
  void set_keep(const ap_uint<kBytes> &k) {
#pragma HLS inline
 keep = k;
  }
  void set_last(const ap_uint<1> &l) {
#pragma HLS inline
 last = l;
  }
  void keep_all() {
#pragma HLS inline
 ap_uint<kBytes> k = 0;
    keep = ~k;
  }

  qdma_axis() {
#pragma HLS inline
 ;
  }
  qdma_axis(ap_uint<WData> d) : data(d) {
#pragma HLS inline
 ;
  }
  qdma_axis(ap_uint<WData> d, ap_uint<kBytes> k) : data(d), keep(k) {
#pragma HLS inline
 ;
  }
  qdma_axis(ap_uint<WData> d, ap_uint<kBytes> k, ap_uint<1> l)
      : data(d), keep(k), last(l) {
#pragma HLS inline
 ;
  }
  qdma_axis(const qdma_axis<WData, 0, 0, 0> &d)
      : data(d.data), keep(d.keep), last(d.last) {
#pragma HLS inline
 ;
  }
  qdma_axis &operator=(const qdma_axis<WData, 0, 0, 0> &d) {
#pragma HLS inline
 data = d.data;
    keep = d.keep;
    last = d.last;
    return *this;
  }
};




namespace hls {

template <typename T, size_t WUser, size_t WId, size_t WDest>
class stream<axis<T, WUser, WId, WDest>> {
  typedef axis<T, WUser, WId, WDest> __STREAM_T__;

public:

  inline __attribute__((always_inline)) stream() {}

  inline __attribute__((always_inline)) stream(const char *name) { (void)name; }


private:
  inline __attribute__((always_inline)) stream(const stream<__STREAM_T__> &chn) : V(chn.V) {}

public:

  inline __attribute__((always_inline)) void operator>>(__STREAM_T__ &rdata) { read(rdata); }

  inline __attribute__((always_inline)) void operator<<(const __STREAM_T__ &wdata) { write(wdata); }


  bool empty() {
#pragma HLS inline
 bool tmp = __fpga_axis_valid(&V.data, &V.keep, &V.strb, V.get_user_ptr(),
                                 &V.last, V.get_id_ptr(), V.get_dest_ptr());
    return !tmp;
  }

  bool full() {
#pragma HLS inline
 bool tmp = __fpga_axis_ready(&V.data, &V.keep, &V.strb, V.get_user_ptr(),
                                 &V.last, V.get_id_ptr(), V.get_dest_ptr());
    return !tmp;
  }


  void read(__STREAM_T__ &dout) {
#pragma HLS inline
 __STREAM_T__ tmp;
    __fpga_axis_pop(&V.data, &V.keep, &V.strb, V.get_user_ptr(), &V.last,
                    V.get_id_ptr(), V.get_dest_ptr(), &tmp.data, &tmp.keep,
                    &tmp.strb, tmp.get_user_ptr(), &tmp.last, tmp.get_id_ptr(),
                    tmp.get_dest_ptr());
    dout = tmp;
  }

  __STREAM_T__ read() {
#pragma HLS inline
 __STREAM_T__ tmp;
    __fpga_axis_pop(&V.data, &V.keep, &V.strb, V.get_user_ptr(), &V.last,
                    V.get_id_ptr(), V.get_dest_ptr(), &tmp.data, &tmp.keep,
                    &tmp.strb, tmp.get_user_ptr(), &tmp.last, tmp.get_id_ptr(),
                    tmp.get_dest_ptr());
    return tmp;
  }


  void write(const __STREAM_T__ &din) {
#pragma HLS inline
 __STREAM_T__ tmp = din;
    __fpga_axis_push(&V.data, &V.keep, &V.strb, V.get_user_ptr(), &V.last,
                     V.get_id_ptr(), V.get_dest_ptr(), &tmp.data, &tmp.keep,
                     &tmp.strb, tmp.get_user_ptr(), &tmp.last, tmp.get_id_ptr(),
                     tmp.get_dest_ptr());
  }


  bool read_nb(__STREAM_T__ &dout) {
#pragma HLS inline
 __STREAM_T__ tmp;
    if (__fpga_axis_nb_pop(&V.data, &V.keep, &V.strb, V.get_user_ptr(), &V.last,
                           V.get_id_ptr(), V.get_dest_ptr(), &tmp.data,
                           &tmp.keep, &tmp.strb, tmp.get_user_ptr(),
                           &tmp.last, tmp.get_id_ptr(), tmp.get_dest_ptr())) {
      dout = tmp;
      return true;
    } else {
      return false;
    }
  }


  bool write_nb(const __STREAM_T__ &in) {
#pragma HLS inline
 __STREAM_T__ tmp = in;
    bool full_n = __fpga_axis_nb_push(
        &V.data, &V.keep, &V.strb, V.get_user_ptr(), &V.last, V.get_id_ptr(),
        V.get_dest_ptr(), &tmp.data, &tmp.keep, &tmp.strb, tmp.get_user_ptr(),
        &tmp.last, tmp.get_id_ptr(), tmp.get_dest_ptr());
    return full_n;
  }

private:
  __STREAM_T__ V __attribute__((no_ctor));
};


template <size_t WData>
class stream<qdma_axis<WData, 0, 0, 0>> {
  typedef qdma_axis<WData, 0, 0, 0> __STREAM_T__;

public:

  inline __attribute__((always_inline)) stream() {}

  inline __attribute__((always_inline)) stream(const char *name) { (void)name; }


private:
  inline __attribute__((always_inline)) stream(const stream<__STREAM_T__> &chn) : V(chn.V) {}

public:

  inline __attribute__((always_inline)) void operator>>(__STREAM_T__ &rdata) { read(rdata); }

  inline __attribute__((always_inline)) void operator<<(const __STREAM_T__ &wdata) { write(wdata); }


  bool empty() {
#pragma HLS inline
 bool tmp = __fpga_axis_valid(&V.data, &V.keep, V.get_strb_ptr(), V.get_user_ptr(),
                                 &V.last, V.get_id_ptr(), V.get_dest_ptr());
    return !tmp;
  }

  bool full() {
#pragma HLS inline
 bool tmp = __fpga_axis_ready(&V.data, &V.keep, V.get_strb_ptr(), V.get_user_ptr(),
                                 &V.last, V.get_id_ptr(), V.get_dest_ptr());
    return !tmp;
  }


  void read(__STREAM_T__ &dout) {
#pragma HLS inline
 __STREAM_T__ tmp;
    __fpga_axis_pop(&V.data, &V.keep, V.get_strb_ptr(), V.get_user_ptr(),
                    &V.last, V.get_id_ptr(), V.get_dest_ptr(), &tmp.data,
                    &tmp.keep, tmp.get_strb_ptr(), tmp.get_user_ptr(),
                    &tmp.last, tmp.get_id_ptr(), tmp.get_dest_ptr());
    dout = tmp;
  }

  __STREAM_T__ read() {
#pragma HLS inline
 __STREAM_T__ tmp;
    __fpga_axis_pop(&V.data, &V.keep, V.get_strb_ptr(), V.get_user_ptr(), &V.last,
                    V.get_id_ptr(), V.get_dest_ptr(), &tmp.data, &tmp.keep,
                    tmp.get_strb_ptr(), tmp.get_user_ptr(), &tmp.last, tmp.get_id_ptr(),
                    tmp.get_dest_ptr());
    return tmp;
  }


  void write(const __STREAM_T__ &din) {
#pragma HLS inline
 __STREAM_T__ tmp = din;
    __fpga_axis_push(&V.data, &V.keep, V.get_strb_ptr(), V.get_user_ptr(), &V.last,
                     V.get_id_ptr(), V.get_dest_ptr(), &tmp.data, &tmp.keep,
                     tmp.get_strb_ptr(), tmp.get_user_ptr(), &tmp.last, tmp.get_id_ptr(),
                     tmp.get_dest_ptr());
  }


  bool read_nb(__STREAM_T__ &dout) {
#pragma HLS inline
 __STREAM_T__ tmp;

    if (__fpga_axis_nb_pop(&V.data, &V.keep, &V.strb, V.get_user_ptr(), &V.last,
                           V.get_id_ptr(), V.get_dest_ptr(), &tmp.data,
                           &tmp.keep, &tmp.strb, tmp.get_user_ptr(),
                           &tmp.last, tmp.get_id_ptr(), tmp.get_dest_ptr())) {
      dout = tmp;
      return true;
    } else {
      return false;
    }
  }


  bool write_nb(const __STREAM_T__ &in) {
#pragma HLS inline
 __STREAM_T__ tmp = in;
    bool full_n = __fpga_axis_nb_push(
        &V.data, &V.keep, V.get_strb_ptr(), V.get_user_ptr(), &V.last, V.get_id_ptr(),
        V.get_dest_ptr(), &tmp.data, &tmp.keep, tmp.get_strb_ptr(), tmp.get_user_ptr(),
        &tmp.last, tmp.get_id_ptr(), tmp.get_dest_ptr());
    return full_n;
  }

private:
  __STREAM_T__ V __attribute__((no_ctor));
};

}
# 40 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_axi_io.h" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/39\\utils/x_hls_utils.h" 1
# 35 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/39\\utils/x_hls_utils.h"
# 1 "C:\\Xilinx\\Vitis_HLS\\2020.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\stdint.h" 1 3
# 63 "C:\\Xilinx\\Vitis_HLS\\2020.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\stdint.h" 3
# 1 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdint.h" 1 3
# 32 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdint.h" 3
# 1 "C:\\Xilinx\\Vitis_HLS\\2020.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\stddef.h" 1 3
# 33 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdint.h" 2 3


typedef signed char int8_t;
typedef unsigned char uint8_t;
typedef short int16_t;
typedef unsigned short uint16_t;
typedef int int32_t;
typedef unsigned uint32_t;
__extension__ typedef long long int64_t;
__extension__ typedef unsigned long long uint64_t;


typedef signed char int_least8_t;
typedef unsigned char uint_least8_t;
typedef short int_least16_t;
typedef unsigned short uint_least16_t;
typedef int int_least32_t;
typedef unsigned uint_least32_t;
__extension__ typedef long long int_least64_t;
__extension__ typedef unsigned long long uint_least64_t;





typedef signed char int_fast8_t;
typedef unsigned char uint_fast8_t;
typedef short int_fast16_t;
typedef unsigned short uint_fast16_t;
typedef int int_fast32_t;
typedef unsigned int uint_fast32_t;
__extension__ typedef long long int_fast64_t;
__extension__ typedef unsigned long long uint_fast64_t;


__extension__ typedef long long intmax_t;
__extension__ typedef unsigned long long uintmax_t;
# 64 "C:\\Xilinx\\Vitis_HLS\\2020.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\stdint.h" 2 3
# 36 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/39\\utils/x_hls_utils.h" 2

# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_half.h" 1
# 38 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/39\\utils/x_hls_utils.h" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\limits" 1 3
# 41 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\limits" 3
# 158 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\limits" 3
namespace std
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 202 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\limits" 3
  struct __numeric_limits_base
  {


    static constexpr bool is_specialized = false;




    static constexpr int digits = 0;


    static constexpr int digits10 = 0;




    static constexpr int max_digits10 = 0;



    static constexpr bool is_signed = false;


    static constexpr bool is_integer = false;




    static constexpr bool is_exact = false;



    static constexpr int radix = 0;



    static constexpr int min_exponent = 0;



    static constexpr int min_exponent10 = 0;




    static constexpr int max_exponent = 0;



    static constexpr int max_exponent10 = 0;


    static constexpr bool has_infinity = false;



    static constexpr bool has_quiet_NaN = false;



    static constexpr bool has_signaling_NaN = false;


    static constexpr float_denorm_style has_denorm = denorm_absent;



    static constexpr bool has_denorm_loss = false;



    static constexpr bool is_iec559 = false;




    static constexpr bool is_bounded = false;
# 288 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\limits" 3
    static constexpr bool is_modulo = false;


    static constexpr bool traps = false;


    static constexpr bool tinyness_before = false;




    static constexpr float_round_style round_style =
          round_toward_zero;
  };
# 314 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static constexpr _Tp
      min() noexcept { return _Tp(); }


      static constexpr _Tp
      max() noexcept { return _Tp(); }




      static constexpr _Tp
      lowest() noexcept { return _Tp(); }




      static constexpr _Tp
      epsilon() noexcept { return _Tp(); }


      static constexpr _Tp
      round_error() noexcept { return _Tp(); }


      static constexpr _Tp
      infinity() noexcept { return _Tp(); }



      static constexpr _Tp
      quiet_NaN() noexcept { return _Tp(); }



      static constexpr _Tp
      signaling_NaN() noexcept { return _Tp(); }




      static constexpr _Tp
      denorm_min() noexcept { return _Tp(); }
    };


  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };






  template<>
    struct numeric_limits<bool>
    {
      static constexpr bool is_specialized = true;

      static constexpr bool
      min() noexcept { return false; }

      static constexpr bool
      max() noexcept { return true; }


      static constexpr bool
      lowest() noexcept { return min(); }

      static constexpr int digits = 1;
      static constexpr int digits10 = 0;

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr bool
      epsilon() noexcept { return false; }

      static constexpr bool
      round_error() noexcept { return false; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr bool
      infinity() noexcept { return false; }

      static constexpr bool
      quiet_NaN() noexcept { return false; }

      static constexpr bool
      signaling_NaN() noexcept { return false; }

      static constexpr bool
      denorm_min() noexcept { return false; }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;




      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static constexpr bool is_specialized = true;

      static constexpr char
      min() noexcept { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }

      static constexpr char
      max() noexcept { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }


      static constexpr char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((char)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char
      epsilon() noexcept { return 0; }

      static constexpr char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr
      char infinity() noexcept { return char(); }

      static constexpr char
      quiet_NaN() noexcept { return char(); }

      static constexpr char
      signaling_NaN() noexcept { return char(); }

      static constexpr char
      denorm_min() noexcept { return static_cast<char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static constexpr bool is_specialized = true;

      static constexpr signed char
      min() noexcept { return -127 - 1; }

      static constexpr signed char
      max() noexcept { return 127; }


      static constexpr signed char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr signed char
      epsilon() noexcept { return 0; }

      static constexpr signed char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr signed char
      infinity() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      quiet_NaN() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      signaling_NaN() noexcept
      { return static_cast<signed char>(0); }

      static constexpr signed char
      denorm_min() noexcept
      { return static_cast<signed char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned char
      min() noexcept { return 0; }

      static constexpr unsigned char
      max() noexcept { return 127 * 2U + 1; }


      static constexpr unsigned char
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned char
      epsilon() noexcept { return 0; }

      static constexpr unsigned char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned char
      infinity() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      quiet_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      signaling_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      denorm_min() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr wchar_t
      min() noexcept { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0); }

      static constexpr wchar_t
      max() noexcept { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }


      static constexpr wchar_t
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((wchar_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr wchar_t
      epsilon() noexcept { return 0; }

      static constexpr wchar_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr wchar_t
      infinity() noexcept { return wchar_t(); }

      static constexpr wchar_t
      quiet_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      signaling_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      denorm_min() noexcept { return wchar_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };



  template<>
    struct numeric_limits<char16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char16_t
      min() noexcept { return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (char16_t)0); }

      static constexpr char16_t
      max() noexcept { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }

      static constexpr char16_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char16_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char16_t
      epsilon() noexcept { return 0; }

      static constexpr char16_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char16_t
      infinity() noexcept { return char16_t(); }

      static constexpr char16_t
      quiet_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      signaling_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      denorm_min() noexcept { return char16_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char32_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char32_t
      min() noexcept { return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (char32_t)0); }

      static constexpr char32_t
      max() noexcept { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }

      static constexpr char32_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char32_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char32_t
      epsilon() noexcept { return 0; }

      static constexpr char32_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char32_t
      infinity() noexcept { return char32_t(); }

      static constexpr char32_t
      quiet_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      signaling_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      denorm_min() noexcept { return char32_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };



  template<>
    struct numeric_limits<short>
    {
      static constexpr bool is_specialized = true;

      static constexpr short
      min() noexcept { return -32767 - 1; }

      static constexpr short
      max() noexcept { return 32767; }


      static constexpr short
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr short
      epsilon() noexcept { return 0; }

      static constexpr short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr short
      infinity() noexcept { return short(); }

      static constexpr short
      quiet_NaN() noexcept { return short(); }

      static constexpr short
      signaling_NaN() noexcept { return short(); }

      static constexpr short
      denorm_min() noexcept { return short(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned short
      min() noexcept { return 0; }

      static constexpr unsigned short
      max() noexcept { return 32767 * 2U + 1; }


      static constexpr unsigned short
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned short
      epsilon() noexcept { return 0; }

      static constexpr unsigned short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned short
      infinity() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      quiet_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      signaling_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      denorm_min() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static constexpr bool is_specialized = true;

      static constexpr int
      min() noexcept { return -2147483647 - 1; }

      static constexpr int
      max() noexcept { return 2147483647; }


      static constexpr int
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr int
      epsilon() noexcept { return 0; }

      static constexpr int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr int
      infinity() noexcept { return static_cast<int>(0); }

      static constexpr int
      quiet_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      signaling_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      denorm_min() noexcept { return static_cast<int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned int
      min() noexcept { return 0; }

      static constexpr unsigned int
      max() noexcept { return 2147483647 * 2U + 1; }


      static constexpr unsigned int
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned int
      epsilon() noexcept { return 0; }

      static constexpr unsigned int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned int
      infinity() noexcept { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      quiet_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      signaling_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      denorm_min() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long
      min() noexcept { return -9223372036854775807L - 1; }

      static constexpr long
      max() noexcept { return 9223372036854775807L; }


      static constexpr long
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long
      epsilon() noexcept { return 0; }

      static constexpr long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long
      infinity() noexcept { return static_cast<long>(0); }

      static constexpr long
      quiet_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      signaling_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      denorm_min() noexcept { return static_cast<long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long
      min() noexcept { return 0; }

      static constexpr unsigned long
      max() noexcept { return 9223372036854775807L * 2UL + 1; }


      static constexpr unsigned long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long
      infinity() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      quiet_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      signaling_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      denorm_min() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long long
      min() noexcept { return -9223372036854775807LL - 1; }

      static constexpr long long
      max() noexcept { return 9223372036854775807LL; }


      static constexpr long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long long
      epsilon() noexcept { return 0; }

      static constexpr long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long long
      infinity() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      quiet_NaN() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      signaling_NaN() noexcept
      { return static_cast<long long>(0); }

      static constexpr long long
      denorm_min() noexcept { return static_cast<long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long long
      min() noexcept { return 0; }

      static constexpr unsigned long long
      max() noexcept { return 9223372036854775807LL * 2ULL + 1; }


      static constexpr unsigned long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long long
      infinity() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      quiet_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      signaling_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      denorm_min() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
# 1569 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\limits" 3
  template<> struct numeric_limits<__int128> { static constexpr bool is_specialized = true; static constexpr __int128 min() noexcept { return (((__int128)(-1) < 0) ? -(((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0) - 1 : (__int128)0); } static constexpr __int128 max() noexcept { return (((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0); } static constexpr int digits = 128 - 1; static constexpr int digits10 = (128 - 1) * 643L / 2136; static constexpr bool is_signed = true; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr __int128 epsilon() noexcept { return 0; } static constexpr __int128 round_error() noexcept { return 0; } static constexpr __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr __int128 infinity() noexcept { return static_cast<__int128>(0); } static constexpr __int128 quiet_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 signaling_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 denorm_min() noexcept { return static_cast<__int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = false; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; }; template<> struct numeric_limits<unsigned __int128> { static constexpr bool is_specialized = true; static constexpr unsigned __int128 min() noexcept { return 0; } static constexpr unsigned __int128 max() noexcept { return (((unsigned __int128)(-1) < 0) ? (((((unsigned __int128)1 << ((128 - ((unsigned __int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(unsigned __int128)0); } static constexpr unsigned __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int digits = 128; static constexpr int digits10 = 128 * 643L / 2136; static constexpr bool is_signed = false; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr unsigned __int128 epsilon() noexcept { return 0; } static constexpr unsigned __int128 round_error() noexcept { return 0; } static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr unsigned __int128 infinity() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 quiet_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 signaling_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 denorm_min() noexcept { return static_cast<unsigned __int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = true; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; };
# 1592 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\limits" 3
  template<>
    struct numeric_limits<float>
    {
      static constexpr bool is_specialized = true;

      static constexpr float
      min() noexcept { return 1.17549435e-38F; }

      static constexpr float
      max() noexcept { return 3.40282347e+38F; }


      static constexpr float
      lowest() noexcept { return -3.40282347e+38F; }


      static constexpr int digits = 24;
      static constexpr int digits10 = 6;

      static constexpr int max_digits10
  = (2 + (24) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr float
      epsilon() noexcept { return 1.19209290e-7F; }

      static constexpr float
      round_error() noexcept { return 0.5F; }

      static constexpr int min_exponent = (-125);
      static constexpr int min_exponent10 = (-37);
      static constexpr int max_exponent = 128;
      static constexpr int max_exponent10 = 38;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
       = false;

      static constexpr float
      infinity() noexcept { return __builtin_huge_valf(); }

      static constexpr float
      quiet_NaN() noexcept { return __builtin_nanf(""); }

      static constexpr float
      signaling_NaN() noexcept { return __builtin_nansf(""); }

      static constexpr float
      denorm_min() noexcept { return 1.40129846e-45F; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static constexpr bool is_specialized = true;

      static constexpr double
      min() noexcept { return 2.2250738585072014e-308; }

      static constexpr double
      max() noexcept { return 1.7976931348623157e+308; }


      static constexpr double
      lowest() noexcept { return -1.7976931348623157e+308; }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr double
      epsilon() noexcept { return 2.2204460492503131e-16; }

      static constexpr double
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
        = false;

      static constexpr double
      infinity() noexcept { return __builtin_huge_val(); }

      static constexpr double
      quiet_NaN() noexcept { return __builtin_nan(""); }

      static constexpr double
      signaling_NaN() noexcept { return __builtin_nans(""); }

      static constexpr double
      denorm_min() noexcept { return 4.9406564584124654e-324; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static constexpr bool is_specialized = true;

      static constexpr long double
      min() noexcept { return 2.2250738585072014e-308L; }

      static constexpr long double
      max() noexcept { return 1.7976931348623157e+308L; }


      static constexpr long double
      lowest() noexcept { return -1.7976931348623157e+308L; }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr long double
      epsilon() noexcept { return 2.2204460492503131e-16L; }

      static constexpr long double
      round_error() noexcept { return 0.5L; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
 = false;

      static constexpr long double
      infinity() noexcept { return __builtin_huge_vall(); }

      static constexpr long double
      quiet_NaN() noexcept { return __builtin_nanl(""); }

      static constexpr long double
      signaling_NaN() noexcept { return __builtin_nansl(""); }

      static constexpr long double
      denorm_min() noexcept { return 4.9406564584124654e-324L; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before =
      false;
      static constexpr float_round_style round_style =
            round_to_nearest;
    };






}
# 39 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/39\\utils/x_hls_utils.h" 2
# 69 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/39\\utils/x_hls_utils.h"
namespace hls {

    template<typename T>
    class numeric_limits {
    public:
        static T max() { return std::numeric_limits<T>::max(); }
        static T min() { return std::numeric_limits<T>::min(); }
        static T epsilon() { return std::numeric_limits<T>::epsilon(); }
    };

    template <int W, int I, ap_q_mode Q, ap_o_mode O>
    class numeric_limits<ap_fixed<W,I,Q,O> > {
    public:
        static ap_fixed<W,I,Q,O> max() {
            ap_int<W> m = ::hls::numeric_limits<ap_int<W> >::max();
            ap_fixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_fixed<W,I,Q,O> min() {
            ap_int<W> m = ::hls::numeric_limits<ap_int<W> >::min();
            ap_fixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_fixed<W,I,Q,O> epsilon() {
          ap_fixed<W,I,Q,O> x = 0;
          x[0] = 1;

          return x;
        }
    };

    template <int W, int I, ap_q_mode Q, ap_o_mode O>
    class numeric_limits<ap_ufixed<W,I,Q,O> > {
    public:
        static ap_ufixed<W,I,Q,O> max() {
            ap_uint<W> m = ::hls::numeric_limits<ap_uint<W> >::max();
            ap_ufixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_ufixed<W,I,Q,O> min() { return 0; }
        static ap_ufixed<W,I,Q,O> epsilon() {
          ap_ufixed<W,I,Q,O> x = 0;
          x[0] = 1;
          return x;
        }
    };

    template <int W>
    class numeric_limits<ap_int<W> > {
    public:
        static ap_int<W> max() { ap_int<W> m = min(); return ~m; }
        static ap_int<W> min() { ap_int<W> m = 0; m[W-1] = 1; return m; }
        static ap_int<W> epsilon() {
          ap_int<W> x = 0;
          x[0] = 1;
          return x;
        }
    };

    template <int W>
    class numeric_limits<ap_uint<W> > {
    public:
        static ap_uint<W> max() { ap_uint<W> zero = 0; return ~zero; }
        static ap_uint<W> min() { return 0; }
        static ap_uint<W> epsilon() {
          ap_uint<W> x = 0;
          x[0] = 1;
          return x;
        }
    };
}


namespace hlstmp {

    template<typename T>
    class numeric_limits {
    public:
        static T max() { return std::numeric_limits<T>::max(); }
        static T min() { return std::numeric_limits<T>::min(); }
        static T epsilon() { return std::numeric_limits<T>::epsilon(); }
    };

    template <int W, int I, ap_q_mode Q, ap_o_mode O>
    class numeric_limits<ap_fixed<W,I,Q,O> > {
    public:
        static ap_fixed<W,I,Q,O> max() {
            ap_int<W> m = ::hlstmp::numeric_limits<ap_int<W> >::max();
            ap_fixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_fixed<W,I,Q,O> min() {
            ap_int<W> m = ::hlstmp::numeric_limits<ap_int<W> >::min();
            ap_fixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_fixed<W,I,Q,O> epsilon() {
          ap_fixed<W,I,Q,O> x = 0;
          x[0] = 1;

          return x;
        }
    };

    template <int W, int I, ap_q_mode Q, ap_o_mode O>
    class numeric_limits<ap_ufixed<W,I,Q,O> > {
    public:
        static ap_ufixed<W,I,Q,O> max() {
            ap_uint<W> m = ::hlstmp::numeric_limits<ap_uint<W> >::max();
            ap_ufixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_ufixed<W,I,Q,O> min() { return 0; }
        static ap_ufixed<W,I,Q,O> epsilon() {
          ap_ufixed<W,I,Q,O> x = 0;
          x[0] = 1;
          return x;
        }
    };

    template <int W>
    class numeric_limits<ap_int<W> > {
    public:
        static ap_int<W> max() { ap_int<W> m = min(); return ~m; }
        static ap_int<W> min() { ap_int<W> m = 0; m[W-1] = 1; return m; }
        static ap_int<W> epsilon() {
          ap_int<W> x = 0;
          x[0] = 1;
          return x;
        }
    };

    template <int W>
    class numeric_limits<ap_uint<W> > {
    public:
        static ap_uint<W> max() { ap_uint<W> zero = 0; return ~zero; }
        static ap_uint<W> min() { return 0; }
        static ap_uint<W> epsilon() {
          ap_uint<W> x = 0;
          x[0] = 1;
          return x;
        }
    };
}


static inline
const
uint32_t pow2(uint32_t e)
{
    switch(e) {
        case 0: return 1; break;
        case 1: return 2; break;
        case 2: return 4; break;
        case 3: return 8; break;
        case 4: return 16; break;
        case 5: return 32; break;
        case 6: return 64; break;
        case 7: return 128; break;
        case 8: return 256; break;
        case 9: return 512; break;
        case 10: return 1024; break;
        case 11: return 2048; break;
        default: return 0;
    }
}

template<typename T>
__attribute__((hls_preserve)) T reg(T d)
{
#pragma HLS PIPELINE II=1
#pragma HLS LATENCY min=1 max=1
#pragma HLS INLINE off
 return d;
}
# 266 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/39\\utils/x_hls_utils.h"
static inline
float to_float(float v)
{
    return v;
}

template<int _W, int _I>
float to_float(ap_fixed<_W, _I> v)
{
    return v.to_float();
}
# 285 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/39\\utils/x_hls_utils.h"
template <typename T>
class fp_struct
{
};

union single_cast {
    float f;
    uint32_t i;
};

template <>
class fp_struct<float>
{
public:
    const static int EXP_INFNAN = 255;
    const static int EXP_BIAS = 127;
    const static int EXP_BITS = 8;
    const static int SIG_BITS = 23;
    const static int BITS = 32;

    fp_struct() {
    }
    fp_struct(float f) {


        union single_cast dc;
        dc.f = f;
        ap_uint<32> data = dc.i;





        sign[0] = data[31];
        exp(7,0)= data(30,23);
        sig(22,0)= data(22,0);
    }
    fp_struct(ap_uint<32> data) {
        sign[0] = data[31];
        exp(7,0)= data(30,23);
        sig(22,0)= data(22,0);
    }
    fp_struct(uint32_t i) {
        ap_uint<32> data = i;
        sign[0] = data[31];
        exp(7,0)= data(30,23);
        sig(22,0)= data(22,0);
    }
    inline ap_uint<32> data() const {
        ap_uint<32> t;
        t[31] = sign[0];
        t(30,23) = exp(7,0);
        t(22,0) = sig(22,0);
        return t;
    }
    inline int expv() const {
        return exp-127;
    }
    inline int32_t to_int() const {
        return data().to_int();
    }
    inline float to_float() const {


        union single_cast ret;
        ret.i = data().to_uint();
        return ret.f;







    }
    inline void set_mantissa(ap_ufixed<1+SIG_BITS,1> mantissa) {
        ap_ufixed<SIG_BITS,0> significand = mantissa;
        sig = significand(SIG_BITS-1,0);
    }
    inline ap_ufixed<1+SIG_BITS,1> mantissa() const {
        ap_ufixed<1+SIG_BITS,1> y = 0;
        y(y.wl()-1,0) = sig(SIG_BITS-1,0);
        y[y.wl()-1] = 1;
        return y;
    }
    inline float to_ieee() const {
        return to_float();
    }
    inline int __signbit() const {
        return sign.to_int();
    }

    static float infinity() {
        fp_struct<float> x;
        x.sign = 0;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    static float minus_infinity() {
        fp_struct<float> x;
        x.sign = 1;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    typedef uint32_t inttype;
    typedef ap_uint<32> data_type;
    ap_uint<1> sign;
    ap_uint<EXP_BITS> exp;
    ap_uint<SIG_BITS> sig;
};
# 415 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/39\\utils/x_hls_utils.h"
static inline
void
castSingle(
    float din,
    fp_struct<float> &dout)
{
    fp_struct<float> t(din);
    dout = t;
}

static inline
float
castSingle(
    fp_struct<float> din)
{
    return din.to_float();
}

static inline
void
dumpSingle(
    float da,
    fp_struct<float> ds)
{
# 452 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/39\\utils/x_hls_utils.h"
   (void)(da);
   (void)(ds);

}







union double_cast {
    double d;
    uint64_t i;
};

template <>
class fp_struct<double>
{
public:
    const static int EXP_INFNAN = 2047;
    const static int EXP_BIAS = 1023;
    const static int EXP_BITS = 11;
    const static int SIG_BITS = 52;
    const static int BITS = 64;

    fp_struct() {
    }
    fp_struct(double f) {
        union double_cast dc;
        dc.d = f;
        ap_uint<64> data = dc.i;
        sign[0] = data[63];
        exp(10,0) = data(62,52);
        sig(51,0) = data(51,0);
    }
    fp_struct(ap_uint<64> data) {
        sign[0] = data[63];
        exp(10,0) = data(62,52);
        sig(51,0) = data(51,0);
    }
    fp_struct(uint64_t i) {
        ap_uint<64> data = i;
        sign[0] = data[EXP_BITS+SIG_BITS+1-1];
        exp(EXP_BITS-1,0) = data(EXP_BITS-1+SIG_BITS,SIG_BITS);
        sig(SIG_BITS-1,0) = data(SIG_BITS-1,0);
    }
    inline ap_uint<64> data() const {
        ap_uint<64> t;
        t[EXP_BITS+SIG_BITS+1-1] = sign[0];
        t(EXP_BITS-1+SIG_BITS,SIG_BITS) = exp(EXP_BITS-1,0);
        t(SIG_BITS-1,0) = sig(SIG_BITS-1,0);
        return t;
    }
    inline int64_t to_int() const {
        return data().to_int64();
    }
    inline int expv() const {
        return exp-1023;
    }
    inline ap_uint<20> sig_msb() const {
        return sig(51,32);
    }
    inline ap_uint<32> sig_lsb() const {
        return sig(31,0);
    }
    inline double to_double() const {
        union double_cast ret;
        ret.i = data().to_uint64();
        return ret.d;
    }
    inline void set_mantissa(ap_ufixed<1+SIG_BITS,1> mantissa) {
        ap_ufixed<SIG_BITS,0> significand = mantissa;
        sig = significand(SIG_BITS-1,0);
    }
    inline ap_ufixed<1+SIG_BITS,1> mantissa() const {
        ap_ufixed<1+SIG_BITS,1> y = 0;
        y(y.wl()-1,0) = sig(SIG_BITS-1,0);
        y[y.wl()-1] = 1;
        return y;
    }
    inline double to_ieee() const {
        return to_double();
    }
    inline int __signbit() const {
        return sign.to_int();
    }

    static double infinity() {
        fp_struct<double> x;
        x.sign = 0;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    static double minus_infinity() {
        fp_struct<double> x;
        x.sign = 1;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    typedef uint64_t inttype;
    typedef ap_uint<64> data_type;
    ap_uint<1> sign;
    ap_uint<EXP_BITS> exp;
    ap_uint<SIG_BITS> sig;
};
# 576 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/39\\utils/x_hls_utils.h"
static inline
void
castDouble(
    double din,
    fp_struct<double> &dout)
{
    fp_struct<double> t(din);
    dout = t;
}

static inline
double
castDouble(
    fp_struct<double> din)
{
    return din.to_double();
}

static inline
void
dumpDouble(
    double da,
    fp_struct<double> ds)
{
# 613 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/39\\utils/x_hls_utils.h"
   (void)(da);
   (void)(ds);

}
# 626 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/39\\utils/x_hls_utils.h"
union half_cast {
    half d;
    uint16_t i;
};


template <>
class fp_struct<half>
{
public:
    const static int EXP_INFNAN = 31;
    const static int EXP_BIAS = 15;
    const static int EXP_BITS = 5;
    const static int SIG_BITS = 10;
    const static int BITS = 16;

    fp_struct() {
    }
    fp_struct(half f) {

        union half_cast dc;
        dc.d = f;
        ap_uint<16> data = dc.i;



        sign[0] = data[EXP_BITS+SIG_BITS+1-1];
        exp(EXP_BITS-1,0) = data(EXP_BITS-1+SIG_BITS,SIG_BITS);
        sig(SIG_BITS-1,0) = data(SIG_BITS-1,0);
    }
    fp_struct(ap_uint<16> data) {
        sign[0] = data[EXP_BITS+SIG_BITS+1-1];
        exp(EXP_BITS-1,0) = data(EXP_BITS-1+SIG_BITS,SIG_BITS);
        sig(SIG_BITS-1,0) = data(SIG_BITS-1,0);
    }
    fp_struct(uint16_t i) {
        ap_uint<16> data = i;
        sign[0] = data[EXP_BITS+SIG_BITS+1-1];
        exp(EXP_BITS-1,0) = data(EXP_BITS-1+SIG_BITS,SIG_BITS);
        sig(SIG_BITS-1,0) = data(SIG_BITS-1,0);
    }
    inline ap_uint<16> data() const {
        ap_uint<16> t;
        t[EXP_BITS+SIG_BITS+1-1] = sign[0];
        t(EXP_BITS-1+SIG_BITS,SIG_BITS) = exp(EXP_BITS-1,0);
        t(SIG_BITS-1,0) = sig(SIG_BITS-1,0);
        return t;
    }
    inline int expv() const {
        return exp-EXP_BIAS;
    }
    inline int16_t to_int() const {
        return uint16_t(data().to_int());
    }
    inline half to_half() const {

        union half_cast ret;
        ret.i = data().to_uint64();
        return ret.d;





    }
    inline void set_mantissa(ap_ufixed<1+SIG_BITS,1> mantissa) {
        ap_ufixed<SIG_BITS,0> significand = mantissa;
        sig = significand(SIG_BITS-1,0);
    }
    inline ap_ufixed<1+SIG_BITS,1> mantissa() const {
        ap_ufixed<1+SIG_BITS,1> y = 0;
        y(y.wl()-1,0) = sig(SIG_BITS-1,0);
        y[y.wl()-1] = 1;
        return y;
    }
    inline half to_ieee() const {
        return to_half();
    }
    inline int __signbit() const {
        return sign.to_int();
    }

    static half infinity() {
        fp_struct<half> x;
        x.sign = 0;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    static half minus_infinity() {
        fp_struct<half> x;
        x.sign = 1;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    typedef uint16_t inttype;
    typedef ap_uint<16> data_type;
    ap_uint<1> sign;
    ap_uint<EXP_BITS> exp;
    ap_uint<SIG_BITS> sig;
};
# 744 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/39\\utils/x_hls_utils.h"
static inline
void
castHalf(
    half din,
    fp_struct<half> &dout)
{
    fp_struct<half> t(din);
    dout = t;
}

static inline
half
castHalf(
    fp_struct<half> din)
{
    return din.to_half();
}

static inline
void
dumpHalf(
    half da,
    fp_struct<half> ds)
{
# 781 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/39\\utils/x_hls_utils.h"
   (void)(da);
   (void)(ds);

}
# 799 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/39\\utils/x_hls_utils.h"
template < unsigned int _Base, unsigned int _Num >
class Power
{
public:
    static const unsigned int Value = _Base * Power< _Base, _Num - 1 >::Value;
};

template < unsigned int _Base >
class Power< _Base, 0 >
{
public:
    static const unsigned int Value = 1;
};
# 821 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/39\\utils/x_hls_utils.h"
template < unsigned int _Num, unsigned int _I=_Num/2>
class BitWidth
{
public:
    static const unsigned int Value = 1 + BitWidth<_Num,_I/2>::Value;
};

template <unsigned int _Num>
class BitWidth<_Num, 0>
{
public:
    static const unsigned int Value = 2;
};
# 843 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/39\\utils/x_hls_utils.h"
template < unsigned int _Num, unsigned int _I=_Num/2>
class UnsignedBitWidth
{
public:
    static const unsigned int Value = 1 + UnsignedBitWidth<_Num,_I/2>::Value;
};

template <unsigned int _Num>
class UnsignedBitWidth<_Num, 0>
{
public:
    static const unsigned int Value = 1;
};
# 864 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/39\\utils/x_hls_utils.h"
template < typename T >
class Type_BitWidth
{
public:
    static const unsigned int Value = 8*sizeof(T);
};

template <int W >
class Type_BitWidth< ap_uint<W> >
{
public:
    static const unsigned int Value = W;
};

template < int W >
class Type_BitWidth< ap_int<W> >
{
public:
    static const unsigned int Value = W;
};

template < int W, int I >
class Type_BitWidth< ap_ufixed<W, I> >
{
public:
    static const unsigned int Value = W;
};

template < int W, int I >
class Type_BitWidth< ap_fixed<W, I> >
{
public:
    static const unsigned int Value = W;
};
# 912 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/39\\utils/x_hls_utils.h"
template <typename _T, int _Num, int _I=_Num-1>
class Table : public Table<_T, _Num, _I-1>
{
public:
    typedef typename _T::TableType TableType;
    static const typename _T::TableType dummy;
    static const int size = _Num;

};

template <typename _T, int _Num>
class Table<_T, _Num, 0>
{
public:
    static const typename _T::TableType dummy;
    static typename _T::TableType array[_Num];
};
# 939 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/39\\utils/x_hls_utils.h"
template <typename _T, int _Num, int _I>
const typename _T::TableType Table<_T, _Num, _I>::dummy
    = Table<_T, _Num, 0>::array[_I] = _T::apply(_I,_Num) + 0*Table<_T, _Num, _I-1>::dummy;

template <typename _T, int _Num>
const typename _T::TableType Table<_T, _Num, 0>::dummy
    = Table<_T, _Num, 0>::array[0] = _T::apply(0,_Num);




template <typename _T, int _Num>
typename _T::TableType Table<_T, _Num, 0>::array[_Num];



template <class T>
struct is_fptype { static const bool value = false; };
template <> struct is_fptype<float> { static const bool value = true; };
template <> struct is_fptype<double> { static const bool value = true; };
template <> struct is_fptype<half> { static const bool value = true; };

template <class T>
struct is_integraltype { static const bool value = false; };
template <> struct is_integraltype<int> { static const bool value = true; };
template <> struct is_integraltype<unsigned int> { static const bool value = true; };
template <> struct is_integraltype<char> { static const bool value = true; };
template <> struct is_integraltype<signed char> { static const bool value = true; };
template <> struct is_integraltype<unsigned char> { static const bool value = true; };
template <> struct is_integraltype<short> { static const bool value = true; };
template <> struct is_integraltype<unsigned short> { static const bool value = true; };
template <> struct is_integraltype<long> { static const bool value = true; };
template <> struct is_integraltype<unsigned long> { static const bool value = true; };
template <> struct is_integraltype<long long> { static const bool value = true; };
template <> struct is_integraltype<unsigned long long> { static const bool value = true; };
template <int W> struct is_integraltype<ap_int<W> > { static const bool value = true; };
template <int W> struct is_integraltype<ap_uint<W> > { static const bool value = true; };

template <class T>
struct is_fixedtype { static const bool value = false; };
template <int W, int I, ap_q_mode Q, ap_o_mode O> struct is_fixedtype<ap_fixed<W,I,Q,O> > { static const bool value = true; };
template <int W, int I, ap_q_mode Q, ap_o_mode O> struct is_fixedtype<ap_ufixed<W,I,Q,O> > { static const bool value = true; };

namespace hls {
    template<bool B, class T = void>
    struct enable_if {};

    template<class T>
    struct enable_if<true, T> { typedef T type; };
    template<typename T, T _v>
    struct integral_constant
    {
        static const T value = _v;
        typedef T value_type;
        typedef integral_constant<T,_v> type;
        operator value_type() { return value; }
    };

    typedef integral_constant<bool, true> true_type;
    typedef integral_constant<bool, false> false_type;

    template<typename T1, typename T2>
    struct is_same;

    template<typename T1, typename T2>
    struct is_same : public false_type { };

    template<typename T1>
    struct is_same<T1,T1> : public true_type { };

    template<typename T>
    struct is_arithmetic : public integral_constant<bool, (is_integraltype<T>::value || is_fptype<T>::value)> { };
}

template<typename T1, typename T2>
struct enable_or { static const bool value = T1::value || T2::value; };

template<typename T1, typename T2>
struct enable_and { static const bool value = T1::value && T2::value; };



template<typename T, bool = is_integraltype<T>::value>
struct __promote { typedef double type; };

template<typename T>
struct __promote<T, false> { };

template<>
struct __promote<double> { typedef double type; };

template<>
struct __promote<float> { typedef float type; };

template<>
struct __promote<half> { typedef half type; };
# 41 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_axi_io.h" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\assert.h" 1 3
# 17 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\assert.h" 3
# 1 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\stdlib.h" 1 3
# 36 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\stdlib.h" 3
# 1 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\cstdlib" 1 3
# 40 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\cstdlib" 3
# 75 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\cstdlib" 3
# 1 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 1 3
# 16 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
#pragma pack(push,_CRT_PACKING)


extern "C" {
# 40 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
  typedef int (__attribute__((__cdecl__)) *_onexit_t)(void);
# 50 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
  typedef struct _div_t {
    int quot;
    int rem;
  } div_t;

  typedef struct _ldiv_t {
    long quot;
    long rem;
  } ldiv_t;





#pragma pack(4)
 typedef struct {
    unsigned char ld[10];
  } _LDOUBLE;
#pragma pack()



 typedef struct {
    double x;
  } _CRT_DOUBLE;

  typedef struct {
    float f;
  } _CRT_FLOAT;




  typedef struct {
    long double x;
  } _LONGDOUBLE;



#pragma pack(4)
 typedef struct {
    unsigned char ld12[12];
  } _LDBL12;
#pragma pack()
# 105 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
 extern int * __imp___mb_cur_max;
# 131 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
  typedef void (__attribute__((__cdecl__)) *_purecall_handler)(void);

  __attribute__ ((__dllimport__)) _purecall_handler __attribute__((__cdecl__)) _set_purecall_handler(_purecall_handler _Handler);
  __attribute__ ((__dllimport__)) _purecall_handler __attribute__((__cdecl__)) _get_purecall_handler(void);

  typedef void (__attribute__((__cdecl__)) *_invalid_parameter_handler)(const wchar_t *,const wchar_t *,const wchar_t *,unsigned int,uintptr_t);
  __attribute__ ((__dllimport__)) _invalid_parameter_handler __attribute__((__cdecl__)) _set_invalid_parameter_handler(_invalid_parameter_handler _Handler);
  __attribute__ ((__dllimport__)) _invalid_parameter_handler __attribute__((__cdecl__)) _get_invalid_parameter_handler(void);



  __attribute__ ((__dllimport__)) extern int *__attribute__((__cdecl__)) _errno(void);

  errno_t __attribute__((__cdecl__)) _set_errno(int _Value);
  errno_t __attribute__((__cdecl__)) _get_errno(int *_Value);

  __attribute__ ((__dllimport__)) unsigned long *__attribute__((__cdecl__)) __doserrno(void);

  errno_t __attribute__((__cdecl__)) _set_doserrno(unsigned long _Value);
  errno_t __attribute__((__cdecl__)) _get_doserrno(unsigned long *_Value);




  extern __attribute__ ((__dllimport__)) char *_sys_errlist[1];
  extern __attribute__ ((__dllimport__)) int _sys_nerr;
# 171 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
  extern int * __imp___argc;







  extern char *** __imp___argv;







  extern wchar_t *** __imp___wargv;
# 199 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
  extern char *** __imp__environ;
# 208 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
  extern wchar_t *** __imp__wenviron;
# 217 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
  extern char ** __imp__pgmptr;
# 226 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
  extern wchar_t ** __imp__wpgmptr;



  errno_t __attribute__((__cdecl__)) _get_pgmptr(char **_Value);
  errno_t __attribute__((__cdecl__)) _get_wpgmptr(wchar_t **_Value);




  extern int * __imp__fmode;



  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _set_fmode(int _Mode);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_fmode(int *_PMode);





  extern unsigned int * __imp__osplatform;
# 256 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
  extern unsigned int * __imp__osver;
# 265 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
  extern unsigned int * __imp__winver;
# 274 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
  extern unsigned int * __imp__winmajor;
# 283 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
  extern unsigned int * __imp__winminor;




  errno_t __attribute__((__cdecl__)) _get_osplatform(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_osver(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_winver(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_winmajor(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_winminor(unsigned int *_Value);




  extern "C++" {
    template <typename _CountofType,size_t _SizeOfArray> char (*__countof_helper( _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];

  }





  void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) exit(int _Code) __attribute__ ((__noreturn__));
  void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _exit(int _Code) __attribute__ ((__noreturn__));



  void __attribute__((__cdecl__)) _Exit(int) __attribute__ ((__noreturn__));
# 320 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
  void __attribute__((__cdecl__)) __attribute__((noreturn)) abort(void);




  __attribute__ ((__dllimport__)) unsigned int __attribute__((__cdecl__)) _set_abort_behavior(unsigned int _Flags,unsigned int _Mask);







  __extension__ long __attribute__((__cdecl__)) _abs64(long);

  extern __inline__ __attribute__((__always_inline__,__gnu_inline__)) long __attribute__((__cdecl__)) _abs64(long x) {
    return __builtin_llabs(x);
  }


  int __attribute__((__cdecl__)) atexit(void (__attribute__((__cdecl__)) *)(void));





  int __attribute__((__cdecl__)) atoi(const char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoi_l(const char *_Str,_locale_t _Locale);
  long __attribute__((__cdecl__)) atol(const char *_Str);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _atol_l(const char *_Str,_locale_t _Locale);


  void *__attribute__((__cdecl__)) bsearch(const void *_Key,const void *_Base,size_t _NumOfElements,size_t _SizeOfElements,int (__attribute__((__cdecl__)) *_PtFuncCompare)(const void *,const void *));
  void __attribute__((__cdecl__)) qsort(void *_Base,size_t _NumOfElements,size_t _SizeOfElements,int (__attribute__((__cdecl__)) *_PtFuncCompare)(const void *,const void *));

  unsigned short __attribute__((__cdecl__)) _byteswap_ushort(unsigned short _Short);
  unsigned long __attribute__((__cdecl__)) _byteswap_ulong (unsigned long _Long);
  __extension__ unsigned long __attribute__((__cdecl__)) _byteswap_uint64(unsigned long _Int64);
  div_t __attribute__((__cdecl__)) div(int _Numerator,int _Denominator);
  char *__attribute__((__cdecl__)) getenv(const char *_VarName) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _itoa(int _Value,char *_Dest,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _i64toa(long _Val,char *_DstBuf,int _Radix) ;
  __extension__ __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ui64toa(unsigned long _Val,char *_DstBuf,int _Radix) ;
  __extension__ __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _atoi64(const char *_String);
  __extension__ __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _atoi64_l(const char *_String,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _strtoi64(const char *_String,char **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _strtoi64_l(const char *_String,char **_EndPtr,int _Radix,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _strtoui64(const char *_String,char **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _strtoui64_l(const char *_String,char **_EndPtr,int _Radix,_locale_t _Locale);
  ldiv_t __attribute__((__cdecl__)) ldiv(long _Numerator,long _Denominator);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ltoa(long _Value,char *_Dest,int _Radix) ;
  int __attribute__((__cdecl__)) mblen(const char *_Ch,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _mblen_l(const char *_Ch,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrlen(const char *_Str);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrlen_l(const char *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrnlen(const char *_Str,size_t _MaxCount);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrnlen_l(const char *_Str,size_t _MaxCount,_locale_t _Locale);
  int __attribute__((__cdecl__)) mbtowc(wchar_t * __restrict__ _DstCh,const char * __restrict__ _SrcCh,size_t _SrcSizeInBytes);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _mbtowc_l(wchar_t * __restrict__ _DstCh,const char * __restrict__ _SrcCh,size_t _SrcSizeInBytes,_locale_t _Locale);
  size_t __attribute__((__cdecl__)) mbstowcs(wchar_t * __restrict__ _Dest,const char * __restrict__ _Source,size_t _MaxCount);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstowcs_l(wchar_t * __restrict__ _Dest,const char * __restrict__ _Source,size_t _MaxCount,_locale_t _Locale);
  int __attribute__((__cdecl__)) mkstemp(char *template_name);
  int __attribute__((__cdecl__)) rand(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _set_error_mode(int _Mode);
  void __attribute__((__cdecl__)) srand(unsigned int _Seed);
# 395 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
inline __attribute__((__cdecl__))
double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtod(const char * __restrict__ _Str,char ** __restrict__ _EndPtr)
{
  double __attribute__((__cdecl__)) __mingw_strtod (const char * __restrict__, char ** __restrict__);
  return __mingw_strtod( _Str, _EndPtr);
}

inline __attribute__((__cdecl__))
float __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtof(const char * __restrict__ _Str,char ** __restrict__ _EndPtr)
{
  float __attribute__((__cdecl__)) __mingw_strtof (const char * __restrict__, char ** __restrict__);
  return __mingw_strtof( _Str, _EndPtr);
}






  long double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtold(const char * __restrict__ , char ** __restrict__ );


  extern double __attribute__((__cdecl__)) __attribute__ ((__nothrow__))
  __strtod (const char * __restrict__ , char ** __restrict__);






  float __attribute__((__cdecl__)) __mingw_strtof (const char * __restrict__, char ** __restrict__);
  double __attribute__((__cdecl__)) __mingw_strtod (const char * __restrict__, char ** __restrict__);
  long double __attribute__((__cdecl__)) __mingw_strtold(const char * __restrict__, char ** __restrict__);

  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _strtod_l(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,_locale_t _Locale);
  long __attribute__((__cdecl__)) strtol(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _strtol_l(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);
  unsigned long __attribute__((__cdecl__)) strtoul(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _strtoul_l(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);


  int __attribute__((__cdecl__)) system(const char *_Command);

  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ultoa(unsigned long _Value,char *_Dest,int _Radix) ;
  int __attribute__((__cdecl__)) wctomb(char *_MbCh,wchar_t _WCh) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wctomb_l(char *_MbCh,wchar_t _WCh,_locale_t _Locale) ;
  size_t __attribute__((__cdecl__)) wcstombs(char * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _MaxCount) ;
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _wcstombs_l(char * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _MaxCount,_locale_t _Locale) ;



  void *__attribute__((__cdecl__)) calloc(size_t _NumOfElements,size_t _SizeOfElements);
  void __attribute__((__cdecl__)) free(void *_Memory);
  void *__attribute__((__cdecl__)) malloc(size_t _Size);
  void *__attribute__((__cdecl__)) realloc(void *_Memory,size_t _NewSize);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _recalloc(void *_Memory,size_t _Count,size_t _Size);






  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _aligned_free(void *_Memory);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_malloc(size_t _Size,size_t _Alignment);



  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_offset_malloc(size_t _Size,size_t _Alignment,size_t _Offset);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_realloc(void *_Memory,size_t _Size,size_t _Alignment);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_recalloc(void *_Memory,size_t _Count,size_t _Size,size_t _Alignment);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_offset_realloc(void *_Memory,size_t _Size,size_t _Alignment,size_t _Offset);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_offset_recalloc(void *_Memory,size_t _Count,size_t _Size,size_t _Alignment,size_t _Offset);





  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _itow(int _Value,wchar_t *_Dest,int _Radix) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _ltow(long _Value,wchar_t *_Dest,int _Radix) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _ultow(unsigned long _Value,wchar_t *_Dest,int _Radix) ;

  double __attribute__((__cdecl__)) __mingw_wcstod(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr);
  float __attribute__((__cdecl__)) __mingw_wcstof(const wchar_t * __restrict__ nptr, wchar_t ** __restrict__ endptr);
  long double __attribute__((__cdecl__)) __mingw_wcstold(const wchar_t * __restrict__, wchar_t ** __restrict__);


  inline __attribute__((__cdecl__))
  double __attribute__((__cdecl__)) wcstod(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr){
    return __mingw_wcstod(_Str,_EndPtr);
  }
  inline __attribute__((__cdecl__))
  float __attribute__((__cdecl__)) wcstof(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr){
    return __mingw_wcstof(_Str,_EndPtr);
  }






  long double __attribute__((__cdecl__)) wcstold(const wchar_t * __restrict__, wchar_t ** __restrict__);

  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _wcstod_l(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,_locale_t _Locale);
  long __attribute__((__cdecl__)) wcstol(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wcstol_l(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);
  unsigned long __attribute__((__cdecl__)) wcstoul(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _wcstoul_l(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wgetenv(const wchar_t *_VarName) ;


  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wsystem(const wchar_t *_Command);

  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _wtof(const wchar_t *_Str);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _wtof_l(const wchar_t *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wtoi(const wchar_t *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wtoi_l(const wchar_t *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wtol(const wchar_t *_Str);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wtol_l(const wchar_t *_Str,_locale_t _Locale);

  __extension__ __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _i64tow(long _Val,wchar_t *_DstBuf,int _Radix) ;
  __extension__ __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _ui64tow(unsigned long _Val,wchar_t *_DstBuf,int _Radix) ;
  __extension__ __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wtoi64(const wchar_t *_Str);
  __extension__ __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wtoi64_l(const wchar_t *_Str,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wcstoi64(const wchar_t *_Str,wchar_t **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wcstoi64_l(const wchar_t *_Str,wchar_t **_EndPtr,int _Radix,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _wcstoui64(const wchar_t *_Str,wchar_t **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _wcstoui64_l(const wchar_t *_Str ,wchar_t **_EndPtr,int _Radix,_locale_t _Locale);


  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _putenv(const char *_EnvString);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wputenv(const wchar_t *_EnvString);



  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _fullpath(char *_FullPath,const char *_Path,size_t _SizeInBytes);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ecvt(double _Val,int _NumOfDigits,int *_PtDec,int *_PtSign) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _fcvt(double _Val,int _NumOfDec,int *_PtDec,int *_PtSign) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _gcvt(double _Val,int _NumOfDigits,char *_DstBuf) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atodbl(_CRT_DOUBLE *_Result,char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoldbl(_LDOUBLE *_Result,char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoflt(_CRT_FLOAT *_Result,char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atodbl_l(_CRT_DOUBLE *_Result,char *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoldbl_l(_LDOUBLE *_Result,char *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoflt_l(_CRT_FLOAT *_Result,char *_Str,_locale_t _Locale);
# 554 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
unsigned long __attribute__((__cdecl__)) _lrotl(unsigned long,int);
unsigned long __attribute__((__cdecl__)) _lrotr(unsigned long,int);





  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _makepath(char *_Path,const char *_Drive,const char *_Dir,const char *_Filename,const char *_Ext);
  _onexit_t __attribute__((__cdecl__)) _onexit(_onexit_t _Func);



  void __attribute__((__cdecl__)) perror(const char *_ErrMsg);





  __extension__ unsigned long __attribute__((__cdecl__)) _rotl64(unsigned long _Val,int _Shift);
  __extension__ unsigned long __attribute__((__cdecl__)) _rotr64(unsigned long Value,int Shift);






  unsigned int __attribute__((__cdecl__)) _rotr(unsigned int _Val,int _Shift);
  unsigned int __attribute__((__cdecl__)) _rotl(unsigned int _Val,int _Shift);


  __extension__ unsigned long __attribute__((__cdecl__)) _rotr64(unsigned long _Val,int _Shift);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _searchenv(const char *_Filename,const char *_EnvVar,char *_ResultPath) ;
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _splitpath(const char *_FullPath,char *_Drive,char *_Dir,char *_Filename,char *_Ext) ;
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _swab(char *_Buf1,char *_Buf2,int _SizeInBytes);



  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wfullpath(wchar_t *_FullPath,const wchar_t *_Path,size_t _SizeInWords);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wmakepath(wchar_t *_ResultPath,const wchar_t *_Drive,const wchar_t *_Dir,const wchar_t *_Filename,const wchar_t *_Ext);


  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wperror(const wchar_t *_ErrMsg);

  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wsearchenv(const wchar_t *_Filename,const wchar_t *_EnvVar,wchar_t *_ResultPath) ;
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wsplitpath(const wchar_t *_FullPath,wchar_t *_Drive,wchar_t *_Dir,wchar_t *_Filename,wchar_t *_Ext) ;


  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _beep(unsigned _Frequency,unsigned _Duration) __attribute__ ((__deprecated__));

  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _seterrormode(int _Mode) __attribute__ ((__deprecated__));
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _sleep(unsigned long _Duration) __attribute__ ((__deprecated__));
# 625 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
  char *__attribute__((__cdecl__)) ecvt(double _Val,int _NumOfDigits,int *_PtDec,int *_PtSign) ;
  char *__attribute__((__cdecl__)) fcvt(double _Val,int _NumOfDec,int *_PtDec,int *_PtSign) ;
  char *__attribute__((__cdecl__)) gcvt(double _Val,int _NumOfDigits,char *_DstBuf) ;
  char *__attribute__((__cdecl__)) itoa(int _Val,char *_DstBuf,int _Radix) ;
  char *__attribute__((__cdecl__)) ltoa(long _Val,char *_DstBuf,int _Radix) ;
  int __attribute__((__cdecl__)) putenv(const char *_EnvString) ;



  void __attribute__((__cdecl__)) swab(char *_Buf1,char *_Buf2,int _SizeInBytes) ;


  char *__attribute__((__cdecl__)) ultoa(unsigned long _Val,char *_Dstbuf,int _Radix) ;
  _onexit_t __attribute__((__cdecl__)) onexit(_onexit_t _Func);





  typedef struct { __extension__ long long quot, rem; } lldiv_t;

  __extension__ lldiv_t __attribute__((__cdecl__)) lldiv(long long, long long);

  __extension__ long long __attribute__((__cdecl__)) llabs(long long);




  __extension__ long long __attribute__((__cdecl__)) strtoll(const char * __restrict__, char ** __restrict, int);
  __extension__ unsigned long long __attribute__((__cdecl__)) strtoull(const char * __restrict__, char ** __restrict__, int);


  __extension__ long long __attribute__((__cdecl__)) atoll (const char *);


  __extension__ long long __attribute__((__cdecl__)) wtoll (const wchar_t *);
  __extension__ char *__attribute__((__cdecl__)) lltoa (long long, char *, int);
  __extension__ char *__attribute__((__cdecl__)) ulltoa (unsigned long long , char *, int);
  __extension__ wchar_t *__attribute__((__cdecl__)) lltow (long long, wchar_t *, int);
  __extension__ wchar_t *__attribute__((__cdecl__)) ulltow (unsigned long long, wchar_t *, int);
# 680 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
}


#pragma pack(pop)


# 1 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\sec_api/stdlib_s.h" 1 3








# 1 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\stdlib.h" 1 3
# 30 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\stdlib.h" 3
# 1 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 1 3
# 31 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\stdlib.h" 2 3
# 10 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\sec_api/stdlib_s.h" 2 3




extern "C" {


  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _dupenv_s(char **_PBuffer,size_t *_PBufferSizeInBytes,const char *_VarName);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _itoa_s(int _Value,char *_DstBuf,size_t _Size,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _i64toa_s(long _Val,char *_DstBuf,size_t _Size,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ui64toa_s(unsigned long _Val,char *_DstBuf,size_t _Size,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ltoa_s(long _Val,char *_DstBuf,size_t _Size,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) mbstowcs_s(size_t *_PtNumOfCharConverted,wchar_t *_DstBuf,size_t _SizeInWords,const char *_SrcBuf,size_t _MaxCount);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _mbstowcs_s_l(size_t *_PtNumOfCharConverted,wchar_t *_DstBuf,size_t _SizeInWords,const char *_SrcBuf,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ultoa_s(unsigned long _Val,char *_DstBuf,size_t _Size,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wctomb_s_l(int *_SizeConverted,char *_MbCh,size_t _SizeInBytes,wchar_t _WCh,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcstombs_s(size_t *_PtNumOfCharConverted,char *_Dst,size_t _DstSizeInBytes,const wchar_t *_Src,size_t _MaxCountInBytes);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcstombs_s_l(size_t *_PtNumOfCharConverted,char *_Dst,size_t _DstSizeInBytes,const wchar_t *_Src,size_t _MaxCountInBytes,_locale_t _Locale);



  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _itow_s (int _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ltow_s (long _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ultow_s (unsigned long _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wgetenv_s(size_t *_ReturnSize,wchar_t *_DstBuf,size_t _DstSizeInWords,const wchar_t *_VarName);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wdupenv_s(wchar_t **_Buffer,size_t *_BufferSizeInWords,const wchar_t *_VarName);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _i64tow_s(long _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ui64tow_s(unsigned long _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);



  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ecvt_s(char *_DstBuf,size_t _Size,double _Val,int _NumOfDights,int *_PtDec,int *_PtSign);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _fcvt_s(char *_DstBuf,size_t _Size,double _Val,int _NumOfDec,int *_PtDec,int *_PtSign);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _gcvt_s(char *_DstBuf,size_t _Size,double _Val,int _NumOfDigits);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _makepath_s(char *_PathResult,size_t _Size,const char *_Drive,const char *_Dir,const char *_Filename,const char *_Ext);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _putenv_s(const char *_Name,const char *_Value);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _searchenv_s(const char *_Filename,const char *_EnvVar,char *_ResultPath,size_t _SizeInBytes);

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _splitpath_s(const char *_FullPath,char *_Drive,size_t _DriveSize,char *_Dir,size_t _DirSize,char *_Filename,size_t _FilenameSize,char *_Ext,size_t _ExtSize);
  extern "C++" { template <size_t __drive_size, size_t __dir_size, size_t __name_size, size_t __ext_size> inline errno_t __attribute__((__cdecl__)) _splitpath_s(const char *_Dest, char (&__drive)[__drive_size], char (&__dir)[__dir_size], char (&__name)[__name_size], char (&__ext)[__ext_size]) { return _splitpath_s(_Dest, __drive, __drive_size, __dir, __dir_size, __name, __name_size, __ext, __ext_size); } }



  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wmakepath_s(wchar_t *_PathResult,size_t _SizeInWords,const wchar_t *_Drive,const wchar_t *_Dir,const wchar_t *_Filename,const wchar_t *_Ext);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wputenv_s(const wchar_t *_Name,const wchar_t *_Value);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wsearchenv_s(const wchar_t *_Filename,const wchar_t *_EnvVar,wchar_t *_ResultPath,size_t _SizeInWords);

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wsplitpath_s(const wchar_t *_FullPath,wchar_t *_Drive,size_t _DriveSizeInWords,wchar_t *_Dir,size_t _DirSizeInWords,wchar_t *_Filename,size_t _FilenameSizeInWords,wchar_t *_Ext,size_t _ExtSizeInWords);
  extern "C++" { template <size_t __drive_size, size_t __dir_size, size_t __name_size, size_t __ext_size> inline errno_t __attribute__((__cdecl__)) _wsplitpath_s(const wchar_t *_Dest, wchar_t (&__drive)[__drive_size], wchar_t (&__dir)[__dir_size], wchar_t (&__name)[__name_size], wchar_t (&__ext)[__ext_size]) { return _wsplitpath_s(_Dest, __drive, __drive_size, __dir, __dir_size, __name, __name_size, __ext, __ext_size); } }





  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) qsort_s(void *_Base,size_t _NumOfElements,size_t _SizeOfElements,int (__attribute__((__cdecl__)) *_PtFuncCompare)(void *,const void *,const void *),void *_Context);





}
# 686 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 2 3
# 1 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\malloc.h" 1 3
# 11 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\malloc.h" 3
#pragma pack(push,_CRT_PACKING)


extern "C" {
# 46 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\malloc.h" 3
  typedef struct _heapinfo {
    int *_pentry;
    size_t _size;
    int _useflag;
  } _HEAPINFO;


  extern unsigned int _amblksiz;
# 103 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\malloc.h" 3
void * __mingw_aligned_malloc (size_t _Size, size_t _Alignment);
void __mingw_aligned_free (void *_Memory);
void * __mingw_aligned_offset_realloc (void *_Memory, size_t _Size, size_t _Alignment, size_t _Offset);
void * __mingw_aligned_realloc (void *_Memory, size_t _Size, size_t _Offset);



  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _resetstkoflw (void);
  __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _set_malloc_crt_max_wait(unsigned long _NewValue);

  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _expand(void *_Memory,size_t _NewSize);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _msize(void *_Memory);






  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _get_sbh_threshold(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _set_sbh_threshold(size_t _NewValue);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _set_amblksiz(size_t _Value);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_amblksiz(size_t *_Value);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapadd(void *_Memory,size_t _Size);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapchk(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapmin(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapset(unsigned int _Fill);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapwalk(_HEAPINFO *_EntryInfo);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _heapused(size_t *_Used,size_t *_Commit);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _get_heap_handle(void);
# 144 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\malloc.h" 3
  static __inline void *_MarkAllocaS(void *_Ptr,unsigned int _Marker) {
    if(_Ptr) {
      *((unsigned int*)_Ptr) = _Marker;
      _Ptr = (char*)_Ptr + 16;
    }
    return _Ptr;
  }
# 163 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\malloc.h" 3
  static __inline void __attribute__((__cdecl__)) _freea(void *_Memory) {
    unsigned int _Marker;
    if(_Memory) {
      _Memory = (char*)_Memory - 16;
      _Marker = *(unsigned int *)_Memory;
      if(_Marker==0xDDDD) {
 free(_Memory);
      }





    }
  }
# 206 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\malloc.h" 3
}


#pragma pack(pop)
# 687 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 2 3
# 76 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\cstdlib" 2 3
# 118 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\cstdlib" 3
extern "C++"
{
namespace std
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;





  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;





  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline long
  abs(long __i) { return __builtin_labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }



  inline __int128
  abs(__int128 __x) { return __x >= 0 ? __x : -__x; }
# 202 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\cstdlib" 3
}
# 215 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\cstdlib" 3
namespace __gnu_cxx
{



  using ::lldiv_t;





  using ::_Exit;



  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 247 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}



}
# 37 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\stdlib.h" 2 3

using std::abort;
using std::atexit;
using std::exit;
# 51 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\stdlib.h" 3
using std::div_t;
using std::ldiv_t;

using std::abs;
using std::atof;
using std::atoi;
using std::atol;
using std::bsearch;
using std::calloc;
using std::div;
using std::free;
using std::getenv;
using std::labs;
using std::ldiv;
using std::malloc;

using std::mblen;
using std::mbstowcs;
using std::mbtowc;

using std::qsort;
using std::rand;
using std::realloc;
using std::srand;
using std::strtod;
using std::strtol;
using std::strtoul;
using std::system;

using std::wcstombs;
using std::wctomb;
# 18 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\assert.h" 2 3



extern "C" {
# 45 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\assert.h" 3
extern void __attribute__((__cdecl__))
_wassert(const wchar_t *_Message,const wchar_t *_File,unsigned _Line);
extern void __attribute__((__cdecl__))
_assert (const char *_Message, const char *_File, unsigned _Line);


}
# 42 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_axi_io.h" 2

namespace hls {

template<int W, typename T>
void AXIGetBitFields(ap_uint<W> pix, int start, int w, T& val) {
#pragma HLS inline
 (void) ((!!(start >= 0 && start+w <= W)) || (_assert("start >= 0 && start+w <= W","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_axi_io.h",48),0));
    val = (T)pix(start+w-1, start);
}

template<int W>
void AXIGetBitFields(ap_uint<W> pix, int start, int w, float& val) {
#pragma HLS inline
 (void) ((!!(w == 32 && start >= 0 && start+w <= W)) || (_assert("w == 32 && start >= 0 && start+w <= W","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_axi_io.h",55),0));
    fp_struct<float> temp((ap_uint<32>)pix(start+w-1, start));
    val = temp.to_float();
}

template<int W>
void AXIGetBitFields(ap_uint<W> pix, int start, int w, double& val) {
#pragma HLS inline
 (void) ((!!(w == 64 && start >= 0 && start+w <= W)) || (_assert("w == 64 && start >= 0 && start+w <= W","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_axi_io.h",63),0));
    fp_struct<double> temp((ap_uint<64>)pix(start+w-1, start));
    val = temp.to_double();
}

template<int W, typename T>
void AXIGetBitFields(ap_axiu<W,1,1,1> axi, int start, int w, T& val) {
#pragma HLS inline
 AXIGetBitFields(axi.data, start, w, val);
}

template<int W, typename T>
void AXISetBitFields(ap_uint<W>& pix, int start, int w, T val) {
#pragma HLS inline
 (void) ((!!(start >= 0 && start+w <= W)) || (_assert("start >= 0 && start+w <= W","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_axi_io.h",77),0));
    pix(start+w-1, start) = val;
}

template<int W>
void AXISetBitFields(ap_uint<W>& pix, int start, int w, float val) {
#pragma HLS inline
 (void) ((!!(w == 32 && start >= 0 && start+w <= W)) || (_assert("w == 32 && start >= 0 && start+w <= W","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_axi_io.h",84),0));
    fp_struct<float> temp(val);
    pix(start+w-1, start) = temp.data();
}

template<int W>
void AXISetBitFields(ap_uint<W>& pix, int start, int w, double val) {
#pragma HLS inline
 (void) ((!!(w == 64 && start >= 0 && start+w <= W)) || (_assert("w == 64 && start >= 0 && start+w <= W","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_axi_io.h",92),0));
    fp_struct<double> temp(val);
    pix(start+w-1, start) = temp.data();
}

template<int W, typename T>
void AXISetBitFields(ap_axiu<W,1,1,1>& axi, int start, int w, T val) {
#pragma HLS inline
 AXISetBitFields(axi.data, start, w, val);
}

}
# 49 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src\\hls_video.h" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_math.h" 1
# 40 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_math.h"
# 1 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\cmath" 1 3
# 40 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\6.2.0\\include\\c++\\cmath" 3
# 41 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_math.h" 2

# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_fpo.h" 1
# 63 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_fpo.h"
# 1 "C:/Xilinx/Vitis_HLS/2020.2/tps/mingw/6.2.0/win64.o/nt\\x86_64-w64-mingw32\\include\\assert.h" 1 3
# 64 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_fpo.h" 2
# 43 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_math.h" 2


namespace hls {


  int signbit(double);
  int signbit(float);
  int signbit(half);
  int signbitf(float);
  int half_signbit(half);


  double nan(const char*);
  float nanf(const char*);
  half half_nan(const char *);


  int isfinite(double);
  int isfinite(float);
  int isfinite(half);
  int isfinitef(float);
  int half_isfinite(half);


  int __isfinite(double);
  int __isfinite(float);
  int __isfinite(half);
  int __isfinitef(float);


  int isinf(double);
  int isinf(float);
  int isinf(half);
  int isinff(float);
  int half_isinf(half);


  int __isinf(double);
  int __isinf(float);
  int __isinf(half);
  int __isinff(float);


  int isnan(double);
  int isnan(float);
  int isnan(half);
  int _isnanf(float);
  int half_isnan(half);


  int __isnan(double);
  int __isnan(float);
  int __isnan(half);
  int __isnanf(float);


  int isnormal(double);
  int isnormal(float);
  int isnormal(half);
  int isnormalf(float);
  int half_isnormal(half);


  int __isnormal(double);
  int __isnormal(float);
  int __isnormal(half);
  int __isnormalf(float);


  int fpclassify(double);
  int fpclassify(float);
  int fpclassify(half);
  int fpclassifyf(float);
  int half_fpclassify(half);


  int __fpclassify(double);
  int __fpclassify(float);
  int __fpclassify(half);
  int __fpclassifyf(float);


  double copysign(double, double);
  float copysign(float, float);
  half copysign(half, half);
  float copysignf(float, float);
  half half_copysign(half, half);
  int8_t copysign(int8_t, int8_t);
  uint8_t copysign(uint8_t, uint8_t);
  int16_t copysign(int16_t, int16_t);
  uint16_t copysign(uint16_t, uint16_t);
  int32_t copysign(int32_t, int32_t);
  uint32_t copysign(uint32_t, uint32_t);


  double fabs(double);
  float fabs(float);
  half fabs(half);
  float fabsf(float);
  half half_fabs(half);
  int8_t fabs(int8_t);
  uint8_t fabs(uint8_t);
  int16_t fabs(int16_t);
  uint16_t fabs(uint16_t);
  int32_t fabs(int32_t);
  uint32_t fabs(uint32_t);


  double abs(double);
  float abs(float);
  half abs(half);
  float absf(float);
  half half_abs(half);
  int8_t abs(int8_t);
  uint8_t abs(uint8_t);
  int16_t abs(int16_t);
  uint16_t abs(uint16_t);
  int32_t abs(int32_t);
  uint32_t abs(uint32_t);


  double fma(double, double, double);
  float fma(float, float, float);
  half fma(half, half, half);
  float fmaf(float, float, float);
  half half_fma(half, half, half);


  double mad(double, double, double);
  float mad(float, float, float);
  half mad(half, half, half);
  float madf(float, float, float);
  half half_mad(half, half, half);


  int isequal(double, double);
  int isequal(float, float);
  int isequal(half, half);
  int isequalf(float, float);
  int half_isequal(half, half);


  int isgreater(double, double);
  int isgreater(float, float);
  int isgreater(half, half);
  int isgreaterf(float, float);
  int half_isgreater(half, half);


  int isgreaterequal(double, double);
  int isgreaterequal(float, float);
  int isgreaterequal(half, half);
  int isgreaterequalf(float, float);
  int half_isgreaterequal(half, half);


  int isless(double, double);
  int isless(float, float);
  int isless(half, half);
  int islessf(float, float);
  int half_isless(half, half);


  int islessequal(double, double);
  int islessequal(float, float);
  int islessequal(half, half);
  int islessequalf(float, float);
  int half_islessequal(half, half);


  int islessgreater(double, double);
  int islessgreater(float, float);
  int islessgreater(half, half);
  int islessgreaterf(float, float);
  int half_islessgreater(half, half);


  int isnotequal(double, double);
  int isnotequal(float, float);
  int isnotequal(half, half);
  int isnotequalf(float, float);
  int half_isnotequal(half, half);


  double fmax(double, double);
  float fmax(float, float);
  half fmax(half, half);
  float fmaxf(float, float);
  half half_fmax(half, half);
  int8_t fmax(int8_t,int8_t);
  uint8_t fmax(uint8_t, uint8_t);
  int16_t fmax(int16_t, int16_t);
  uint16_t fmax(uint16_t, uint16_t);
  int32_t fmax(int32_t, int32_t);
  uint32_t fmax(uint32_t, uint32_t);


  double fmin(double, double);
  float fmin(float, float);
  half fmin(half, half);
  float fminf(float, float);
  half half_fmin(half, half);
  int8_t fmin(int8_t,int8_t);
  uint8_t fmin(uint8_t, uint8_t);
  int16_t fmin(int16_t, int16_t);
  uint16_t fmin(uint16_t, uint16_t);
  int32_t fmin(int32_t, int32_t);
  uint32_t fmin(uint32_t, uint32_t);


  template <class T>
  T max(T x, T y){
 return (x > y) ? x : y;
  }


  template <class T>
  T min(T x, T y){
 return (x < y) ? x : y;
  }


  double fdim(double, double);
  float fdim(float, float);
  half fdim(half, half);
  float fdimf(float, float);
  half half_fdim(half, half);
  int8_t fdim(int8_t,int8_t);
  uint8_t fdim(uint8_t, uint8_t);
  int16_t fdim(int16_t, int16_t);
  uint16_t fdim(uint16_t, uint16_t);
  int32_t fdim(int32_t, int32_t);
  uint32_t fdim(uint32_t, uint32_t);


  double maxmag(double, double);
  float maxmag(float, float);
  half maxmag(half, half);
  float maxmagf(float, float);
  half half_maxmag(half, half);
  int8_t maxmag(int8_t,int8_t);
  uint8_t maxmag(uint8_t, uint8_t);
  int16_t maxmag(int16_t, int16_t);
  uint16_t maxmag(uint16_t, uint16_t);
  int32_t maxmag(int32_t, int32_t);
  uint32_t maxmag(uint32_t, uint32_t);


  double minmag(double, double);
  float minmag(float, float);
  half minmag(half, half);
  float minmagf(float, float);
  half half_minmag(half, half);
  int8_t minmag(int8_t,int8_t);
  uint8_t minmag(uint8_t, uint8_t);
  int16_t minmag(int16_t, int16_t);
  uint16_t minmag(uint16_t, uint16_t);
  int32_t minmag(int32_t, int32_t);
  uint32_t minmag(uint32_t, uint32_t);



  double frexp(double, int*);
  float frexp(float, int*);
  half frexp(half, int*);
  float frexpf(float, int*);
  half half_frexp(half, int*);


  double ldexp(double, int);
  float ldexp(float, int);
  half ldexp(half, int);
  float ldexpf(float, int);
  half half_ldexp(half, int);


  int ilogb(double);
  int ilogb(float);
  int ilogb(half);
  int ilogbf(float);
  int half_ilogb(half);


  double scalbn(double, int);
  float scalbn(float, int);
  half scalbn(half, int);
  float scalbnf(float, int);
  half half_scalbn(half, int);


  double scalbln(double, long int);
  float scalbln(float, long int);
  half scalbln(half, long int);
  float scalblnf(float, long int);
  half half_scalbln(half, long int);


  double ceil(double);
  float ceil(float);
  half ceil(half);
  float ceilf(float);
  half half_ceil(half);


  double floor(double);
  float floor(float);
  half floor(half);
  float floorf(float);
  half half_floor(half);


  double trunc(double);
  float trunc(float);
  half trunc(half);
  float truncf(float);
  half half_trunc(half);


  double round(double);
  float round(float);
  half round(half);
  float roundf(float);
  half half_round(half);


  double rint(double);
  float rint(float);
  half rint(half);
  float rintf(float);
  half half_rint(half);


  long int lround(double);
  long int lround(float);
  long int lround(half);
  long int lroundf(float);
  long int half_lround(half);


  long long int llround(double);
  long long int llround(float);
  long long int llround(half);
  long long int llroundf(float);
  long long int half_llround(half);


  long int lrint(double);
  long int lrint(float);
  long int lrint(half);
  long int lrintf(float);
  long int half_lrint(half);


  long long int llrint(double);
  long long int llrint(float);
  long long int llrint(half);
  long long int llrintf(float);
  long long int half_llrint(half);


  template<class T>
  T cast_IEEE754(double, bool);
  template<class T>
  T cast_IEEE754(float, bool);
  template<class T>
  T cast_IEEE754(half, bool);

  template<class T>
  T cast_IEEE754(double);
  template<class T>
  T cast_IEEE754(float);
  template<class T>
  T cast_IEEE754(half);



  template<>
  char cast_IEEE754<char>(double, bool);
  template<>
  char cast_IEEE754<char>(float, bool);
  template<>
  char cast_IEEE754<char>(half, bool);
  template<>
  char cast_IEEE754<char>(double);
  template<>
  char cast_IEEE754<char>(float);
  template<>
  char cast_IEEE754<char>(half);


  template<>
  int8_t cast_IEEE754<int8_t>(double, bool);
  template<>
  int8_t cast_IEEE754<int8_t>(float, bool);
  template<>
  int8_t cast_IEEE754<int8_t>(half, bool);
  template<>
  int8_t cast_IEEE754<int8_t>(double);
  template<>
  int8_t cast_IEEE754<int8_t>(float);
  template<>
  int8_t cast_IEEE754<int8_t>(half);


  template<>
  uint8_t cast_IEEE754<uint8_t>(double, bool);
  template<>
  uint8_t cast_IEEE754<uint8_t>(float, bool);
  template<>
  uint8_t cast_IEEE754<uint8_t>(half, bool);
  template<>
  uint8_t cast_IEEE754<uint8_t>(double);
  template<>
  uint8_t cast_IEEE754<uint8_t>(float);
  template<>
  uint8_t cast_IEEE754<uint8_t>(half);


  template<>
  int16_t cast_IEEE754<int16_t>(double, bool);
  template<>
  int16_t cast_IEEE754<int16_t>(float, bool);
  template<>
  int16_t cast_IEEE754<int16_t>(half, bool);
  template<>
  int16_t cast_IEEE754<int16_t>(double);
  template<>
  int16_t cast_IEEE754<int16_t>(float);
  template<>
  int16_t cast_IEEE754<int16_t>(half);


  template<>
  uint16_t cast_IEEE754<uint16_t>(double, bool);
  template<>
  uint16_t cast_IEEE754<uint16_t>(float, bool);
  template<>
  uint16_t cast_IEEE754<uint16_t>(half, bool);
  template<>
  uint16_t cast_IEEE754<uint16_t>(double);
  template<>
  uint16_t cast_IEEE754<uint16_t>(float);
  template<>
  uint16_t cast_IEEE754<uint16_t>(half);


  template<>
  int32_t cast_IEEE754<int32_t>(double, bool);
  template<>
  int32_t cast_IEEE754<int32_t>(float, bool);
  template<>
  int32_t cast_IEEE754<int32_t>(half, bool);
  template<>
  int32_t cast_IEEE754<int32_t>(double);
  template<>
  int32_t cast_IEEE754<int32_t>(float);
  template<>
  int32_t cast_IEEE754<int32_t>(half);


  template<>
  uint32_t cast_IEEE754<uint32_t>(double, bool);
  template<>
  uint32_t cast_IEEE754<uint32_t>(float, bool);
  template<>
  uint32_t cast_IEEE754<uint32_t>(half, bool);
  template<>
  uint32_t cast_IEEE754<uint32_t>(double);
  template<>
  uint32_t cast_IEEE754<uint32_t>(float);
  template<>
  uint32_t cast_IEEE754<uint32_t>(half);


  template<>
  int64_t cast_IEEE754<int64_t>(double, bool);
  template<>
  int64_t cast_IEEE754<int64_t>(float, bool);
  template<>
  int64_t cast_IEEE754<int64_t>(half, bool);
  template<>
  int64_t cast_IEEE754<int64_t>(double);
  template<>
  int64_t cast_IEEE754<int64_t>(float);
  template<>
  int64_t cast_IEEE754<int64_t>(half);


  template<>
  uint64_t cast_IEEE754<uint64_t>(double, bool);
  template<>
  uint64_t cast_IEEE754<uint64_t>(float, bool);
  template<>
  uint64_t cast_IEEE754<uint64_t>(half, bool);
  template<>
  uint64_t cast_IEEE754<uint64_t>(double);
  template<>
  uint64_t cast_IEEE754<uint64_t>(float);
  template<>
  uint64_t cast_IEEE754<uint64_t>(half);



  double nearbyint(double);
  float nearbyint(float);
  half nearbyint(half);
  float nearbyintf(float);
  half half_nearbyint(half);


  double modf(double, double*);
  float modf(float, float*);
  half modf(half, half*);
  float modff(float, float*);
  half half_modf(half, half*);


  double fract(double, double*);
  float fract(float, float*);
  half fract(half, half*);
  float fractf(float, float*);
  half half_fract(half, half*);


  int isordered(double, double);
  int isordered(float, float);
  int isordered(half, half);
  int isorderedf(float, float);
  int half_isordered(half, half);


  int isunordered(double, double);
  int isunordered(float, float);
  int isunordered(half, half);
  int isunorderedf(float, float);
  int half_isunordered(half, half);


  double bitselect(double, double, double);
  float bitselect(float, float, float);
  int bitselect(int, int, int);
  uint32_t bitselect(uint32_t, uint32_t, uint32_t);
  half bitselect(half, half, half);
  float bitselectf(float, float, float);
  half half_bitselect(half, half, half);


  namespace hotbm {
 double sin(double);
 float sin(float);
 half sin(half);
 float sinf(float);
 half half_sin(half);

 double cos(double);
 float cos(float);
 half cos(half);
 float cosf(float);
 half half_cos(half);

 void sincos(double, double*, double*);
 void sincos(float, float*, float*);
 void sincos(half, half*, half*);
 void sincosf(float, float*, float*);
 void half_sincos(half, half*, half*);
  }


  namespace cordic {
 double sin(double);
 float sin(float);
 half sin(half);
 float sinf(float);
 half half_sin(half);

 double cos(double);
 float cos(float);
 half cos(half);
 float cosf(float);
 half half_cos(half);

 void sincos(double, double*, double*);
 void sincos(float, float*, float*);
 void sincos(half, half*, half*);
 void sincosf(float, float*, float*);
 void half_sincos(half, half*, half*);
  }


  double sin(double);
  float sin(float);
  half sin(half);
  float sinf(float);
  half half_sin(half);

  double cos(double);
  float cos(float);
  half cos(half);
  float cosf(float);
  half half_cos(half);


  void sincos(double, double*, double*);
  void sincos(float, float*, float*);
  void sincos(half, half*, half*);
  void sincosf(float, float*, float*);
  void half_sincos(half, half*, half*);


  double sinpi(double);
  float sinpi(float);
  half sinpi(half);
  float sinpif(float);
  half half_sinpi(half);


  double cospi(double);
  float cospi(float);
  half cospi(half);
  float cospif(float);
  half half_cospi(half);


  double tanpi(double);
  float tanpi(float);
  half tanpi(half);
  float tanpif(float);
  half half_tanpi(half);


  double atan(double);
  float atan(float);
  half atan(half);
  float atanf(float);
  half half_atan(half);


  double atan2(double, double);
  float atan2(float, float);
  half atan2(half, half);
  float atan2f(float, float);
  half half_atan2(half, half);


  double tan(double);
  float tan(float);
  half tan(half);
  float tanf(float);
  half half_tan(half);


  double sinh(double);
  float sinh(float);
  half sinh(half);
  float sinhf(float);
  half half_sinh(half);


  double cosh(double);
  float cosh(float);
  half cosh(half);
  float coshf(float);
  half half_cosh(half);


  double exp(double);
  float exp(float);
  half exp(half);
  float expf(float);
  half half_exp(half);
  int8_t exp(int8_t);
  uint8_t exp(uint8_t);
  int16_t exp(int16_t);
  uint16_t exp(uint16_t);
  int32_t exp(int32_t);
  uint32_t exp(uint32_t);


  double exp2(double);
  float exp2(float);
  half exp2(half);
  float exp2f(float);
  half half_exp2(half);


  double exp10(double);
  float exp10(float);
  half exp10(half);
  float exp10f(float);
  half half_exp10(half);


  double expm1(double);
  float expm1(float);
  half expm1(half);
  float expm1f(float);
  half half_expm1(half);


  double log(double);
  float log(float);
  half log(half);
  float logf(float);
  half half_log(half);
  int8_t log(int8_t);
  uint8_t log(uint8_t);
  int16_t log(int16_t);
  uint16_t log(uint16_t);
  int32_t log(int32_t);
  uint32_t log(uint32_t);


  double log2(double);
  float log2(float);
  half log2(half);
  float log2f(float);
  half half_log2(half);


  double log10(double);
  float log10(float);
  half log10(half);
  float log10f(float);
  half half_log10(half);
  int8_t log10(int8_t);
  uint8_t log10(uint8_t);
  int16_t log10(int16_t);
  uint16_t log10(uint16_t);
  int32_t log10(int32_t);
  uint32_t log10(uint32_t);


  double logb(double);
  float logb(float);
  half logb(half);
  float logbf(float);
  half half_logb(half);

  double log1p(double);
  float log1p(float);
  half log1p(half);
  float log1pf(float);
  half half_log1p(half);


  half pow(half, half);
  float pow(float, float);
  double pow(double, double);
  float powf(float, float);
  half half_pow(half, half);
  int8_t pow(int8_t, int8_t);
  uint8_t pow(uint8_t, uint8_t);
  int16_t pow(int16_t, int16_t);
  uint16_t pow(uint16_t, uint16_t);
  int32_t pow(int32_t, int32_t);
  uint32_t pow(uint32_t, uint32_t);
  int8_t powr(int8_t, int8_t);
  uint8_t powr(uint8_t, uint8_t);
  int16_t powr(int16_t, int16_t);
  uint16_t powr(uint16_t, uint16_t);
  int32_t powr(int32_t, int32_t);
  uint32_t powr(uint32_t, uint32_t);


  half powr(half, half);
  float powr(float, float);
  double powr(double, double);
  float powrf(float, float);
  half half_powr(half, half);


  half pown(half, int);
  float pown(float, int);
  double pown(double, int);
  float pownf(float, int);
  half half_pown(half, int);


  half rootn(half, int);
  float rootn(float, int);
  double rootn(double, int);
  float rootnf(float, int);
  half half_rootn(half, int);


  double sqrt(double);
  float sqrt(float);
  half sqrt(half);
  float sqrtf(float);
  half half_sqrt(half);
  int8_t sqrt(int8_t);
  uint8_t sqrt(uint8_t);
  int16_t sqrt(int16_t);
  uint16_t sqrt(uint16_t);
  int32_t sqrt(int32_t);
  uint32_t sqrt(uint32_t);
# 858 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_math.h"
  double recip(double);
  float recip(float);
  half recip(half);
  float recipf(float);
  half half_recip(half);
  int8_t recip(int8_t);
  uint8_t recip(uint8_t);
  int16_t recip(int16_t);
  uint16_t recip(uint16_t);
  int32_t recip(int32_t);
  uint32_t recip(uint32_t);


  double rsqrt(double);
  float rsqrt(float);
  half rsqrt(half);
  float rsqrtf(float);
  half half_rsqrt(half);
  int8_t rsqrt(int8_t);
  uint8_t rsqrt(uint8_t);
  int16_t rsqrt(int16_t);
  uint16_t rsqrt(uint16_t);
  int32_t rsqrt(int32_t);
  uint32_t rsqrt(uint32_t);


  double cbrt(double);
  float cbrt(float);
  half cbrt(half);
  float cbrtf(float);
  half half_cbrt(half);


  double hypot(double, double);
  float hypot(float, float);
  half hypot(half, half);
  float hypotf(float, float);
  half half_hypot(half, half);


  double erf(double);
  float erf(float);
  half erf(half);
  float erff(float);
  half half_erf(half);
  int8_t erf(int8_t);
  uint8_t erf(uint8_t);
  int16_t erf(int16_t);
  uint16_t erf(uint16_t);
  int32_t erf(int32_t);
  uint32_t erf(uint32_t);


  double erfc(double);
  float erfc(float);
  half erfc(half);
  float erfcf(float);
  half half_erfc(half);
  int8_t erfc(int8_t);
  uint8_t erfc(uint8_t);
  int16_t erfc(int16_t);
  uint16_t erfc(uint16_t);
  int32_t erfc(int32_t);
  uint32_t erfc(uint32_t);


  double lgamma(double);
  float lgamma(float);
  half lgamma(half);
  float lgammaf(float);
  half half_lgamma(half);
  int8_t lgamma(int8_t);
  uint8_t lgamma(uint8_t);
  int16_t lgamma(int16_t);
  uint16_t lgamma(uint16_t);
  int32_t lgamma(int32_t);
  uint32_t lgamma(uint32_t);


  double lgamma_r(double, int*);
  float lgamma_r(float, int*);
  half lgamma_r(half, int*);
  float lgamma_rf(float, int*);
  half half_lgamma_r(half, int*);
  int8_t lgamma_r(int8_t);
  uint8_t lgamma_r(uint8_t);
  int16_t lgamma_r(int16_t);
  uint16_t lgamma_r(uint16_t);
  int32_t lgamma_r(int32_t);
  uint32_t lgamma_r(uint32_t);


  double tgamma(double);
  float tgamma(float);
  half tgamma(half);
  float tgammaf(float);
  half half_tgamma(half);
  int8_t tgamma(int8_t);
  uint8_t tgamma(uint8_t);
  int16_t tgamma(int16_t);
  uint16_t tgamma(uint16_t);
  int32_t tgamma(int32_t);
  uint32_t tgamma(uint32_t);

  double tgamma_p_reduce(double);
  float tgamma_p_reduce(float);
  float tgammaf_p_reduce(float);


  double fmod(double, double);
  float fmod(float, float);
  half fmod(half, half);
  float fmodf(float, float);
  half half_fmod(half, half);


  double remainder(double, double);
  float remainder(float, float);
  half remainder(half, half);
  float remainderf(float, float);
  half half_remainder(half, half);


  double remquo(double, double, int*);
  float remquo(float, float, int*);
  half remquo(half, half, int*);
  float remquof(float, float, int*);
  half half_remquo(half, half, int*);


  double divide(double, double);
  float divide(float, float);
  half divide(half, half);
  float dividef(float, float);
  half half_divide(half, half);


  double nextafter(double, double);
  float nextafter(float, float);
  half nextafter(half, half);
  float nextafterf(float, float);
  half half_nextafter(half, half);


  double tanh(double);
  float tanh(float);
  half tanh(half);
  float tanhf(float);
  half half_tanh(half);


  double atanh(double);
  float atanh(float);
  half atanh(half);
  float atanhf(float);
  half half_atanh(half);


  double asinh(double);
  float asinh(float);
  half asinh(half);
  float asinhf(float);
  half half_asinh(half);


  double acosh(double);
  float acosh(float);
  half acosh(half);
  float acoshf(float);
  half half_acosh(half);


  double asin(double);
  float asin(float);
  half asin(half);
  float asinf(float);
  half half_asin(half);


  double acos(double);
  float acos(float);
  half acos(half);
  float acosf(float);
  half half_acos(half);


  double asinpi(double);
  float asinpi(float);
  half asinpi(half);
  float asinpif(float);
  half half_asinpi(half);


  double acospi(double);
  float acospi(float);
  half acospi(half);
  float acospif(float);
  half half_acospi(half);


  double atanpi(double);
  float atanpi(float);
  half atanpi(half);
  float atanpif(float);
  half half_atanpi(half);
}


# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_hotbm_apfixed.h" 1
# 43 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_hotbm_apfixed.h"
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/ap_int.h" 1
# 44 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_hotbm_apfixed.h" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/utils/x_hls_defines.h" 1
# 40 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/utils/x_hls_defines.h"
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/ap_int.h" 1
# 41 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/utils/x_hls_defines.h" 2
# 108 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/utils/x_hls_defines.h"
template<int M, int E>
struct float_struct {
    ap_uint<M> mant;
    ap_uint<E> exp;
    ap_uint<1> sign;
};




template<int M, int E>
struct float_struct2 {
    ap_int<M> mant;
    ap_uint<E> exp;
};
# 45 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_hotbm_apfixed.h" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/utils/x_hls_utils.h" 1
# 46 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_hotbm_apfixed.h" 2






namespace hotbm_apfixed
{

  namespace first_order_fixed_16{
 extern const ap_fixed<19,2> sin_cos_K0[256];
 extern const ap_fixed<11,2> sin_cos_K1[256];
  };

  namespace second_order_float{
 extern const ap_fixed<29,0> cos_K0[128];
 extern const ap_fixed<23,1> cos_K1[128];
 extern const ap_fixed<15,0> cos_K2[128];
 extern const ap_fixed<30,1> sin_K0[128];
 extern const ap_fixed<21,-1> sin_K1[128];
 extern const ap_fixed<13,-2> sin_K2[128];
 extern const ap_ufixed<30,1> sin_cos_K0[256];
 extern const ap_fixed<23,1> sin_cos_K1[256];
 extern const ap_fixed<15,0> sin_cos_K2[256];
  };

  namespace fourth_order_double{
 extern const ap_fixed<59,0> cos_K0[128];
 extern const ap_fixed<53,1> cos_K1[128];
 extern const ap_fixed<45,0> cos_K2[128];
 extern const ap_fixed<35,-3> cos_K3[128];
 extern const ap_fixed<27,-4> cos_K4[128];
 extern const ap_fixed<60,1> sin_K0[128];
 extern const ap_fixed<51,-1> sin_K1[128];
 extern const ap_fixed<43,-2> sin_K2[128];
 extern const ap_fixed<33,-5> sin_K3[128];
 extern const ap_fixed<24,-7> sin_K4[128];
 extern const ap_fixed<59,1> sin_cos_K0[256];
 extern const ap_fixed<52,1> sin_cos_K1[256];
 extern const ap_fixed<44,0> sin_cos_K2[256];
 extern const ap_fixed<34,-3> sin_cos_K3[256];
 extern const ap_fixed<26,-4> sin_cos_K4[256];
  };

  template<class T>
  struct value_list{
  };

  template<>
  struct value_list<double>{
    typedef double T;
 static const int g = 10;
 static const int p1 = 61;
 static const int alpha = 7;

 static const int beta1 = 0;

 static const int beta2 = alpha;

    static const int W_dout = fp_struct<T>::SIG_BITS+1+g;
    static const int W_Mx = fp_struct<T>::SIG_BITS+1+g;

    template <int Wx, int Wr>
    static ap_ufixed<Wx, 1> sin_or_cos_approximation(bool do_cos,
              ap_uint<3> &k,
              ap_ufixed<Wx, 0> &x,
              ap_ufixed<Wr, 0> &Mx,
              ap_int<fp_struct<double>::EXP_BITS> &Ex){

   const bool swap_table[8] = {0,1,1,0,0,1,1,0};
#pragma HLS array_partition variable=swap_table complete
#pragma HLS RESOURCE variable=fourth_order_double::sin_cos_K0 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::sin_cos_K1 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::sin_cos_K2 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::sin_cos_K3 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::sin_cos_K4 core=ROM_1P_LUTRAM

 (void)(Ex);
   ap_uint<alpha+1> A = x(x.wl()-x.iwl()-1,x.wl()-x.iwl()-alpha);
   ap_ufixed<Wx-alpha-beta1, -alpha> B = x;
   ap_ufixed<Wx-alpha-beta2, -alpha> B_trunc = B;
   ap_ufixed<Wx-2*alpha, -2*alpha> B_squared = B_trunc*B_trunc;
   ap_ufixed<Wx-3*alpha, -3*alpha> B_third_power = B_trunc*B_squared;
   ap_ufixed<Wx-4*alpha, -4*alpha> B_fourth_power = B_squared*B_squared;

   bool sin_basis = do_cos? swap_table[k]:!swap_table[k];
   A[alpha] = sin_basis;

   ap_fixed<Wx, 1> t1 = fourth_order_double::sin_cos_K0[A];
   ap_fixed<Wx, 1> t2 = B*fourth_order_double::sin_cos_K1[A];
   ap_fixed<Wx, 1> t3 = B_squared*fourth_order_double::sin_cos_K2[A];
   ap_fixed<Wx, 1> t4 = B_third_power*fourth_order_double::sin_cos_K3[A];
   ap_fixed<Wx, 1> t5 = B_fourth_power*fourth_order_double::sin_cos_K4[A];
   ap_ufixed<Wx, 1> result = Mx*(t1+t2+t3+t4+t5);
   return result;
    }

    template <int Wx, int Wr>
    static void sincos_approximation(ap_uint<3> &k,
          ap_ufixed<Wx, 0> &x,
          ap_ufixed<Wr, 0> Mx,
          ap_int<fp_struct<double>::EXP_BITS> Ex,
          ap_ufixed<Wr, 1> &sin_result,
          ap_ufixed<Wr, 1> &cos_result
          ) {
#pragma HLS RESOURCE variable=fourth_order_double::cos_K0 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::cos_K1 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::cos_K2 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::cos_K3 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::cos_K4 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::sin_K0 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::sin_K1 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::sin_K2 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::sin_K3 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::sin_K4 core=ROM_1P_LUTRAM

 (void)(k);
          (void)(Ex);
   ap_uint<alpha> A = x(x.wl()-x.iwl()-1,
         x.wl()-x.iwl()-alpha);
   ap_ufixed<Wx-alpha-beta1, -alpha> B = x;
   ap_ufixed<Wx-alpha-beta2, -alpha> B_trunc = B;
   ap_ufixed<Wx-2*alpha, -2*alpha> B_squared = B_trunc*B_trunc;
   ap_ufixed<Wx-3*alpha, -3*alpha> B_third_power = B_trunc*B_squared;
   ap_ufixed<Wx-4*alpha, -4*alpha> B_fourth_power = B_squared*B_squared;

   ap_fixed<Wx, 1> cos_t1 = fourth_order_double::cos_K0[A];
   ap_fixed<Wx, 1> cos_t2 = B*fourth_order_double::cos_K1[A];
   ap_fixed<Wx, 1> cos_t3 = B_squared*fourth_order_double::cos_K2[A];
   ap_fixed<Wx, 1> cos_t4 = B_third_power*fourth_order_double::cos_K3[A];
   ap_fixed<Wx, 1> cos_t5 = B_fourth_power*fourth_order_double::cos_K4[A];
   cos_result = 1 - (cos_t1 + cos_t2 + cos_t3 + cos_t4 + cos_t5);

   ap_fixed<Wx, 1> sin_t1 = fourth_order_double::sin_K0[A];
   ap_fixed<Wx, 1> sin_t2 = B*fourth_order_double::sin_K1[A];
   ap_fixed<Wx, 1> sin_t3 = B_squared*fourth_order_double::sin_K2[A];
   ap_fixed<Wx, 1> sin_t4 = B_third_power*fourth_order_double::sin_K3[A];
   ap_fixed<Wx, 1> sin_t5 = B_fourth_power*fourth_order_double::sin_K4[A];
   sin_result = Mx * (sin_t1 + sin_t2 + sin_t3 + sin_t4 + sin_t5);
    }
  };

  template<>
  struct value_list<float> {
 typedef float T;
 static const int g = 5;
 static const int p1 = 29;
 static const int alpha = 7;
 static const int beta1 = 0;
 static const int beta2 = 7;

 static const int W_dout = fp_struct<T>::SIG_BITS+1+g;
 static const int W_Mx = fp_struct<T>::SIG_BITS+1+g;

 template <int Wx, int Wr>
 static ap_ufixed<Wx, 1> sin_or_cos_approximation(bool do_cos,
              ap_uint<3> &k,
              ap_ufixed<Wx, 0> &x,
              ap_ufixed<Wr, 0> &Mx,
              ap_int<fp_struct<float>::EXP_BITS> &Ex){

   const bool swap_table[8] = {0,1,1,0,0,1,1,0};

#pragma HLS array_partition variable=swap_table complete
#pragma HLS RESOURCE variable=second_order_float::sin_cos_K0 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=second_order_float::sin_cos_K1 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=second_order_float::sin_cos_K2 core=ROM_1P_LUTRAM

 (void)(Ex);
   ap_uint<alpha+1> A = x(x.wl()-x.iwl()-1,x.wl()-x.iwl()-alpha);
   ap_ufixed<Wx-alpha-beta1, -alpha> B = x;
   ap_ufixed<Wx-alpha-beta2, -alpha> B_trunc = B;
   ap_ufixed<Wx-2*alpha, -2*alpha> B_squared = B_trunc*B_trunc;

   bool sin_basis = do_cos? swap_table[k]:!swap_table[k];
   A[alpha] = sin_basis;

   ap_fixed<Wx, 1> t1 = second_order_float::sin_cos_K0[A];
   ap_fixed<Wx, 1> t2 = B*second_order_float::sin_cos_K1[A];
   ap_fixed<Wx, 1> t3 = B_squared*second_order_float::sin_cos_K2[A];
   ap_ufixed<Wx, 1> result = (t1+t2+t3) * Mx;

   return result;
 }

 template <int Wx, int Wr>
 static void sincos_approximation(ap_uint<3> &k,
          ap_ufixed<Wx, 0> &x,
          ap_ufixed<Wr, 0> &Mx,
          ap_int<fp_struct<float>::EXP_BITS> &Ex,
          ap_ufixed<Wr, 1> &sin_result,
          ap_ufixed<Wr, 1> &cos_result
          ) {
#pragma HLS RESOURCE variable=second_order_float::cos_K0 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=second_order_float::cos_K1 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=second_order_float::cos_K2 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=second_order_float::sin_K0 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=second_order_float::sin_K1 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=second_order_float::sin_K2 core=ROM_1P_LUTRAM

 (void)(k);
          (void)(Ex);
   ap_uint<alpha> A = x(x.wl()-x.iwl()-1,
         x.wl()-x.iwl()-alpha);
   ap_ufixed<Wx-alpha-beta1, -alpha> B = x;
   ap_ufixed<Wx-alpha-beta2, -alpha> B_trunc = B;
   ap_ufixed<Wx-2*alpha, -2*alpha> B_squared = B_trunc*B_trunc;


   ap_ufixed<Wx, 1> cos_t1 = second_order_float::cos_K0[A];
   ap_ufixed<Wx, 1> cos_t2 = B*second_order_float::cos_K1[A];
   ap_ufixed<Wx, 1> cos_t3 = B_squared*second_order_float::cos_K2[A];
   cos_result = 1 - (cos_t1 + cos_t2 + cos_t3);

   ap_fixed<Wx, 1> sin_t1 = second_order_float::sin_K0[A];
   ap_fixed<Wx, 1> sin_t2 = B*second_order_float::sin_K1[A];
   ap_fixed<Wx, 1> sin_t3 = B_squared*second_order_float::sin_K2[A];
   sin_result = Mx * (sin_t1 + sin_t2 + sin_t3);
 }
  };

  struct sin_cos_fixed_16 {

 typedef half T;
 static const int g = 3;
 static const int p1 = 12;
 static const int alpha = 8;
 static const int beta1 = 4;

 template <int W_dout>
 static ap_ufixed<W_dout, 1> sin_or_cos_approximation(bool do_cos,
               ap_uint<2> &k,
               ap_ufixed<W_dout, 0> &x){

#pragma HLS RESOURCE variable=first_order_fixed_16::sin_cos_K0 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=first_order_fixed_16::sin_cos_K1 core=ROM_1P_LUTRAM
 (void)(do_cos);
          (void)(k);

   ap_uint<alpha> A = x(x.wl()-x.iwl()-1,x.wl()-x.iwl()-alpha);

   const int BW = (W_dout-alpha-beta1)>1 ? W_dout-alpha-beta1 : 2;
   ap_ufixed<BW, -alpha> B = x;

   ap_fixed<W_dout, 1> t1 = first_order_fixed_16::sin_cos_K0[A];
   ap_fixed<W_dout, 1> t2 = B*first_order_fixed_16::sin_cos_K1[A];
   ap_ufixed<W_dout, 1> result = (t1+t2);

   return result;
 };
  };

  template<int W, int I>
  ap_fixed<W,2>
  sinf_or_cosf(ap_fixed<W,I> t_in, bool do_cos, bool do_pi,
      typename hls::enable_if<(W > 16) && (W <= 32), bool>::type dummy = true)
  {
 const int WO = W;
 const int g = 3;

 const bool swap_table[8] = {0,1,1,0,0,1,1,0};
 const bool neg_sin_table[16] = {0,0,1,0,1,1,0,1, 1,0,1,1,0,1,0,0};
 const bool neg_cos_table[16] = {0,0,0,1,1,1,1,0, 0,1,1,1,1,0,0,0};

#pragma HLS array_partition variable=swap_table complete
#pragma HLS array_partition variable=neg_sin_table complete
#pragma HLS array_partition variable=neg_cos_table complete

 (void)(dummy);
 ap_uint<3> k;
 ap_ufixed<WO+1+g, 0> x;
 ap_ufixed<WO+1+g, 0> Mx;
 ap_int<fp_struct<float>::EXP_BITS> Ex = 0;

 int exactly_pi_over_4 = 0;
 bool is_negative = t_in[t_in.wl()-1];
 ap_ufixed<W, I> din = is_negative ? ap_fixed<W, I>(-t_in) : t_in;

 if(do_pi) {
   k = din*4;
   x = din*4;
   ap_ufixed<W, 1> Mx_bits_extended = din*4;



   exactly_pi_over_4 = (Mx_bits_extended == 1);
 } else {
   ap_ufixed<WO+1+g+3, 3> Wx = din * ap_ufixed<W+1+g,2>(4/3.14159265358979323846);
   k = Wx;
   x = Wx;
 }




 if(k[0] == 1) {
   x = 1-x;
 }
 Mx = x;

 bool cos_basis = do_cos?!swap_table[k]: swap_table[k];
 if(cos_basis) {


   Mx = ap_ufixed<value_list<float>::W_dout, 0, AP_RND, AP_SAT>(1);
   Ex = 0;
 }

 ap_ufixed<WO+1+g, 1> result = value_list<float>::sin_or_cos_approximation(do_cos,k,x,Mx,Ex);

 if(exactly_pi_over_4) {
   result = 0.7071067811865475244008443;
 }

 ap_uint<4> index = k;
 index[3] = is_negative;

 if(cos_basis ? neg_cos_table[index] : neg_sin_table[index]) {
   return -result;
 } else {
   return result;
 }
  }


  template<int W, int I>
  ap_fixed<W,2>
  sinf_or_cosf(ap_fixed<W,I> t_in, bool do_cos, bool do_pi,
      typename hls::enable_if<(W > 32) && (W <= 64), bool>::type dummy = true)
  {
 const int WO = W;
 const int g = 3;

 const bool swap_table[8] = {0,1,1,0,0,1,1,0};
 const bool neg_sin_table[16] = {0,0,1,0,1,1,0,1, 1,0,1,1,0,1,0,0};
 const bool neg_cos_table[16] = {0,0,0,1,1,1,1,0, 0,1,1,1,1,0,0,0};
#pragma HLS array_partition variable=swap_table complete
#pragma HLS array_partition variable=neg_sin_table complete
#pragma HLS array_partition variable=neg_cos_table complete

 (void)(dummy);
 ap_uint<3> k;
 ap_ufixed<WO+1+g, 0> x;
 ap_ufixed<WO+1+g, 0> Mx;
 ap_int<fp_struct<double>::EXP_BITS> Ex = 0;

 int exactly_pi_over_4 = 0;
 bool is_negative = t_in[t_in.wl()-1];
 ap_ufixed<W, I> din = is_negative ? ap_fixed<W, I>(-t_in) : t_in;

 if(do_pi) {
   k = din*4;
   x = din*4;
   ap_ufixed<W, 1> Mx_bits_extended = din*4;



   exactly_pi_over_4 = (Mx_bits_extended == 1);
 } else {
   ap_ufixed<WO+1+g+3, 3> Wx = din * ap_ufixed<W+1+g,2>(4/3.14159265358979323846);
   k = Wx;
   x = Wx;
 }




 if(k[0] == 1) {
   x = 1-x;
 }
 Mx = x;

 bool cos_basis = do_cos?!swap_table[k]: swap_table[k];
 if(cos_basis) {


   Mx = ap_ufixed<value_list<double>::W_dout, 0, AP_RND, AP_SAT>(1);
   Ex = 0;
 }

 ap_ufixed<WO+1+g, 1> result = value_list<double>::sin_or_cos_approximation(do_cos,k,x,Mx,Ex);

 if(exactly_pi_over_4) {
   result = 0.7071067811865475244008443;
 }

 ap_uint<4> index = k;
 index[3] = is_negative;

 if(cos_basis ? neg_cos_table[index] : neg_sin_table[index]) {
   return -result;
 } else {
   return result;
 }
  };


  template<int W, int I>
  ap_fixed<W,2>
  sinf_or_cosf(ap_fixed<W,I> t_in, bool do_cos, bool do_pi,
      typename hls::enable_if<W <= 16, bool>::type dummy = true)
  {
 const int WO = W;
 const int g = 4;

 const bool neg_sin_table[8] = {0,0,1,1, 1,1,0,0};
 const bool neg_cos_table[8] = {0,1,1,0, 0,1,1,0};
#pragma HLS array_partition variable=neg_sin_table complete
#pragma HLS array_partition variable=neg_cos_table complete

 (void)(dummy);
 ap_uint<2> k;
 ap_ufixed<WO+1+g, 0> x;

 bool is_negative = t_in[t_in.wl()-1];
 ap_ufixed<W, I> din = is_negative ? ap_fixed<W, I>(-t_in) : t_in;

 if(do_pi) {
   k = din*2;
   x = din*2;
   ap_ufixed<W, 1> Mx_bits_extended = din*2;
 }
 else {
   ap_ufixed<WO+1+g+2, 2> Wx = din * ap_ufixed<W+1+g,2>(2/3.14159265358979323846);
   k = Wx;
   x = Wx;
 }

 bool is_special_case = false;

 if((k[0] == 1) ^ !do_cos) {
   ap_ufixed<WO+1+g+1, 1> Wx = 1-x;
   x = Wx;
   is_special_case = (Wx[Wx.wl()-1] == 1);
 }

 ap_ufixed<WO+1+g, 1> result = sin_cos_fixed_16::sin_or_cos_approximation(do_cos,k,x);

 if(is_special_case) {
   ap_uint<3> index = k;
   index[2] = do_cos;
   const bool special_case_table[8] = {0,1,0,1,1,0,1,0};
   result(result.wl()-2,0) = 0;
   result[result.wl()-1] = special_case_table[index];
 }

 {
   ap_uint<3> index = k;
   index[2] = is_negative;

   if(do_cos ? neg_cos_table[index] : neg_sin_table[index]) {
  return -result;
   } else {
  return result;
   }
 }
  };

};
# 1066 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_math.h" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_cordic_apfixed.h" 1
# 41 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_cordic_apfixed.h"
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/ap_int.h" 1
# 42 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_cordic_apfixed.h" 2





namespace cordic_apfixed {

  extern const ap_ufixed<128,2> circ_table_arctan_128[128];
  extern const int hyperb_table_tau_128[128];
  extern const ap_ufixed<128,4> hyperb_table_arctanh_128[128];





  template<int W, int I, int Wo>
  void circ_range_redux( ap_ufixed<W,I> x,
                         ap_uint<2> &k,
                         ap_ufixed<Wo,1> &r) {

    ap_ufixed<(Wo+I),0> inv_pi2("0x0.A2F9836E4E43FC715BBF");
    ap_ufixed<Wo+1,1> pi2("1.5707963267948966192313216916397514420985846996876");
    ap_ufixed<Wo+I,I> prod = x * inv_pi2;
    ap_uint<I> kint = prod;

    k = kint;
    r = x - kint * pi2;
  };






  template<int W, int I, int MODE>
  void cordic_circ_apfixed( ap_fixed<W,I> &x,
                            ap_fixed<W,I> &y,
                            ap_fixed<W,I> &z) {

    const int Nmax = W;

    ap_fixed<W,I> tx, ty, tz;
    ap_fixed<W,I> x_s, y_s, z_s;
    ap_uint<1> d;

    VITIS_LOOP_87_1: for (int n=0; n<Nmax; n++){
#pragma HLS pipeline

 if(MODE == 1) {
        d = ~y[W-1];
      }
      else {
        d = z[W-1];
      }

      x_s = x >> n;
      y_s = y >> n;
      z_s = circ_table_arctan_128[n];

      if(d){
        tx = x + y_s;
        ty = y - x_s;
        tz = z + z_s;
      }
      else{
        tx = x - y_s;
        ty = y + x_s;
        tz = z - z_s;
      }

      x = tx;
      y = ty;
      z = tz;
# 126 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_cordic_apfixed.h"
    }
  };







  template<int W, int I, int MODE, int INTYPE>
  void doublecordic_apfixed( ap_fixed<W,I> &x,
                             ap_fixed<W,I> &y,
                             ap_fixed<W,I> &z,
                             ap_fixed<W,I> &t) {

    const int Nmax = W - I + 1;

    VITIS_LOOP_143_1: for (int n=0; n<Nmax; n++){

      if(INTYPE==64){
#pragma HLS pipeline II=5
 }
      else if(INTYPE==32){
#pragma HLS pipeline II=3
 }
      else if(INTYPE==16){
#pragma HLS pipeline II=1
 }
      else{
#pragma HLS pipeline II=4
 }

      ap_uint<1> d;
      if(MODE == 0) {
        if(y<=t){
          d = x[W-1];
        }
        else{
          d = ~x[W-1];
        }
      }
      else {
        if(x>=t){
          d = y[W-1];
        }
        else{
          d = ~y[W-1];
        }
      }

      ap_fixed<W,I> x_s = x >> (n-1);
      ap_fixed<W,I> y_s = y >> (n-1);
      ap_fixed<W,I> x_s2 = x_s >> (n+1);
      ap_fixed<W,I> y_s2 = y_s >> (n+1);

      x = x - x_s2;
      y = y - y_s2;
      if(d){
        x = x + y_s;
        y = y - x_s;
      }
      else{
        x = x - y_s;
        y = y + x_s;
      }


      ap_fixed<W,I> t_s;
      int n2 = (n << 1);
      if(n2<W){
        t_s = (t >> n2);
        t = t + t_s;
      }


      ap_fixed<W,I> ca = circ_table_arctan_128[n];
      ap_fixed<W,I> z_s = (ca << 1);
      ap_fixed<W,I> tz;
      if(d){
        tz = z - z_s;
      }
      else{
        tz = z + z_s;
      }
      z = tz;
# 221 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_cordic_apfixed.h"
    }
  };



  template<int W, int I>
  void generic_sincos(ap_fixed<W,I> in,
                      ap_fixed<W-I+2,2> & outsin, ap_fixed<W-I+2,2> & outcos){

    ap_uint<1> sign0 = (in > 0) ? 1: 0;


    ap_ufixed<W,I> inabs;
    if(sign0)
      inabs = in;
    else
      inabs = -in;


    const int Fr = (W - I) + I + 1;
    ap_uint<2> k;
    ap_ufixed<Fr,1> r;
    circ_range_redux(inabs, k, r);

    ap_fixed<W+2,3> x, y, z;

    const ap_fixed<W+2,3> K1("0x0.9B74EDA8435E47F277F7");
    x = K1;
    y = 0;

    if(k==1 or k==3){
      ap_ufixed<Fr,1> pi2("0x1.921FB54442D1846");

      z = pi2 - r;
    }
    else{
      z = r;
    }







    cordic_circ_apfixed<W+2,3,0>(x,y,z);







    if(k==0){
      outsin = y;
      outcos = x;
    }
    else if(k==1){
      outsin = y;
      outcos = -x;
    }
    else if(k==2){
      outsin = -y;
      outcos = -x;
    }
    else{
      outsin = -y;
      outcos = x;
    }

    if(sign0==0)
      outsin = -outsin;
  };


  template<int W, int I>
  ap_fixed<W,I> generic_tan(ap_fixed<W,I> x){

    const int Ix = I;
    const int Fx = (((W-I)>(I-1)) ? (W-I): (I-1)) + I;
    const int Wx = I + Fx;

    ap_fixed<Wx,Ix> xs = x;

    ap_fixed<Wx-Ix+2,2> outsin;
    ap_fixed<Wx-Ix+2,2> outcos;
    generic_sincos(xs, outsin, outcos);

    ap_fixed<W,I> out = outsin / outcos;


    if(I==1){
      if(out[W-1]==1){
        out[W-1] = 0;
        VITIS_LOOP_315_1: for(int i=0;i<W-1;i++){
#pragma HLS UNROLL
 out[i] = 1;
        }
      }
    }

    return out;
  };


  template<int W, int I>
  ap_ufixed<W,I> generic_tan(ap_ufixed<W,I> in) {
    ap_fixed<W+1,I+1> fin = in;
    ap_fixed<W+1,I+1> fout = generic_tan(fin);
    ap_ufixed<W,I> out = 0;
    if(fout[W]==0){
        out = fout;
    }
    return out;
  };


  template<int I>
  ap_int<I> generic_tan(ap_int<I> in) {
    ap_fixed<I,I> fin = in;
    ap_fixed<I,I> fout = generic_tan(fin);
    ap_int<I> out = fout;
    return out;
  };


  template<int I>
  ap_uint<I> generic_tan(ap_uint<I> in) {
    ap_fixed<I+1,I+1> fin = in;
    ap_fixed<I+1,I+1> fout = generic_tan(fin);
    ap_uint<I> out = 0;
    if(fout[I]==0){
        out = fout;
    }
    return out;
  };
# 366 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_cordic_apfixed.h"
  template<int W, int I, int Wo>
  void circ_range_redux_pi( ap_ufixed<W,I> x,
                             ap_uint<2> &k,
                             ap_ufixed<Wo,1> &r) {

    ap_ufixed<Wo+1,1> pi2("1.5707963267948966192313216916397514420985846996876");
    ap_ufixed<W+1,I+1> prod = x << 1;
    ap_uint<I+1> kint = prod;

    k = kint;
    r = (prod - kint) * pi2;
  };

  template<int W, int I>
  void generic_sincospi(ap_fixed<W,I> in,
                      ap_fixed<W-I+2,2> & outsin, ap_fixed<W-I+2,2> & outcos){

    ap_uint<1> sign0 = (in > 0) ? 1: 0;


    ap_ufixed<W,I> inabs;
    if(sign0)
      inabs = in;
    else
      inabs = -in;


    const int Fr = (W - I) + I + 1;
    ap_uint<2> k;
    ap_ufixed<Fr,1> r;
    circ_range_redux_pi(inabs, k, r);

    ap_fixed<W+2,3> x, y, z;

    const ap_fixed<W+2,3> K1("0x0.9B74EDA8435E47F277F7");
    x = K1;
    y = 0;

    if(k==1 or k==3){
      ap_ufixed<Fr,1> pi2("0x1.921FB54442D1846");
      z = pi2 - r;
    }
    else{
      z = r;
    }







    cordic_circ_apfixed<W+2,3,0>(x,y,z);







    if(k==0){
      outsin = y;
      outcos = x;
    }
    else if(k==1){
      outsin = y;
      outcos = -x;
    }
    else if(k==2){
      outsin = -y;
      outcos = -x;
    }
    else{
      outsin = -y;
      outcos = x;
    }

    if(sign0==0)
      outsin = -outsin;
  };


  template<int W, int I>
  ap_fixed<W,I> generic_tanpi(ap_fixed<W,I> x){

    const int Ix = I;
    const int Fx = (((W-I)>(I-1)) ? (W-I): (I-1)) + I;
    const int Wx = I + Fx;

    ap_fixed<Wx,Ix> xs = x;

    ap_fixed<Wx-Ix+2,2> outsin;
    ap_fixed<Wx-Ix+2,2> outcos;
    generic_sincospi(xs, outsin, outcos);

    ap_fixed<W,I> out;
    ap_int<1> bpoint=0;
    if(!outcos){
        bpoint = 1;
    }else{
        out = outsin / outcos;
    }




    if(I==1||bpoint){
      if( out[W-1]==1 ){
        out[W-1] = 0;
        VITIS_LOOP_475_1: for(int i=0;i<W-1;i++){
#pragma HLS UNROLL
 out[i] = 1;
        }
      }
    }

    return out;
  };


  template<int W, int I>
  ap_ufixed<W,I> generic_tanpi(ap_ufixed<W,I> in) {
    ap_fixed<W+1,I+1> fin = in;
    ap_fixed<W+1,I+1> fout = generic_tanpi(fin);
    ap_ufixed<W,I> out = 0;
    if(fout[W]==0){
        out = fout;
    }
    return out;
  };


  template<int I>
  ap_int<I> generic_tanpi(ap_int<I> in) {
    (void)(in);
    return ap_int<I>(0);
  };


  template<int I>
  ap_uint<I> generic_tanpi(ap_uint<I> in) {
    (void)(in);
    return ap_uint<I>(0);
  };


  template<int W, int I>
  ap_fixed<W,2> generic_atan(ap_fixed<W,I> in){

    ap_uint<1> sign0 = (in > 0) ? 1: 0;


    ap_fixed<W+1,I+1> inabs;
    if(sign0)
      inabs = in;
    else
      inabs = -in;


    ap_uint<1> sign1 = (inabs > 1) ? 1: 0;

    ap_fixed<W+2,3> x, y, z;
    if(sign1){
      x = 1;

      y = 1.0 / inabs.to_double();
      z = 0;
    }
    else{
      x = 1;
      y = inabs;
      z = 0;
    }
    cordic_circ_apfixed<W+2,3,1>(x,y,z);

    ap_fixed<W,2> out;
    if(sign1){
      const ap_fixed<W,2> pi2("0x1.921FB54442D1846");
      out = pi2 - z;
    }
    else{
      out = z;
    }


    if(sign0){
      return out;
    }
    else{
      return -out;
    }
  };


  template<int W, int I>
  ap_ufixed<W,2> generic_atan(ap_ufixed<W,I> in){
    ap_fixed<W+1,I+1> fin = in;
    ap_fixed<W+1,2> fout = generic_atan(fin);
    ap_ufixed<W,2> out = 0;
    if(fout[W]==0){
        out = fout;
    }
    return out;
  };


  template<int I>
  ap_int<2> generic_atan(ap_int<I> in){
    if(in<-1)
      return ap_int<2>(-1);
    else if(in>1)
      return ap_int<2>(1);
    else
      return ap_int<2>(0);
  };


  template<int I>
  ap_uint<1> generic_atan(ap_uint<I> in){
    if(in>1)
      return ap_uint<1>(1);
    else
      return ap_uint<1>(0);
  };


  template<int W, int I>
  ap_fixed<W,3> generic_atan2(ap_fixed<W,I> in1,
                              ap_fixed<W,I> in2){

    const ap_fixed<W+1,3> pi("0x3.243F6A8885A308D3");
    const ap_fixed<W+2,3> pi2("0x1.921FB54442D1846");
    const ap_fixed<W+1,3> pi4("0x0.C90FDAA22168C23");
    const ap_fixed<W+1,3> pi3_("-0x2.5B2F8FE6643A469");

    ap_uint<2> signin1 = (in1 > 0) ? 2: (in1==0) ? 1: 0;
    ap_uint<2> signin2 = (in2 > 0) ? 2: (in2==0) ? 1: 0;

    ap_fixed<W,3> out;



    if(signin1==1 and signin2==2){
      out = 0;
      return out;
    }
    else if(signin1==1 and signin2==0){
      out = pi;
      return out;
    }
    else if(signin1==2 and signin2==1){
      out = pi2;
      return out;
    }
    else if(signin1==0 and signin2==1){
      out = -pi2;
      return out;
    }
    else if(in1==in2){
      if(signin1==2){
        out = pi4;
        return out;
      }
      else if(signin1==1){
        out = 0;
        return out;
      }
      else{
        out = pi3_;
        return out;
      }
    }



    ap_fixed<W+1,I+1> in1abs;
    if(signin1==0)
      in1abs = -in1;
    else
      in1abs = in1;

    ap_fixed<W+1,I+1> in2abs;
    if(signin2==0)
      in2abs = -in2;
    else
      in2abs = in2;

    ap_fixed<W+1,2> in1abs_sft;
    ap_fixed<W+1,2> in2abs_sft;
    VITIS_LOOP_655_1: for(int i=0;i<W+1;i++){
#pragma HLS UNROLL
 in1abs_sft[i] = in1abs[i];
    }
    VITIS_LOOP_659_2: for(int i=0;i<W+1;i++){
#pragma HLS UNROLL
 in2abs_sft[i] = in2abs[i];
    }

    ap_fixed<W+7,3> x, y, z;
    if(in1abs > in2abs){
      x = in1abs_sft;
      y = in2abs_sft;
      z = 0;
    }
    else{
      x = in2abs_sft;
      y = in1abs_sft;
      z = 0;
    }
    cordic_circ_apfixed<W+7,3,1>(x,y,z);

    if(in1abs > in2abs){
      z = pi2 - z;
    }

    if(signin2==0 and signin1==2){
      out = pi - z;
    }
    else if(signin2==0 and signin1==0){
      out = z - pi;
    }
    else if(signin2==2 and signin1==0){
      out = -z;
    }
    else{
      out = z;
    }

    return out;
  };


  template<int W, int I>
  ap_ufixed<W,3> generic_atan2(ap_ufixed<W,I> in1,
                               ap_ufixed<W,I> in2){
    ap_fixed<W+1,I+1> fin1 = in1;
    ap_fixed<W+1,I+1> fin2 = in2;
    ap_fixed<W+1,3> fout = generic_atan2(fin1, fin2);
    ap_ufixed<W,3> out = 0;
    if(fout[W]==0){
        out = fout;
    }
    return out;
  }


  template<int I>
  ap_int<3> generic_atan2(ap_int<I> in1,
                          ap_int<I> in2){
    ap_fixed<I+1,I+1> fin1 = in1;
    ap_fixed<I+1,I+1> fin2 = in2;
    ap_fixed<I+1,3> fout = generic_atan2(fin1, fin2);
    ap_int<3> out = fout;
    return out;
  }


  template<int I>
  ap_uint<2> generic_atan2(ap_uint<I> in1,
                           ap_uint<I> in2){
    ap_fixed<I+1,I+1> fin1 = in1;
    ap_fixed<I+1,I+1> fin2 = in2;
    ap_fixed<I+1,3> fout = generic_atan2(fin1, fin2);
    ap_uint<2> out = 0;
    if(fout[I]==0){
        out = fout;
    }
    return out;
  }





  template<int W, int I, int Wo>
  void hyperb_range_redux( ap_ufixed<W,I> x,
                           ap_uint<I+1> &k,
                           ap_ufixed<Wo,0> &r) {

    ap_ufixed<(Wo+I)+1,1> inv_ln2("0x1.71547652b82fe1777d0ffda0d23a7d11d6aef551cp0");
    ap_ufixed<Wo,0> ln2("0xb.17217f7d1cf79abc9e3b39803f2f6af40f343267p-4");
    ap_ufixed<Wo+(I+1),I+1> prod = x * inv_ln2;
    ap_ufixed<Wo,0> prod_dec = prod;
    k = prod;
    r = prod_dec * ln2;
  };






  template<int W, int I, int MODE>
  void cordic_hyperb_apfixed( ap_fixed<W,I> &x,
                              ap_fixed<W,I> &y,
                              ap_fixed<W,I> &z) {

    const int Nmax = W + 1;

    ap_fixed<W,I> tx, ty, tz;
    ap_fixed<W,I> x_s, y_s, z_s;
    ap_uint<1> d;

    VITIS_LOOP_769_1: for (int n=0; n<Nmax; n++){

      int k = hyperb_table_tau_128[n];

      if(MODE == 1) {
        d = ~y[W-1];
      }
      else {
        d = z[W-1];
      }

      x_s = x >> k;
      y_s = y >> k;
      z_s = hyperb_table_arctanh_128[k-1];

      if(d){
        tx = x - y_s;
        ty = y - x_s;
        tz = z + z_s;
      }
      else{
        tx = x + y_s;
        ty = y + x_s;
        tz = z - z_s;
      }

      x = tx;
      y = ty;
      z = tz;
# 806 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_cordic_apfixed.h"
    }
  }


  template <int W, int I>
  void sinh_cosh_range_redux_cordic( ap_fixed<W,I> in,
                                     ap_fixed<W,I> &s_out,
                                     ap_fixed<W,I> &c_out){

    ap_uint<1> sign0 = in[W-1];

    ap_ufixed<W,I> inabs;
    if(sign0 == 0)
      inabs = in;
    else
      inabs = -in;

    const int Fr = (W - I) + I;

    if(in==0){
      s_out = 0;
      c_out = 1;
      return;
    }


    ap_uint<I+1> k;
    ap_ufixed<Fr,0> r;
    hyperb_range_redux(inabs, k, r);

    ap_fixed<Fr+2,2> x("1.20749706776307212887772");
    ap_fixed<Fr+2,2> y(0);
    ap_fixed<Fr+2,2> z(r);




    cordic_hyperb_apfixed<Fr+2,2,0>(x,y,z);



    ap_fixed<Fr+(I+2),I+2> er, e_r;
    er = x + y;
    e_r = x - y;



    er <<= (k-1);
    e_r >>= (k+1);



    ap_fixed<W+1,I+1> s_out_tmp = er - e_r;
    ap_fixed<W+1,I+1> c_out_tmp = er + e_r;




    if(s_out_tmp[W-1]==1){
      s_out_tmp[W-1] = 0;
      VITIS_LOOP_866_1: for(int i=0;i<W-1;i++){
#pragma HLS UNROLL
 s_out_tmp[i] = 1;
      }
    }


    if(sign0 == 0){
      s_out = s_out_tmp;
    }
    else{
      s_out = -s_out_tmp;
    }




    if(c_out_tmp[W-1]==1){
      c_out[W-1] = 0;
      VITIS_LOOP_885_2: for(int i=0;i<W-1;i++){
#pragma HLS UNROLL
 c_out[i] = 1;
      }
    }
    else{
      c_out = c_out_tmp;
    }
  };

    template<int W, int I>
    void tanh_range_redux_cordic(ap_fixed<W,I> in, ap_fixed<W,I> &tan_out) {

        ap_uint<1> sign0 = in[W-1];

        ap_ufixed<W,I> inabs;
        if(sign0 == 0)
            inabs = in;
        else
            inabs = -in;

        const int Fr = (W - I) + I;

        if(in==0){
            tan_out = 0;
            return;
        }

        ap_uint<I+1> k;
        ap_ufixed<Fr,0> r;
        hyperb_range_redux(inabs, k, r);

        ap_fixed<Fr+2,2> x("1.20749706776307212887772");
        ap_fixed<Fr+2,2> y(0);
        ap_fixed<Fr+2,2> z(r);

        cordic_hyperb_apfixed<Fr+2,2,0>(x,y,z);
        ap_fixed<Fr+(I+2),I+2> er, e_r;
        er = x + y;
        e_r = x - y;
        er <<= k;
        e_r >>= k;
        tan_out = (er/(er+e_r))*2 - 1;
    }

    template<int W, int I>
    ap_fixed<W,I> generic_tanh(ap_fixed<W,I> in) {
        ap_fixed<W,I> tan_out;
        tanh_range_redux_cordic(in, tan_out);
        return tan_out;
    }

    template<int W, int I>
    ap_ufixed<W,I> generic_tanh(ap_ufixed<W,I> in) {
        ap_fixed<W+1,I+1> fin = in;
        ap_fixed<W+1,I+1> fout = generic_tanh(fin);
        ap_ufixed<W,I> tan_out = fout;
        return tan_out;
    }

    template<int I>
    ap_int<I> generic_tanh(ap_int<I> in) {
        ap_fixed<I,I> fin = in;
        ap_fixed<I,I> fout = generic_tanh(fin);
        ap_int<I> tan_out = fout;
        return tan_out;
    }

    template<int I>
    ap_uint<I> generic_tanh(ap_uint<I> in) {
        ap_fixed<I+1,I+1> fin = in;
        ap_fixed<I+1,I+1> fout = generic_tanh(fin);
        ap_uint<I> tan_out = fout;
        return tan_out;
    }

  template<int W, int I>
  ap_fixed<W,I> generic_sinh(ap_fixed<W,I> in) {
    ap_fixed<W,I> s_out, c_out;
    sinh_cosh_range_redux_cordic(in,s_out,c_out);
    return s_out;
  }


  template<int W, int I>
  ap_ufixed<W,I> generic_sinh(ap_ufixed<W,I> in) {
    ap_fixed<W+1,I+1> fin = in;
    ap_fixed<W+1,I+1> fout = generic_sinh(fin);
    ap_ufixed<W,I> out = 0;
    if(fout[W]==0){
        out = fout;
    }
    return out;
  };


  template<int I>
  ap_int<I> generic_sinh(ap_int<I> in) {
    ap_fixed<I,I> fin = in;
    ap_fixed<I,I> fout = generic_sinh(fin);
    ap_int<I> out = fout;
    return out;
  };


  template<int I>
  ap_uint<I> generic_sinh(ap_uint<I> in) {
    ap_fixed<I+1,I+1> fin = in;
    ap_fixed<I+1,I+1> fout = generic_sinh(fin);
    ap_uint<I> out = 0;
    if(fout[I]==0){
        out = fout;
    }
    return out;
  };


  template<int W, int I>
  ap_fixed<W, I> generic_cosh(ap_fixed<W,I> in) {
    ap_fixed<W,I> s_out, c_out;
    sinh_cosh_range_redux_cordic(in,s_out,c_out);
    return c_out;
  }


  template<int W, int I>
  ap_ufixed<W,I> generic_cosh(ap_ufixed<W,I> in) {
    ap_fixed<W+1,I+1> fin = in;
    ap_fixed<W+1,I+1> fout = generic_cosh(fin);
    ap_ufixed<W,I> out = 0;
    if(fout[W]==0){
        out = fout;
    }
    return out;
  };


  template<int I>
  ap_int<I> generic_cosh(ap_int<I> in) {
    ap_fixed<I,I> fin = in;
    ap_fixed<I,I> fout = generic_cosh(fin);
    ap_int<I> out = fout;
    return out;
  };


  template<int I>
  ap_uint<I> generic_cosh(ap_uint<I> in) {
    ap_fixed<I+1,I+1> fin = in;
    ap_fixed<I+1,I+1> fout = generic_cosh(fin);
    ap_uint<I> out = 0;
    if(fout[I]==0){
        out = fout;
    }
    return out;
  };



  template<int W, int I>
  ap_fixed<W-I+3,3> generic_asin(ap_fixed<W,I> in){

    const int I0 = 3;
    const int W0 = W - I + I0 + 6;

    const ap_fixed<W+1,I+1> cst1("0x1");
    const ap_fixed<W,I> cst0("0x0");
    const ap_fixed<W,I> cst_1("-0x1");
# 1064 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_cordic_apfixed.h"
    ap_fixed<W-I+3,3> out;


    if(in==cst1){
      out = ap_fixed<W-I+3,3>("0x1.921FB54442D1846");
      return out;
    }
    else if(in==cst_1){
      out = ap_fixed<W-I+3,3>("-0x1.921FB54442D1846");
      return out;
    }
    else if(in==cst0){
      out = ap_fixed<W-I+3,3>("0x0");
      return out;
    }


    ap_uint<1> sign0 = (in >= 0) ? 1: 0;


    ap_fixed<W,I> inabs;
    if(sign0)
      inabs = in;
    else
      inabs = -in;

    ap_fixed<W,I> absout;


    if(inabs[W-I-1]==0){
      ap_fixed<W0,I0> x("0x1");
      ap_fixed<W0,I0> y("0x0");
      ap_fixed<W0,I0> z("0x0");
      ap_fixed<W0,I0> t = inabs;
      doublecordic_apfixed<W0,I0,0,0>(x,y,z,t);
      absout = z;
    }
    else{
      const int F1 = W - I;
      const int W1 = F1 + F1 + I;
      ap_fixed<W1,I> one("0x1");
      ap_fixed<W1,I> onex = one - inabs * inabs;
      ap_fixed<W1,I> sqrtonex = ::__builtin_sqrt(onex.to_double());
      ap_fixed<W1,I> xsqrtonex = inabs / (one + sqrtonex);
      absout = generic_atan(xsqrtonex) << 1;
    }


    if(sign0)
      out = absout;
    else
      out = -absout;

    return out;
  }



  template<int W, int I>
  ap_fixed<W-I+3,3> generic_acos(ap_fixed<W,I> in){

    const int I0 = 3;
    const int W0 = W - I + I0;
# 1142 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_cordic_apfixed.h"
    const ap_fixed<W0,I0> pi2("0x1.921FB54442D1846");
    ap_fixed<W0,I0> out = pi2 - generic_asin(in);

    if(out[W0-1]==1){
      out = -out;
    }

    return out;
  }

  template<int W, int I>
  void cordic_semi_recovery_asinh(ap_fixed<W,I> in_top, ap_fixed<W,I>& out) {

    if(in_top == 0) {
      out = 0;
      return;
    }

    ap_fixed<W,I> in;
    if(in_top >= 0) {
      in = in_top;
    }
    else {
      in = -in_top;
    }

    int m = in.countLeadingZeros();
    int k = I-m;

    if(W-I-2 >= k) {

      ap_fixed<W,I> boundk = 1.0;
      ap_fixed<W,I> bound_k_2 = 1.0;
      boundk <<= k;
      bound_k_2 >>= k;
      bound_k_2 >>= 2;

      if(in >= (boundk - bound_k_2)) {
        k+=1;
      }

    }

    if(k < 0) {
      k = 0;
    }

    const int Nmax = W - I + 1;
    int tau;
    ap_fixed<W,I> x_r(1);
    ap_fixed<W,I> y_r(0);
    ap_fixed<W,I> z_r(0);
    ap_fixed<W,I> x1_tau, x_2tau, y1_tau, y_2tau, z_s;
    ap_fixed<W,I> xk, x_k, yk, y_k;
    ap_fixed<W,I> y_semi_recovery;
    ap_fixed<W,I> in_s;

    VITIS_LOOP_1199_1: for(int i=0; i<Nmax; i++) {

      xk = x_r << k;
      x_k = x_r >> k;
      yk = y_r << k;
      y_k = y_r >> k;

      y_semi_recovery = (xk - x_k + yk + y_k) >> 1;

      tau = hyperb_table_tau_128[i+1];
      z_s = hyperb_table_arctanh_128[tau-1] << 1;

      x1_tau = ((x_r >> tau) << 1);
      x_2tau = (x_r >> (tau << 1));
      y1_tau = ((y_r >> tau) << 1);
      y_2tau = (y_r >> (tau << 1));

      if(y_semi_recovery <= in) {
        x_r += x_2tau + y1_tau;
        y_r += y_2tau + x1_tau;
        z_r += z_s;
      }
      else {
        x_r += x_2tau - y1_tau;
        y_r += y_2tau - x1_tau;
        z_r -= z_s;
      }

      in_s = in >> (tau << 1);
      in -= in_s;
    }

    ap_ufixed<W,0> ln2("0xb.17217f7d1cf79abc9e3b39803f2f6af40f343267p-4");
    if(in_top >= 0) {
      out = z_r + k*ln2;
    }
    else {
      out = -z_r - k*ln2;
    }
  }

  template<int W, int I>
  void cordic_semi_recovery_acosh(ap_fixed<W,I> in, ap_fixed<W,I>& out) {






    if(in == 1) {
      out = 0;
      return;
    }

    int m = in.countLeadingZeros();
    int k = I-m;


    ap_fixed<W,I> boundk = 1.0;
    ap_fixed<W,I> bound_k_1 = 1.0;
    boundk <<= k;
    boundk >>= 1;
    bound_k_1 >>= k;
    bound_k_1 >>= 1;

      if(in < (boundk - bound_k_1)) {
        k-=1;
      }

    if(k < 0) {
      k = 0;
    }

    const int Nmax = W - I + 1;
    int tau;
    ap_fixed<W,I> x_r(1);
    ap_fixed<W,I> y_r(0);
    ap_fixed<W,I> z_r(0);
    ap_fixed<W,I> x1_tau, x_2tau, y1_tau, y_2tau, z_s;
    ap_fixed<W,I> xk, x_k, yk, y_k;
    ap_fixed<W,I> x_semi_recovery;
    ap_fixed<W,I> in_s;

    VITIS_LOOP_1282_1: for(int i=0; i<Nmax; i++) {

      xk = x_r << k;
      x_k = x_r >> k;
      yk = y_r << k;
      y_k = y_r >> k;

      x_semi_recovery = (xk + x_k + yk - y_k) >> 1;

      tau = hyperb_table_tau_128[i+1];
      z_s = hyperb_table_arctanh_128[tau-1] << 1;

      x1_tau = ((x_r >> tau) << 1);
      x_2tau = (x_r >> (tau << 1));
      y1_tau = ((y_r >> tau) << 1);
      y_2tau = (y_r >> (tau << 1));

      if(x_semi_recovery <= in) {
        x_r += x_2tau + y1_tau;
        y_r += y_2tau + x1_tau;
        z_r += z_s;
      }
      else {
        x_r += x_2tau - y1_tau;
        y_r += y_2tau - x1_tau;
        z_r -= z_s;
      }

      in_s = in >> (tau << 1);
      in -= in_s;
    }

    ap_ufixed<W,0> ln2("0xb.17217f7d1cf79abc9e3b39803f2f6af40f343267p-4");
    out = z_r + k*ln2;
  }


  template<int W, int I>
  ap_fixed<W,I> generic_asinh(ap_fixed<W,I> in) {
    ap_fixed<W+1,I+1> input, output; input = in;
    cordic_semi_recovery_asinh(input, output);
    return output;
  }


  template<int W, int I>
  ap_ufixed<W,I> generic_asinh(ap_ufixed<W,I> in) {
    ap_fixed<W+1,I+1> input, output;
    input = in;
    cordic_semi_recovery_asinh(input, output);
    return output;
  };


  template<int I>
  ap_int<I> generic_asinh(ap_int<I> in) {
    ap_fixed<I+1,I+1> input, output;
    input = in;
    cordic_semi_recovery_asinh(input, output);
    return output;
  };


  template<int I>
  ap_uint<I> generic_asinh(ap_uint<I> in) {
    ap_fixed<I+1,I+1> input, output;
    input = in;
    cordic_semi_recovery_asinh(input, output);
    return output;
  };


  template<int W, int I>
  ap_fixed<W,I> generic_acosh(ap_fixed<W,I> in) {
    ap_fixed<W+1,I+1> input, output;
    input = in;
    cordic_semi_recovery_acosh(input, output);
    return output;
  }


  template<int W, int I>
  ap_ufixed<W,I> generic_acosh(ap_ufixed<W,I> in) {
    ap_fixed<W+1,I+1> input, output;
    input = in;
    cordic_semi_recovery_acosh(input, output);
    return output;
  };


  template<int I>
  ap_int<I> generic_acosh(ap_int<I> in) {
    ap_fixed<I,I> input, output;
    input = in;
    cordic_semi_recovery_acosh(input, output);
    return output;
  };


  template<int I>
  ap_uint<I> generic_acosh(ap_uint<I> in) {
    ap_fixed<I+1,I+1> input, output;
    input = in;
    cordic_semi_recovery_acosh(input, output);
    return output;
  };


  template<int W, int I>
  ap_fixed<W,I> generic_asinpi(ap_fixed<W,I> x) {
      const static int we = I < 3? 3: I;
      ap_fixed<W-I+we, we> xi = x;
      ap_fixed<W-I+3,3> asin_x = generic_asin(xi);






      static const int F = W - I;





      static const int wf = F < 1? 0: F - 1;
      ap_ufixed<2+wf,2> pi = 3.14159265358979323846;





      ap_fixed<W,I> r = asin_x/pi;





      return r;
  }
  template<int W, int I>
  ap_ufixed<W,I> generic_asinpi(ap_ufixed<W,I> x) {
      ap_fixed<W+1,I+1> xi = x;
      return generic_asinpi(xi);
  }
  template<int I>
  ap_int<I> generic_asinpi(ap_int<I> x) {

      if(x==-1){

        return -1;
      }else if(x==0){
        return 0;
      }else if(x==1){

        return 1;
      }else{




        return 0;
      };
  }
  template<int I>
  ap_uint<I> generic_asinpi(ap_uint<I> x) {

      if(x==0){
        return 0;

      } else if(x==1){
        return 1;
      } else{




        return 0;
      };
  }

  template<int W, int I>
  ap_fixed<W,I> generic_acospi(ap_fixed<W,I> x) {





      const static int we = I < 3? 3 : I;
      ap_fixed<W-I+we,we> xi = x;
      ap_fixed<W-I+3,3> acos_x = generic_acos(xi);





      static const int F = W - I;





      static const int wf = F;
      ap_ufixed<2+wf,2> pi = 3.14159265358979323846;





      ap_fixed<W,I> r = acos_x/pi;





      return r;
  }
  template<int W, int I>
  ap_ufixed<W,I> generic_acospi(ap_ufixed<W,I> x) {
      ap_fixed<W+1,I+1> xi = x;
      return generic_acospi(xi);
  }
  template<int I>
  ap_int<I> generic_acospi(ap_int<I> x) {

      if(x==-1){
        return 1;

      } else if(x==0){
        return 1;
      } else if(x==1){
        return 0;
      } else{




        return 0;
      };
  }
  template<int I>
  ap_uint<I> generic_acospi(ap_uint<I> x) {

      if(x==0){
        return 1;
      } else if(x==1){
        return 0;
      } else{




        return 0;
      };
  }

  template<int W, int I>
  ap_fixed<W,I> generic_atanpi(ap_fixed<W,I> x) {
      ap_fixed<W-I+3,3> atan_x = generic_atan(x);





      static const int F = W - I;





      static const int wf = F < 1? 0: F - 1;
      ap_ufixed<2+wf,2> pi = 3.14159265358979323846;
      ap_fixed<W,I> r = atan_x/pi;






      return r;
  }
  template<int W, int I>
  ap_ufixed<W,I> generic_atanpi(ap_ufixed<W,I> x) {
      ap_fixed<W+1,I+1> xi = x;
      return generic_atanpi(xi);
  }
  template<int I>
  ap_int<I> generic_atanpi(ap_int<I> x) {

      (void)(x);
      return 0;
  }
  template<int I>
  ap_uint<I> generic_atanpi(ap_uint<I> x) {

      (void)(x);
      return 0;
  }

  template<int W, int I>
  ap_fixed<W,I> generic_atan2pi(ap_fixed<W,I> y, ap_fixed<W, I> x) {
      ap_fixed<W-I+3,3> atan2_x = generic_atan2(y, x);
      static const int F = W - I;





      static const int wf = F;
      ap_ufixed<2+wf,2> pi = 3.14159265358979323846;
      ap_fixed<W,I> r = atan2_x/pi;
      return r;
  }
  template<int W, int I>
  ap_ufixed<W,I> generic_atan2pi(ap_ufixed<W,I> y, ap_ufixed<W,I> x) {
      ap_fixed<W+1,I+1> xi = x;
      ap_fixed<W+1,I+1> yi = y;
      return generic_atan2pi(yi, xi);
  }
  template<int I>
  ap_int<I> generic_atan2pi(ap_int<I> y, ap_int<I> x) {

      bool x_sig = x[I-1];
      bool y_sig = y[I-1];
      if(y==0 && x==0) return 0;


      else if(y_sig && x==0) return -1;

      else if(!y_sig && x==0) return 1;

      else if(!y_sig && x_sig) return 1;

      else if(y_sig && x_sig) return -1;
      else return 0;
  }
  template<int I>
  ap_uint<I> generic_atan2pi(ap_uint<I> y, ap_uint<I> x) {


      if(y!=0 && x==0) return 1;
      else return 0;
  }

}
# 1067 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_math.h" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_exp_apfixed.h" 1
# 36 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_exp_apfixed.h"
namespace exp_reduce {

template<int W_, int I_>
ap_fixed<W_,I_> exp(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline

 int F_ = W_ - I_;
    if (I_>33) return 0;
    else if (F_>32) return 0;




    int I_s_;
    int M_ = (I_-1>F_) ? (I_-1) : F_;
    if (M_==1) I_s_ = 1;
    else if (M_==2) I_s_ = 2;
    else if (M_<6) I_s_ = 3;
    else if (M_<12) I_s_ = 4;
    else if (M_<24) I_s_ = 5;
    else I_s_ = 6;

    ap_fixed<W_,I_> r;
    if (I_s_==1) {
        ap_fixed<3,2> x_l = x;
        ap_ufixed<2,1> y = 0;
        if (x_l[2]!=x_l[1]) {
            if (!x_l[2]) y = "0x1.8p0";
        } else {
            if (!x_l[2]) y[1] = 1;
            if (x_l[2]|x_l[0]) y[0] = 1;
        }
        if (I_<2) {
            if (y[1]) {
                y[1] = 0;
                y[0] = 1;
            }
        }
        r = y;
    } else if (I_s_==2) {
        ap_fixed<5,3> x_l = x;
        ap_ufixed<4,2> y = 0;
        ap_fixed<2,2> x_l_int;
        x_l_int(1,0) = x_l(3,2);
        ap_ufixed<2,0> x_l_fract;
        x_l_fract(1,0) = x_l(1,0);

        if ((x_l[4]!=x_l[3])||((x_l_int==1)&&(x_l_fract>=ap_ufixed<2,0>("0x0.8p0")))) {
            if (!x_l[4]) y = "0x3.cp0";
        } else {
            if (!x_l[4]&((x_l[1]&x_l[0])|x_l[2])) y[3] = 1;
            if (!x_l[4]&((!x_l[2]&!x_l[0])|(!x_l[1]&x_l[0]))) y[2] = 1;
            if ((!x_l[4]&x_l[1]&!x_l[0])|(!x_l[4]&x_l[2])|(x_l[2]&x_l[0])|(x_l[2]&x_l[1])) y[1] = 1;
            if ((!x_l[2]&!x_l[1]&x_l[0])|(!x_l[2]&x_l[1]&!x_l[0])|(x_l[2]&!x_l[1]&!x_l[0])|(x_l[2]&x_l[1]&x_l[0])|(x_l[4]&!x_l[3])) y[0] = 1;
        }
        if (I_<3) {
            bool overf = 0;
            VITIS_LOOP_94_1: for (int j = 3; j >= I_+1; j--) {
#pragma HLS unroll
 if (y[j])
                    overf = 1;
            }
            if (overf) {
                VITIS_LOOP_100_2: for (int j = 3; j >= I_+1; j--){
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_104_3: for (int j = I_; j >= 0; j--){
#pragma HLS unroll
 y[j] = 1;
               }
            }
        }
        r = y;
    } else if (I_s_==3) {
        ap_fixed<11,6> x_l = x;
        ap_ufixed<10,5> y = 0;
        ap_fixed<3,3> x_l_int;
        x_l_int(2,0) = x_l(7,5);
        ap_ufixed<5,0> x_l_fract;
        x_l_fract(4,0) = x_l(4,0);

        if ((x_l[10]!=x_l[9])||(x_l[10]!=x_l[8])||(x_l[10]!=x_l[7])||((x_l_int==3)&&(x_l_fract>ap_fixed<5,0>("0x0.7p0")))) {
            if (!x_l[10]) y = "0x1f.f8p0";
        } else {





            ap_uint<4> x_msb_ind;
            x_msb_ind[3] = x_l[10];
            x_msb_ind(2,0) = x_l(6,4);
            ap_uint<4> x_lsb_ind;
            x_lsb_ind(3,0) = x_l(3,0);
            ap_ufixed<4,-1> x_lsb = x_l;
# 153 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_exp_apfixed.h"
            const static ap_ufixed<12,0> exp_x_lsb_m_1_table[16] = {
                "0x0.0p0", "0x0.082p0", "0x0.108p0", "0x0.193p0", "0x0.221p0", "0x0.2b5p0", "0x0.34dp0", "0x0.3eap0",
                "0x0.48bp0", "0x0.532p0", "0x0.5dfp0", "0x0.69p0", "0x0.748p0", "0x0.805p0", "0x0.8c8p0", "0x0.991p0",
            };
            ap_ufixed<12, 0> exp_x_lsb_m_1 = exp_x_lsb_m_1_table[x_lsb_ind];

            const static ap_ufixed<12,5> exp_x_msb_table[16] = {
                "0x1.0p0", "0x1.a6p0", "0x2.b8p0", "0x4.7cp0", "0x7.64p0", "0xc.2ep0", "0x14.16p0", "0x21.1ep0",
                "0x0.04p0", "0x0.08p0", "0x0.0cp0", "0x0.16p0", "0x0.22p0", "0x0.3ap0", "0x0.5ep0", "0x0.9cp0",
            };
            ap_ufixed<12,5> exp_x_msb = exp_x_msb_table[x_msb_ind];
            ap_ufixed<24,5> y_lo = exp_x_msb * exp_x_lsb_m_1;
            ap_ufixed<12,5> y_lo_s = y_lo;
            ap_ufixed<12,5> y_l = y_lo_s + exp_x_msb;
            y = y_l;
        }
        if (I_<6) {
            bool overf = 0;
            VITIS_LOOP_171_4: for (int j = 9; j >= I_+4; j--) {
#pragma HLS unroll
 if (y[j])
                    overf = 1;
            }
            if (overf) {
                VITIS_LOOP_177_5: for (int j = 9; j >= I_+4; j--){
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_181_6: for (int j = I_+3; j >= 0; j--){
#pragma HLS unroll
 y[j] = 1;
                }
            }
        }
        r = y;
    } else if (I_s_==4) {
        ap_fixed<23,12> x_l = x;
        ap_ufixed<22,11> y = 0;
        ap_fixed<4,4> x_l_int;
        x_l_int(3,0) = x_l(14,11);
        ap_ufixed<11,0> x_l_fract;
        x_l_fract(10,0) = x_l(10,0);
        bool overf = 0;
        VITIS_LOOP_196_7: for (int j = 14; j < 22; j++){
#pragma HLS unroll
 if (x_l[22]!=x_l[j])
                overf = 1;
        }

        if (overf||((x_l_int==7)&&(x_l_fract>ap_ufixed<11,0>("0x0.ap0")))) {
            if (!x_l[22]) {
                VITIS_LOOP_204_8: for (int j = 0; j < 22; j++){
#pragma HLS unroll
 y[j] = 1;
                }
            }
        } else {
            ap_uint<5> x_msb_ind_1;
            x_msb_ind_1[4] = x_l[22];
            x_msb_ind_1(3,0) = x_l(13,10);
            ap_uint<5> x_msb_ind_2;
            x_msb_ind_2(4,0) = x_l(9,5);
            ap_ufixed<5,-1> x_msb_2 = x_l;
            ap_uint<5> x_lsb_ind;
            x_lsb_ind(4,0) = x_l(4,0);


            const static ap_ufixed<11,-13> f_x_lsb_table[32] = {
                "0x0.0p0", "0x0.000002p0", "0x0.000008p0", "0x0.000012p0",
                "0x0.00002p0", "0x0.000032p0", "0x0.000048p0", "0x0.000062p0",
                "0x0.00008p0", "0x0.0000a2p0", "0x0.0000c9p0", "0x0.0000f3p0",
                "0x0.000121p0", "0x0.000153p0", "0x0.000189p0", "0x0.0001c3p0",
                "0x0.000202p0", "0x0.000244p0", "0x0.00028ap0", "0x0.0002d4p0",
                "0x0.000323p0", "0x0.000375p0", "0x0.0003ccp0", "0x0.000426p0",
                "0x0.000485p0", "0x0.0004e7p0", "0x0.00054ep0", "0x0.0005b9p0",
                "0x0.000627p0", "0x0.00069ap0", "0x0.000711p0", "0x0.00078cp0",
            };
            ap_ufixed<11,-13> f_x_lsb = f_x_lsb_table[x_lsb_ind];
            ap_ufixed<18, -6> exp_x_lsb_m_1 = 0;
            exp_x_lsb_m_1(17,13) = x_lsb_ind(4,0);
            exp_x_lsb_m_1(10,0) = f_x_lsb(10,0);

            const static ap_ufixed<25,0> exp_x_msb_2_m_1_table[32] = {
                "0x0.0000000p0", "0x0.04080a8p0", "0x0.0820560p0", "0x0.0c49238p0",
                "0x0.1082b58p0", "0x0.14cd500p0", "0x0.1929370p0", "0x0.1d96b10p0",
                "0x0.2216048p0", "0x0.26a7790p0", "0x0.2b4b588p0", "0x0.3001ed0p0",
                "0x0.34cb818p0", "0x0.39a8628p0", "0x0.3e98de8p0", "0x0.439d440p0",
                "0x0.48b5e40p0", "0x0.4de30f0p0", "0x0.5325180p0", "0x0.587c540p0",
                "0x0.5de9178p0", "0x0.636bb98p0", "0x0.6904930p0", "0x0.6eb3fc8p0",
                "0x0.747a510p0", "0x0.7a57ee0p0", "0x0.804d300p0", "0x0.865a778p0",
                "0x0.8c80248p0", "0x0.92be998p0", "0x0.99163b0p0", "0x0.9f876e8p0",
            };
            ap_ufixed<25, 0> exp_x_msb_2_m_1 = exp_x_msb_2_m_1_table[x_msb_ind_2];

            ap_ufixed<43,-6> f_x_msb_2_lsb = exp_x_msb_2_m_1 * exp_x_lsb_m_1;
            ap_ufixed<19,-6> f_x_msb_2_lsb_s = f_x_msb_2_lsb;
            ap_ufixed<25, 0> exp_x_msb_2_lsb_m_1 = f_x_msb_2_lsb_s + exp_x_lsb_m_1 + exp_x_msb_2_m_1;

            const static ap_ufixed<25,11> exp_x_msb_1_table[32] = {
                "0x1.0000p0", "0x1.a614p0", "0x2.b7e0p0", "0x4.7b50p0",
                "0x7.6398p0", "0xc.2eb8p0", "0x14.15e4p0", "0x21.1d90p0",
                "0x36.9920p0", "0x5a.0464p0", "0x94.69c4p0", "0xf4.b124p0",
                "0x193.6dc4p0", "0x299.2444p0", "0x448.a218p0", "0x710.0adcp0",
                "0x0.0014p0", "0x0.0024p0", "0x0.003cp0", "0x0.0064p0",
                "0x0.00a4p0", "0x0.010cp0", "0x0.01b8p0", "0x0.02d8p0",
                "0x0.04b0p0", "0x0.07bcp0", "0x0.0cc0p0", "0x0.1504p0",
                "0x0.22a4p0", "0x0.3920p0", "0x0.5e2cp0", "0x0.9b44p0",
            };
            ap_ufixed<25,11> exp_x_msb_1 = exp_x_msb_1_table[x_msb_ind_1];
            ap_ufixed<50,11> y_lo = exp_x_msb_1 * exp_x_msb_2_lsb_m_1;
            ap_ufixed<25,11> y_lo_s = y_lo;
            ap_ufixed<25,11> y_l = y_lo_s + exp_x_msb_1;
            y = y_l;
        }
        if (I_<12) {
            bool overf = 0;
            VITIS_LOOP_269_9: for (int j = 21; j >= I_+10; j--) {
#pragma HLS unroll
 if (y[j])
                    overf = 1;
            }
            if (overf) {
                VITIS_LOOP_275_10: for (int j = 21; j >= I_+10; j--) {
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_279_11: for (int j = I_+9; j >= 0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        }
        r = y;
    } else if (I_s_==5) {
        ap_fixed<47,24> x_l = x;
        ap_ufixed<46,23> y = 0;
        ap_fixed<5,5> x_l_int;
        x_l_int(4,0) = x_l(27,23);
        ap_ufixed<23,0> x_l_fract;
        x_l_fract(22,0) = x_l(22,0);
        bool overf = 0;
        VITIS_LOOP_294_12: for (int j = 27; j < 46; j++){
#pragma HLS unroll
 if (x_l[46]!=x_l[j])
                overf = 1;
        }

        if (overf||((x_l_int==15)&&(x_l_fract>=ap_ufixed<23,0>("0x0.f14028p0")))) {
            if (!x_l[46]) {
                VITIS_LOOP_302_13: for (int j = 0; j < 46; j++) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        } else {
            ap_uint<8> x_msb_ind_1;
            x_msb_ind_1[7] = x_l[46];
            x_msb_ind_1(6,0) = x_l(26,20);
            ap_uint<8> x_msb_ind_2;
            x_msb_ind_2(7,0) = x_l(19,12);
            ap_uint<5> x_msb_ind_3;
            x_msb_ind_3(4,0) = x_l(11,7);
            ap_uint<3> x_msb_ind_4;
            x_msb_ind_4(2,0) = x_l(6,4);
            ap_uint<4> x_lsb_ind;
            x_lsb_ind(3,0) = x_l(3,0);

            ap_ufixed<8, -3> x_msb_2 = x_l;
            ap_ufixed<5,-11> x_msb_3 = x_l;
            ap_ufixed<3,-16> x_msb_4 = x_l;
            ap_ufixed<4,-19> x_lsb = x_l;

            const static ap_ufixed< 6,-33> f_x_msb_4_h_table[8] = {
"0x0.0000000000p0", "0x0.0000000002p0", "0x0.0000000008p0", "0x0.0000000012p0",
"0x0.0000000020p0", "0x0.0000000032p0", "0x0.0000000048p0", "0x0.0000000062p0",
            };
            const static ap_ufixed< 7,-51> f_x_msb_4_l_table[8] = {
"0x0.000000000000000p0", "0x0.000000000000000p0", "0x0.00000000000000cp0", "0x0.000000000000024p0",
"0x0.000000000000054p0", "0x0.0000000000000a8p0", "0x0.000000000000120p0", "0x0.0000000000001c8p0",
            };
            ap_ufixed< 6,-33> f_x_msb_4_h = f_x_msb_4_h_table[x_msb_ind_4];
            ap_ufixed< 7,-51> f_x_msb_4_l = f_x_msb_4_l_table[x_msb_ind_4];

            const static ap_ufixed< 8,-39> f_x_lsb_table[16] = {
"0x0.000000000000p0", "0x0.000000000002p0", "0x0.000000000008p0", "0x0.000000000012p0",
"0x0.000000000020p0", "0x0.000000000032p0", "0x0.000000000048p0", "0x0.000000000062p0",
"0x0.000000000080p0", "0x0.0000000000a2p0", "0x0.0000000000c8p0", "0x0.0000000000f2p0",
"0x0.000000000120p0", "0x0.000000000152p0", "0x0.000000000188p0", "0x0.0000000001c2p0",
            };
            ap_ufixed< 8,-39> f_x_lsb = f_x_lsb_table[x_lsb_ind];

            ap_ufixed< 7,-35> f_x_msb_4_lsb = x_msb_4 * x_lsb;

            ap_ufixed<10,-32> exp_x_msb_4_lsb_m_1_m = 0;
            exp_x_msb_4_lsb_m_1_m(8,3) = f_x_msb_4_h(5,0);
            exp_x_msb_4_lsb_m_1_m(2,0) = f_x_lsb(7,5);
            exp_x_msb_4_lsb_m_1_m = exp_x_msb_4_lsb_m_1_m + f_x_msb_4_lsb;

            ap_ufixed<42,-16> exp_x_msb_4_lsb_m_1 = 0;
            exp_x_msb_4_lsb_m_1(41,35) = x_l(6,0);
            exp_x_msb_4_lsb_m_1(25,16) = exp_x_msb_4_lsb_m_1_m(9,0);
            exp_x_msb_4_lsb_m_1(15,11) = f_x_lsb(4,0);
            exp_x_msb_4_lsb_m_1( 6, 0) = f_x_msb_4_l(6,0);


            const static ap_ufixed<32,-23> f_x_msb_3_table[32] = {
"0x0.00000000000000p0", "0x0.0000000080002ap0", "0x0.00000002000156p0", "0x0.00000004800480p0",
"0x0.00000008000aaap0", "0x0.0000000c8014d6p0", "0x0.00000012002400p0", "0x0.0000001880392cp0",
"0x0.00000020005556p0", "0x0.00000028807982p0", "0x0.0000003200a6acp0", "0x0.0000003c80ddd8p0",
"0x0.00000048012004p0", "0x0.00000054816e30p0", "0x0.0000006201c95cp0", "0x0.00000070823288p0",
"0x0.0000008002aab6p0", "0x0.000000908332e2p0", "0x0.000000a203cc12p0", "0x0.000000b4847740p0",
"0x0.000000c8053570p0", "0x0.000000dc8607a0p0", "0x0.000000f206eed0p0", "0x0.0000010887ec02p0",
"0x0.00000120090036p0", "0x0.000001388a2c6ap0", "0x0.000001520b71a0p0", "0x0.0000016c8cd0d6p0",
"0x0.000001880e4b0ep0", "0x0.000001a48fe148p0", "0x0.000001c2119484p0", "0x0.000001e09365c0p0",
            };

            ap_ufixed<32,-23> f_x_msb_3 = f_x_msb_3_table[x_msb_ind_3];
            ap_ufixed<44,-11> exp_x_msb_3_m_1 = 0;
            exp_x_msb_3_m_1(43,39) = x_msb_3(4,0);
            exp_x_msb_3_m_1(31, 0) = f_x_msb_3(31,0);

            ap_ufixed<86,-27> f_x_msb_3_4_lsb = exp_x_msb_3_m_1 * exp_x_msb_4_lsb_m_1;
            ap_ufixed<31,-27> f_x_msb_3_4_lsb_s = f_x_msb_3_4_lsb;
            ap_ufixed<48,-10> exp_x_msb_3_4_lsb_m_1 = f_x_msb_3_4_lsb_s + exp_x_msb_3_m_1 + exp_x_msb_4_lsb_m_1;


            const static ap_ufixed<46,-6> f_x_msb_2_table[256] = {
"0x0", "0x0.0000020015560p0", "0x0.00000800AAB55p0", "0x0.0000120240360p0",
"0x0.0000200556001p0", "0x0.0000320A6C4B8p0", "0x0.0000481203608p0", "0x0.0000621C9B971p0",
"0x0.0000802AB5577p0", "0x0.0000A23CD119Dp0", "0x0.0000C8536F668p0", "0x0.0000F26F10D5Dp0",
"0x0.0001209036103p0", "0x0.000152B75FCE3p0", "0x0.000188E50ED86p0", "0x0.0001C319C4077p0",
"0x0.0002015600445p0", "0x0.0002439A4487Ep0", "0x0.000289E711DB3p0", "0x0.0002D43CE9577p0",
"0x0.0003229C4C260p0", "0x0.00037505BB805p0", "0x0.0003CB79B8B01p0", "0x0.000425F8C50F2p0",
"0x0.0004848362076p0", "0x0.0004E71A11131p0", "0x0.00054DBD53BC8p0", "0x0.0005B86DAB9E3p0",
"0x0.0006272B9A630p0", "0x0.000699F7A1C5Dp0", "0x0.000710D24391Ep0", "0x0.00078BBC01A29p0",
"0x0.00080AB55DE39p0", "0x0.00088DBEDA50Bp0", "0x0.000914D8F8F63p0", "0x0.0009A0043BF07p0",
"0x0.000A2F41256C2p0", "0x0.000AC29037A63p0", "0x0.000B59F1F4EBDp0", "0x0.000BF566DF9AAp0",
"0x0.000C94EF7A206p0", "0x0.000D388C46FB4p0", "0x0.000DE03DC8B9Bp0", "0x0.000E8C0481FA7p0",
"0x0.000F3BE0F56CAp0", "0x0.000FEFD3A5CFAp0", "0x0.0010A7DD15F36p0", "0x0.001163FDC8B7Fp0",
"0x0.00122436410DDp0", "0x0.0012E88701F5Ep0", "0x0.0013B0F08E817p0", "0x0.00147D7369D22p0",
"0x0.00154E101719Fp0", "0x0.001622C7199B7p0", "0x0.0016FB98F4A96p0", "0x0.0017D8862BA72p0",
"0x0.0018B98F42084p0", "0x0.00199EB4BB511p0", "0x0.001A87F71B161p0", "0x0.001B7556E4FC4p0",
"0x0.001C66D49CB93p0", "0x0.001D5C70C612Dp0", "0x0.001E562BE4DFAp0", "0x0.001F54067D067p0",
"0x0.00205601127ECp0", "0x0.00215C1C29507p0", "0x0.0022665845940p0", "0x0.002374B5EB724p0",
"0x0.002487359F24Cp0", "0x0.00259DD7E4F57p0", "0x0.0026B89D413EFp0", "0x0.0027D786386C4p0",
"0x0.0028FA934EF90p0", "0x0.002A21C509717p0", "0x0.002B4D1BEC726p0", "0x0.002C7C987CA92p0",
"0x0.002DB03B3ED3Ap0", "0x0.002EE804B7C07p0", "0x0.003023F56C4ECp0", "0x0.0031640DE16E3p0",
"0x0.0032A84E9C1F5p0", "0x0.0033F0B821730p0", "0x0.00353D4AF68B0p0", "0x0.00368E07A0999p0",
"0x0.0037E2EEA4E19p0", "0x0.00393C0088B6Cp0", "0x0.003A993DD17D5p0", "0x0.003BFAA704AA3p0",
"0x0.003D603CA7C32p0", "0x0.003EC9FF405E6p0", "0x0.004037EF54230p0", "0x0.0041AA0D68C8Cp0",
"0x0.0043205A04182p0", "0x0.00449AD5ABEA5p0", "0x0.00461980E6294p0", "0x0.00479C5C38CF9p0",
"0x0.0049236829E8Bp0", "0x0.004AAEA53F90Ep0", "0x0.004C3E13FFF51p0", "0x0.004DD1B4F152Fp0",
"0x0.004F698899F90p0", "0x0.0051058F8046Ap0", "0x0.0052A5CA2AABFp0", "0x0.00544A391FA9Cp0",
"0x0.0055F2DCE5D1Ep0", "0x0.00579FB603C6Ep0", "0x0.005950C5003C2p0", "0x0.005B060A61F5Dp0",
"0x0.005CBF86AFC91p0", "0x0.005E7D3A709BEp0", "0x0.00603F262B650p0", "0x0.0062054A672C2p0",
"0x0.0063CFA7AB09Dp0", "0x0.00659E3E7E278p0", "0x0.0067710F67BFAp0", "0x0.0069481AEF1D5p0",
"0x0.006B23619B9CFp0", "0x0.006D02E3F4AB7p0", "0x0.006EE6A281C6Fp0", "0x0.0070CE9DCA7E6p0",
"0x0.0072BAD65671Bp0", "0x0.0074AB4CAD51Cp0", "0x0.0076A00156E07p0", "0x0.007898F4DAF09p0",
"0x0.007A9627C165Fp0", "0x0.007C979A92356p0", "0x0.007E9D4DD564Ap0", "0x0.0080A742130A8p0",
"0x0.0082B577D34EDp0", "0x0.0084C7EF9E6A7p0", "0x0.0086DEA9FCA73p0", "0x0.0088F9A776601p0",
"0x0.008B18E894010p0", "0x0.008D3C6DDE06Fp0", "0x0.008F6437DD000p0", "0x0.00919047198B6p0",
"0x0.0093C09C1C595p0", "0x0.0095F5376E2B2p0", "0x0.00982E1997D33p0", "0x0.009A6B4322352p0",
"0x0.009CACB496458p0", "0x0.009EF26E7D0A2p0", "0x0.00A13C715F99Ep0", "0x0.00A38ABDC71CEp0",
"0x0.00A5DD543CCC4p0", "0x0.00A8343549F26p0", "0x0.00AA8F6177EADp0", "0x0.00ACEED950222p0",
"0x0.00AF529D5C165p0", "0x0.00B1BAAE25566p0", "0x0.00B4270C3582Ap0", "0x0.00B697B8164C7p0",
"0x0.00B90CB25176Ap0", "0x0.00BB85FB70D50p0", "0x0.00BE0393FE4CCp0", "0x0.00C0857C83D44p0",
"0x0.00C30BB58B732p0", "0x0.00C5963F9F424p0", "0x0.00C8251B496BEp0", "0x0.00CAB849142B5p0",
"0x0.00CD4FC989CD6p0", "0x0.00CFEB9D34B00p0", "0x0.00D28BC49F428p0", "0x0.00D5304054059p0",
"0x0.00D7D910DD8B1p0", "0x0.00DA8636C6764p0", "0x0.00DD37B2997BCp0", "0x0.00DFED84E1618p0",
"0x0.00E2A7AE28FECp0", "0x0.00E5662EFB3C3p0", "0x0.00E82907E313Dp0", "0x0.00EAF0396B910p0",
"0x0.00EDBBC41FD08p0", "0x0.00F08BA88B009p0", "0x0.00F35FE73860Bp0", "0x0.00F63880B341Ep0",
"0x0.00F9157587069p0", "0x0.00FBF6C63F228p0", "0x0.00FEDC73671B0p0", "0x0.0101C67D8A86Cp0",
"0x0.0104B4E5350DFp0", "0x0.0107A7AAF26A2p0", "0x0.010A9ECF4E667p0", "0x0.010D9A52D4DF8p0",
"0x0.01109A3611C34p0", "0x0.01139E7991116p0", "0x0.0116A71DDEDADp0", "0x0.0119B42387423p0",
"0x0.011CC58B167B9p0", "0x0.011FDB5518CCAp0", "0x0.0122F5821A8C7p0", "0x0.01261412A823Cp0",
"0x0.012937074E0CDp0", "0x0.012C5E6098D37p0", "0x0.012F8A1F15151p0", "0x0.0132BA434F80Ap0",
"0x0.0135EECDD4D6Cp0", "0x0.013927BF31E98p0", "0x0.013C6517F39CCp0", "0x0.013FA6D8A6E5Dp0",
"0x0.0142ED01D8CBCp0", "0x0.0146379416673p0", "0x0.0149868FECE26p0", "0x0.014CD9F5E9795p0",
"0x0.015031C699799p0", "0x0.01538E028A426p0", "0x0.0156EEAA4944Bp0", "0x0.015A53BE64033p0",
"0x0.015DBD3F68122p0", "0x0.01612B2DE3178p0", "0x0.01649D8A62CB1p0", "0x0.0168145574F65p0",
"0x0.016B8F8FA7745p0", "0x0.016F0F3988321p0", "0x0.01729353A52E4p0", "0x0.01761BDE8C792p0",
"0x0.0179A8DACC350p0", "0x0.017D3A48F295Dp0", "0x0.0180D0298DE13p0", "0x0.01846A7D2C6ECp0",
"0x0.018809445CA7Bp0", "0x0.018BAC7FAD074p0", "0x0.018F542FAC1A4p0", "0x0.01930054E87F8p0",
"0x0.0196B0EFF0E79p0", "0x0.019A66015414Dp0", "0x0.019E1F89A0DBAp0", "0x0.01A1DD8966221p0",
"0x0.01A5A00132E02p0", "0x0.01A966F1961FCp0", "0x0.01AD325B1EFC9p0", "0x0.01B1023E5CA45p0",
"0x0.01B4D69BDE569p0", "0x0.01B8AF743364Cp0", "0x0.01BC8CC7EB323p0", "0x0.01C06E9795345p0",
"0x0.01C454E3C0F24p0", "0x0.01C83FACFE054p0", "0x0.01CC2EF3DC187p0", "0x0.01D022B8EAE8Fp0",
"0x0.01D41AFCBA45Ep0", "0x0.01D817BFDA104p0", "0x0.01DC1902DA3B1p0", "0x0.01E01EC64ACB7p0",
"0x0.01E4290ABBD87p0", "0x0.01E837D0BD8B2p0", "0x0.01EC4B18E01E9p0", "0x0.01F062E3B3DFEp0",
"0x0.01F47F31C92E4p0", "0x0.01F8A003B07AFp0", "0x0.01FCC559FA492p0", "0x0.0200EF35372E4p0",
"0x0.02051D95F7D1Cp0", "0x0.0209507CCCED1p0", "0x0.020D87EA474BEp0", "0x0.0211C3DEF7CBDp0",
            };
            ap_ufixed<46,-6> f_x_msb_2 = f_x_msb_2_table[x_msb_ind_2];
            ap_ufixed< 5,-6> f_x_msb_2_h;
            f_x_msb_2_h(4,0) = f_x_msb_2(45,41);
            ap_ufixed< 9,-2> exp_x_msb_2_m_1_h = f_x_msb_2_h + x_msb_2;
            ap_ufixed<50,-2> exp_x_msb_2_m_1;
            exp_x_msb_2_m_1(49,41) = exp_x_msb_2_m_1_h(8,0);
            exp_x_msb_2_m_1(40, 0) = f_x_msb_2(40,0);

            ap_ufixed<98,-12> f_x_msb_2_3_4_lsb = exp_x_msb_2_m_1 * exp_x_msb_3_4_lsb_m_1;
            ap_ufixed<46,-12> f_x_msb_2_3_4_lsb_s = f_x_msb_2_3_4_lsb;
            ap_ufixed<50,-2> exp_x_msb_2_3_4_lsb_m_1 = f_x_msb_2_3_4_lsb_s + exp_x_msb_2_m_1 + exp_x_msb_3_4_lsb_m_1;

            const static ap_ufixed<50,23> exp_x_msb_1_table[256] = {
"0x1.0000000p0", "0x1.2216045p0", "0x1.48B5E3Cp0", "0x1.747A513p0",
"0x1.A61298Ep0", "0x1.DE455DFp0", "0x2.1DF3B68p0", "0x2.661CB0Fp0",
"0x2.B7E1516p0", "0x3.1489176p0", "0x3.7D871DBp0", "0x3.F47FE87p0",
"0x4.7B4FF99p0", "0x5.1413452p0", "0x5.C12DA41p0", "0x6.855466Ep0",
"0x7.63992E3p0", "0x8.5F7635Bp0", "0x9.7CDC417p0", "0xA.C042667p0",
"0xC.2EB7EC9p0", "0xD.CDF892Ep0", "0xF.A48385Ep0", "0x11.B9B5652p0",
"0x14.15E5BF6p0", "0x16.C2887C1p0", "0x19.CA53B78p0", "0x1D.396AA97p0",
"0x21.1D8E427p0", "0x25.865441Cp0", "0x2A.8565A14p0", "0x30.2EC550Bp0",
"0x36.99205C4p0", "0x3D.DE28BF3p0", "0x46.1AFC4DBp0", "0x4F.7099532p0",
"0x5A.0462B78p0", "0x66.00B5BC9p0", "0x73.9593ABBp0", "0x82.F9621ADp0",
"0x94.69C4CB8p0", "0xA8.2C948C1p0", "0xBE.90F6F83p0", "0xD7.F09B78Cp0",
"0xF4.B122790p0", "0x115.45B4704p0", "0x13A.30CF1CCp0", "0x164.0650296p0",
"0x193.6DC5690p0", "0x1C9.250BEDCp0", "0x206.03487A3p0", "0x24A.FC4533Cp0",
"0x299.2442102p0", "0x2F1.B447462p0", "0x356.0F0B0F9p0", "0x3C7.C67E5BEp0",
"0x448.A216ABBp0", "0x4DA.A5EE46Ap0", "0x580.1AD754Fp0", "0x63B.9782341p0",
"0x710.0ADBAC7p0", "0x800.C7CC8E3p0", "0x911.9289C39p0", "0xA46.AFAA2ADp0",
"0xBA4.F53EA38p0", "0xD31.DE30C52p0", "0xEF3.A035D57p0", "0x10F1.44ADE60p0",
"0x1332.C4D2B7Cp0", "0x15C1.29A744Cp0", "0x18A6.B027DA0p0", "0x1BEE.F24BB12p0",
"0x1FA7.157C470p0", "0x23DD.FF3C8BAp0", "0x28A4.90D2CCEp0", "0x2E0D.EAE454Bp0",
"0x342F.BA11823p0", "0x3B22.8DC5359p0", "0x4302.3A933EEp0", "0x4BEE.49AFCDCp0",
"0x560A.773E541p0", "0x617F.4171BF9p0", "0x6E7A.8ABB4A8p0", "0x7D30.5191764p0",
"0x8DDB.80AF426p0", "0xA0BE.DB0DB10p0", "0xB626.0748BAEp0", "0xCE66.BE9EAADp0",
"0xE9E2.2447727p0", "0x10906.4A831F8p0", "0x12C4F.EB75B2Ap0", "0x1544C.5CB6133p0",
"0x1819B.C560F61p0", "0x1B4F3.9F8AF64p0", "0x1EF21.8F1B001p0", "0x2310E.996C40Fp0",
"0x27BC2.CA9A6F9p0", "0x2D069.571279Ap0", "0x33055.49F35D9p0", "0x39D06.D2FEF17p0",
"0x41831.49596E9p0", "0x4A3C1.FB2AC39p0", "0x541E7.E56949Dp0", "0x5F51C.72B7532p0",
"0x6C02D.645AB25p0", "0x7A648.0CFF534p0", "0x8AB06.0A3EE9Fp0", "0x9D27B.AFE4CF1p0",
"0xB2148.5EAE56Cp0", "0xC9CA9.07F86EFp0", "0xE4A8D.2881EDBp0", "0x1031AE.8E4996Cp0",
"0x1259AC.48BF05Dp0", "0x14CB29.2F2B31Fp0", "0x178FEE.7792E44p0", "0x1AB312.E89CD0Dp0",
"0x1E4127.437732Bp0", "0x224868.979FC2Ep0", "0x26D8F9.4A204BEp0", "0x2C0521.B4A8E0Bp0",
"0x31E199.5F5A550p0", "0x3885D9.FA89D00p0", "0x400C7D.64D3386p0", "0x4893A8.361032Dp0",
"0x523D82.79EDAEFp0", "0x5D30C0.7DAB686p0", "0x69993D.D4F2D95p0", "0x77A8AD.02A7C71p0",
"0x0.000001Ep0", "0x0.0000022p0", "0x0.0000026p0", "0x0.000002Bp0",
"0x0.0000031p0", "0x0.0000038p0", "0x0.000003Fp0", "0x0.0000048p0",
"0x0.0000052p0", "0x0.000005Dp0", "0x0.0000069p0", "0x0.0000077p0",
"0x0.0000087p0", "0x0.0000099p0", "0x0.00000ADp0", "0x0.00000C4p0",
"0x0.00000DFp0", "0x0.00000FCp0", "0x0.000011Ep0", "0x0.0000144p0",
"0x0.0000170p0", "0x0.00001A1p0", "0x0.00001D8p0", "0x0.0000217p0",
"0x0.000025Ep0", "0x0.00002AFp0", "0x0.000030Bp0", "0x0.0000372p0",
"0x0.00003E8p0", "0x0.000046Dp0", "0x0.0000504p0", "0x0.00005AFp0",
"0x0.0000671p0", "0x0.000074Cp0", "0x0.0000845p0", "0x0.000095Fp0",
"0x0.0000A9Fp0", "0x0.0000C09p0", "0x0.0000DA3p0", "0x0.0000F74p0",
"0x0.0001183p0", "0x0.00013D8p0", "0x0.000167Cp0", "0x0.000197Bp0",
"0x0.0001CDFp0", "0x0.00020B7p0", "0x0.0002513p0", "0x0.0002A02p0",
"0x0.0002F9Ap0", "0x0.00035F1p0", "0x0.0003D20p0", "0x0.0004543p0",
"0x0.0004E7Cp0", "0x0.00058F0p0", "0x0.00064C7p0", "0x0.0007232p0",
"0x0.0008167p0", "0x0.00092A2p0", "0x0.000A628p0", "0x0.000BC48p0",
"0x0.000D55Ap0", "0x0.000F1C2p0", "0x0.00111F3p0", "0x0.001366Cp0",
"0x0.0015FC2p0", "0x0.0018E98p0", "0x0.001C3AAp0", "0x0.001FFCEp0",
"0x0.00243F3p0", "0x0.002912Bp0", "0x0.002E8ABp0", "0x0.0034BD2p0",
"0x0.003BC2Dp0", "0x0.0043B7Dp0", "0x0.004CBC1p0", "0x0.0056F3Ap0",
"0x0.0062878p0", "0x0.006FA5Fp0", "0x0.007E83Ap0", "0x0.008F5C0p0",
"0x0.00A2728p0", "0x0.00B813Bp0", "0x0.00D0963p0", "0x0.00EC5C1p0",
"0x0.010BD4Ap0", "0x0.012F7DEp0", "0x0.0157E6Bp0", "0x0.0185B0Fp0",
"0x0.01B993Fp0", "0x0.01F45F9p0", "0x0.0236FF5p0", "0x0.02827E0p0",
"0x0.02D80A0p0", "0x0.0338F9Fp0", "0x0.03A6D22p0", "0x0.04234A7p0",
"0x0.04B0556p0", "0x0.0550280p0", "0x0.0605424p0", "0x0.06D279Ap0",
"0x0.07BB040p0", "0x0.08C284Cp0", "0x0.09ED1B4p0", "0x0.0B3F736p0",
"0x0.0CBED86p0", "0x0.0E7149Cp0", "0x0.105D938p0", "0x0.128B697p0",
"0x0.150385Cp0", "0x0.17CFCC2p0", "0x0.1AFB718p0", "0x0.1E9328Bp0",
"0x0.22A5554p0", "0x0.2742456p0", "0x0.2C7C72Fp0", "0x0.3268CDBp0",
"0x0.391F0EEp0", "0x0.40BA188p0", "0x0.495860Dp0", "0x0.531C6C9p0",
"0x0.5E2D58Dp0", "0x0.6AB7782p0", "0x0.78ED03Ap0", "0x0.8906E49p0",
"0x0.9B4597Ep0", "0x0.AFF230Ap0", "0x0.C75F7CFp0", "0x0.E1EB512p0",
            };
            ap_ufixed<50,23> exp_x_msb_1 = exp_x_msb_1_table[x_msb_ind_1];
            ap_ufixed<100,21> y_lo = exp_x_msb_1 * exp_x_msb_2_3_4_lsb_m_1;
            ap_ufixed<48,21> y_lo_s = y_lo;
            ap_ufixed<50,23> y_l = y_lo_s + exp_x_msb_1;
            y = y_l;
        }
        if (I_<24) {
            bool overf = 0;
            VITIS_LOOP_531_14: for (int j = 45; j >= I_+22; j--) {
#pragma HLS unroll
 if (y[j])
                    overf = 1;
            }
            if (overf) {
                VITIS_LOOP_537_15: for (int j = 45; j >= I_+22; j--){
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_541_16: for (int j = I_+21; j >= 0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        }
        r = y;
    } else {

        ap_fixed<65,33> x_l = 0;
        VITIS_LOOP_551_17: for (int j = 32-F_; j < 32+I_; j++){
#pragma HLS unroll
 x_l[j] = x[j-(32-F_)];
        }
        VITIS_LOOP_555_18: for (int j = 32+I_; j <= 64; j++){
#pragma HLS unroll
 x_l[j] = x[W_-1];
        }
        ap_ufixed<64,32> y = 0;
        ap_fixed<6,6> x_l_int;
        x_l_int(5,0) = x_l(37,32);
        ap_ufixed<32,0> x_l_fract;
        x_l_fract(31,0) = x_l(31,0);
        bool overf = 0;
        VITIS_LOOP_565_19: for (int j = 37; j < 64; j++) {
#pragma HLS unroll
 if (x_l[64]!=x_l[j])
                overf = 1;
        }

        if (overf||(x_l_int>22)||((x_l_int==22)&&(x_l_fract>=ap_ufixed<32,0>("0x0.2e42fefap0")))) {
            if (!x_l[64]) {
                VITIS_LOOP_573_20: for (int j = 0; j < 64; j++){
#pragma HLS unroll
 y[j] = 1;
                }
            }
        } else {
            ap_uint<8> x_msb_ind_1;
            x_msb_ind_1[7] = x_l[64];
            x_msb_ind_1(6,0) = x_l(36,30);
            ap_uint<8> x_msb_ind_2;
            x_msb_ind_2(7,0) = x_l(29,22);
            ap_uint<8> x_msb_ind_3;
            x_msb_ind_3(7,0) = x_l(21,14);
            ap_uint<8> x_msb_ind_4;
            x_msb_ind_4(7,0) = x_l(13,6);
            ap_uint<6> x_lsb_ind;
            x_lsb_ind(5,0) = x_l(5,0);

            ap_ufixed<8, -2> x_msb_2 = x_l;
            ap_ufixed<8,-10> x_msb_3 = x_l;
            ap_ufixed<8,-18> x_msb_4 = x_l;
            ap_ufixed<6,-26> x_lsb = x_l;

            const static ap_ufixed<31,-37> f_x_msb_4_table[256] = {
"0x0.000000000000000000p0", "0x0.000000000000080000p0", "0x0.000000000000200000p0", "0x0.000000000000480000p0",
"0x0.000000000000800000p0", "0x0.000000000000C80000p0", "0x0.000000000001200000p0", "0x0.000000000001880000p0",
"0x0.000000000002000001p0", "0x0.000000000002880001p0", "0x0.000000000003200002p0", "0x0.000000000003C80003p0",
"0x0.000000000004800004p0", "0x0.000000000005480005p0", "0x0.000000000006200007p0", "0x0.000000000007080008p0",
"0x0.00000000000800000Ap0", "0x0.00000000000908000Cp0", "0x0.00000000000A20000Fp0", "0x0.00000000000B480011p0",
"0x0.00000000000C800014p0", "0x0.00000000000DC80018p0", "0x0.00000000000F20001Bp0", "0x0.00000000001088001Fp0",
"0x0.000000000012000024p0", "0x0.000000000013880028p0", "0x0.00000000001520002Dp0", "0x0.000000000016C80033p0",
"0x0.000000000018800039p0", "0x0.00000000001A48003Fp0", "0x0.00000000001C200046p0", "0x0.00000000001E08004Dp0",
"0x0.000000000020000055p0", "0x0.00000000002208005Dp0", "0x0.000000000024200066p0", "0x0.00000000002648006Fp0",
"0x0.000000000028800079p0", "0x0.00000000002AC80083p0", "0x0.00000000002D20008Ep0", "0x0.00000000002F88009Ap0",
"0x0.0000000000320000A6p0", "0x0.0000000000348800B3p0", "0x0.0000000000372000C0p0", "0x0.000000000039C800CFp0",
"0x0.00000000003C8000DDp0", "0x0.00000000003F4800EDp0", "0x0.0000000000422000FDp0", "0x0.00000000004508010Ep0",
"0x0.000000000048000120p0", "0x0.00000000004B080132p0", "0x0.00000000004E200145p0", "0x0.000000000051480159p0",
"0x0.00000000005480016Ep0", "0x0.000000000057C80183p0", "0x0.00000000005B20019Ap0", "0x0.00000000005E8801B1p0",
"0x0.0000000000620001C9p0", "0x0.0000000000658801E2p0", "0x0.0000000000692001FCp0", "0x0.00000000006CC80216p0",
"0x0.000000000070800232p0", "0x0.00000000007448024Fp0", "0x0.00000000007820026Cp0", "0x0.00000000007C08028Bp0",
"0x0.0000000000800002AAp0", "0x0.0000000000840802CBp0", "0x0.0000000000882002ECp0", "0x0.00000000008C48030Fp0",
"0x0.000000000090800332p0", "0x0.000000000094C80357p0", "0x0.00000000009920037Dp0", "0x0.00000000009D8803A4p0",
"0x0.0000000000A20003CCp0", "0x0.0000000000A68803F5p0", "0x0.0000000000AB20041Fp0", "0x0.0000000000AFC8044Ap0",
"0x0.0000000000B4800477p0", "0x0.0000000000B94804A4p0", "0x0.0000000000BE2004D3p0", "0x0.0000000000C3080503p0",
"0x0.0000000000C8000535p0", "0x0.0000000000CD080567p0", "0x0.0000000000D220059Bp0", "0x0.0000000000D74805D1p0",
"0x0.0000000000DC800607p0", "0x0.0000000000E1C8063Fp0", "0x0.0000000000E7200678p0", "0x0.0000000000EC8806B2p0",
"0x0.0000000000F20006EEp0", "0x0.0000000000F788072Bp0", "0x0.0000000000FD20076Ap0", "0x0.000000000102C807AAp0",
"0x0.0000000001088007EBp0", "0x0.00000000010E48082Ep0", "0x0.000000000114200872p0", "0x0.00000000011A0808B8p0",
"0x0.000000000120000900p0", "0x0.000000000126080948p0", "0x0.00000000012C200993p0", "0x0.0000000001324809DEp0",
"0x0.000000000138800A2Cp0", "0x0.00000000013EC80A7Bp0", "0x0.000000000145200ACBp0", "0x0.00000000014B880B1Dp0",
"0x0.000000000152000B71p0", "0x0.000000000158880BC6p0", "0x0.00000000015F200C1Dp0", "0x0.000000000165C80C76p0",
"0x0.00000000016C800CD0p0", "0x0.000000000173480D2Cp0", "0x0.00000000017A200D8Ap0", "0x0.000000000181080DE9p0",
"0x0.000000000188000E4Ap0", "0x0.00000000018F080EADp0", "0x0.000000000196200F12p0", "0x0.00000000019D480F78p0",
"0x0.0000000001A4800FE0p0", "0x0.0000000001ABC8104Ap0", "0x0.0000000001B32010B6p0", "0x0.0000000001BA881124p0",
"0x0.0000000001C2001194p0", "0x0.0000000001C9881205p0", "0x0.0000000001D1201278p0", "0x0.0000000001D8C812EEp0",
"0x0.0000000001E0801365p0", "0x0.0000000001E84813DEp0", "0x0.0000000001F0201459p0", "0x0.0000000001F80814D6p0",
"0x0.000000000200001555p0", "0x0.0000000002080815D6p0", "0x0.000000000210201659p0", "0x0.0000000002184816DEp0",
"0x0.000000000220801765p0", "0x0.000000000228C817EEp0", "0x0.000000000231201879p0", "0x0.000000000239881907p0",
"0x0.000000000242001996p0", "0x0.00000000024A881A28p0", "0x0.000000000253201ABBp0", "0x0.00000000025BC81B51p0",
"0x0.000000000264801BE9p0", "0x0.00000000026D481C84p0", "0x0.000000000276201D20p0", "0x0.00000000027F081DBFp0",
"0x0.000000000288001E60p0", "0x0.000000000291081F03p0", "0x0.00000000029A201FA8p0", "0x0.0000000002A3482050p0",
"0x0.0000000002AC8020FAp0", "0x0.0000000002B5C821A6p0", "0x0.0000000002BF202255p0", "0x0.0000000002C8882306p0",
"0x0.0000000002D20023B9p0", "0x0.0000000002DB88246Fp0", "0x0.0000000002E5202527p0", "0x0.0000000002EEC825E1p0",
"0x0.0000000002F880269Ep0", "0x0.00000000030248275Dp0", "0x0.00000000030C20281Fp0", "0x0.0000000003160828E3p0",
"0x0.0000000003200029AAp0", "0x0.00000000032A082A73p0", "0x0.000000000334202B3Fp0", "0x0.00000000033E482C0Dp0",
"0x0.000000000348802CDEp0", "0x0.000000000352C82DB2p0", "0x0.00000000035D202E88p0", "0x0.000000000367882F60p0",
"0x0.00000000037200303Cp0", "0x0.00000000037C883119p0", "0x0.0000000003872031FAp0", "0x0.000000000391C832DDp0",
"0x0.00000000039C8033C3p0", "0x0.0000000003A74834ABp0", "0x0.0000000003B2203596p0", "0x0.0000000003BD083684p0",
"0x0.0000000003C8003775p0", "0x0.0000000003D3083868p0", "0x0.0000000003DE20395Ep0", "0x0.0000000003E9483A57p0",
"0x0.0000000003F4803B53p0", "0x0.0000000003FFC83C52p0", "0x0.00000000040B203D53p0", "0x0.000000000416883E57p0",
"0x0.000000000422003F5Ep0", "0x0.00000000042D884068p0", "0x0.000000000439204175p0", "0x0.000000000444C84285p0",
"0x0.000000000450804397p0", "0x0.00000000045C4844ADp0", "0x0.0000000004682045C5p0", "0x0.0000000004740846E1p0",
"0x0.000000000480004800p0", "0x0.00000000048C084921p0", "0x0.000000000498204A46p0", "0x0.0000000004A4484B6Dp0",
"0x0.0000000004B0804C98p0", "0x0.0000000004BCC84DC5p0", "0x0.0000000004C9204EF6p0", "0x0.0000000004D588502Ap0",
"0x0.0000000004E2005161p0", "0x0.0000000004EE88529Bp0", "0x0.0000000004FB2053D8p0", "0x0.000000000507C85518p0",
"0x0.00000000051480565Cp0", "0x0.0000000005214857A3p0", "0x0.00000000052E2058EDp0", "0x0.00000000053B085A3Ap0",
"0x0.000000000548005B8Ap0", "0x0.000000000555085CDEp0", "0x0.000000000562205E35p0", "0x0.00000000056F485F8Fp0",
"0x0.00000000057C8060ECp0", "0x0.000000000589C8624Dp0", "0x0.0000000005972063B1p0", "0x0.0000000005A4886519p0",
"0x0.0000000005B2006684p0", "0x0.0000000005BF8867F2p0", "0x0.0000000005CD206963p0", "0x0.0000000005DAC86AD8p0",
"0x0.0000000005E8806C51p0", "0x0.0000000005F6486DCDp0", "0x0.000000000604206F4Cp0", "0x0.0000000006120870CFp0",
"0x0.000000000620007255p0", "0x0.00000000062E0873DFp0", "0x0.00000000063C20756Cp0", "0x0.00000000064A4876FDp0",
"0x0.000000000658807891p0", "0x0.000000000666C87A29p0", "0x0.000000000675207BC4p0", "0x0.000000000683887D64p0",
"0x0.000000000692007F06p0", "0x0.0000000006A08880ADp0", "0x0.0000000006AF208256p0", "0x0.0000000006BDC88404p0",
"0x0.0000000006CC8085B5p0", "0x0.0000000006DB48876Ap0", "0x0.0000000006EA208923p0", "0x0.0000000006F9088ADFp0",
"0x0.000000000708008CA0p0", "0x0.000000000717088E63p0", "0x0.00000000072620902Bp0", "0x0.0000000007354891F6p0",
"0x0.0000000007448093C6p0", "0x0.000000000753C89599p0", "0x0.000000000763209770p0", "0x0.00000000077288994Ap0",
"0x0.000000000782009B29p0", "0x0.000000000791889D0Bp0", "0x0.0000000007A1209EF2p0", "0x0.0000000007B0C8A0DCp0",
"0x0.0000000007C080A2CAp0", "0x0.0000000007D048A4BCp0", "0x0.0000000007E020A6B2p0", "0x0.0000000007F008A8ACp0",
            };
            ap_ufixed<31,-37> f_x_msb_4 = f_x_msb_4_table[x_msb_ind_4];

            const static ap_ufixed<12,-53> f_x_lsb_table[64] = {
"0x0.00000000000000000p0", "0x0.00000000000000008p0", "0x0.00000000000000020p0", "0x0.00000000000000048p0",
"0x0.00000000000000080p0", "0x0.000000000000000c8p0", "0x0.00000000000000120p0", "0x0.00000000000000188p0",
"0x0.00000000000000200p0", "0x0.00000000000000288p0", "0x0.00000000000000320p0", "0x0.000000000000003c8p0",
"0x0.00000000000000480p0", "0x0.00000000000000548p0", "0x0.00000000000000620p0", "0x0.00000000000000708p0",
"0x0.00000000000000800p0", "0x0.00000000000000908p0", "0x0.00000000000000a20p0", "0x0.00000000000000b48p0",
"0x0.00000000000000c80p0", "0x0.00000000000000dc8p0", "0x0.00000000000000f20p0", "0x0.00000000000001088p0",
"0x0.00000000000001200p0", "0x0.00000000000001388p0", "0x0.00000000000001520p0", "0x0.000000000000016c8p0",
"0x0.00000000000001880p0", "0x0.00000000000001a48p0", "0x0.00000000000001c20p0", "0x0.00000000000001e08p0",
"0x0.00000000000002000p0", "0x0.00000000000002208p0", "0x0.00000000000002420p0", "0x0.00000000000002648p0",
"0x0.00000000000002880p0", "0x0.00000000000002ac8p0", "0x0.00000000000002d20p0", "0x0.00000000000002f88p0",
"0x0.00000000000003200p0", "0x0.00000000000003488p0", "0x0.00000000000003720p0", "0x0.000000000000039c8p0",
"0x0.00000000000003c80p0", "0x0.00000000000003f48p0", "0x0.00000000000004220p0", "0x0.00000000000004508p0",
"0x0.00000000000004800p0", "0x0.00000000000004b08p0", "0x0.00000000000004e20p0", "0x0.00000000000005148p0",
"0x0.00000000000005480p0", "0x0.000000000000057c8p0", "0x0.00000000000005b20p0", "0x0.00000000000005e88p0",
"0x0.00000000000006200p0", "0x0.00000000000006588p0", "0x0.00000000000006920p0", "0x0.00000000000006cc8p0",
"0x0.00000000000007080p0", "0x0.00000000000007448p0", "0x0.00000000000007820p0", "0x0.00000000000007c08p0",
            };
            ap_ufixed<12,-53> f_x_lsb = f_x_lsb_table[x_lsb_ind];

            ap_ufixed<14,-44> f_x_msb_4_lsb = x_msb_4 * x_lsb;

            ap_ufixed<15,-43> exp_x_msb_4_lsb_m_1_m1 = 0;
            exp_x_msb_4_lsb_m_1_m1(4,0) = f_x_lsb(11,7);
            exp_x_msb_4_lsb_m_1_m1 = exp_x_msb_4_lsb_m_1_m1 + f_x_msb_4_lsb;

            ap_ufixed<22,-43> exp_x_msb_4_lsb_m_1_m2 = exp_x_msb_4_lsb_m_1_m1;
            exp_x_msb_4_lsb_m_1_m2(6,0) = f_x_lsb(6,0);

            ap_ufixed<29,-36> exp_x_msb_4_lsb_m_1_m3 = 0;
            exp_x_msb_4_lsb_m_1_m3(27,0) = f_x_msb_4(30,3);
            exp_x_msb_4_lsb_m_1_m3 = exp_x_msb_4_lsb_m_1_m3 + exp_x_msb_4_lsb_m_1_m2;

            ap_ufixed<32,-36> exp_x_msb_4_lsb_m_1_m = exp_x_msb_4_lsb_m_1_m3;
            exp_x_msb_4_lsb_m_1_m(2,0) = f_x_msb_4(2,0);

            ap_ufixed<50,-18> exp_x_msb_4_lsb_m_1 = 0;
            exp_x_msb_4_lsb_m_1(49,36) = x_l(13,0);
            exp_x_msb_4_lsb_m_1(31, 0) = exp_x_msb_4_lsb_m_1_m(31,0);


            const static ap_ufixed<51,-21> f_x_msb_3_table[256] = {
"0x0", "0x0.00000000080000AAAAp0", "0x0.000000002000055556p0", "0x0.000000004800120003p0",
"0x0.0000000080002AAAB5p0", "0x0.00000000C80053556Fp0", "0x0.000000012000900036p0", "0x0.000000018800E4AB0Ep0",
"0x0.000000020001555600p0", "0x0.000000028801E60111p0", "0x0.0000000320029AAC4Bp0", "0x0.00000003C8037757B7p0",
"0x0.000000048004800360p0", "0x0.000000054805B8AF50p0", "0x0.000000062007255B96p0", "0x0.000000070808CA083Dp0",
"0x0.00000008000AAAB555p0", "0x0.00000009080CCB62EDp0", "0x0.0000000A200F301116p0", "0x0.0000000B4811DCBFE0p0",
"0x0.0000000C8014D56F60p0", "0x0.0000000DC8181E1FA7p0", "0x0.0000000F201BBAD0CBp0", "0x0.00000010881FAF82E1p0",
"0x0.000000120024003600p0", "0x0.000000138828B0EA3Fp0", "0x0.00000015202DC59FB6p0", "0x0.00000016C83342567Fp0",
"0x0.0000001880392B0EB5p0", "0x0.0000001A483F83C874p0", "0x0.0000001C20465083D6p0", "0x0.0000001E084D9540FBp0",
"0x0.000000200055560001p0", "0x0.00000022085D96C106p0", "0x0.0000002420665B842Cp0", "0x0.00000026486FA84995p0",
"0x0.000000288079811161p0", "0x0.0000002AC883E9DBB6p0", "0x0.0000002D208EE6A8B8p0", "0x0.0000002F889A7B788Cp0",
"0x0.0000003200A6AC4B58p0", "0x0.0000003488B37D2145p0", "0x0.0000003720C0F1FA7Ap0", "0x0.00000039C8CF0ED721p0",
"0x0.0000003C80DDD7B765p0", "0x0.0000003F48ED509B71p0", "0x0.0000004220FD7D8371p0", "0x0.00000045090E626F94p0",
"0x0.000000480120036008p0", "0x0.0000004B09326454FBp0", "0x0.0000004E2145894E9Fp0", "0x0.000000514959764D26p0",
"0x0.00000054816E2F50C1p0", "0x0.00000057C983B859A4p0", "0x0.0000005B219A156804p0", "0x0.0000005E89B14A7C16p0",
"0x0.0000006201C95B9611p0", "0x0.0000006589E24CB62Cp0", "0x0.0000006921FC21DCA0p0", "0x0.0000006CCA16DF09A6p0",
"0x0.000000708232883D78p0", "0x0.000000744A4F217853p0", "0x0.00000078226CAEBA73p0", "0x0.0000007C0A8B340414p0",
"0x0.0000008002AAB55577p0", "0x0.000000840ACB36AEDAp0", "0x0.0000008822ECBC107Dp0", "0x0.0000008C4B0F497AA3p0",
"0x0.000000908332E2ED8Ep0", "0x0.00000094CB578C6981p0", "0x0.00000099237D49EEC0p0", "0x0.0000009D8BA41F7D92p0",
"0x0.000000A203CC11163Dp0", "0x0.000000A68BF522B908p0", "0x0.000000AB241F58663Cp0", "0x0.000000AFCC4AB61E22p0",
"0x0.000000B484773FE105p0", "0x0.000000B94CA4F9AF31p0", "0x0.000000BE24D3E788F1p0", "0x0.000000C30D040D6E94p0",
"0x0.000000C805356F6068p0", "0x0.000000CD0D68115EBCp0", "0x0.000000D2259BF769E1p0", "0x0.000000D74DD1258228p0",
"0x0.000000DC86079FA7E4p0", "0x0.000000E1CE3F69DB69p0", "0x0.000000E72678881D0Bp0", "0x0.000000EC8EB2FE6D1Fp0",
"0x0.000000F206EED0CBFDp0", "0x0.000000F78F2C0339FAp0", "0x0.000000FD276A99B771p0", "0x0.00000102CFAA9844BBp0",
"0x0.0000010887EC02E231p0", "0x0.0000010E502EDD9030p0", "0x0.0000011428732C4F14p0", "0x0.0000011A10B8F31F3Bp0",
"0x0.000001200900360103p0", "0x0.000001261148F8F4CBp0", "0x0.0000012C29933FFAF5p0", "0x0.0000013251DF0F13E1p0",
"0x0.000001388A2C6A3FF3p0", "0x0.0000013ED27B557F8Dp0", "0x0.000001452ACBD4D315p0", "0x0.0000014B931DEC3AEFp0",
"0x0.000001520B719FB782p0", "0x0.0000015893C6F34937p0", "0x0.0000015F2C1DEAF074p0", "0x0.00000165D4768AADA5p0",
"0x0.0000016C8CD0D68133p0", "0x0.00000173552CD26B89p0", "0x0.0000017A2D8A826D16p0", "0x0.0000018115E9EA8645p0",
"0x0.000001880E4B0EB785p0", "0x0.0000018F16ADF30147p0", "0x0.000001962F129B63FAp0", "0x0.0000019D57790BE010p0",
"0x0.000001A48FE14875FBp0", "0x0.000001ABD84B552630p0", "0x0.000001B330B735F122p0", "0x0.000001BA9924EED748p0",
"0x0.000001C2119483D917p0", "0x0.000001C99A05F8F707p0", "0x0.000001D13279523191p0", "0x0.000001D8DAEE93892Ep0",
"0x0.000001E09365C0FE59p0", "0x0.000001E85BDEDE918Dp0", "0x0.000001F03459F04347p0", "0x0.000001F81CD6FA1405p0",
"0x0.000002001556000444p0", "0x0.000002081DD7061485p0", "0x0.00000210365A104547p0", "0x0.000002185EDF22970Dp0",
"0x0.000002209766410A5Ap0", "0x0.00000228DFEF6F9FAFp0", "0x0.00000231387AB25793p0", "0x0.00000239A1080D328Ap0",
"0x0.00000242199784311Cp0", "0x0.0000024AA2291B53CFp0", "0x0.000002533ABCD69B2Dp0", "0x0.0000025BE352BA07BEp0",
"0x0.000002649BEAC99A0Dp0", "0x0.0000026D64850952A7p0", "0x0.000002763D217D3216p0", "0x0.0000027F25C02938EAp0",
"0x0.000002881E611167B0p0", "0x0.00000291270439BEF8p0", "0x0.0000029A3FA9A63F53p0", "0x0.000002A368515AE951p0",
"0x0.000002ACA0FB5BBD86p0", "0x0.000002B5E9A7ACBC86p0", "0x0.000002BF425651E6E4p0", "0x0.000002C8AB074F3D36p0",
"0x0.000002D223BAA8C013p0", "0x0.000002DBAC70627012p0", "0x0.000002E54528804DCDp0", "0x0.000002EEEDE30659DBp0",
"0x0.000002F8A69FF894D9p0", "0x0.000003026F5F5AFF61p0", "0x0.0000030C4821319A10p0", "0x0.0000031630E5806584p0",
"0x0.0000032029AC4B625Bp0", "0x0.0000032A3275969134p0", "0x0.000003344B4165F2B1p0", "0x0.0000033E740FBD8772p0",
"0x0.00000348ACE0A1501Bp0", "0x0.00000352F5B4154D4Fp0", "0x0.0000035D4E8A1D7FB2p0", "0x0.00000367B762BDE7EAp0",
"0x0.00000372303DFA869Ep0", "0x0.0000037CB91BD75C75p0", "0x0.0000038751FC586A18p0", "0x0.00000391FADF81B02Fp0",
"0x0.0000039CB3C5572F67p0", "0x0.000003A77CADDCE86Ap0", "0x0.000003B2559916DBE4p0", "0x0.000003BD3E87090A84p0",
"0x0.000003C83777B774F8p0", "0x0.000003D3406B261BF0p0", "0x0.000003DE596159001Cp0", "0x0.000003E9825A54222Dp0",
"0x0.000003F4BB561B82D7p0", "0x0.000004000454B322CCp0", "0x0.0000040B5D561F02C2p0", "0x0.00000416C65A63236Ep0",
"0x0.000004223F61838586p0", "0x0.0000042DC86B8429C2p0", "0x0.0000043961786910DBp0", "0x0.000004450A88363B8Ap0",
"0x0.00000450C39AEFAA8Ap0", "0x0.0000045C8CB0995E96p0", "0x0.0000046865C937586Bp0", "0x0.000004744EE4CD98C6p0",
"0x0.000004804803602067p0", "0x0.0000048C5124F2F00Cp0", "0x0.000004986A498A0876p0", "0x0.000004A49371296A67p0",
"0x0.000004B0CC9BD516A1p0", "0x0.000004BD15C9910DE8p0", "0x0.000004C96EFA615101p0", "0x0.000004D5D82E49E0B0p0",
"0x0.000004E251654EBDBDp0", "0x0.000004EEDA9F73E8F0p0", "0x0.000004FB73DCBD6310p0", "0x0.000005081D1D2F2CE7p0",
"0x0.00000514D660CD4740p0", "0x0.000005219FA79BB2E7p0", "0x0.0000052E78F19E70A8p0", "0x0.0000053B623ED98150p0",
"0x0.000005485B8F50E5AFp0", "0x0.0000055564E3089E93p0", "0x0.000005627E3A04ACCEp0", "0x0.0000056FA794491131p0",
"0x0.0000057CE0F1D9CC8Ep0", "0x0.0000058A2A52BADFBAp0", "0x0.0000059783B6F04B88p0", "0x0.000005A4ED1E7E10CFp0",
"0x0.000005B26689683064p0", "0x0.000005BFEFF7B2AB20p0", "0x0.000005CD89696181DBp0", "0x0.000005DB32DE78B56Fp0",
"0x0.000005E8EC56FC46B6p0", "0x0.000005F6B5D2F0368Cp0", "0x0.000006048F525885CDp0", "0x0.0000061278D5393558p0",
"0x0.00000620725B96460Ap0", "0x0.0000062E7BE573B8C3p0", "0x0.0000063C9572D58E64p0", "0x0.0000064ABF03BFC7CEp0",
"0x0.00000658F8983665E5p0", "0x0.0000066742303D698Bp0", "0x0.000006759BCBD8D3A5p0", "0x0.00000684056B0CA519p0",
"0x0.000006927F0DDCDECEp0", "0x0.000006A108B44D81AAp0", "0x0.000006AFA25E628E98p0", "0x0.000006BE4C0C20067Fp0",
"0x0.000006CD05BD89EA4Bp0", "0x0.000006DBCF72A43AE8p0", "0x0.000006EAA92B72F942p0", "0x0.000006F992E7FA2646p0",
"0x0.000007088CA83DC2E4p0", "0x0.00000717966C41D00Ap0", "0x0.00000726B0340A4EAAp0", "0x0.00000735D9FF9B3FB6p0",
"0x0.0000074513CEF8A41Ep0", "0x0.000007545DA2267CD9p0", "0x0.00000763B77928CAD9p0", "0x0.000007732154038F14p0",
"0x0.000007829B32BACA82p0", "0x0.000007922515527E1Ap0", "0x0.000007A1BEFBCEAAD4p0", "0x0.000007B168E63351AAp0",
"0x0.000007C122D4847397p0", "0x0.000007D0ECC6C61195p0", "0x0.000007E0C6BCFC2CA3p0", "0x0.000007F0B0B72AC5BEp0",
            };
            ap_ufixed<51,-21> f_x_msb_3 = f_x_msb_3_table[x_msb_ind_3];
            ap_ufixed<62,-10> exp_x_msb_3_m_1 = 0;
            exp_x_msb_3_m_1(61,54) = x_msb_3(7,0);
            exp_x_msb_3_m_1(50, 0) = f_x_msb_3(50,0);

            ap_ufixed<50,-10> exp_x_msb_3_m_1_s = exp_x_msb_3_m_1;
            ap_ufixed<100,-28> f_x_msb_3_4_lsb = exp_x_msb_3_m_1_s * exp_x_msb_4_lsb_m_1;
            ap_ufixed<44,-28> f_x_msb_3_4_lsb_s = f_x_msb_3_4_lsb;
            ap_ufixed<63, -9> exp_x_msb_3_4_lsb_m_1 = f_x_msb_3_4_lsb_s + exp_x_msb_3_m_1 + exp_x_msb_4_lsb_m_1;


            const static ap_ufixed<64,-4> f_x_msb_2_table[256] = {
"0x0.0p0", "0x0.00000800AAB555DDEp0", "0x0.00002005560011127p0", "0x0.00004812036081A9Cp0",
"0x0.0000802AB55777D28p0", "0x0.0000C8536F6684062p0", "0x0.0001209036103740Dp0", "0x0.000188E50ED8634A0p0",
"0x0.0002015600445B0C3p0", "0x0.000289E711DB32FD7p0", "0x0.0003229C4C260197Ep0", "0x0.0003CB79B8B01FE26p0",
"0x0.0004848362076A08Dp0", "0x0.00054DBD53BC80058p0", "0x0.0006272B9A630659Dp0", "0x0.000710D24391E6D7Ap0",
"0x0.00080AB55DE3917ABp0", "0x0.000914D8F8F63D524p0", "0x0.000A2F41256C297AFp0", "0x0.000B59F1F4EBDE291p0",
"0x0.000C94EF7A206DC2Dp0", "0x0.000DE03DC8B9B60B1p0", "0x0.000F3BE0F56CA15C4p0", "0x0.0010A7DD15F367F40p0",
"0x0.00122436410DD14E5p0", "0x0.0013B0F08E817591Ep0", "0x0.00154E101719FF0C5p0", "0x0.0016FB98F4A96BBEFp0",
"0x0.0018B98F42084EFBDp0", "0x0.001A87F71B1613137p0", "0x0.001C66D49CB93B127p0", "0x0.001E562BE4DFA4904p0",
"0x0.00205601127EC98E0p0", "0x0.00226658459402659p0", "0x0.002487359F24C7C99p0", "0x0.0026B89D413EF4D5Ep0",
"0x0.0028FA934EF909304p0", "0x0.002B4D1BEC726B39Cp0", "0x0.002DB03B3ED3AA50Ep0", "0x0.003023F56C4EC123Fp0",
"0x0.0032A84E9C1F58145p0", "0x0.00353D4AF68B07AA1p0", "0x0.0037E2EEA4E19B185p0", "0x0.003A993DD17D52D25p0",
"0x0.003D603CA7C32730Fp0", "0x0.004037EF54230B293p0", "0x0.0043205A04182F12Fp0", "0x0.00461980E62943810p0",
"0x0.0049236829E8BC292p0", "0x0.004C3E13FFF512DD8p0", "0x0.004F698899F90A966p0", "0x0.0052A5CA2AABF28D0p0",
"0x0.0055F2DCE5D1E966Ep0", "0x0.005950C5003C20723p0", "0x0.005CBF86AFC91EF2Bp0", "0x0.00603F262B65057FCp0",
"0x0.0063CFA7AB09D1732p0", "0x0.0067710F67BFA0687p0", "0x0.006B23619B9CF3CDEp0", "0x0.006EE6A281C6F4857p0",
"0x0.0072BAD65671B6977p0", "0x0.0076A00156E07CF57p0", "0x0.007A9627C165FD4EDp0", "0x0.007E9D4DD564A3F5Ep0",
"0x0.0082B577D34ED7D5Bp0", "0x0.0086DEA9FCA73E799p0", "0x0.008B18E8940100253p0", "0x0.008F6437DD000BFDAp0",
"0x0.0093C09C1C595C43Ep0", "0x0.00982E1997D33A9FCp0", "0x0.009CACB49645847CCp0", "0x0.00A13C715F99EF773p0",
"0x0.00A5DD543CCC4DDAFp0", "0x0.00AA8F6177EAD3336p0", "0x0.00AF529D5C1658EBCp0", "0x0.00B4270C3582A301Dp0",
"0x0.00B90CB25176A4C8Bp0", "0x0.00BE0393FE4CC5BD7p0", "0x0.00C30BB58B73266CAp0", "0x0.00C8251B496BE5696p0",
"0x0.00CD4FC989CD64555p0", "0x0.00D28BC49F428CFA3p0", "0x0.00D7D910DD8B16743p0", "0x0.00DD37B2997BCA6E6p0",
"0x0.00E2A7AE28FECA6FBp0", "0x0.00E82907E313D5399p0", "0x0.00EDBBC41FD08C383p0", "0x0.00F35FE73860B9038p0",
"0x0.00F91575870692F24p0", "0x0.00FEDC73671B04BDFp0", "0x0.0104B4E5350DF2386p0", "0x0.010A9ECF4E667E12Dp0",
"0x0.01109A3611C34FB64p0", "0x0.0116A71DDEDAD92D8p0", "0x0.011CC58B167B9D206p0", "0x0.0122F5821A8C74E0Dp0",
"0x0.012937074E0CD6893p0", "0x0.012F8A1F15151B2C6p0", "0x0.0135EECDD4D6C5172p0", "0x0.013C6517F39CC6233p0",
"0x0.0142ED01D8CBC61C4p0", "0x0.0149868FECE26935Dp0", "0x0.015031C6997996937p0", "0x0.0156EEAA4944BEE23p0",
"0x0.015DBD3F68122303Ep0", "0x0.01649D8A62CB1ACBEp0", "0x0.016B8F8FA7745BCDBp0", "0x0.01729353A52E403D8p0",
"0x0.0179A8DACC350DE1Dp0", "0x0.0180D0298DE13D179p0", "0x0.018809445CA7BFE78p0", "0x0.018F542FAC1A492D6p0",
"0x0.0196B0EFF0E793D15p0", "0x0.019E1F89A0DBAA128p0", "0x0.01A5A00132E02CE42p0", "0x0.01AD325B1EFC9B5BCp0",
"0x0.01B4D69BDE569A322p0", "0x0.01BC8CC7EB323B553p0", "0x0.01C454E3C0F2458C8p0", "0x0.01CC2EF3DC187C2F6p0",
"0x0.01D41AFCBA45E6ED2p0", "0x0.01DC1902DA3B19A6Dp0", "0x0.01E4290ABBD87C5BCp0", "0x0.01EC4B18E01E9326Fp0",
"0x0.01F47F31C92E464FCp0", "0x0.01FCC559FA492A6B6p0", "0x0.02051D95F7D1C8917p0", "0x0.020D87EA474BE6A1Cp0",
"0x0.0216045B6F5CCF9CEp0", "0x0.021E92EDF7CB9C0E4p0", "0x0.022733A669817A88Ap0", "0x0.022FE6894E89F834Cp0",
"0x0.0238AB9B321349722p0", "0x0.024182E0A06E9289Bp0", "0x0.024A6C5E271030733p0", "0x0.02536818549001AC1p0",
"0x0.025C7613B8A9AF215p0", "0x0.02659654E43CF52B1p0", "0x0.026EC8E0694DEC9A9p0", "0x0.02780DBADB0553DA6p0",
"0x0.028164E8CDB0D8211p0", "0x0.028ACE6ED6C35EB5Fp0", "0x0.02944A518CD54E484p0", "0x0.029DD89587A4D858Dp0",
"0x0.02A7793F601642B5Dp0", "0x0.02B12C53B03431090p0", "0x0.02BAF1D7132FEE788p0", "0x0.02C4C9CE2561B759Fp0",
"0x0.02CEB43D844902F7Ap0", "0x0.02D8B129CE8CCD68Fp0", "0x0.02E2C097A3FBE17C9p0", "0x0.02ECE28BA58D22B56p0",
"0x0.02F7170A755FD759Ep0", "0x0.03015E18B6BBF2966p0", "0x0.030BB7BB0E125EB13p0", "0x0.031623F620FD4751Ep0",
"0x0.0320A2CE964063DACp0", "0x0.032B344915C941D54p0", "0x0.0335D86A48AF8F70Cp0", "0x0.03408F36D93566140p0",
"0x0.034B58B372C795013p0", "0x0.035634E4C1FDEC0D0p0", "0x0.036123CF749B8667Cp0", "0x0.036C2578398F157A0p0",
"0x0.037739E3C0F32BD30p0", "0x0.03826116BC0E882ACp0", "0x0.038D9B15DD5460763p0", "0x0.0398E7E5D864AD0E9p0",
"0x0.03A4478B620C73EB5p0", "0x0.03AFBA0B304613EEDp0", "0x0.03BB3F69FA3990464p0", "0x0.03C6D7AC783CDBDBFp0",
"0x0.03D282D763D424DCDp0", "0x0.03DE40EF77B220509p0", "0x0.03EA11F96FB855C4Fp0", "0x0.03F5F5FA08F76B0BBp0",
"0x0.0401ECF601AF700BDp0", "0x0.040DF6F219502AA55p0", "0x0.041A13F3107962A88p0", "0x0.042643FDA8FB2DDFBp0",
"0x0.04328716A5D63C2C4p0", "0x0.043EDD42CB3C23B6Dp0", "0x0.044B4686DE8FAD325p0", "0x0.0457C2E7A66520322p0",
"0x0.04645269EA828F932p0", "0x0.0470F51273E025F89p0", "0x0.047DAAE60CA8725B3p0", "0x0.048A73E98038B4ABFp0",
"0x0.049750219B212A8A0p0", "0x0.04A43F932B255C0B7p0", "0x0.04B14242FF3C689A0p0", "0x0.04BE5835E79153E1Dp0",
"0x0.04CB8170B58352D4Ep0", "0x0.04D8BDF83BA618C04p0", "0x0.04E60DD14DC22475Ep0", "0x0.04F37100C0D50D88Ep0",
"0x0.0500E78B6B11D19D6p0", "0x0.050E717623E121CBAp0", "0x0.051C0EC5C3E1B016Cp0", "0x0.0529BF7F24E87CF6Ap0",
"0x0.053783A7220124F51p0", "0x0.05455B42976E2E5EAp0", "0x0.0553465662A95706Bp0", "0x0.056144E76263E21F4p0",
"0x0.056F56FA7686E623Ep0", "0x0.057D7C9480339AD83p0", "0x0.058BB5BA61C3A75A3p0", "0x0.059A0270FEC97047Ap0",
"0x0.05A862BD3C1065F74p0", "0x0.05B6D6A3FF9D52C58p0", "0x0.05C55E2A30AEA974Ep0", "0x0.05D3F954B7BCD3A1Bp0",
"0x0.05E2A8287E7A8049Ep0", "0x0.05F16AAA6FD4F267Bp0", "0x0.060040DF77F44FA13p0", "0x0.060F2ACC843BEF0A0p0",
"0x0.061E2876834AA7FA4p0", "0x0.062D39E264FB20F7Ep0", "0x0.063C5F151A641EB4Cp0", "0x0.064B981395D8D31FEp0",
"0x0.065AE4E2CAE92C8AAp0", "0x0.066A4587AE6224E1Cp0", "0x0.0679BA07364E10FA3p0", "0x0.0689426659F4EFF1Bp0",
"0x0.0698DEAA11DCBAA37p0", "0x0.06A88ED757C9B3304p0", "0x0.06B852F326BEB49B0p0", "0x0.06C82B027AFD8278Ap0",
"0x0.06D8170A520718B46p0", "0x0.06E8170FAA9BFB67Ep0", "0x0.06F82B1784BC86C72p0", "0x0.07085326E1A93F207p0",
"0x0.07188F42C3E320F0Bp0", "0x0.0728DF702F2BF10B2p0", "0x0.073943B428868CD5Ap0", "0x0.0749BC13B6373A98Fp0",
"0x0.075A4893DFC3F9E4Cp0", "0x0.076AE939ADF4D4083p0", "0x0.077B9E0A2AD42C9E8p0", "0x0.078C670A61AF122F4p0",
"0x0.079D443F5F158EE3Ap0", "0x0.07AE35AE30DAF94F1p0", "0x0.07BF3B5BE616454CBp0", "0x0.07D0554D8F2254F0Cp0",
"0x0.07E183883D9E498E2p0", "0x0.07F2C611046DD4D06p0", "0x0.08041CECF7B989EA2p0", "0x0.081588212CEF2ED73p0",
"0x0.082707B2BAC20DB40p0", "0x0.08389BA6B92B46284p0", "0x0.084A4402416A1EE6Fp0", "0x0.085C00CA6E045741Fp0",
"0x0.086DD2045AC678D2Bp0", "0x0.087FB7B524C42936Cp0", "0x0.0891B1E1EA587BE12p0", "0x0.08A3C08FCB2643FFEp0",
            };
            ap_ufixed<64,-4> f_x_msb_2 = f_x_msb_2_table[x_msb_ind_2];
            ap_ufixed< 6,-4> f_x_msb_2_h;
            f_x_msb_2_h(5,0) = f_x_msb_2(63,58);
            ap_ufixed< 9,-1> exp_x_msb_2_m_1_h = f_x_msb_2_h + x_msb_2;
            ap_ufixed<67,-1> exp_x_msb_2_m_1;
            exp_x_msb_2_m_1(66,58) = exp_x_msb_2_m_1_h(8,0);
            exp_x_msb_2_m_1(57, 0) = f_x_msb_2(57,0);

            ap_ufixed<130,-10> f_x_msb_2_3_4_lsb = exp_x_msb_2_m_1 * exp_x_msb_3_4_lsb_m_1;
            ap_ufixed<62,-10> f_x_msb_2_3_4_lsb_s = f_x_msb_2_3_4_lsb;
            ap_ufixed<72,0> exp_x_msb_2_3_4_lsb_m_1 = f_x_msb_2_3_4_lsb_s + exp_x_msb_2_m_1 + exp_x_msb_3_4_lsb_m_1;

            const static ap_ufixed<68,32> exp_x_msb_1_table[256] = {
"0x1.000000000p0", "0x1.48B5E3C3Ep0", "0x1.A61298E1Ep0", "0x2.1DF3B68CFp0",
"0x2.B7E151628p0", "0x3.7D871DB61p0", "0x4.7B4FF993Fp0", "0x5.C12DA416Ep0",
"0x7.63992E353p0", "0x9.7CDC417A3p0", "0xC.2EB7EC98Fp0", "0xF.A48385EDFp0",
"0x14.15E5BF6FBp0", "0x19.CA53B7811p0", "0x21.1D8E4272Dp0", "0x2A.8565A144Cp0",
"0x36.99205C4E7p0", "0x46.1AFC4DB59p0", "0x5A.0462B7877p0", "0x73.9593ABB7Dp0",
"0x94.69C4CB819p0", "0xBE.90F6F83E9p0", "0xF4.B122790DDp0", "0x13A.30CF1CCBBp0",
"0x193.6DC5690C0p0", "0x206.03487A3B1p0", "0x299.2442102D9p0", "0x356.0F0B0F980p0",
"0x448.A216ABB76p0", "0x580.1AD754FA3p0", "0x710.0ADBAC7DAp0", "0x911.9289C3923p0",
"0xBA4.F53EA3863p0", "0xEF3.A035D5798p0", "0x1332.C4D2B7C4Ap0", "0x18A6.B027DA0A7p0",
"0x1FA7.157C470F8p0", "0x28A4.90D2CCEF1p0", "0x342F.BA11823B8p0", "0x4302.3A933EE5Cp0",
"0x560A.773E54157p0", "0x6E7A.8ABB4A83Cp0", "0x8DDB.80AF4269Dp0", "0xB626.0748BAEC7p0",
"0xE9E2.2447727BFp0", "0x12C4F.EB75B2AB0p0", "0x1819B.C560F6113p0", "0x1EF21.8F1B001A4p0",
"0x27BC2.CA9A6F934p0", "0x33055.49F35D91Fp0", "0x41831.49596E996p0", "0x541E7.E56949D58p0",
"0x6C02D.645AB2554p0", "0x8AB06.0A3EE9FB1p0", "0xB2148.5EAE56C5Bp0", "0xE4A8D.2881EDBE8p0",
"0x1259AC.48BF05D6Ep0", "0x178FEE.7792E44B3p0", "0x1E4127.437732B71p0", "0x26D8F9.4A204BEA5p0",
"0x31E199.5F5A550DDp0", "0x400C7D.64D3386CBp0", "0x523D82.79EDAEF9Cp0", "0x69993D.D4F2D9524p0",
"0x87975E.854001024p0", "0xAE1A47.C38A42CD0p0", "0xDF8D5F.6DCFE5CEAp0", "0x11F0BF8.1E99FDEB6p0",
"0x1709348.C0EA4F8CEp0", "0x1D94295.464477ACCp0", "0x25FAD90.65C78E342p0", "0x30C4623.616ED2BE2p0",
"0x3E9E441.232817A61p0", "0x506744D.3B342FC94p0", "0x673D70B.C00F1F76Dp0", "0x849012B.C127FC962p0",
"0xAA36C7C.F69370B94p0", "0xDA8F202.DD9ACE661p0", "0x118A2AAE.0AA05236Bp0", "0x16857CFA.1AA8A5555p0",
"0x1CEB088B.68E804021p0", "0x2521AEDA.32CD52BE5p0", "0x2FAD89E1.79BAB8EADp0", "0x3D3838C6.BE0F13F06p0",
"0x4E9B87F6.7BB3F5597p0", "0x64EF201B.01109A4A5p0", "0x819A1801.9394C0D96p0", "0xA6698403.CF5D9E663p0",
"0xD5AD6DCE.21AFFC0DDp0", "0x1125E066B.0B19418CCp0", "0x1604B68CF.05F65FAA9p0", "0x1C45AED0A.D0C934CDCp0",
"0x244D5E676.3FB814AF0p0", "0x2E9CEBF49.9C21839C7p0", "0x3BDA2CBD0.9F5AC2146p0", "0x4CDA0FD41.989F004E7p0",
"0x62ADFED51.D7EDCCDE6p0", "0x7EB50B520.76F91D6E8p0", "0xA2B1FD3D9.A57B6C33Cp0", "0xD0E7A50F4.EF0D7447Fp0",
"0x10C3D39209.62C88AAFBp0", "0x1586D0722B.3EEB27301p0", "0x1BA4068AAC.2B6E3EE34p0", "0x237DCBF1E5.709A9F9C1p0",
"0x2D9264D2D4.D6B94153Bp0", "0x3A83F23B18.FE5BD524Ap0", "0x4B22A1B5C3.27A2FD85Ap0", "0x6079C1866C.71A93951Dp0",
"0x7BE08BDFD9.CC72249ABp0", "0x9F0FB7309C.B446D3919p0", "0xCC3D265776.C3D25779Ep0", "0x1063F7612B0.C0831CA6Cp0",
"0x150BBA37963.79A4FB6ADp0", "0x1B05FA9B62E.737D935B8p0", "0x22B2DC5C41D.AD89559EBp0", "0x2C8DD1AB28B.404414BE7p0",
"0x39355C8C638.0AC5631B1p0", "0x49750434675.301B8D0E7p0", "0x5E521E7A16E.51F9CD3C2p0", "0x791C3B06F8B.EA2DEC48Cp0",
"0x9B823857614.764F43E20p0", "0xC7AD559D438.E7C270C30p0", "0x10063F4E687B.A1A43A35Bp0", "0x149363C905BA.3641D0164p0",
"0x1A6B765D8CDF.6CDBF1C63p0", "0x21EC75240E66.E2891CE63p0", "0x2B8F1073A6AF.BA219DB61p0", "0x37EE3FFC0063.E360F931Fp0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000001p0", "0x0.000000001p0", "0x0.000000002p0",
"0x0.000000002p0", "0x0.000000003p0", "0x0.000000004p0", "0x0.000000005p0",
"0x0.000000007p0", "0x0.000000009p0", "0x0.00000000Bp0", "0x0.00000000Ep0",
"0x0.000000013p0", "0x0.000000018p0", "0x0.00000001Fp0", "0x0.000000028p0",
"0x0.000000034p0", "0x0.000000042p0", "0x0.000000055p0", "0x0.00000006Ep0",
"0x0.00000008Dp0", "0x0.0000000B5p0", "0x0.0000000E9p0", "0x0.00000012Bp0",
"0x0.000000181p0", "0x0.0000001EEp0", "0x0.00000027Ap0", "0x0.00000032Fp0",
"0x0.000000416p0", "0x0.00000053Fp0", "0x0.0000006BDp0", "0x0.0000008A7p0",
"0x0.000000B1Cp0", "0x0.000000E44p0", "0x0.000001252p0", "0x0.000001786p0",
"0x0.000001E35p0", "0x0.0000026C9p0", "0x0.0000031CEp0", "0x0.000003FF3p0",
"0x0.00000521Dp0", "0x0.000006970p0", "0x0.000008762p0", "0x0.00000ADD6p0",
"0x0.00000DF36p0", "0x0.000011E9Cp0", "0x0.000017003p0", "0x0.00001D88Ap0",
"0x0.000025EC0p0", "0x0.000030B15p0", "0x0.00003E85Dp0", "0x0.00005047Ep0",
"0x0.000067153p0", "0x0.0000845C6p0", "0x0.0000A9F46p0", "0x0.0000DA39Ep0",
"0x0.000118354p0", "0x0.000167CB5p0", "0x0.0001CDFC2p0", "0x0.000251334p0",
"0x0.0002F9AF3p0", "0x0.0003D205Ap0", "0x0.0004E7CE2p0", "0x0.00064C7C6p0",
"0x0.000816791p0", "0x0.000A628A3p0", "0x0.000D55A1Fp0", "0x0.00111F30Fp0",
"0x0.0015FC210p0", "0x0.001C3AA91p0", "0x0.00243F374p0", "0x0.002E8ABFCp0",
"0x0.003BC2D73p0", "0x0.004CBC19Ap0", "0x0.006287862p0", "0x0.007E83A56p0",
"0x0.00A2728F8p0", "0x0.00D096336p0", "0x0.010BD4A5Ap0", "0x0.0157E6BFEp0",
"0x0.01B993FE0p0", "0x0.0236FF5BFp0", "0x0.02D80A08Dp0", "0x0.03A6D2222p0",
"0x0.04B0556E0p0", "0x0.0605424D5p0", "0x0.07BB04063p0", "0x0.09ED1B429p0",
"0x0.0CBED8666p0", "0x0.105D93892p0", "0x0.150385C09p0", "0x0.1AFB718E8p0",
"0x0.22A555477p0", "0x0.2C7C72FC0p0", "0x0.391F0EE49p0", "0x0.495860DCAp0",
"0x0.5E2D58D8Bp0", "0x0.78ED03AFBp0", "0x0.9B4597E37p0", "0x0.C75F7CF56p0",
            };
            ap_ufixed<68,32> exp_x_msb_1 = exp_x_msb_1_table[x_msb_ind_1];
            ap_ufixed<140,32> y_lo = exp_x_msb_1 * exp_x_msb_2_3_4_lsb_m_1;
            ap_ufixed<68,32> y_lo_s = y_lo;
            ap_ufixed<68,32> y_l = y_lo_s + exp_x_msb_1;
            y = y_l;
        }
        if (I_<33) {
            bool overf = 0;
            VITIS_LOOP_934_21: for (int j = 63; j >= I_+31; j--) {
#pragma HLS unroll
 if (y[j])
                    overf = 1;
            }
            if (overf) {
                VITIS_LOOP_940_22: for (int j = 63; j >= I_+31; j--) {
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_944_23: for (int j = I_+30; j >= 0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        }
        r = y;
    }
    return r;
}


template<int WO_, int I_, int WI_>
ap_fixed<WO_,I_> exp_core(ap_fixed<WI_,I_> x)
{
#pragma HLS pipeline

 const static int FO_ = WO_ - I_;
    const static int FI_ = WI_ - I_;


    if (I_>33) return 0;
    else if (FO_>32) return 0;
    else if (FI_>100) return 0;




    int I_s_;
    int M_ = (I_-1>FO_) ? (I_-1) : FO_;
    if (M_==1) I_s_ = 1;
    else if (M_==2) I_s_ = 2;
    else if (M_<6) I_s_ = 3;
    else if (M_<12) I_s_ = 4;
    else if (M_<24) I_s_ = 5;
    else I_s_ = 6;

    ap_fixed<WO_,I_> r = 0;

    ap_ufixed<1,-FO_> delta = 0;
    delta[0] = 1;

    if (I_s_==1) {






        const static int w = 7;
        const static int we = 2;
        const static int wf = 5;

        ap_fixed<w,we> x_l = x;
        ap_ufixed<3,2> y = 0;
        ap_ufixed<5,0> x_l_fract=0;
        x_l_fract(4,0) = x_l(4,0);


        if (x_l[6]!=x_l[5]) {
            if (!x_l[6]) y = "0x1.8p0";
        } else {
            if (!x_l[6]) y[1] = 1;

            if (!x_l[6]&(x_l[4]|(x_l[2]&x_l[3]))) y[0]=1;
            if (!x_l[6]&x_l[2]&x_l[3]) y[0]=1;
            if (x_l[6]&((x_l[4]&x_l[3])|x_l[5])) y[0] = 1;
            if (x_l[6]&x_l[5]&!x_l[4]&x_l[3]&!x_l[2]&x_l[1]) y[0] = 1;
        }
        y += delta;

            if (y[1]|y[2]) {
                y[2] = 0;
                y[1] = 0;
                y[0] = 1;
            }

        r = y;

    } else if (I_s_==2) {
        const static int w = 10;
        const static int we = 3;
        const static int wf = 7;


        ap_fixed<w,we> x_l = x;
        ap_ufixed<5,3> y = 0;
        ap_fixed<2,2> x_l_int;
        x_l_int(1,0) = x_l(wf+1,wf);
        ap_ufixed<7,0> x_l_fract;
        x_l_fract(6,0) = x_l(6,0);

        ap_uint<5> x_msb_ind;
        x_msb_ind[3] = x_l[w-1];
        x_msb_ind(2,0) = x_l(wf,wf-3);
        ap_ufixed<4,-3> x_lsb = x_l;


        if ((x_l[w-1]!=x_l[w-2])||((x_l_int==1)&&(x_l_fract>=ap_ufixed<wf,0>("0x0.54p0")))) {
            if (!x_l[w-1]) y = "0x3.cp0";
        } else {
            ap_ufixed<5,2> exp_x_msb_table[32] = {
               "0x1.00p0", "0x1.48p0", "0x1.A6p0", "0x2.1Dp0", "0x2.B7p0", "0x3.7Dp0", "0x4.7Bp0", "0x5.C1p0",
               "0x0.22p0", "0x0.2Cp0", "0x0.39p0", "0x0.49p0", "0x0.5Ep0", "0x0.78p0", "0x0.9Bp0", "0x0.C7p0",
            };
            ap_ufixed<5,2> exp_x_msb = exp_x_msb_table[x_msb_ind];


            ap_ufixed<5,0> y_lo = x_lsb * exp_x_msb;

            ap_ufixed<5,2> y_l = y_lo + exp_x_msb;

            y = y_l;
        }
        y += delta;
            bool overf = 0;
            VITIS_LOOP_1060_1: for (int j = 4; j >= I_+1; j--) {
#pragma HLS unroll
 if (y[j])
                    overf = 1;
            }
            if (overf) {
                VITIS_LOOP_1066_2: for (int j = 4; j >= I_+1; j--) {
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_1070_3: for (int j = I_; j >= 0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        r = y;
    } else if (I_s_==3) {

        const static int w = 19;
        const static int we = 6;
        const static int wf = 13;

        ap_fixed<w,we> x_l = x;
        ap_ufixed<11,6> y = 0;
        ap_fixed<3,3> x_l_int;
        x_l_int(2,0) = x_l(wf+2,wf);
        ap_ufixed<wf,0> x_l_fract;
        x_l_fract(wf-1,0) = x_l(wf-1,0);




        if ((x_l[w-1]!=x_l[w-2])||(x_l[w-1]!=x_l[w-3])||(x_l[w-1]!=x_l[w-4])||((x_l_int==3)&&(x_l_fract>ap_ufixed<wf,0>("0x0.76FAp0")))) {
            if (!x_l[18]) y = "0x1f.f8p0";
        } else {
            const static int g = 2;
            const static int Maxprecision = FO_+we+g;
            ap_uint<4> x_msb_ind_1;
            x_msb_ind_1[3] = x_l[w-1];

            x_msb_ind_1(2,0) = x_l(wf+1,wf-1);

            ap_uint<6> x_msb_ind_2;
            x_msb_ind_2(5,0) = x_l(wf-2,wf-7);
            ap_ufixed<6,-1> x_msb_2 = x_l;

            ap_ufixed<wf-7,-7> x_lsb = x_l;

            const static ap_ufixed<Maxprecision,0> exp_x_msb_2_m_1_table[64] = {
                "0x0.0p0", "0x0.0202p0", "0x0.0408p0", "0x0.0612p0",
                "0x0.0820p0", "0x0.0A32p0", "0x0.0C49p0", "0x0.0E63p0",
                "0x0.1082p0", "0x0.12A5p0", "0x0.14CDp0", "0x0.16F9p0",
                "0x0.1929p0", "0x0.1B5Dp0", "0x0.1D96p0", "0x0.1FD4p0",
                "0x0.2216p0", "0x0.245Cp0", "0x0.26A7p0", "0x0.28F7p0",
                "0x0.2B4Bp0", "0x0.2DA4p0", "0x0.3001p0", "0x0.3264p0",
                "0x0.34CBp0", "0x0.3737p0", "0x0.39A8p0", "0x0.3C1Ep0",
                "0x0.3E98p0", "0x0.4118p0", "0x0.439Dp0", "0x0.4627p0",
                "0x0.48B5p0", "0x0.4B49p0", "0x0.4DE3p0", "0x0.5081p0",
                "0x0.5325p0", "0x0.55CEp0", "0x0.587Cp0", "0x0.5B2Fp0",
                "0x0.5DE9p0", "0x0.60A7p0", "0x0.636Bp0", "0x0.6635p0",
                "0x0.6904p0", "0x0.6BD9p0", "0x0.6EB3p0", "0x0.7194p0",
                "0x0.747Ap0", "0x0.7766p0", "0x0.7A57p0", "0x0.7D4Fp0",
                "0x0.804Dp0", "0x0.8350p0", "0x0.865Ap0", "0x0.896Ap0",
                "0x0.8C80p0", "0x0.8F9Cp0", "0x0.92BEp0", "0x0.95E7p0",
                "0x0.9916p0", "0x0.9C4Bp0", "0x0.9F87p0", "0x0.A2C9p0",
            };

            ap_ufixed<5,-8> f_x_msb_2_lsb = x_msb_2 * x_lsb;


            ap_ufixed<7,-6> f_x_msb_2_lsb_m_1_m=0;
            f_x_msb_2_lsb_m_1_m(5,0) = x_lsb(5,0);
            f_x_msb_2_lsb_m_1_m = f_x_msb_2_lsb_m_1_m + f_x_msb_2_lsb;


            ap_ufixed<Maxprecision+1,1> exp_x_msb_2_m_1 = exp_x_msb_2_m_1_table[x_msb_ind_2];
            ap_ufixed<Maxprecision,1> exp_x_msb_2_lsb_m_1 = f_x_msb_2_lsb_m_1_m + exp_x_msb_2_m_1;


            const static ap_ufixed<Maxprecision,5> exp_x_msb_1_table[16] = {
                "0x1.0000p0", "0x1.A612p0", "0x2.B7E1p0", "0x4.7B4Fp0",
                "0x7.6399p0", "0xC.2EB7p0", "0x14.15E5p0", "0x21.1D8Ep0",
                "0x0.04B0p0", "0x0.07BBp0", "0x0.0CBEp0", "0x0.1503p0",
                "0x0.22A5p0", "0x0.391Fp0", "0x0.5E2Dp0", "0x0.9B45p0",

            };
            ap_ufixed<Maxprecision,5> exp_x_msb = exp_x_msb_1_table[x_msb_ind_1];

            ap_ufixed<2*Maxprecision+1,6> y_lo = exp_x_msb * exp_x_msb_2_lsb_m_1;
            ap_ufixed<Maxprecision,5> y_lo_s = y_lo;
            ap_ufixed<Maxprecision,5> y_l = y_lo_s + exp_x_msb;
            y = y_l;

        }
        y += delta;

            bool overf = 0;
            VITIS_LOOP_1157_4: for (int j = 10; j >= I_+4; j--) {
#pragma HLS unroll
 if (y[j])
                    overf = 1;
            }
            if (overf) {
                VITIS_LOOP_1163_5: for (int j = 10; j >= I_+4; j--) {
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_1167_6: for (int j = I_+3; j >= 0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }

        r = y;
    } else if (I_s_==4) {

        const static int wf = 25;
        const static int we = 12;
        const static int w = 37;
        ap_fixed<w,we> x_l = x;
        ap_ufixed<23,12> y = 0;
        ap_fixed<4,4> x_l_int;
        x_l_int(3,0) = x_l(wf+3,wf);
        ap_ufixed<wf,0> x_l_fract;
        x_l_fract(wf-1,0) = x_l(wf-1,0);
        bool overf = 0;
        VITIS_LOOP_1186_7: for (int j = wf+3; j < w-1; j++) {
#pragma HLS unroll
 if (x_l[w-1]!=x_l[j])
                overf = 1;
        }
        if (overf||((x_l_int==7)&&(x_l_fract>ap_ufixed<wf,0>("0x0.9fe7038p0")))) {
            if (!x_l[w-1]) {
                VITIS_LOOP_1193_8: for (int j = 0; j < 22; j++) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        } else {
            const static int g = 2;
            const static int Maxprecision = 25;
            ap_uint<5> x_msb_ind_1;
            x_msb_ind_1[4] = x_l[w-1];
            x_msb_ind_1(3,0) = x_l(wf+2,wf-1);

            ap_uint<5> x_msb_ind_2;
            x_msb_ind_2(4,0) = x_l(wf-2,wf-6);
            ap_ufixed<5,-1> x_msb_2 = x_l;

            ap_uint<7> x_msb_ind_3;
            x_msb_ind_3(6,0) = x_l(wf-7,wf-13);
            ap_ufixed<7,-6> x_msb_3 = x_l;

            ap_ufixed<7,-13> x_lsb = x_l;

            const static ap_ufixed<12,-13> f_x_msb_3_m_1_table[128] = {
"0x0.0p0", "0x0.0000002p0", "0x0.0000008p0", "0x0.0000012p0",
"0x0.0000020p0", "0x0.0000032p0", "0x0.0000048p0", "0x0.0000062p0",
"0x0.0000080p0", "0x0.00000A2p0", "0x0.00000C8p0", "0x0.00000F2p0",
"0x0.0000120p0", "0x0.0000152p0", "0x0.0000188p0", "0x0.00001C2p0",
"0x0.0000200p0", "0x0.0000242p0", "0x0.0000288p0", "0x0.00002D2p0",
"0x0.0000320p0", "0x0.0000372p0", "0x0.00003C8p0", "0x0.0000422p0",
"0x0.0000481p0", "0x0.00004E3p0", "0x0.0000549p0", "0x0.00005B3p0",
"0x0.0000621p0", "0x0.0000693p0", "0x0.000070Ap0", "0x0.0000784p0",
"0x0.0000802p0", "0x0.0000884p0", "0x0.000090Bp0", "0x0.0000995p0",
"0x0.0000A23p0", "0x0.0000AB6p0", "0x0.0000B4Cp0", "0x0.0000BE6p0",
"0x0.0000C85p0", "0x0.0000D27p0", "0x0.0000DCEp0", "0x0.0000E78p0",
"0x0.0000F26p0", "0x0.0000FD9p0", "0x0.000108Fp0", "0x0.000114Ap0",
"0x0.0001209p0", "0x0.00012CBp0", "0x0.0001392p0", "0x0.000145Cp0",
"0x0.000152Bp0", "0x0.00015FEp0", "0x0.00016D4p0", "0x0.00017AFp0",
"0x0.000188Ep0", "0x0.0001971p0", "0x0.0001A57p0", "0x0.0001B42p0",
"0x0.0001C31p0", "0x0.0001D24p0", "0x0.0001E1Bp0", "0x0.0001F16p0",
"0x0.0002015p0", "0x0.0002118p0", "0x0.000221Fp0", "0x0.000232Ap0",
"0x0.0002439p0", "0x0.000254Cp0", "0x0.0002663p0", "0x0.000277Fp0",
"0x0.000289Ep0", "0x0.00029C1p0", "0x0.0002AE9p0", "0x0.0002C14p0",
"0x0.0002D43p0", "0x0.0002E77p0", "0x0.0002FAEp0", "0x0.00030EAp0",
"0x0.0003229p0", "0x0.000336Dp0", "0x0.00034B4p0", "0x0.0003600p0",
"0x0.0003750p0", "0x0.00038A4p0", "0x0.00039FBp0", "0x0.0003B57p0",
"0x0.0003CB7p0", "0x0.0003E1Bp0", "0x0.0003F83p0", "0x0.00040EFp0",
"0x0.000425Fp0", "0x0.00043D3p0", "0x0.000454Bp0", "0x0.00046C7p0",
"0x0.0004848p0", "0x0.00049CCp0", "0x0.0004B54p0", "0x0.0004CE1p0",
"0x0.0004E71p0", "0x0.0005006p0", "0x0.000519Ep0", "0x0.000533Bp0",
"0x0.00054DBp0", "0x0.0005680p0", "0x0.0005829p0", "0x0.00059D6p0",
"0x0.0005B86p0", "0x0.0005D3Bp0", "0x0.0005EF4p0", "0x0.00060B1p0",
"0x0.0006272p0", "0x0.0006437p0", "0x0.0006600p0", "0x0.00067CEp0",
"0x0.000699Fp0", "0x0.0006B74p0", "0x0.0006D4Ep0", "0x0.0006F2Bp0",
"0x0.000710Dp0", "0x0.00072F2p0", "0x0.00074DCp0", "0x0.00076CAp0",
"0x0.00078BBp0", "0x0.0007AB1p0", "0x0.0007CABp0", "0x0.0007EA9p0",
            };

            ap_ufixed<6,-19> f_x_msb_3_lsb = x_msb_3 * x_lsb;


            ap_ufixed<12,-13> f_x_msb_3 = f_x_msb_3_m_1_table[x_msb_ind_3];

            ap_ufixed<13,-12> exp_x_msb_3_lsb_m_1_m = 0;
            exp_x_msb_3_lsb_m_1_m(11,0) = f_x_msb_3(11,0);
            exp_x_msb_3_lsb_m_1_m = exp_x_msb_3_lsb_m_1_m + f_x_msb_3_lsb;


            ap_ufixed<19,-6> x_msb_3_lsb = x_l;

            ap_ufixed<20,-5> exp_x_msb_3_lsb_m_1 = 0;
            exp_x_msb_3_lsb_m_1(18,0) = x_msb_3_lsb(18,0);
            exp_x_msb_3_lsb_m_1 = exp_x_msb_3_lsb_m_1+ exp_x_msb_3_lsb_m_1_m;


            const static ap_ufixed<25,0> exp_x_msb_2_m_1_table[32] = {
                "0x0.0000000p0", "0x0.04080a8p0", "0x0.0820560p0", "0x0.0c49238p0",
                "0x0.1082b58p0", "0x0.14cd500p0", "0x0.1929370p0", "0x0.1d96b10p0",
                "0x0.2216048p0", "0x0.26a7790p0", "0x0.2b4b588p0", "0x0.3001ed0p0",
                "0x0.34cb818p0", "0x0.39a8628p0", "0x0.3e98de8p0", "0x0.439d440p0",
                "0x0.48b5e40p0", "0x0.4de30f0p0", "0x0.5325180p0", "0x0.587c540p0",
                "0x0.5de9178p0", "0x0.636bb98p0", "0x0.6904930p0", "0x0.6eb3fc8p0",
                "0x0.747a510p0", "0x0.7a57ee0p0", "0x0.804d300p0", "0x0.865a778p0",
                "0x0.8c80248p0", "0x0.92be998p0", "0x0.99163b0p0", "0x0.9f876e8p0",
            };
            ap_ufixed<25, 0> exp_x_msb_2_m_1 = exp_x_msb_2_m_1_table[x_msb_ind_2];

            ap_ufixed<50,-5> f_x_msb_2_3_lsb = exp_x_msb_2_m_1 * exp_x_msb_3_lsb_m_1;
            ap_ufixed<20,-5> f_x_msb_2_3_lsb_s = f_x_msb_2_3_lsb;
            ap_ufixed<25, 0> exp_x_msb_2_3_lsb_m_1 = f_x_msb_2_3_lsb_s + exp_x_msb_3_lsb_m_1 + exp_x_msb_2_m_1;


            const static ap_ufixed<25,11> exp_x_msb_1_table[32] = {
                "0x1.0000p0", "0x1.a614p0", "0x2.b7e0p0", "0x4.7b50p0",
                "0x7.6398p0", "0xc.2eb8p0", "0x14.15e4p0", "0x21.1d90p0",
                "0x36.9920p0", "0x5a.0464p0", "0x94.69c4p0", "0xf4.b124p0",
                "0x193.6dc4p0", "0x299.2444p0", "0x448.a218p0", "0x710.0adcp0",
                "0x0.0014p0", "0x0.0024p0", "0x0.003cp0", "0x0.0064p0",
                "0x0.00a4p0", "0x0.010cp0", "0x0.01b8p0", "0x0.02d8p0",
                "0x0.04b0p0", "0x0.07bcp0", "0x0.0cc0p0", "0x0.1504p0",
                "0x0.22a4p0", "0x0.3920p0", "0x0.5e2cp0", "0x0.9b44p0",
            };
            ap_ufixed<25,11> exp_x_msb_1 = exp_x_msb_1_table[x_msb_ind_1];


            ap_ufixed<50,11> y_lo = exp_x_msb_1 * exp_x_msb_2_3_lsb_m_1;

            ap_ufixed<25,11> y_lo_s = y_lo;

            ap_ufixed<25,11> y_l = y_lo_s + exp_x_msb_1;

            y = y_l;

        }
        y += delta;

            overf = 0;
            VITIS_LOOP_1309_9: for (int j = 22; j >= I_+10; j--) {
#pragma HLS unroll
 if (y[j])
                    overf = 1;
            }
            if (overf) {
                VITIS_LOOP_1315_10: for (int j = 22; j >= I_+10; j--){
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_1319_11: for (int j = I_+9; j >= 0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }

        r = y;
    } else if (I_s_==5) {

        if(WI_>73) return 0;
        const static int we = 24;
        const static int wf = 49;
        const static int w = 73;
        ap_fixed<w,we> x_l = x;
        ap_ufixed<47,24> y = 0;
        ap_fixed<5,5> x_l_int;
        x_l_int(4,0) = x_l(wf+4,wf);
        ap_ufixed<wf,0> x_l_fract;
        x_l_fract(wf-1,0) = x_l(wf-1,0);
        bool overf = 0;
        VITIS_LOOP_1339_12: for (int j = wf+4; j < w-1; j++){
#pragma HLS unroll
 if (x_l[w-1]!=x_l[j])
                overf = 1;
        }
        if (overf||((x_l_int==15)&&(x_l_fract>=ap_ufixed<wf,0>("0x0.F1402743D99F8p0")))) {
            if (!x_l[w-1]) {
                VITIS_LOOP_1346_13: for (int j = 0; j < 46; j++) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        } else {
            const static int g=4;
            const static int Maxprecision = 51;
            ap_uint<8> x_msb_ind_1;
            x_msb_ind_1[7] = x_l[w-1];
            x_msb_ind_1(6,0) = x_l(wf+3,wf-3);

            ap_uint<8> x_msb_ind_2;
            x_msb_ind_2(7,0) = x_l(wf-4,wf-11);
            ap_uint<5> x_msb_ind_3;
            x_msb_ind_3(4,0) = x_l(wf-12,wf-16);
            ap_uint<3> x_msb_ind_4;
            x_msb_ind_4(2,0) = x_l(wf-17,wf-19);

            ap_uint<6> x_msb_ind_5;
            x_msb_ind_5(5,0) = x_l(wf-20,wf-25);

            ap_ufixed<8, -3> x_msb_2 = x_l;
            ap_ufixed<5,-11> x_msb_3 = x_l;
            ap_ufixed<3,-16> x_msb_4 = x_l;
            ap_ufixed<6,-19> x_msb_5 = x_l;

            ap_ufixed<7,-25> x_lsb = x_l;

            const static ap_ufixed<12,-39> f_x_msb_5_table[64] = {
"0x0.0000000000000p0", "0x0.0000000000002p0", "0x0.0000000000008p0", "0x0.0000000000012p0",
"0x0.0000000000020p0", "0x0.0000000000032p0", "0x0.0000000000048p0", "0x0.0000000000062p0",
"0x0.0000000000080p0", "0x0.00000000000A2p0", "0x0.00000000000C8p0", "0x0.00000000000F2p0",
"0x0.0000000000120p0", "0x0.0000000000152p0", "0x0.0000000000188p0", "0x0.00000000001C2p0",
"0x0.0000000000200p0", "0x0.0000000000242p0", "0x0.0000000000288p0", "0x0.00000000002D2p0",
"0x0.0000000000320p0", "0x0.0000000000372p0", "0x0.00000000003C8p0", "0x0.0000000000422p0",
"0x0.0000000000480p0", "0x0.00000000004E2p0", "0x0.0000000000548p0", "0x0.00000000005B2p0",
"0x0.0000000000620p0", "0x0.0000000000692p0", "0x0.0000000000708p0", "0x0.0000000000782p0",
"0x0.0000000000800p0", "0x0.0000000000882p0", "0x0.0000000000908p0", "0x0.0000000000992p0",
"0x0.0000000000A20p0", "0x0.0000000000AB2p0", "0x0.0000000000B48p0", "0x0.0000000000BE2p0",
"0x0.0000000000C80p0", "0x0.0000000000D22p0", "0x0.0000000000DC8p0", "0x0.0000000000E72p0",
"0x0.0000000000F20p0", "0x0.0000000000FD2p0", "0x0.0000000001088p0", "0x0.0000000001142p0",
"0x0.0000000001200p0", "0x0.00000000012C2p0", "0x0.0000000001388p0", "0x0.0000000001452p0",
"0x0.0000000001520p0", "0x0.00000000015F2p0", "0x0.00000000016C8p0", "0x0.00000000017A2p0",
"0x0.0000000001880p0", "0x0.0000000001962p0", "0x0.0000000001A48p0", "0x0.0000000001B32p0",
"0x0.0000000001C20p0", "0x0.0000000001D12p0", "0x0.0000000001E08p0", "0x0.0000000001F02p0",

            };
            ap_ufixed<12,-39> f_x_msb_5 = f_x_msb_5_table[x_msb_ind_5];

            const static ap_ufixed<7,-33> f_x_msb_4_table[8] = {
"0x0.0000000000p0", "0x0.0000000002p0", "0x0.0000000008p0", "0x0.0000000012p0",
"0x0.0000000020p0", "0x0.0000000032p0", "0x0.0000000048p0", "0x0.0000000062p0",
            };
            ap_ufixed<7,-33> f_x_msb_4 = f_x_msb_4_table[x_msb_ind_4];

            ap_ufixed<7,-44> f_x_msb_5_lsb = x_msb_5 * x_lsb;

            ap_ufixed<16,-19> x_msb_5_lsb = x_l;

            ap_ufixed<19,-35> f_x_msb_4_5_lsb = x_msb_5_lsb * x_msb_4;
            ap_ufixed<16,-35> f_x_msb_4_5_lsb_s = f_x_msb_4_5_lsb;

            ap_ufixed<13,-38> exp_x_msb_4_5_lsb_m_1_m3 = 0;
            exp_x_msb_4_5_lsb_m_1_m3(11,0)=f_x_msb_5(11,0);
            exp_x_msb_4_5_lsb_m_1_m3 = exp_x_msb_4_5_lsb_m_1_m3+f_x_msb_5_lsb;

            ap_ufixed<17,-34> exp_x_msb_4_5_lsb_m_1_m4 = 0;
            exp_x_msb_4_5_lsb_m_1_m4(15,0)=f_x_msb_4_5_lsb_s(15,0);
            exp_x_msb_4_5_lsb_m_1_m4 = exp_x_msb_4_5_lsb_m_1_m4 + f_x_msb_4_5_lsb_s;

            ap_ufixed<8,-32> exp_x_msb_4_5_lsb_m_1_m5_s = 0;
            exp_x_msb_4_5_lsb_m_1_m5_s(5,0)=exp_x_msb_4_5_lsb_m_1_m4(16,11);
            exp_x_msb_4_5_lsb_m_1_m5_s = f_x_msb_4+exp_x_msb_4_5_lsb_m_1_m5_s;

            ap_ufixed<19,-32> exp_x_msb_4_5_lsb_m_1_m5 = exp_x_msb_4_5_lsb_m_1_m5_s;
            exp_x_msb_4_5_lsb_m_1_m5(10,0)=exp_x_msb_4_5_lsb_m_1_m4(10,0);

            ap_ufixed<32,-15> exp_x_msb_4_5_lsb_m_1_m6 = 0;
            ap_ufixed<wf-16,-16> x_msb_4_5_lsb = x_l;
            exp_x_msb_4_5_lsb_m_1_m6(14,0) = exp_x_msb_4_5_lsb_m_1_m5(18,4);
            exp_x_msb_4_5_lsb_m_1_m6 = exp_x_msb_4_5_lsb_m_1_m6 + x_msb_4_5_lsb;
            ap_ufixed<36,-15> exp_x_msb_4_5_lsb_m_1 = exp_x_msb_4_5_lsb_m_1_m6;
            exp_x_msb_4_5_lsb_m_1(3,0) = exp_x_msb_4_5_lsb_m_1_m5(3,0);


            const static ap_ufixed<32,-23> f_x_msb_3_table[32] = {
"0x0.00000000000000p0", "0x0.0000000080002ap0", "0x0.00000002000156p0", "0x0.00000004800480p0",
"0x0.00000008000aaap0", "0x0.0000000c8014d6p0", "0x0.00000012002400p0", "0x0.0000001880392cp0",
"0x0.00000020005556p0", "0x0.00000028807982p0", "0x0.0000003200a6acp0", "0x0.0000003c80ddd8p0",
"0x0.00000048012004p0", "0x0.00000054816e30p0", "0x0.0000006201c95cp0", "0x0.00000070823288p0",
"0x0.0000008002aab6p0", "0x0.000000908332e2p0", "0x0.000000a203cc12p0", "0x0.000000b4847740p0",
"0x0.000000c8053570p0", "0x0.000000dc8607a0p0", "0x0.000000f206eed0p0", "0x0.0000010887ec02p0",
"0x0.00000120090036p0", "0x0.000001388a2c6ap0", "0x0.000001520b71a0p0", "0x0.0000016c8cd0d6p0",
"0x0.000001880e4b0ep0", "0x0.000001a48fe148p0", "0x0.000001c2119484p0", "0x0.000001e09365c0p0",
            };

            ap_ufixed<32,-23> f_x_msb_3 = f_x_msb_3_table[x_msb_ind_3];
            ap_ufixed<44,-11> exp_x_msb_3_m_1 = 0;
            exp_x_msb_3_m_1(43,39) = x_msb_3(4,0);
            exp_x_msb_3_m_1(31, 0) = f_x_msb_3(31,0);


            ap_ufixed<80,-26> f_x_msb_3_4_lsb = exp_x_msb_3_m_1 * exp_x_msb_4_5_lsb_m_1;
            ap_ufixed<31,-26> f_x_msb_3_4_lsb_s = f_x_msb_3_4_lsb;
            ap_ufixed<48,-10> exp_x_msb_3_4_lsb_m_1 = f_x_msb_3_4_lsb_s + exp_x_msb_3_m_1 + exp_x_msb_4_5_lsb_m_1;


            const static ap_ufixed<46,-6> f_x_msb_2_table[256] = {
"0x0.0p0", "0x0.0000020015560p0", "0x0.00000800AAB55p0", "0x0.0000120240360p0",
"0x0.0000200556001p0", "0x0.0000320A6C4B8p0", "0x0.0000481203608p0", "0x0.0000621C9B971p0",
"0x0.0000802AB5577p0", "0x0.0000A23CD119Dp0", "0x0.0000C8536F668p0", "0x0.0000F26F10D5Dp0",
"0x0.0001209036103p0", "0x0.000152B75FCE3p0", "0x0.000188E50ED86p0", "0x0.0001C319C4077p0",
"0x0.0002015600445p0", "0x0.0002439A4487Ep0", "0x0.000289E711DB3p0", "0x0.0002D43CE9577p0",
"0x0.0003229C4C260p0", "0x0.00037505BB805p0", "0x0.0003CB79B8B01p0", "0x0.000425F8C50F2p0",
"0x0.0004848362076p0", "0x0.0004E71A11131p0", "0x0.00054DBD53BC8p0", "0x0.0005B86DAB9E3p0",
"0x0.0006272B9A630p0", "0x0.000699F7A1C5Dp0", "0x0.000710D24391Ep0", "0x0.00078BBC01A29p0",
"0x0.00080AB55DE39p0", "0x0.00088DBEDA50Bp0", "0x0.000914D8F8F63p0", "0x0.0009A0043BF07p0",
"0x0.000A2F41256C2p0", "0x0.000AC29037A63p0", "0x0.000B59F1F4EBDp0", "0x0.000BF566DF9AAp0",
"0x0.000C94EF7A206p0", "0x0.000D388C46FB4p0", "0x0.000DE03DC8B9Bp0", "0x0.000E8C0481FA7p0",
"0x0.000F3BE0F56CAp0", "0x0.000FEFD3A5CFAp0", "0x0.0010A7DD15F36p0", "0x0.001163FDC8B7Fp0",
"0x0.00122436410DDp0", "0x0.0012E88701F5Ep0", "0x0.0013B0F08E817p0", "0x0.00147D7369D22p0",
"0x0.00154E101719Fp0", "0x0.001622C7199B7p0", "0x0.0016FB98F4A96p0", "0x0.0017D8862BA72p0",
"0x0.0018B98F42084p0", "0x0.00199EB4BB511p0", "0x0.001A87F71B161p0", "0x0.001B7556E4FC4p0",
"0x0.001C66D49CB93p0", "0x0.001D5C70C612Dp0", "0x0.001E562BE4DFAp0", "0x0.001F54067D067p0",
"0x0.00205601127ECp0", "0x0.00215C1C29507p0", "0x0.0022665845940p0", "0x0.002374B5EB724p0",
"0x0.002487359F24Cp0", "0x0.00259DD7E4F57p0", "0x0.0026B89D413EFp0", "0x0.0027D786386C4p0",
"0x0.0028FA934EF90p0", "0x0.002A21C509717p0", "0x0.002B4D1BEC726p0", "0x0.002C7C987CA92p0",
"0x0.002DB03B3ED3Ap0", "0x0.002EE804B7C07p0", "0x0.003023F56C4ECp0", "0x0.0031640DE16E3p0",
"0x0.0032A84E9C1F5p0", "0x0.0033F0B821730p0", "0x0.00353D4AF68B0p0", "0x0.00368E07A0999p0",
"0x0.0037E2EEA4E19p0", "0x0.00393C0088B6Cp0", "0x0.003A993DD17D5p0", "0x0.003BFAA704AA3p0",
"0x0.003D603CA7C32p0", "0x0.003EC9FF405E6p0", "0x0.004037EF54230p0", "0x0.0041AA0D68C8Cp0",
"0x0.0043205A04182p0", "0x0.00449AD5ABEA5p0", "0x0.00461980E6294p0", "0x0.00479C5C38CF9p0",
"0x0.0049236829E8Bp0", "0x0.004AAEA53F90Ep0", "0x0.004C3E13FFF51p0", "0x0.004DD1B4F152Fp0",
"0x0.004F698899F90p0", "0x0.0051058F8046Ap0", "0x0.0052A5CA2AABFp0", "0x0.00544A391FA9Cp0",
"0x0.0055F2DCE5D1Ep0", "0x0.00579FB603C6Ep0", "0x0.005950C5003C2p0", "0x0.005B060A61F5Dp0",
"0x0.005CBF86AFC91p0", "0x0.005E7D3A709BEp0", "0x0.00603F262B650p0", "0x0.0062054A672C2p0",
"0x0.0063CFA7AB09Dp0", "0x0.00659E3E7E278p0", "0x0.0067710F67BFAp0", "0x0.0069481AEF1D5p0",
"0x0.006B23619B9CFp0", "0x0.006D02E3F4AB7p0", "0x0.006EE6A281C6Fp0", "0x0.0070CE9DCA7E6p0",
"0x0.0072BAD65671Bp0", "0x0.0074AB4CAD51Cp0", "0x0.0076A00156E07p0", "0x0.007898F4DAF09p0",
"0x0.007A9627C165Fp0", "0x0.007C979A92356p0", "0x0.007E9D4DD564Ap0", "0x0.0080A742130A8p0",
"0x0.0082B577D34EDp0", "0x0.0084C7EF9E6A7p0", "0x0.0086DEA9FCA73p0", "0x0.0088F9A776601p0",
"0x0.008B18E894010p0", "0x0.008D3C6DDE06Fp0", "0x0.008F6437DD000p0", "0x0.00919047198B6p0",
"0x0.0093C09C1C595p0", "0x0.0095F5376E2B2p0", "0x0.00982E1997D33p0", "0x0.009A6B4322352p0",
"0x0.009CACB496458p0", "0x0.009EF26E7D0A2p0", "0x0.00A13C715F99Ep0", "0x0.00A38ABDC71CEp0",
"0x0.00A5DD543CCC4p0", "0x0.00A8343549F26p0", "0x0.00AA8F6177EADp0", "0x0.00ACEED950222p0",
"0x0.00AF529D5C165p0", "0x0.00B1BAAE25566p0", "0x0.00B4270C3582Ap0", "0x0.00B697B8164C7p0",
"0x0.00B90CB25176Ap0", "0x0.00BB85FB70D50p0", "0x0.00BE0393FE4CCp0", "0x0.00C0857C83D44p0",
"0x0.00C30BB58B732p0", "0x0.00C5963F9F424p0", "0x0.00C8251B496BEp0", "0x0.00CAB849142B5p0",
"0x0.00CD4FC989CD6p0", "0x0.00CFEB9D34B00p0", "0x0.00D28BC49F428p0", "0x0.00D5304054059p0",
"0x0.00D7D910DD8B1p0", "0x0.00DA8636C6764p0", "0x0.00DD37B2997BCp0", "0x0.00DFED84E1618p0",
"0x0.00E2A7AE28FECp0", "0x0.00E5662EFB3C3p0", "0x0.00E82907E313Dp0", "0x0.00EAF0396B910p0",
"0x0.00EDBBC41FD08p0", "0x0.00F08BA88B009p0", "0x0.00F35FE73860Bp0", "0x0.00F63880B341Ep0",
"0x0.00F9157587069p0", "0x0.00FBF6C63F228p0", "0x0.00FEDC73671B0p0", "0x0.0101C67D8A86Cp0",
"0x0.0104B4E5350DFp0", "0x0.0107A7AAF26A2p0", "0x0.010A9ECF4E667p0", "0x0.010D9A52D4DF8p0",
"0x0.01109A3611C34p0", "0x0.01139E7991116p0", "0x0.0116A71DDEDADp0", "0x0.0119B42387423p0",
"0x0.011CC58B167B9p0", "0x0.011FDB5518CCAp0", "0x0.0122F5821A8C7p0", "0x0.01261412A823Cp0",
"0x0.012937074E0CDp0", "0x0.012C5E6098D37p0", "0x0.012F8A1F15151p0", "0x0.0132BA434F80Ap0",
"0x0.0135EECDD4D6Cp0", "0x0.013927BF31E98p0", "0x0.013C6517F39CCp0", "0x0.013FA6D8A6E5Dp0",
"0x0.0142ED01D8CBCp0", "0x0.0146379416673p0", "0x0.0149868FECE26p0", "0x0.014CD9F5E9795p0",
"0x0.015031C699799p0", "0x0.01538E028A426p0", "0x0.0156EEAA4944Bp0", "0x0.015A53BE64033p0",
"0x0.015DBD3F68122p0", "0x0.01612B2DE3178p0", "0x0.01649D8A62CB1p0", "0x0.0168145574F65p0",
"0x0.016B8F8FA7745p0", "0x0.016F0F3988321p0", "0x0.01729353A52E4p0", "0x0.01761BDE8C792p0",
"0x0.0179A8DACC350p0", "0x0.017D3A48F295Dp0", "0x0.0180D0298DE13p0", "0x0.01846A7D2C6ECp0",
"0x0.018809445CA7Bp0", "0x0.018BAC7FAD074p0", "0x0.018F542FAC1A4p0", "0x0.01930054E87F8p0",
"0x0.0196B0EFF0E79p0", "0x0.019A66015414Dp0", "0x0.019E1F89A0DBAp0", "0x0.01A1DD8966221p0",
"0x0.01A5A00132E02p0", "0x0.01A966F1961FCp0", "0x0.01AD325B1EFC9p0", "0x0.01B1023E5CA45p0",
"0x0.01B4D69BDE569p0", "0x0.01B8AF743364Cp0", "0x0.01BC8CC7EB323p0", "0x0.01C06E9795345p0",
"0x0.01C454E3C0F24p0", "0x0.01C83FACFE054p0", "0x0.01CC2EF3DC187p0", "0x0.01D022B8EAE8Fp0",
"0x0.01D41AFCBA45Ep0", "0x0.01D817BFDA104p0", "0x0.01DC1902DA3B1p0", "0x0.01E01EC64ACB7p0",
"0x0.01E4290ABBD87p0", "0x0.01E837D0BD8B2p0", "0x0.01EC4B18E01E9p0", "0x0.01F062E3B3DFEp0",
"0x0.01F47F31C92E4p0", "0x0.01F8A003B07AFp0", "0x0.01FCC559FA492p0", "0x0.0200EF35372E4p0",
"0x0.02051D95F7D1Cp0", "0x0.0209507CCCED1p0", "0x0.020D87EA474BEp0", "0x0.0211C3DEF7CBDp0",
            };
            ap_ufixed<46,-6> f_x_msb_2 = f_x_msb_2_table[x_msb_ind_2];
            ap_ufixed< 5,-6> f_x_msb_2_h;
            f_x_msb_2_h(4,0) = f_x_msb_2(45,41);
            ap_ufixed< 9,-2> exp_x_msb_2_m_1_h = f_x_msb_2_h + x_msb_2;
            ap_ufixed<50,-2> exp_x_msb_2_m_1;
            exp_x_msb_2_m_1(49,41) = exp_x_msb_2_m_1_h(8,0);
            exp_x_msb_2_m_1(40, 0) = f_x_msb_2(40,0);

            ap_ufixed<98,-12> f_x_msb_2_3_4_lsb = exp_x_msb_2_m_1 * exp_x_msb_3_4_lsb_m_1;
            ap_ufixed<46,-12> f_x_msb_2_3_4_lsb_s = f_x_msb_2_3_4_lsb;
            ap_ufixed<50,-2> exp_x_msb_2_3_4_lsb_m_1 = f_x_msb_2_3_4_lsb_s + exp_x_msb_2_m_1 + exp_x_msb_3_4_lsb_m_1;

            const static ap_ufixed<50,23> exp_x_msb_1_table[256] = {
"0x1.0000000p0", "0x1.2216045p0", "0x1.48B5E3Cp0", "0x1.747A513p0",
"0x1.A61298Ep0", "0x1.DE455DFp0", "0x2.1DF3B68p0", "0x2.661CB0Fp0",
"0x2.B7E1516p0", "0x3.1489176p0", "0x3.7D871DBp0", "0x3.F47FE87p0",
"0x4.7B4FF99p0", "0x5.1413452p0", "0x5.C12DA41p0", "0x6.855466Ep0",
"0x7.63992E3p0", "0x8.5F7635Bp0", "0x9.7CDC417p0", "0xA.C042667p0",
"0xC.2EB7EC9p0", "0xD.CDF892Ep0", "0xF.A48385Ep0", "0x11.B9B5652p0",
"0x14.15E5BF6p0", "0x16.C2887C1p0", "0x19.CA53B78p0", "0x1D.396AA97p0",
"0x21.1D8E427p0", "0x25.865441Cp0", "0x2A.8565A14p0", "0x30.2EC550Bp0",
"0x36.99205C4p0", "0x3D.DE28BF3p0", "0x46.1AFC4DBp0", "0x4F.7099532p0",
"0x5A.0462B78p0", "0x66.00B5BC9p0", "0x73.9593ABBp0", "0x82.F9621ADp0",
"0x94.69C4CB8p0", "0xA8.2C948C1p0", "0xBE.90F6F83p0", "0xD7.F09B78Cp0",
"0xF4.B122790p0", "0x115.45B4704p0", "0x13A.30CF1CCp0", "0x164.0650296p0",
"0x193.6DC5690p0", "0x1C9.250BEDCp0", "0x206.03487A3p0", "0x24A.FC4533Cp0",
"0x299.2442102p0", "0x2F1.B447462p0", "0x356.0F0B0F9p0", "0x3C7.C67E5BEp0",
"0x448.A216ABBp0", "0x4DA.A5EE46Ap0", "0x580.1AD754Fp0", "0x63B.9782341p0",
"0x710.0ADBAC7p0", "0x800.C7CC8E3p0", "0x911.9289C39p0", "0xA46.AFAA2ADp0",
"0xBA4.F53EA38p0", "0xD31.DE30C52p0", "0xEF3.A035D57p0", "0x10F1.44ADE60p0",
"0x1332.C4D2B7Cp0", "0x15C1.29A744Cp0", "0x18A6.B027DA0p0", "0x1BEE.F24BB12p0",
"0x1FA7.157C470p0", "0x23DD.FF3C8BAp0", "0x28A4.90D2CCEp0", "0x2E0D.EAE454Bp0",
"0x342F.BA11823p0", "0x3B22.8DC5359p0", "0x4302.3A933EEp0", "0x4BEE.49AFCDCp0",
"0x560A.773E541p0", "0x617F.4171BF9p0", "0x6E7A.8ABB4A8p0", "0x7D30.5191764p0",
"0x8DDB.80AF426p0", "0xA0BE.DB0DB10p0", "0xB626.0748BAEp0", "0xCE66.BE9EAADp0",
"0xE9E2.2447727p0", "0x10906.4A831F8p0", "0x12C4F.EB75B2Ap0", "0x1544C.5CB6133p0",
"0x1819B.C560F61p0", "0x1B4F3.9F8AF64p0", "0x1EF21.8F1B001p0", "0x2310E.996C40Fp0",
"0x27BC2.CA9A6F9p0", "0x2D069.571279Ap0", "0x33055.49F35D9p0", "0x39D06.D2FEF17p0",
"0x41831.49596E9p0", "0x4A3C1.FB2AC39p0", "0x541E7.E56949Dp0", "0x5F51C.72B7532p0",
"0x6C02D.645AB25p0", "0x7A648.0CFF534p0", "0x8AB06.0A3EE9Fp0", "0x9D27B.AFE4CF1p0",
"0xB2148.5EAE56Cp0", "0xC9CA9.07F86EFp0", "0xE4A8D.2881EDBp0", "0x1031AE.8E4996Cp0",
"0x1259AC.48BF05Dp0", "0x14CB29.2F2B31Fp0", "0x178FEE.7792E44p0", "0x1AB312.E89CD0Dp0",
"0x1E4127.437732Bp0", "0x224868.979FC2Ep0", "0x26D8F9.4A204BEp0", "0x2C0521.B4A8E0Bp0",
"0x31E199.5F5A550p0", "0x3885D9.FA89D00p0", "0x400C7D.64D3386p0", "0x4893A8.361032Dp0",
"0x523D82.79EDAEFp0", "0x5D30C0.7DAB686p0", "0x69993D.D4F2D95p0", "0x77A8AD.02A7C71p0",
"0x0.000001Ep0", "0x0.0000022p0", "0x0.0000026p0", "0x0.000002Bp0",
"0x0.0000031p0", "0x0.0000038p0", "0x0.000003Fp0", "0x0.0000048p0",
"0x0.0000052p0", "0x0.000005Dp0", "0x0.0000069p0", "0x0.0000077p0",
"0x0.0000087p0", "0x0.0000099p0", "0x0.00000ADp0", "0x0.00000C4p0",
"0x0.00000DFp0", "0x0.00000FCp0", "0x0.000011Ep0", "0x0.0000144p0",
"0x0.0000170p0", "0x0.00001A1p0", "0x0.00001D8p0", "0x0.0000217p0",
"0x0.000025Ep0", "0x0.00002AFp0", "0x0.000030Bp0", "0x0.0000372p0",
"0x0.00003E8p0", "0x0.000046Dp0", "0x0.0000504p0", "0x0.00005AFp0",
"0x0.0000671p0", "0x0.000074Cp0", "0x0.0000845p0", "0x0.000095Fp0",
"0x0.0000A9Fp0", "0x0.0000C09p0", "0x0.0000DA3p0", "0x0.0000F74p0",
"0x0.0001183p0", "0x0.00013D8p0", "0x0.000167Cp0", "0x0.000197Bp0",
"0x0.0001CDFp0", "0x0.00020B7p0", "0x0.0002513p0", "0x0.0002A02p0",
"0x0.0002F9Ap0", "0x0.00035F1p0", "0x0.0003D20p0", "0x0.0004543p0",
"0x0.0004E7Cp0", "0x0.00058F0p0", "0x0.00064C7p0", "0x0.0007232p0",
"0x0.0008167p0", "0x0.00092A2p0", "0x0.000A628p0", "0x0.000BC48p0",
"0x0.000D55Ap0", "0x0.000F1C2p0", "0x0.00111F3p0", "0x0.001366Cp0",
"0x0.0015FC2p0", "0x0.0018E98p0", "0x0.001C3AAp0", "0x0.001FFCEp0",
"0x0.00243F3p0", "0x0.002912Bp0", "0x0.002E8ABp0", "0x0.0034BD2p0",
"0x0.003BC2Dp0", "0x0.0043B7Dp0", "0x0.004CBC1p0", "0x0.0056F3Ap0",
"0x0.0062878p0", "0x0.006FA5Fp0", "0x0.007E83Ap0", "0x0.008F5C0p0",
"0x0.00A2728p0", "0x0.00B813Bp0", "0x0.00D0963p0", "0x0.00EC5C1p0",
"0x0.010BD4Ap0", "0x0.012F7DEp0", "0x0.0157E6Bp0", "0x0.0185B0Fp0",
"0x0.01B993Fp0", "0x0.01F45F9p0", "0x0.0236FF5p0", "0x0.02827E0p0",
"0x0.02D80A0p0", "0x0.0338F9Fp0", "0x0.03A6D22p0", "0x0.04234A7p0",
"0x0.04B0556p0", "0x0.0550280p0", "0x0.0605424p0", "0x0.06D279Ap0",
"0x0.07BB040p0", "0x0.08C284Cp0", "0x0.09ED1B4p0", "0x0.0B3F736p0",
"0x0.0CBED86p0", "0x0.0E7149Cp0", "0x0.105D938p0", "0x0.128B697p0",
"0x0.150385Cp0", "0x0.17CFCC2p0", "0x0.1AFB718p0", "0x0.1E9328Bp0",
"0x0.22A5554p0", "0x0.2742456p0", "0x0.2C7C72Fp0", "0x0.3268CDBp0",
"0x0.391F0EEp0", "0x0.40BA188p0", "0x0.495860Dp0", "0x0.531C6C9p0",
"0x0.5E2D58Dp0", "0x0.6AB7782p0", "0x0.78ED03Ap0", "0x0.8906E49p0",
"0x0.9B4597Ep0", "0x0.AFF230Ap0", "0x0.C75F7CFp0", "0x0.E1EB512p0",
            };
            ap_ufixed<50,23> exp_x_msb_1 = exp_x_msb_1_table[x_msb_ind_1];

            ap_ufixed<100,21> y_lo = exp_x_msb_1 * exp_x_msb_2_3_4_lsb_m_1;
            ap_ufixed<48,21> y_lo_s = y_lo;
            ap_ufixed<50,23> y_l = y_lo_s + exp_x_msb_1;
            y = y_l;
        }
        y += delta;

            overf = 0;
            VITIS_LOOP_1608_14: for (int j = 46; j >= I_+22; j--) {
#pragma HLS unroll
 if (y[j])
                    overf = 1;
            }
            if (overf) {
                VITIS_LOOP_1614_15: for (int j = 46; j >= I_+22; j--) {
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_1618_16: for (int j = I_+21; j >= 0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }

        r = y;
    } else {
        const static int wf = 67;
        const static int we = 33;
        const static int w = 100;
        ap_fixed<w,we> x_l = x;


        ap_ufixed<65,33> y = 0;

        ap_fixed<6,6> x_l_int;
        x_l_int(5,0) = x_l(wf+5,wf);


        ap_ufixed<wf,0> x_l_fract;
        x_l_fract(wf-1,0) = x_l(wf-1,0);

        bool overf = 0;
        VITIS_LOOP_1642_17: for (int j = wf+5; j < w-1; j++){
#pragma HLS unroll
 if (x_l[w-1]!=x_l[j])
                overf = 1;
        }
        if (overf||(x_l_int>22)||((x_l_int==22)&&(x_l_fract>=ap_ufixed<wf,0>("0x0.2E42FEFA39EF35783p0")))) {
            if (!x_l[w-1]) {
                VITIS_LOOP_1649_18: for (int j = 0; j < 64; j++) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        } else {
            const static int g=4;
            const static int Maxprecision=69;
            ap_uint<8> x_msb_ind_1;
            x_msb_ind_1[7] = x_l[w-1];

            x_msb_ind_1(6,0) = x_l(wf+4,wf-2);
            ap_uint<8> x_msb_ind_2;
            x_msb_ind_2(7,0) = x_l(wf-3,wf-10);
            ap_uint<8> x_msb_ind_3;
            x_msb_ind_3(7,0) = x_l(wf-11,wf-18);
            ap_uint<8> x_msb_ind_4;
            x_msb_ind_4(7,0) = x_l(wf-19,wf-26);

            ap_uint<8> x_msb_ind_5;
            x_msb_ind_5(7,0) = x_l(wf-27,wf-34);

            ap_ufixed<8, -2> x_msb_2 = x_l;
            ap_ufixed<8,-10> x_msb_3 = x_l;
            ap_ufixed<8,-18> x_msb_4 = x_l;
            ap_ufixed<8,-26> x_msb_5 = x_l;
            ap_ufixed<9,-34> x_lsb = x_l;

            const static ap_ufixed<32,-37> f_x_msb_4_table[256] = {
"0x0.000000000000000000p0", "0x0.000000000000080000p0", "0x0.000000000000200000p0", "0x0.000000000000480000p0",
"0x0.000000000000800000p0", "0x0.000000000000C80000p0", "0x0.000000000001200000p0", "0x0.000000000001880000p0",
"0x0.000000000002000001p0", "0x0.000000000002880001p0", "0x0.000000000003200002p0", "0x0.000000000003C80003p0",
"0x0.000000000004800004p0", "0x0.000000000005480005p0", "0x0.000000000006200007p0", "0x0.000000000007080008p0",
"0x0.00000000000800000Ap0", "0x0.00000000000908000Cp0", "0x0.00000000000A20000Fp0", "0x0.00000000000B480011p0",
"0x0.00000000000C800014p0", "0x0.00000000000DC80018p0", "0x0.00000000000F20001Bp0", "0x0.00000000001088001Fp0",
"0x0.000000000012000024p0", "0x0.000000000013880028p0", "0x0.00000000001520002Dp0", "0x0.000000000016C80033p0",
"0x0.000000000018800039p0", "0x0.00000000001A48003Fp0", "0x0.00000000001C200046p0", "0x0.00000000001E08004Dp0",
"0x0.000000000020000055p0", "0x0.00000000002208005Dp0", "0x0.000000000024200066p0", "0x0.00000000002648006Fp0",
"0x0.000000000028800079p0", "0x0.00000000002AC80083p0", "0x0.00000000002D20008Ep0", "0x0.00000000002F88009Ap0",
"0x0.0000000000320000A6p0", "0x0.0000000000348800B3p0", "0x0.0000000000372000C0p0", "0x0.000000000039C800CFp0",
"0x0.00000000003C8000DDp0", "0x0.00000000003F4800EDp0", "0x0.0000000000422000FDp0", "0x0.00000000004508010Ep0",
"0x0.000000000048000120p0", "0x0.00000000004B080132p0", "0x0.00000000004E200145p0", "0x0.000000000051480159p0",
"0x0.00000000005480016Ep0", "0x0.000000000057C80183p0", "0x0.00000000005B20019Ap0", "0x0.00000000005E8801B1p0",
"0x0.0000000000620001C9p0", "0x0.0000000000658801E2p0", "0x0.0000000000692001FCp0", "0x0.00000000006CC80216p0",
"0x0.000000000070800232p0", "0x0.00000000007448024Fp0", "0x0.00000000007820026Cp0", "0x0.00000000007C08028Bp0",
"0x0.0000000000800002AAp0", "0x0.0000000000840802CBp0", "0x0.0000000000882002ECp0", "0x0.00000000008C48030Fp0",
"0x0.000000000090800332p0", "0x0.000000000094C80357p0", "0x0.00000000009920037Dp0", "0x0.00000000009D8803A4p0",
"0x0.0000000000A20003CCp0", "0x0.0000000000A68803F5p0", "0x0.0000000000AB20041Fp0", "0x0.0000000000AFC8044Ap0",
"0x0.0000000000B4800477p0", "0x0.0000000000B94804A4p0", "0x0.0000000000BE2004D3p0", "0x0.0000000000C3080503p0",
"0x0.0000000000C8000535p0", "0x0.0000000000CD080567p0", "0x0.0000000000D220059Bp0", "0x0.0000000000D74805D1p0",
"0x0.0000000000DC800607p0", "0x0.0000000000E1C8063Fp0", "0x0.0000000000E7200678p0", "0x0.0000000000EC8806B2p0",
"0x0.0000000000F20006EEp0", "0x0.0000000000F788072Bp0", "0x0.0000000000FD20076Ap0", "0x0.000000000102C807AAp0",
"0x0.0000000001088007EBp0", "0x0.00000000010E48082Ep0", "0x0.000000000114200872p0", "0x0.00000000011A0808B8p0",
"0x0.000000000120000900p0", "0x0.000000000126080948p0", "0x0.00000000012C200993p0", "0x0.0000000001324809DEp0",
"0x0.000000000138800A2Cp0", "0x0.00000000013EC80A7Bp0", "0x0.000000000145200ACBp0", "0x0.00000000014B880B1Dp0",
"0x0.000000000152000B71p0", "0x0.000000000158880BC6p0", "0x0.00000000015F200C1Dp0", "0x0.000000000165C80C76p0",
"0x0.00000000016C800CD0p0", "0x0.000000000173480D2Cp0", "0x0.00000000017A200D8Ap0", "0x0.000000000181080DE9p0",
"0x0.000000000188000E4Ap0", "0x0.00000000018F080EADp0", "0x0.000000000196200F12p0", "0x0.00000000019D480F78p0",
"0x0.0000000001A4800FE0p0", "0x0.0000000001ABC8104Ap0", "0x0.0000000001B32010B6p0", "0x0.0000000001BA881124p0",
"0x0.0000000001C2001194p0", "0x0.0000000001C9881205p0", "0x0.0000000001D1201278p0", "0x0.0000000001D8C812EEp0",
"0x0.0000000001E0801365p0", "0x0.0000000001E84813DEp0", "0x0.0000000001F0201459p0", "0x0.0000000001F80814D6p0",
"0x0.000000000200001555p0", "0x0.0000000002080815D6p0", "0x0.000000000210201659p0", "0x0.0000000002184816DEp0",
"0x0.000000000220801765p0", "0x0.000000000228C817EEp0", "0x0.000000000231201879p0", "0x0.000000000239881907p0",
"0x0.000000000242001996p0", "0x0.00000000024A881A28p0", "0x0.000000000253201ABBp0", "0x0.00000000025BC81B51p0",
"0x0.000000000264801BE9p0", "0x0.00000000026D481C84p0", "0x0.000000000276201D20p0", "0x0.00000000027F081DBFp0",
"0x0.000000000288001E60p0", "0x0.000000000291081F03p0", "0x0.00000000029A201FA8p0", "0x0.0000000002A3482050p0",
"0x0.0000000002AC8020FAp0", "0x0.0000000002B5C821A6p0", "0x0.0000000002BF202255p0", "0x0.0000000002C8882306p0",
"0x0.0000000002D20023B9p0", "0x0.0000000002DB88246Fp0", "0x0.0000000002E5202527p0", "0x0.0000000002EEC825E1p0",
"0x0.0000000002F880269Ep0", "0x0.00000000030248275Dp0", "0x0.00000000030C20281Fp0", "0x0.0000000003160828E3p0",
"0x0.0000000003200029AAp0", "0x0.00000000032A082A73p0", "0x0.000000000334202B3Fp0", "0x0.00000000033E482C0Dp0",
"0x0.000000000348802CDEp0", "0x0.000000000352C82DB2p0", "0x0.00000000035D202E88p0", "0x0.000000000367882F60p0",
"0x0.00000000037200303Cp0", "0x0.00000000037C883119p0", "0x0.0000000003872031FAp0", "0x0.000000000391C832DDp0",
"0x0.00000000039C8033C3p0", "0x0.0000000003A74834ABp0", "0x0.0000000003B2203596p0", "0x0.0000000003BD083684p0",
"0x0.0000000003C8003775p0", "0x0.0000000003D3083868p0", "0x0.0000000003DE20395Ep0", "0x0.0000000003E9483A57p0",
"0x0.0000000003F4803B53p0", "0x0.0000000003FFC83C52p0", "0x0.00000000040B203D53p0", "0x0.000000000416883E57p0",
"0x0.000000000422003F5Ep0", "0x0.00000000042D884068p0", "0x0.000000000439204175p0", "0x0.000000000444C84285p0",
"0x0.000000000450804397p0", "0x0.00000000045C4844ADp0", "0x0.0000000004682045C5p0", "0x0.0000000004740846E1p0",
"0x0.000000000480004800p0", "0x0.00000000048C084921p0", "0x0.000000000498204A46p0", "0x0.0000000004A4484B6Dp0",
"0x0.0000000004B0804C98p0", "0x0.0000000004BCC84DC5p0", "0x0.0000000004C9204EF6p0", "0x0.0000000004D588502Ap0",
"0x0.0000000004E2005161p0", "0x0.0000000004EE88529Bp0", "0x0.0000000004FB2053D8p0", "0x0.000000000507C85518p0",
"0x0.00000000051480565Cp0", "0x0.0000000005214857A3p0", "0x0.00000000052E2058EDp0", "0x0.00000000053B085A3Ap0",
"0x0.000000000548005B8Ap0", "0x0.000000000555085CDEp0", "0x0.000000000562205E35p0", "0x0.00000000056F485F8Fp0",
"0x0.00000000057C8060ECp0", "0x0.000000000589C8624Dp0", "0x0.0000000005972063B1p0", "0x0.0000000005A4886519p0",
"0x0.0000000005B2006684p0", "0x0.0000000005BF8867F2p0", "0x0.0000000005CD206963p0", "0x0.0000000005DAC86AD8p0",
"0x0.0000000005E8806C51p0", "0x0.0000000005F6486DCDp0", "0x0.000000000604206F4Cp0", "0x0.0000000006120870CFp0",
"0x0.000000000620007255p0", "0x0.00000000062E0873DFp0", "0x0.00000000063C20756Cp0", "0x0.00000000064A4876FDp0",
"0x0.000000000658807891p0", "0x0.000000000666C87A29p0", "0x0.000000000675207BC4p0", "0x0.000000000683887D64p0",
"0x0.000000000692007F06p0", "0x0.0000000006A08880ADp0", "0x0.0000000006AF208256p0", "0x0.0000000006BDC88404p0",
"0x0.0000000006CC8085B5p0", "0x0.0000000006DB48876Ap0", "0x0.0000000006EA208923p0", "0x0.0000000006F9088ADFp0",
"0x0.000000000708008CA0p0", "0x0.000000000717088E63p0", "0x0.00000000072620902Bp0", "0x0.0000000007354891F6p0",
"0x0.0000000007448093C6p0", "0x0.000000000753C89599p0", "0x0.000000000763209770p0", "0x0.00000000077288994Ap0",
"0x0.000000000782009B29p0", "0x0.000000000791889D0Bp0", "0x0.0000000007A1209EF2p0", "0x0.0000000007B0C8A0DCp0",
"0x0.0000000007C080A2CAp0", "0x0.0000000007D048A4BCp0", "0x0.0000000007E020A6B2p0", "0x0.0000000007F008A8ACp0",
            };
            ap_ufixed<32,-37> f_x_msb_4 = f_x_msb_4_table[x_msb_ind_4];

            const static ap_ufixed<16,-53> f_x_msb_5_table[256] = {
"0x0.000000000000000000p0", "0x0.000000000000000008p0", "0x0.000000000000000020p0", "0x0.000000000000000048p0",
"0x0.000000000000000080p0", "0x0.0000000000000000C8p0", "0x0.000000000000000120p0", "0x0.000000000000000188p0",
"0x0.000000000000000200p0", "0x0.000000000000000288p0", "0x0.000000000000000320p0", "0x0.0000000000000003C8p0",
"0x0.000000000000000480p0", "0x0.000000000000000548p0", "0x0.000000000000000620p0", "0x0.000000000000000708p0",
"0x0.000000000000000800p0", "0x0.000000000000000908p0", "0x0.000000000000000A20p0", "0x0.000000000000000B48p0",
"0x0.000000000000000C80p0", "0x0.000000000000000DC8p0", "0x0.000000000000000F20p0", "0x0.000000000000001088p0",
"0x0.000000000000001200p0", "0x0.000000000000001388p0", "0x0.000000000000001520p0", "0x0.0000000000000016C8p0",
"0x0.000000000000001880p0", "0x0.000000000000001A48p0", "0x0.000000000000001C20p0", "0x0.000000000000001E08p0",
"0x0.000000000000002000p0", "0x0.000000000000002208p0", "0x0.000000000000002420p0", "0x0.000000000000002648p0",
"0x0.000000000000002880p0", "0x0.000000000000002AC8p0", "0x0.000000000000002D20p0", "0x0.000000000000002F88p0",
"0x0.000000000000003200p0", "0x0.000000000000003488p0", "0x0.000000000000003720p0", "0x0.0000000000000039C8p0",
"0x0.000000000000003C80p0", "0x0.000000000000003F48p0", "0x0.000000000000004220p0", "0x0.000000000000004508p0",
"0x0.000000000000004800p0", "0x0.000000000000004B08p0", "0x0.000000000000004E20p0", "0x0.000000000000005148p0",
"0x0.000000000000005480p0", "0x0.0000000000000057C8p0", "0x0.000000000000005B20p0", "0x0.000000000000005E88p0",
"0x0.000000000000006200p0", "0x0.000000000000006588p0", "0x0.000000000000006920p0", "0x0.000000000000006CC8p0",
"0x0.000000000000007080p0", "0x0.000000000000007448p0", "0x0.000000000000007820p0", "0x0.000000000000007C08p0",
"0x0.000000000000008000p0", "0x0.000000000000008408p0", "0x0.000000000000008820p0", "0x0.000000000000008C48p0",
"0x0.000000000000009080p0", "0x0.0000000000000094C8p0", "0x0.000000000000009920p0", "0x0.000000000000009D88p0",
"0x0.00000000000000A200p0", "0x0.00000000000000A688p0", "0x0.00000000000000AB20p0", "0x0.00000000000000AFC8p0",
"0x0.00000000000000B480p0", "0x0.00000000000000B948p0", "0x0.00000000000000BE20p0", "0x0.00000000000000C308p0",
"0x0.00000000000000C800p0", "0x0.00000000000000CD08p0", "0x0.00000000000000D220p0", "0x0.00000000000000D748p0",
"0x0.00000000000000DC80p0", "0x0.00000000000000E1C8p0", "0x0.00000000000000E720p0", "0x0.00000000000000EC88p0",
"0x0.00000000000000F200p0", "0x0.00000000000000F788p0", "0x0.00000000000000FD20p0", "0x0.0000000000000102C8p0",
"0x0.000000000000010880p0", "0x0.000000000000010E48p0", "0x0.000000000000011420p0", "0x0.000000000000011A08p0",
"0x0.000000000000012000p0", "0x0.000000000000012608p0", "0x0.000000000000012C20p0", "0x0.000000000000013248p0",
"0x0.000000000000013880p0", "0x0.000000000000013EC8p0", "0x0.000000000000014520p0", "0x0.000000000000014B88p0",
"0x0.000000000000015200p0", "0x0.000000000000015888p0", "0x0.000000000000015F20p0", "0x0.0000000000000165C8p0",
"0x0.000000000000016C80p0", "0x0.000000000000017348p0", "0x0.000000000000017A20p0", "0x0.000000000000018108p0",
"0x0.000000000000018800p0", "0x0.000000000000018F08p0", "0x0.000000000000019620p0", "0x0.000000000000019D48p0",
"0x0.00000000000001A480p0", "0x0.00000000000001ABC8p0", "0x0.00000000000001B320p0", "0x0.00000000000001BA88p0",
"0x0.00000000000001C200p0", "0x0.00000000000001C988p0", "0x0.00000000000001D120p0", "0x0.00000000000001D8C8p0",
"0x0.00000000000001E080p0", "0x0.00000000000001E848p0", "0x0.00000000000001F020p0", "0x0.00000000000001F808p0",
"0x0.000000000000020000p0", "0x0.000000000000020808p0", "0x0.000000000000021020p0", "0x0.000000000000021848p0",
"0x0.000000000000022080p0", "0x0.0000000000000228C8p0", "0x0.000000000000023120p0", "0x0.000000000000023988p0",
"0x0.000000000000024200p0", "0x0.000000000000024A88p0", "0x0.000000000000025320p0", "0x0.000000000000025BC8p0",
"0x0.000000000000026480p0", "0x0.000000000000026D48p0", "0x0.000000000000027620p0", "0x0.000000000000027F08p0",
"0x0.000000000000028800p0", "0x0.000000000000029108p0", "0x0.000000000000029A20p0", "0x0.00000000000002A348p0",
"0x0.00000000000002AC80p0", "0x0.00000000000002B5C8p0", "0x0.00000000000002BF20p0", "0x0.00000000000002C888p0",
"0x0.00000000000002D200p0", "0x0.00000000000002DB88p0", "0x0.00000000000002E520p0", "0x0.00000000000002EEC8p0",
"0x0.00000000000002F880p0", "0x0.000000000000030248p0", "0x0.000000000000030C20p0", "0x0.000000000000031608p0",
"0x0.000000000000032000p0", "0x0.000000000000032A08p0", "0x0.000000000000033420p0", "0x0.000000000000033E48p0",
"0x0.000000000000034880p0", "0x0.0000000000000352C8p0", "0x0.000000000000035D20p0", "0x0.000000000000036788p0",
"0x0.000000000000037200p0", "0x0.000000000000037C88p0", "0x0.000000000000038720p0", "0x0.0000000000000391C8p0",
"0x0.000000000000039C80p0", "0x0.00000000000003A748p0", "0x0.00000000000003B220p0", "0x0.00000000000003BD08p0",
"0x0.00000000000003C800p0", "0x0.00000000000003D308p0", "0x0.00000000000003DE20p0", "0x0.00000000000003E948p0",
"0x0.00000000000003F480p0", "0x0.00000000000003FFC8p0", "0x0.000000000000040B20p0", "0x0.000000000000041688p0",
"0x0.000000000000042200p0", "0x0.000000000000042D88p0", "0x0.000000000000043920p0", "0x0.0000000000000444C8p0",
"0x0.000000000000045080p0", "0x0.000000000000045C48p0", "0x0.000000000000046820p0", "0x0.000000000000047408p0",
"0x0.000000000000048000p0", "0x0.000000000000048C08p0", "0x0.000000000000049820p0", "0x0.00000000000004A448p0",
"0x0.00000000000004B080p0", "0x0.00000000000004BCC8p0", "0x0.00000000000004C920p0", "0x0.00000000000004D588p0",
"0x0.00000000000004E200p0", "0x0.00000000000004EE88p0", "0x0.00000000000004FB20p0", "0x0.0000000000000507C8p0",
"0x0.000000000000051480p0", "0x0.000000000000052148p0", "0x0.000000000000052E20p0", "0x0.000000000000053B08p0",
"0x0.000000000000054800p0", "0x0.000000000000055508p0", "0x0.000000000000056220p0", "0x0.000000000000056F48p0",
"0x0.000000000000057C80p0", "0x0.0000000000000589C8p0", "0x0.000000000000059720p0", "0x0.00000000000005A488p0",
"0x0.00000000000005B200p0", "0x0.00000000000005BF88p0", "0x0.00000000000005CD20p0", "0x0.00000000000005DAC8p0",
"0x0.00000000000005E880p0", "0x0.00000000000005F648p0", "0x0.000000000000060420p0", "0x0.000000000000061208p0",
"0x0.000000000000062000p0", "0x0.000000000000062E08p0", "0x0.000000000000063C20p0", "0x0.000000000000064A48p0",
"0x0.000000000000065880p0", "0x0.0000000000000666C8p0", "0x0.000000000000067520p0", "0x0.000000000000068388p0",
"0x0.000000000000069200p0", "0x0.00000000000006A088p0", "0x0.00000000000006AF20p0", "0x0.00000000000006BDC8p0",
"0x0.00000000000006CC80p0", "0x0.00000000000006DB48p0", "0x0.00000000000006EA20p0", "0x0.00000000000006F908p0",
"0x0.000000000000070800p0", "0x0.000000000000071708p0", "0x0.000000000000072620p0", "0x0.000000000000073548p0",
"0x0.000000000000074480p0", "0x0.0000000000000753C8p0", "0x0.000000000000076320p0", "0x0.000000000000077288p0",
"0x0.000000000000078200p0", "0x0.000000000000079188p0", "0x0.00000000000007A120p0", "0x0.00000000000007B0C8p0",
"0x0.00000000000007C080p0", "0x0.00000000000007D048p0", "0x0.00000000000007E020p0", "0x0.00000000000007F008p0",
            };

            ap_ufixed<16,-53> f_x_msb_5 = f_x_msb_5_table[x_msb_ind_5];

            ap_ufixed<9,-60> f_x_msb_5_lsb = x_msb_5 * x_lsb;

            ap_ufixed<25,-26> x_msb_5_lsb = x_l;

            ap_ufixed<25,-44> f_x_msb_4_5_lsb = x_msb_5_lsb * x_msb_4;

            ap_ufixed<6,-37> f_x_msb_4_s = f_x_msb_4;
            ap_ufixed<6,-63> exp_x_msb_4_5_lsb_m_1_m1 = x_msb_5 * f_x_msb_4;

            ap_ufixed<10,-59> exp_x_msb_4_5_lsb_m_1_m2 = 0;
            exp_x_msb_4_5_lsb_m_1_m2(8,0) = f_x_msb_5_lsb(8,0);
            exp_x_msb_4_5_lsb_m_1_m2 = exp_x_msb_4_5_lsb_m_1_m1 + exp_x_msb_4_5_lsb_m_1_m2;

            ap_ufixed<17,-52> exp_x_msb_4_5_lsb_m_1_m3 = 0;
            exp_x_msb_4_5_lsb_m_1_m3(15,0) = f_x_msb_5(15,0);
            exp_x_msb_4_5_lsb_m_1_m3 = exp_x_msb_4_5_lsb_m_1_m2+exp_x_msb_4_5_lsb_m_1_m3;

            ap_ufixed<26,-43> exp_x_msb_4_5_lsb_m_1_m4 =0;
            exp_x_msb_4_5_lsb_m_1_m4(24,0) = f_x_msb_4_5_lsb(24,0);
            exp_x_msb_4_5_lsb_m_1_m4 = exp_x_msb_4_5_lsb_m_1_m4 + exp_x_msb_4_5_lsb_m_1_m3;

            ap_ufixed<33,-36> exp_x_msb_4_5_lsb_m_1_m5 = 0;
            exp_x_msb_4_5_lsb_m_1_m5(31,0) = f_x_msb_4(31,0);
            exp_x_msb_4_5_lsb_m_1_m5 = exp_x_msb_4_5_lsb_m_1_m5 + exp_x_msb_4_5_lsb_m_1_m4;

            ap_ufixed<wf-18,-18> x_msb_4_5_lsb = x_l;
            ap_ufixed<wf-17,-17> exp_x_msb_4_5_lsb_m_1_s = 0;
            exp_x_msb_4_5_lsb_m_1_s(30,0) = exp_x_msb_4_5_lsb_m_1_m5(32,2);
            exp_x_msb_4_5_lsb_m_1_s = exp_x_msb_4_5_lsb_m_1_s + x_msb_4_5_lsb;

            ap_ufixed<52,-17> exp_x_msb_4_5_lsb_m_1 = exp_x_msb_4_5_lsb_m_1_s;
            exp_x_msb_4_5_lsb_m_1(1,0) = exp_x_msb_4_5_lsb_m_1_m5(1,0);


            const static ap_ufixed<51,-21> f_x_msb_3_table[256] = {
"0x0", "0x0.00000000080000AAAAp0", "0x0.000000002000055556p0", "0x0.000000004800120003p0",
"0x0.0000000080002AAAB5p0", "0x0.00000000C80053556Fp0", "0x0.000000012000900036p0", "0x0.000000018800E4AB0Ep0",
"0x0.000000020001555600p0", "0x0.000000028801E60111p0", "0x0.0000000320029AAC4Bp0", "0x0.00000003C8037757B7p0",
"0x0.000000048004800360p0", "0x0.000000054805B8AF50p0", "0x0.000000062007255B96p0", "0x0.000000070808CA083Dp0",
"0x0.00000008000AAAB555p0", "0x0.00000009080CCB62EDp0", "0x0.0000000A200F301116p0", "0x0.0000000B4811DCBFE0p0",
"0x0.0000000C8014D56F60p0", "0x0.0000000DC8181E1FA7p0", "0x0.0000000F201BBAD0CBp0", "0x0.00000010881FAF82E1p0",
"0x0.000000120024003600p0", "0x0.000000138828B0EA3Fp0", "0x0.00000015202DC59FB6p0", "0x0.00000016C83342567Fp0",
"0x0.0000001880392B0EB5p0", "0x0.0000001A483F83C874p0", "0x0.0000001C20465083D6p0", "0x0.0000001E084D9540FBp0",
"0x0.000000200055560001p0", "0x0.00000022085D96C106p0", "0x0.0000002420665B842Cp0", "0x0.00000026486FA84995p0",
"0x0.000000288079811161p0", "0x0.0000002AC883E9DBB6p0", "0x0.0000002D208EE6A8B8p0", "0x0.0000002F889A7B788Cp0",
"0x0.0000003200A6AC4B58p0", "0x0.0000003488B37D2145p0", "0x0.0000003720C0F1FA7Ap0", "0x0.00000039C8CF0ED721p0",
"0x0.0000003C80DDD7B765p0", "0x0.0000003F48ED509B71p0", "0x0.0000004220FD7D8371p0", "0x0.00000045090E626F94p0",
"0x0.000000480120036008p0", "0x0.0000004B09326454FBp0", "0x0.0000004E2145894E9Fp0", "0x0.000000514959764D26p0",
"0x0.00000054816E2F50C1p0", "0x0.00000057C983B859A4p0", "0x0.0000005B219A156804p0", "0x0.0000005E89B14A7C16p0",
"0x0.0000006201C95B9611p0", "0x0.0000006589E24CB62Cp0", "0x0.0000006921FC21DCA0p0", "0x0.0000006CCA16DF09A6p0",
"0x0.000000708232883D78p0", "0x0.000000744A4F217853p0", "0x0.00000078226CAEBA73p0", "0x0.0000007C0A8B340414p0",
"0x0.0000008002AAB55577p0", "0x0.000000840ACB36AEDAp0", "0x0.0000008822ECBC107Dp0", "0x0.0000008C4B0F497AA3p0",
"0x0.000000908332E2ED8Ep0", "0x0.00000094CB578C6981p0", "0x0.00000099237D49EEC0p0", "0x0.0000009D8BA41F7D92p0",
"0x0.000000A203CC11163Dp0", "0x0.000000A68BF522B908p0", "0x0.000000AB241F58663Cp0", "0x0.000000AFCC4AB61E22p0",
"0x0.000000B484773FE105p0", "0x0.000000B94CA4F9AF31p0", "0x0.000000BE24D3E788F1p0", "0x0.000000C30D040D6E94p0",
"0x0.000000C805356F6068p0", "0x0.000000CD0D68115EBCp0", "0x0.000000D2259BF769E1p0", "0x0.000000D74DD1258228p0",
"0x0.000000DC86079FA7E4p0", "0x0.000000E1CE3F69DB69p0", "0x0.000000E72678881D0Bp0", "0x0.000000EC8EB2FE6D1Fp0",
"0x0.000000F206EED0CBFDp0", "0x0.000000F78F2C0339FAp0", "0x0.000000FD276A99B771p0", "0x0.00000102CFAA9844BBp0",
"0x0.0000010887EC02E231p0", "0x0.0000010E502EDD9030p0", "0x0.0000011428732C4F14p0", "0x0.0000011A10B8F31F3Bp0",
"0x0.000001200900360103p0", "0x0.000001261148F8F4CBp0", "0x0.0000012C29933FFAF5p0", "0x0.0000013251DF0F13E1p0",
"0x0.000001388A2C6A3FF3p0", "0x0.0000013ED27B557F8Dp0", "0x0.000001452ACBD4D315p0", "0x0.0000014B931DEC3AEFp0",
"0x0.000001520B719FB782p0", "0x0.0000015893C6F34937p0", "0x0.0000015F2C1DEAF074p0", "0x0.00000165D4768AADA5p0",
"0x0.0000016C8CD0D68133p0", "0x0.00000173552CD26B89p0", "0x0.0000017A2D8A826D16p0", "0x0.0000018115E9EA8645p0",
"0x0.000001880E4B0EB785p0", "0x0.0000018F16ADF30147p0", "0x0.000001962F129B63FAp0", "0x0.0000019D57790BE010p0",
"0x0.000001A48FE14875FBp0", "0x0.000001ABD84B552630p0", "0x0.000001B330B735F122p0", "0x0.000001BA9924EED748p0",
"0x0.000001C2119483D917p0", "0x0.000001C99A05F8F707p0", "0x0.000001D13279523191p0", "0x0.000001D8DAEE93892Ep0",
"0x0.000001E09365C0FE59p0", "0x0.000001E85BDEDE918Dp0", "0x0.000001F03459F04347p0", "0x0.000001F81CD6FA1405p0",
"0x0.000002001556000444p0", "0x0.000002081DD7061485p0", "0x0.00000210365A104547p0", "0x0.000002185EDF22970Dp0",
"0x0.000002209766410A5Ap0", "0x0.00000228DFEF6F9FAFp0", "0x0.00000231387AB25793p0", "0x0.00000239A1080D328Ap0",
"0x0.00000242199784311Cp0", "0x0.0000024AA2291B53CFp0", "0x0.000002533ABCD69B2Dp0", "0x0.0000025BE352BA07BEp0",
"0x0.000002649BEAC99A0Dp0", "0x0.0000026D64850952A7p0", "0x0.000002763D217D3216p0", "0x0.0000027F25C02938EAp0",
"0x0.000002881E611167B0p0", "0x0.00000291270439BEF8p0", "0x0.0000029A3FA9A63F53p0", "0x0.000002A368515AE951p0",
"0x0.000002ACA0FB5BBD86p0", "0x0.000002B5E9A7ACBC86p0", "0x0.000002BF425651E6E4p0", "0x0.000002C8AB074F3D36p0",
"0x0.000002D223BAA8C013p0", "0x0.000002DBAC70627012p0", "0x0.000002E54528804DCDp0", "0x0.000002EEEDE30659DBp0",
"0x0.000002F8A69FF894D9p0", "0x0.000003026F5F5AFF61p0", "0x0.0000030C4821319A10p0", "0x0.0000031630E5806584p0",
"0x0.0000032029AC4B625Bp0", "0x0.0000032A3275969134p0", "0x0.000003344B4165F2B1p0", "0x0.0000033E740FBD8772p0",
"0x0.00000348ACE0A1501Bp0", "0x0.00000352F5B4154D4Fp0", "0x0.0000035D4E8A1D7FB2p0", "0x0.00000367B762BDE7EAp0",
"0x0.00000372303DFA869Ep0", "0x0.0000037CB91BD75C75p0", "0x0.0000038751FC586A18p0", "0x0.00000391FADF81B02Fp0",
"0x0.0000039CB3C5572F67p0", "0x0.000003A77CADDCE86Ap0", "0x0.000003B2559916DBE4p0", "0x0.000003BD3E87090A84p0",
"0x0.000003C83777B774F8p0", "0x0.000003D3406B261BF0p0", "0x0.000003DE596159001Cp0", "0x0.000003E9825A54222Dp0",
"0x0.000003F4BB561B82D7p0", "0x0.000004000454B322CCp0", "0x0.0000040B5D561F02C2p0", "0x0.00000416C65A63236Ep0",
"0x0.000004223F61838586p0", "0x0.0000042DC86B8429C2p0", "0x0.0000043961786910DBp0", "0x0.000004450A88363B8Ap0",
"0x0.00000450C39AEFAA8Ap0", "0x0.0000045C8CB0995E96p0", "0x0.0000046865C937586Bp0", "0x0.000004744EE4CD98C6p0",
"0x0.000004804803602067p0", "0x0.0000048C5124F2F00Cp0", "0x0.000004986A498A0876p0", "0x0.000004A49371296A67p0",
"0x0.000004B0CC9BD516A1p0", "0x0.000004BD15C9910DE8p0", "0x0.000004C96EFA615101p0", "0x0.000004D5D82E49E0B0p0",
"0x0.000004E251654EBDBDp0", "0x0.000004EEDA9F73E8F0p0", "0x0.000004FB73DCBD6310p0", "0x0.000005081D1D2F2CE7p0",
"0x0.00000514D660CD4740p0", "0x0.000005219FA79BB2E7p0", "0x0.0000052E78F19E70A8p0", "0x0.0000053B623ED98150p0",
"0x0.000005485B8F50E5AFp0", "0x0.0000055564E3089E93p0", "0x0.000005627E3A04ACCEp0", "0x0.0000056FA794491131p0",
"0x0.0000057CE0F1D9CC8Ep0", "0x0.0000058A2A52BADFBAp0", "0x0.0000059783B6F04B88p0", "0x0.000005A4ED1E7E10CFp0",
"0x0.000005B26689683064p0", "0x0.000005BFEFF7B2AB20p0", "0x0.000005CD89696181DBp0", "0x0.000005DB32DE78B56Fp0",
"0x0.000005E8EC56FC46B6p0", "0x0.000005F6B5D2F0368Cp0", "0x0.000006048F525885CDp0", "0x0.0000061278D5393558p0",
"0x0.00000620725B96460Ap0", "0x0.0000062E7BE573B8C3p0", "0x0.0000063C9572D58E64p0", "0x0.0000064ABF03BFC7CEp0",
"0x0.00000658F8983665E5p0", "0x0.0000066742303D698Bp0", "0x0.000006759BCBD8D3A5p0", "0x0.00000684056B0CA519p0",
"0x0.000006927F0DDCDECEp0", "0x0.000006A108B44D81AAp0", "0x0.000006AFA25E628E98p0", "0x0.000006BE4C0C20067Fp0",
"0x0.000006CD05BD89EA4Bp0", "0x0.000006DBCF72A43AE8p0", "0x0.000006EAA92B72F942p0", "0x0.000006F992E7FA2646p0",
"0x0.000007088CA83DC2E4p0", "0x0.00000717966C41D00Ap0", "0x0.00000726B0340A4EAAp0", "0x0.00000735D9FF9B3FB6p0",
"0x0.0000074513CEF8A41Ep0", "0x0.000007545DA2267CD9p0", "0x0.00000763B77928CAD9p0", "0x0.000007732154038F14p0",
"0x0.000007829B32BACA82p0", "0x0.000007922515527E1Ap0", "0x0.000007A1BEFBCEAAD4p0", "0x0.000007B168E63351AAp0",
"0x0.000007C122D4847397p0", "0x0.000007D0ECC6C61195p0", "0x0.000007E0C6BCFC2CA3p0", "0x0.000007F0B0B72AC5BEp0",
            };
            ap_ufixed<51,-21> f_x_msb_3 = f_x_msb_3_table[x_msb_ind_3];
            ap_ufixed<62,-10> exp_x_msb_3_m_1 = 0;
            exp_x_msb_3_m_1(61,54) = x_msb_3(7,0);
            exp_x_msb_3_m_1(50, 0) = f_x_msb_3(50,0);

            ap_ufixed<50,-10> exp_x_msb_3_m_1_s = exp_x_msb_3_m_1;

            ap_ufixed<101,-27> f_x_msb_3_4_5_lsb = exp_x_msb_3_m_1_s * exp_x_msb_4_5_lsb_m_1;
            ap_ufixed<45,-27> f_x_msb_3_4_5_lsb_s = f_x_msb_3_4_5_lsb;
            ap_ufixed<63, -9> exp_x_msb_3_4_5_lsb_m_1 = f_x_msb_3_4_5_lsb_s + exp_x_msb_3_m_1 + exp_x_msb_4_5_lsb_m_1;


            const static ap_ufixed<64,-4> f_x_msb_2_table[256] = {
"0x0.0p0", "0x0.00000800AAB555DDEp0", "0x0.00002005560011127p0", "0x0.00004812036081A9Cp0",
"0x0.0000802AB55777D28p0", "0x0.0000C8536F6684062p0", "0x0.0001209036103740Dp0", "0x0.000188E50ED8634A0p0",
"0x0.0002015600445B0C3p0", "0x0.000289E711DB32FD7p0", "0x0.0003229C4C260197Ep0", "0x0.0003CB79B8B01FE26p0",
"0x0.0004848362076A08Dp0", "0x0.00054DBD53BC80058p0", "0x0.0006272B9A630659Dp0", "0x0.000710D24391E6D7Ap0",
"0x0.00080AB55DE3917ABp0", "0x0.000914D8F8F63D524p0", "0x0.000A2F41256C297AFp0", "0x0.000B59F1F4EBDE291p0",
"0x0.000C94EF7A206DC2Dp0", "0x0.000DE03DC8B9B60B1p0", "0x0.000F3BE0F56CA15C4p0", "0x0.0010A7DD15F367F40p0",
"0x0.00122436410DD14E5p0", "0x0.0013B0F08E817591Ep0", "0x0.00154E101719FF0C5p0", "0x0.0016FB98F4A96BBEFp0",
"0x0.0018B98F42084EFBDp0", "0x0.001A87F71B1613137p0", "0x0.001C66D49CB93B127p0", "0x0.001E562BE4DFA4904p0",
"0x0.00205601127EC98E0p0", "0x0.00226658459402659p0", "0x0.002487359F24C7C99p0", "0x0.0026B89D413EF4D5Ep0",
"0x0.0028FA934EF909304p0", "0x0.002B4D1BEC726B39Cp0", "0x0.002DB03B3ED3AA50Ep0", "0x0.003023F56C4EC123Fp0",
"0x0.0032A84E9C1F58145p0", "0x0.00353D4AF68B07AA1p0", "0x0.0037E2EEA4E19B185p0", "0x0.003A993DD17D52D25p0",
"0x0.003D603CA7C32730Fp0", "0x0.004037EF54230B293p0", "0x0.0043205A04182F12Fp0", "0x0.00461980E62943810p0",
"0x0.0049236829E8BC292p0", "0x0.004C3E13FFF512DD8p0", "0x0.004F698899F90A966p0", "0x0.0052A5CA2AABF28D0p0",
"0x0.0055F2DCE5D1E966Ep0", "0x0.005950C5003C20723p0", "0x0.005CBF86AFC91EF2Bp0", "0x0.00603F262B65057FCp0",
"0x0.0063CFA7AB09D1732p0", "0x0.0067710F67BFA0687p0", "0x0.006B23619B9CF3CDEp0", "0x0.006EE6A281C6F4857p0",
"0x0.0072BAD65671B6977p0", "0x0.0076A00156E07CF57p0", "0x0.007A9627C165FD4EDp0", "0x0.007E9D4DD564A3F5Ep0",
"0x0.0082B577D34ED7D5Bp0", "0x0.0086DEA9FCA73E799p0", "0x0.008B18E8940100253p0", "0x0.008F6437DD000BFDAp0",
"0x0.0093C09C1C595C43Ep0", "0x0.00982E1997D33A9FCp0", "0x0.009CACB49645847CCp0", "0x0.00A13C715F99EF773p0",
"0x0.00A5DD543CCC4DDAFp0", "0x0.00AA8F6177EAD3336p0", "0x0.00AF529D5C1658EBCp0", "0x0.00B4270C3582A301Dp0",
"0x0.00B90CB25176A4C8Bp0", "0x0.00BE0393FE4CC5BD7p0", "0x0.00C30BB58B73266CAp0", "0x0.00C8251B496BE5696p0",
"0x0.00CD4FC989CD64555p0", "0x0.00D28BC49F428CFA3p0", "0x0.00D7D910DD8B16743p0", "0x0.00DD37B2997BCA6E6p0",
"0x0.00E2A7AE28FECA6FBp0", "0x0.00E82907E313D5399p0", "0x0.00EDBBC41FD08C383p0", "0x0.00F35FE73860B9038p0",
"0x0.00F91575870692F24p0", "0x0.00FEDC73671B04BDFp0", "0x0.0104B4E5350DF2386p0", "0x0.010A9ECF4E667E12Dp0",
"0x0.01109A3611C34FB64p0", "0x0.0116A71DDEDAD92D8p0", "0x0.011CC58B167B9D206p0", "0x0.0122F5821A8C74E0Dp0",
"0x0.012937074E0CD6893p0", "0x0.012F8A1F15151B2C6p0", "0x0.0135EECDD4D6C5172p0", "0x0.013C6517F39CC6233p0",
"0x0.0142ED01D8CBC61C4p0", "0x0.0149868FECE26935Dp0", "0x0.015031C6997996937p0", "0x0.0156EEAA4944BEE23p0",
"0x0.015DBD3F68122303Ep0", "0x0.01649D8A62CB1ACBEp0", "0x0.016B8F8FA7745BCDBp0", "0x0.01729353A52E403D8p0",
"0x0.0179A8DACC350DE1Dp0", "0x0.0180D0298DE13D179p0", "0x0.018809445CA7BFE78p0", "0x0.018F542FAC1A492D6p0",
"0x0.0196B0EFF0E793D15p0", "0x0.019E1F89A0DBAA128p0", "0x0.01A5A00132E02CE42p0", "0x0.01AD325B1EFC9B5BCp0",
"0x0.01B4D69BDE569A322p0", "0x0.01BC8CC7EB323B553p0", "0x0.01C454E3C0F2458C8p0", "0x0.01CC2EF3DC187C2F6p0",
"0x0.01D41AFCBA45E6ED2p0", "0x0.01DC1902DA3B19A6Dp0", "0x0.01E4290ABBD87C5BCp0", "0x0.01EC4B18E01E9326Fp0",
"0x0.01F47F31C92E464FCp0", "0x0.01FCC559FA492A6B6p0", "0x0.02051D95F7D1C8917p0", "0x0.020D87EA474BE6A1Cp0",
"0x0.0216045B6F5CCF9CEp0", "0x0.021E92EDF7CB9C0E4p0", "0x0.022733A669817A88Ap0", "0x0.022FE6894E89F834Cp0",
"0x0.0238AB9B321349722p0", "0x0.024182E0A06E9289Bp0", "0x0.024A6C5E271030733p0", "0x0.02536818549001AC1p0",
"0x0.025C7613B8A9AF215p0", "0x0.02659654E43CF52B1p0", "0x0.026EC8E0694DEC9A9p0", "0x0.02780DBADB0553DA6p0",
"0x0.028164E8CDB0D8211p0", "0x0.028ACE6ED6C35EB5Fp0", "0x0.02944A518CD54E484p0", "0x0.029DD89587A4D858Dp0",
"0x0.02A7793F601642B5Dp0", "0x0.02B12C53B03431090p0", "0x0.02BAF1D7132FEE788p0", "0x0.02C4C9CE2561B759Fp0",
"0x0.02CEB43D844902F7Ap0", "0x0.02D8B129CE8CCD68Fp0", "0x0.02E2C097A3FBE17C9p0", "0x0.02ECE28BA58D22B56p0",
"0x0.02F7170A755FD759Ep0", "0x0.03015E18B6BBF2966p0", "0x0.030BB7BB0E125EB13p0", "0x0.031623F620FD4751Ep0",
"0x0.0320A2CE964063DACp0", "0x0.032B344915C941D54p0", "0x0.0335D86A48AF8F70Cp0", "0x0.03408F36D93566140p0",
"0x0.034B58B372C795013p0", "0x0.035634E4C1FDEC0D0p0", "0x0.036123CF749B8667Cp0", "0x0.036C2578398F157A0p0",
"0x0.037739E3C0F32BD30p0", "0x0.03826116BC0E882ACp0", "0x0.038D9B15DD5460763p0", "0x0.0398E7E5D864AD0E9p0",
"0x0.03A4478B620C73EB5p0", "0x0.03AFBA0B304613EEDp0", "0x0.03BB3F69FA3990464p0", "0x0.03C6D7AC783CDBDBFp0",
"0x0.03D282D763D424DCDp0", "0x0.03DE40EF77B220509p0", "0x0.03EA11F96FB855C4Fp0", "0x0.03F5F5FA08F76B0BBp0",
"0x0.0401ECF601AF700BDp0", "0x0.040DF6F219502AA55p0", "0x0.041A13F3107962A88p0", "0x0.042643FDA8FB2DDFBp0",
"0x0.04328716A5D63C2C4p0", "0x0.043EDD42CB3C23B6Dp0", "0x0.044B4686DE8FAD325p0", "0x0.0457C2E7A66520322p0",
"0x0.04645269EA828F932p0", "0x0.0470F51273E025F89p0", "0x0.047DAAE60CA8725B3p0", "0x0.048A73E98038B4ABFp0",
"0x0.049750219B212A8A0p0", "0x0.04A43F932B255C0B7p0", "0x0.04B14242FF3C689A0p0", "0x0.04BE5835E79153E1Dp0",
"0x0.04CB8170B58352D4Ep0", "0x0.04D8BDF83BA618C04p0", "0x0.04E60DD14DC22475Ep0", "0x0.04F37100C0D50D88Ep0",
"0x0.0500E78B6B11D19D6p0", "0x0.050E717623E121CBAp0", "0x0.051C0EC5C3E1B016Cp0", "0x0.0529BF7F24E87CF6Ap0",
"0x0.053783A7220124F51p0", "0x0.05455B42976E2E5EAp0", "0x0.0553465662A95706Bp0", "0x0.056144E76263E21F4p0",
"0x0.056F56FA7686E623Ep0", "0x0.057D7C9480339AD83p0", "0x0.058BB5BA61C3A75A3p0", "0x0.059A0270FEC97047Ap0",
"0x0.05A862BD3C1065F74p0", "0x0.05B6D6A3FF9D52C58p0", "0x0.05C55E2A30AEA974Ep0", "0x0.05D3F954B7BCD3A1Bp0",
"0x0.05E2A8287E7A8049Ep0", "0x0.05F16AAA6FD4F267Bp0", "0x0.060040DF77F44FA13p0", "0x0.060F2ACC843BEF0A0p0",
"0x0.061E2876834AA7FA4p0", "0x0.062D39E264FB20F7Ep0", "0x0.063C5F151A641EB4Cp0", "0x0.064B981395D8D31FEp0",
"0x0.065AE4E2CAE92C8AAp0", "0x0.066A4587AE6224E1Cp0", "0x0.0679BA07364E10FA3p0", "0x0.0689426659F4EFF1Bp0",
"0x0.0698DEAA11DCBAA37p0", "0x0.06A88ED757C9B3304p0", "0x0.06B852F326BEB49B0p0", "0x0.06C82B027AFD8278Ap0",
"0x0.06D8170A520718B46p0", "0x0.06E8170FAA9BFB67Ep0", "0x0.06F82B1784BC86C72p0", "0x0.07085326E1A93F207p0",
"0x0.07188F42C3E320F0Bp0", "0x0.0728DF702F2BF10B2p0", "0x0.073943B428868CD5Ap0", "0x0.0749BC13B6373A98Fp0",
"0x0.075A4893DFC3F9E4Cp0", "0x0.076AE939ADF4D4083p0", "0x0.077B9E0A2AD42C9E8p0", "0x0.078C670A61AF122F4p0",
"0x0.079D443F5F158EE3Ap0", "0x0.07AE35AE30DAF94F1p0", "0x0.07BF3B5BE616454CBp0", "0x0.07D0554D8F2254F0Cp0",
"0x0.07E183883D9E498E2p0", "0x0.07F2C611046DD4D06p0", "0x0.08041CECF7B989EA2p0", "0x0.081588212CEF2ED73p0",
"0x0.082707B2BAC20DB40p0", "0x0.08389BA6B92B46284p0", "0x0.084A4402416A1EE6Fp0", "0x0.085C00CA6E045741Fp0",
"0x0.086DD2045AC678D2Bp0", "0x0.087FB7B524C42936Cp0", "0x0.0891B1E1EA587BE12p0", "0x0.08A3C08FCB2643FFEp0",
            };
            ap_ufixed<64,-4> f_x_msb_2 = f_x_msb_2_table[x_msb_ind_2];
            ap_ufixed< 6,-4> f_x_msb_2_h;
            f_x_msb_2_h(5,0) = f_x_msb_2(63,58);
            ap_ufixed< 9,-1> exp_x_msb_2_m_1_h = f_x_msb_2_h + x_msb_2;
            ap_ufixed<67,-1> exp_x_msb_2_m_1;
            exp_x_msb_2_m_1(66,58) = exp_x_msb_2_m_1_h(8,0);
            exp_x_msb_2_m_1(57, 0) = f_x_msb_2(57,0);

            ap_ufixed<130,-10> f_x_msb_2_3_4_5_lsb = exp_x_msb_2_m_1 * exp_x_msb_3_4_5_lsb_m_1;
            ap_ufixed<62,-10> f_x_msb_2_3_4_5_lsb_s = f_x_msb_2_3_4_5_lsb;
            ap_ufixed<72,0> exp_x_msb_2_3_4_5_lsb_m_1 = f_x_msb_2_3_4_5_lsb_s + exp_x_msb_2_m_1 + exp_x_msb_3_4_5_lsb_m_1;

            const static ap_ufixed<68,32> exp_x_msb_1_table[256] = {
"0x1.000000000p0", "0x1.48B5E3C3Ep0", "0x1.A61298E1Ep0", "0x2.1DF3B68CFp0",
"0x2.B7E151628p0", "0x3.7D871DB61p0", "0x4.7B4FF993Fp0", "0x5.C12DA416Ep0",
"0x7.63992E353p0", "0x9.7CDC417A3p0", "0xC.2EB7EC98Fp0", "0xF.A48385EDFp0",
"0x14.15E5BF6FBp0", "0x19.CA53B7811p0", "0x21.1D8E4272Dp0", "0x2A.8565A144Cp0",
"0x36.99205C4E7p0", "0x46.1AFC4DB59p0", "0x5A.0462B7877p0", "0x73.9593ABB7Dp0",
"0x94.69C4CB819p0", "0xBE.90F6F83E9p0", "0xF4.B122790DDp0", "0x13A.30CF1CCBBp0",
"0x193.6DC5690C0p0", "0x206.03487A3B1p0", "0x299.2442102D9p0", "0x356.0F0B0F980p0",
"0x448.A216ABB76p0", "0x580.1AD754FA3p0", "0x710.0ADBAC7DAp0", "0x911.9289C3923p0",
"0xBA4.F53EA3863p0", "0xEF3.A035D5798p0", "0x1332.C4D2B7C4Ap0", "0x18A6.B027DA0A7p0",
"0x1FA7.157C470F8p0", "0x28A4.90D2CCEF1p0", "0x342F.BA11823B8p0", "0x4302.3A933EE5Cp0",
"0x560A.773E54157p0", "0x6E7A.8ABB4A83Cp0", "0x8DDB.80AF4269Dp0", "0xB626.0748BAEC7p0",
"0xE9E2.2447727BFp0", "0x12C4F.EB75B2AB0p0", "0x1819B.C560F6113p0", "0x1EF21.8F1B001A4p0",
"0x27BC2.CA9A6F934p0", "0x33055.49F35D91Fp0", "0x41831.49596E996p0", "0x541E7.E56949D58p0",
"0x6C02D.645AB2554p0", "0x8AB06.0A3EE9FB1p0", "0xB2148.5EAE56C5Bp0", "0xE4A8D.2881EDBE8p0",
"0x1259AC.48BF05D6Ep0", "0x178FEE.7792E44B3p0", "0x1E4127.437732B71p0", "0x26D8F9.4A204BEA5p0",
"0x31E199.5F5A550DDp0", "0x400C7D.64D3386CBp0", "0x523D82.79EDAEF9Cp0", "0x69993D.D4F2D9524p0",
"0x87975E.854001024p0", "0xAE1A47.C38A42CD0p0", "0xDF8D5F.6DCFE5CEAp0", "0x11F0BF8.1E99FDEB6p0",
"0x1709348.C0EA4F8CEp0", "0x1D94295.464477ACCp0", "0x25FAD90.65C78E342p0", "0x30C4623.616ED2BE2p0",
"0x3E9E441.232817A61p0", "0x506744D.3B342FC94p0", "0x673D70B.C00F1F76Dp0", "0x849012B.C127FC962p0",
"0xAA36C7C.F69370B94p0", "0xDA8F202.DD9ACE661p0", "0x118A2AAE.0AA05236Bp0", "0x16857CFA.1AA8A5555p0",
"0x1CEB088B.68E804021p0", "0x2521AEDA.32CD52BE5p0", "0x2FAD89E1.79BAB8EADp0", "0x3D3838C6.BE0F13F06p0",
"0x4E9B87F6.7BB3F5597p0", "0x64EF201B.01109A4A5p0", "0x819A1801.9394C0D96p0", "0xA6698403.CF5D9E663p0",
"0xD5AD6DCE.21AFFC0DDp0", "0x1125E066B.0B19418CCp0", "0x1604B68CF.05F65FAA9p0", "0x1C45AED0A.D0C934CDCp0",
"0x244D5E676.3FB814AF0p0", "0x2E9CEBF49.9C21839C7p0", "0x3BDA2CBD0.9F5AC2146p0", "0x4CDA0FD41.989F004E7p0",
"0x62ADFED51.D7EDCCDE6p0", "0x7EB50B520.76F91D6E8p0", "0xA2B1FD3D9.A57B6C33Cp0", "0xD0E7A50F4.EF0D7447Fp0",
"0x10C3D39209.62C88AAFBp0", "0x1586D0722B.3EEB27301p0", "0x1BA4068AAC.2B6E3EE34p0", "0x237DCBF1E5.709A9F9C1p0",
"0x2D9264D2D4.D6B94153Bp0", "0x3A83F23B18.FE5BD524Ap0", "0x4B22A1B5C3.27A2FD85Ap0", "0x6079C1866C.71A93951Dp0",
"0x7BE08BDFD9.CC72249ABp0", "0x9F0FB7309C.B446D3919p0", "0xCC3D265776.C3D25779Ep0", "0x1063F7612B0.C0831CA6Cp0",
"0x150BBA37963.79A4FB6ADp0", "0x1B05FA9B62E.737D935B8p0", "0x22B2DC5C41D.AD89559EBp0", "0x2C8DD1AB28B.404414BE7p0",
"0x39355C8C638.0AC5631B1p0", "0x49750434675.301B8D0E7p0", "0x5E521E7A16E.51F9CD3C2p0", "0x791C3B06F8B.EA2DEC48Cp0",
"0x9B823857614.764F43E20p0", "0xC7AD559D438.E7C270C30p0", "0x10063F4E687B.A1A43A35Bp0", "0x149363C905BA.3641D0164p0",
"0x1A6B765D8CDF.6CDBF1C63p0", "0x21EC75240E66.E2891CE63p0", "0x2B8F1073A6AF.BA219DB61p0", "0x37EE3FFC0063.E360F931Fp0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000001p0", "0x0.000000001p0", "0x0.000000002p0",
"0x0.000000002p0", "0x0.000000003p0", "0x0.000000004p0", "0x0.000000005p0",
"0x0.000000007p0", "0x0.000000009p0", "0x0.00000000Bp0", "0x0.00000000Ep0",
"0x0.000000013p0", "0x0.000000018p0", "0x0.00000001Fp0", "0x0.000000028p0",
"0x0.000000034p0", "0x0.000000042p0", "0x0.000000055p0", "0x0.00000006Ep0",
"0x0.00000008Dp0", "0x0.0000000B5p0", "0x0.0000000E9p0", "0x0.00000012Bp0",
"0x0.000000181p0", "0x0.0000001EEp0", "0x0.00000027Ap0", "0x0.00000032Fp0",
"0x0.000000416p0", "0x0.00000053Fp0", "0x0.0000006BDp0", "0x0.0000008A7p0",
"0x0.000000B1Cp0", "0x0.000000E44p0", "0x0.000001252p0", "0x0.000001786p0",
"0x0.000001E35p0", "0x0.0000026C9p0", "0x0.0000031CEp0", "0x0.000003FF3p0",
"0x0.00000521Dp0", "0x0.000006970p0", "0x0.000008762p0", "0x0.00000ADD6p0",
"0x0.00000DF36p0", "0x0.000011E9Cp0", "0x0.000017003p0", "0x0.00001D88Ap0",
"0x0.000025EC0p0", "0x0.000030B15p0", "0x0.00003E85Dp0", "0x0.00005047Ep0",
"0x0.000067153p0", "0x0.0000845C6p0", "0x0.0000A9F46p0", "0x0.0000DA39Ep0",
"0x0.000118354p0", "0x0.000167CB5p0", "0x0.0001CDFC2p0", "0x0.000251334p0",
"0x0.0002F9AF3p0", "0x0.0003D205Ap0", "0x0.0004E7CE2p0", "0x0.00064C7C6p0",
"0x0.000816791p0", "0x0.000A628A3p0", "0x0.000D55A1Fp0", "0x0.00111F30Fp0",
"0x0.0015FC210p0", "0x0.001C3AA91p0", "0x0.00243F374p0", "0x0.002E8ABFCp0",
"0x0.003BC2D73p0", "0x0.004CBC19Ap0", "0x0.006287862p0", "0x0.007E83A56p0",
"0x0.00A2728F8p0", "0x0.00D096336p0", "0x0.010BD4A5Ap0", "0x0.0157E6BFEp0",
"0x0.01B993FE0p0", "0x0.0236FF5BFp0", "0x0.02D80A08Dp0", "0x0.03A6D2222p0",
"0x0.04B0556E0p0", "0x0.0605424D5p0", "0x0.07BB04063p0", "0x0.09ED1B429p0",
"0x0.0CBED8666p0", "0x0.105D93892p0", "0x0.150385C09p0", "0x0.1AFB718E8p0",
"0x0.22A555477p0", "0x0.2C7C72FC0p0", "0x0.391F0EE49p0", "0x0.495860DCAp0",
"0x0.5E2D58D8Bp0", "0x0.78ED03AFBp0", "0x0.9B4597E37p0", "0x0.C75F7CF56p0",
            };
            ap_ufixed<68,32> exp_x_msb_1 = exp_x_msb_1_table[x_msb_ind_1];
            ap_ufixed<140,32> y_lo = exp_x_msb_1 * exp_x_msb_2_3_4_5_lsb_m_1;
            ap_ufixed<68,32> y_lo_s = y_lo;
            ap_ufixed<68,32> y_l = y_lo_s + exp_x_msb_1;
            y = y_l;
        }
        y += delta;

            overf = 0;
            VITIS_LOOP_2079_19: for (int j = 64; j >= I_+31; j--) {
#pragma HLS unroll
 if (y[j])
                    overf = 1;
            }
            if (overf) {
                VITIS_LOOP_2085_20: for (int j = 64; j >= I_+31; j--) {
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_2089_21: for (int j = I_+30; j >= 0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }

        r = y;
    }
    return r;
}

template<int W_, int I_>
ap_ufixed<W_,I_> exp(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return exp(xf);
}

template<int I_>
ap_int<I_> exp(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return exp(xf);
}

template<int I_>
ap_uint<I_> exp(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return exp(xf);
}

template<int W, int I>
ap_fixed<W,I> expm1(ap_fixed<W,I> x) {
    ap_fixed<W,I> result, tmp;
    ap_ufixed<1,1> one = 1;
    if(I < 1) {
        result = 0;
    } else {
        ap_fixed<W,I> tmp = exp(x);
        ap_ufixed<1,1> one = 1;
        result = tmp - one;
    }
    return result;
}

template<int W, int I>
ap_ufixed<W,I> expm1(ap_ufixed<W,I> x) {
    ap_fixed<W+1,I+1> xf = x;
    return expm1(xf);
}

template<int I>
ap_int<I> expm1(ap_int<I> x) {
    ap_fixed<I,I> xf = x;
    return expm1(xf);
}

template<int I>
ap_uint<I> expm1(ap_uint<I> x) {
    ap_fixed<I+1,I+1> xf = x;
    return expm1(xf);
}

template<int W, int I>
ap_fixed<W,I> exp2(ap_fixed<W,I> x) {

    int F = W - I;
    if(I > 33 || F > 32) {
        return 0;
    }

    int I_s;
    int M = ((I - 1) > F) ? (I - 1) : F;

    if(M == 1) {
        I_s = 1;
    } else if(M == 2) {
        I_s = 2;
    } else if(M <= 4) {
        I_s = 3;
    } else if(M <= 8) {
        I_s = 4;
    } else if(M <= 16) {
        I_s = 5;
    } else {
        I_s = 6;
    }

    ap_fixed<W,I> r;

    if(I_s == 1) {

        ap_fixed<3,2> x_l = x;
        ap_ufixed<2,1> y = 0;

        if(!x_l[2]) {
            y[1] = 1;
        }
        if(x_l[1]) {
            y[0] = 1;
        }

        if(I<2) {
            if(y[1]) {
                y[1]=0;
                y[0]=1;
            }
        }
        r = y;

    } else if(I_s == 2) {

        ap_fixed<5,3> x_l = x;
        ap_ufixed<4,2> y = 0;
        ap_fixed<2,2> x_l_int;
        x_l_int(1,0) = x_l(3,2);
        ap_ufixed<2,0> x_l_fract;
        x_l_fract(1,0) = x_l(1,0);

        if( (x_l[4]&&(!x_l[3])) || ((!x_l[4])&&x_l[3]) ) {
            if(!x_l[4]) {
                y = "0x3.cp0";
            }
        } else {
            if((!x_l[3])&(x_l[2])) y[3] = 1;
            if(((!x_l[3])&(!x_l[2])) | ((!x_l[3])&x_l[2]&x_l[1]&x_l[0])) y[2] = 1;
            if( (x_l[3]&x_l[2]) | ((!x_l[3])&( (x_l[2]&(x_l[1]^x_l[0])) | ((!x_l[2])&x_l[1]&x_l[0] )))) y[1] = 1;
            if((x_l[3]&(!x_l[2])) | (x_l[1]&((x_l[0]&x_l[2]) | ((!x_l[0])&(!x_l[3]))))) y[0] =1;
        }

        if(I<3) {
            bool overf = 0;
            VITIS_LOOP_2219_1: for(int j=3; j>=I+1; j--) {
#pragma HLS unroll
 if(y[j]) {
                    overf = 1;
                }
            }
            if (overf) {
                VITIS_LOOP_2226_2: for(int j=3; j>=I+1; j--) {
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_2230_3: for(int j=I; j>=0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        }
        r = y;

    } else if(I_s == 3) {

        ap_fixed<9,5> x_l = x;
        ap_ufixed<8,4> y = 0;
        ap_fixed<3,3> x_l_int;
        x_l_int(2,0) = x_l(6,4);
        ap_ufixed<4,0> x_l_fract;
        x_l_fract(3,0) = x_l(3,0);

        if((x_l[8]!=x_l[7])||(x_l[8]!=x_l[6])) {
            if(!x_l[8]) {
                y = "0xf.fp0";
            }
        } else {
            ap_uint<4> x_msb_ind;
            ap_uint<3> x_lsb_ind;
            x_msb_ind[3] = x_l[8];
            x_msb_ind(2,0) = x_l(5,3);
            x_lsb_ind(2,0) = x_l(2,0);
            const static ap_ufixed<10,4> exp2_x_msb_table[16] = {
                "0x1.00p0", "0x1.6Cp0", "0x2.00p0", "0x2.D4p0",
                "0x4.00p0", "0x5.A8p0", "0x8.00p0", "0xB.50p0",
                "0x0.10p0", "0x0.18p0", "0x0.20p0", "0x0.2Cp0",
                "0x0.40p0", "0x0.5Cp0", "0x0.80p0", "0x0.B4p0"
            };
            const static ap_ufixed<10,0> exp2_x_lsb_m_1_table[8] = {
                "0x0.0p0", "0x0.0B4p0", "0x0.174p0", "0x0.238p0",
                "0x0.308p0", "0x0.3E0p0", "0x0.4C0p0", "0x0.5ACp0"
            };
            ap_ufixed<11,0> exp2_x_lsb_m_1 = exp2_x_lsb_m_1_table[x_lsb_ind];
            ap_ufixed<10,4> exp2_x_msb = exp2_x_msb_table[x_msb_ind];
            ap_ufixed<21,4> y_lo = exp2_x_msb * exp2_x_lsb_m_1;
            ap_ufixed<10,4> y_lo_s = y_lo;
            ap_ufixed<10,4> y_l = y_lo_s + exp2_x_msb;
            y = y_l;
        }

        if(I < 5) {
            bool overf = 0;
            VITIS_LOOP_2277_4: for(int j=7; j>=3+I; j--) {
#pragma HLS unroll
 if(y[j]) {
                    overf = 1;
                }
            }
            if(overf) {
                VITIS_LOOP_2284_5: for(int j=7; j>=3+I; j--) {
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_2288_6: for(int j=I+2; j>=0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        }
        r = y;

    } else if(I_s == 4) {

        ap_fixed<17,9> x_l=x;
        ap_ufixed<16,8> y = 0;
        ap_fixed<4,4> x_l_int;
        x_l_int(3,0) = x_l(11,8);
        ap_ufixed<8,0> x_l_fract;
        x_l_fract(7,0) = x_l(7,0);

        bool overf_1 = 0;
        VITIS_LOOP_2306_7: for(int j=11; j<16; j++) {
#pragma HLS unroll
 if(x_l[16]!=x_l[j]) {
                overf_1 = 1;
            }
        }
        if(overf_1) {
            if(!x_l[16]) {
                y = "0xff.ffp0";
            }
        } else {

            ap_uint<5> x_msb_ind_1;
            x_msb_ind_1(4,0) = x_l(11,7);
            ap_uint<4> x_msb_ind_2;
            x_msb_ind_2(3,0) = x_l(6,3);
            ap_uint<3> x_lsb_ind;
            x_lsb_ind = x_l(2,0);

            const static ap_ufixed<14,-5> exp2_x_lsb_m_1_table[8] = {
                "0x0.0p0", "0x0.00B1Ap0", "0x0.0163Ep0", "0x0.02168p0",
                "0x0.02C9Ap0", "0x0.037D4p0", "0x0.04316p0", "0x0.04E60p0"
            };
            ap_ufixed<14,-5> exp2_x_lsb_m_1 = exp2_x_lsb_m_1_table[x_lsb_ind];

            const static ap_ufixed<19,0> exp2_x_msb_2_m_1_table[16] = {
                "0x0.0p0,0", "0x0.059B0p0", "0x0.0B558p0", "0x0.11302p0",
                "0x0.172B8p0", "0x0.1D488p0", "0x0.2387Ap0", "0x0.29E9Ep0",
                "0x0.306FEp0", "0x0.371A8p0", "0x0.3DEA6p0", "0x0.44E08p0",
                "0x0.4BFDAp0", "0x0.5342Cp0", "0x0.5AB08p0", "0x0.6247Ep0"
            };
            ap_ufixed<19,0> exp2_x_msb_2_m_1 = exp2_x_msb_2_m_1_table[x_msb_ind_2];
            ap_ufixed<33,-5> f_x_msb_2_lsb = exp2_x_msb_2_m_1 * exp2_x_lsb_m_1;
            ap_ufixed<19,0> f_x_msb_2_lsb_s = f_x_msb_2_lsb;
            ap_ufixed<19,0> exp2_x_msb_2_lsb_m_1 = f_x_msb_2_lsb_s + exp2_x_msb_2_m_1 + exp2_x_lsb_m_1;

            const static ap_ufixed<19,8> exp2_x_msb_1_table[32] = {
                "0x1.000p0", "0x1.6A0p0", "0x2.000p0", "0x2.D42p0",
                "0x4.000p0", "0x5.A82p0", "0x8.000p0", "0xB.504p0",
                "0x10.000p0", "0x16.A0Ap0", "0x20.000p0", "0x2D.414p0",
                "0x40.000p0", "0x5A.828p0", "0x80.000p0", "0xB5.050p0",
                "0x0.010p0", "0x0.016p0", "0x0.020p0", "0x0.02Ep0",
                "0x0.040p0", "0x0.05Ap0", "0x0.080p0", "0x0.0B6p0",
                "0x0.100p0", "0x0.16Ap0", "0x0.200p0", "0x0.2D4p0",
                "0x0.400p0", "0x0.5A8p0", "0x0.800p0", "0x0.B50p0"
            };
            ap_ufixed<19,8> exp2_x_msb_1 = exp2_x_msb_1_table[x_msb_ind_1];
            ap_ufixed<38,8> y_lo = exp2_x_msb_1 * exp2_x_msb_2_lsb_m_1;
            ap_ufixed<19,8> y_lo_s = y_lo;
            ap_ufixed<19,8> y_l = y_lo_s + exp2_x_msb_1;
            y = y_l;
        }

        if(I < 9) {
            bool overf_2 = 0;
            VITIS_LOOP_2361_8: for(int j=15; j>=7+I; j--) {
#pragma HLS unroll
 if(y[j]) {
                    overf_2 = 1;
                }
            }
            if(overf_2) {
                VITIS_LOOP_2368_9: for(int j=15; j>=7+I; j--) {
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_2372_10: for(int j=6+I; j>=0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        }
        r = y;

    } else if(I_s == 5) {

        ap_fixed<33,17> x_l = x;
        ap_ufixed<32,16> y = 0;
        ap_fixed<5,5> x_l_int;
        x_l_int(4,0) = x_l(20,16);
        ap_ufixed<16,0> x_l_fract;
        x_l_fract(15,0) = x_l(15,0);

        bool overf_1 = 0;
        VITIS_LOOP_2390_11: for(int j=20; j<32; j++) {
#pragma HLS unroll
 if(x_l[32]!=x_l[j]) {
                overf_1 = 1;
            }
        }
        if(overf_1) {
            if(!x_l[32]) {
                y = "0xffff.ffffp0";
            }
        } else {
            ap_uint<6> x_msb_ind_1;
            x_msb_ind_1(5,0) = x_l(20,15);
            ap_uint<5> x_msb_ind_2;
            x_msb_ind_2(4,0) = x_l(14,10);
            ap_uint<5> x_msb_ind_3;
            x_msb_ind_3(4,0) = x_l(9,5);
            ap_uint<5> x_lsb_ind;
            x_lsb_ind = x_l(4,0);

            const static ap_ufixed<25,-11> exp2_x_lsb_m_1_table[32] = {
                "0x0.0p0", "0x0.0000B1725p0", "0x0.000162E52p0", "0x0.000214587p0",
                "0x0.0002C5CC3p0", "0x0.000377408p0", "0x0.000428B53p0", "0x0.0004DA2A7p0",
                "0x0.00058BA02p0", "0x0.00063D165p0", "0x0.0006EE8CFp0", "0x0.0007A0042p0",
                "0x0.0008517BBp0", "0x0.000902F3Dp0", "0x0.0009B46C6p0", "0x0.000A65E57p0",
                "0x0.000B175F0p0", "0x0.000BC8D90p0", "0x0.000C7A538p0", "0x0.000D2BCE8p0",
                "0x0.000DDD4A0p0", "0x0.000E8EC5Fp0", "0x0.000F40425p0", "0x0.000FF1BF4p0",
                "0x0.0010A33CAp0", "0x0.001154BA8p0", "0x0.00120638Dp0", "0x0.0012B7B7Bp0",
                "0x0.001369370p0", "0x0.00141AB6Cp0", "0x0.0014CC371p0", "0x0.00157DB7Dp0"
            };
            ap_ufixed<25,-11> exp2_x_lsb_m_1 = exp2_x_lsb_m_1_table[x_lsb_ind];

            const static ap_ufixed<30,-6> exp2_x_msb_3_m_1_table[32] = {
                "0x0.0p0", "0x0.00162F390p0", "0x0.002C605E3p0", "0x0.0042936FBp0",
                "0x0.0058C86DAp0", "0x0.006EFF584p0", "0x0.0085382FBp0", "0x0.009B72F42p0",
                "0x0.00B1AFA5Bp0", "0x0.00C7EE449p0", "0x0.00DE2ED0Fp0", "0x0.00F4714AFp0",
                "0x0.010AB5B2Dp0", "0x0.0120FC08Ap0", "0x0.0137444CAp0", "0x0.014D8E7EFp0",
                "0x0.0163DA9FBp0", "0x0.017A28AF2p0", "0x0.019078AD7p0", "0x0.01A6CA9ABp0",
                "0x0.01BD1E771p0", "0x0.01D37442Dp0", "0x0.01E9CBFE1p0", "0x0.020025A8Fp0",
                "0x0.02168143Bp0", "0x0.022CDECE7p0", "0x0.02433E495p0", "0x0.02599FB48p0",
                "0x0.027003104p0", "0x0.0286685CAp0", "0x0.029CCF99Dp0", "0x0.02B338C81p0"
            };
            ap_ufixed<30,-6> exp2_x_msb_3_m_1 = exp2_x_msb_3_m_1_table[x_msb_ind_3];
            ap_ufixed<55,-17> f_x_msb_3_lsb = exp2_x_msb_3_m_1 * exp2_x_lsb_m_1;
            ap_ufixed<19,-17> f_x_msb_3_lsb_s = f_x_msb_3_lsb;
            ap_ufixed<30,-6> exp2_x_msb_3_lsb_m_1 = f_x_msb_3_lsb_s + exp2_x_msb_3_m_1 + exp2_x_lsb_m_1;

            const static ap_ufixed<36,0> exp2_x_msb_2_m_1_table[32] = {
                "0x0.0p0", "0x0.02C9A3E78p0", "0x0.059B0D316p0", "0x0.087451876p0",
                "0x0.0B5586CFAp0", "0x0.0E3EC32D4p0", "0x0.11301D012p0", "0x0.1429AAEA9p0",
                "0x0.172B83C7Dp0", "0x0.1A35BEB70p0", "0x0.1D4873169p0", "0x0.2063B8863p0",
                "0x0.2387A6E75p0", "0x0.26B4565E2p0", "0x0.29E9DF520p0", "0x0.2D285A6E4p0",
                "0x0.306FE0A32p0", "0x0.33C08B264p0", "0x0.371A7373Bp0", "0x0.3A7DB34E6p0",
                "0x0.3DEA64C12p0", "0x0.4160A21F7p0", "0x0.44E086062p0", "0x0.486A2B5C1p0",
                "0x0.4BFDAD536p0", "0x0.4F9B2769Dp0", "0x0.5342B569Dp0", "0x0.56F4736B5p0",
                "0x0.5AB07DD48p0", "0x0.5E76F15ADp0", "0x0.6247EB03Ap0", "0x0.662388255p0"
            };
            ap_ufixed<36,0> exp2_x_msb_2_m_1 = exp2_x_msb_2_m_1_table[x_msb_ind_2];
            ap_ufixed<66,-6> f_x_msb_2_lsb = exp2_x_msb_2_m_1 * exp2_x_msb_3_lsb_m_1;
            ap_ufixed<30,-6> f_x_msb_2_lsb_s = f_x_msb_2_lsb;
            ap_ufixed<36,0> exp2_x_msb_2_3_lsb_m_1 = f_x_msb_2_lsb_s + exp2_x_msb_2_m_1 + exp2_x_msb_3_lsb_m_1;

            const static ap_ufixed<36,16> exp2_x_msb_1_table[64] = {
                "0x1.00000p0", "0x1.6A09Ep0", "0x2.00000p0", "0x2.D413Dp0",
                "0x4.00000p0", "0x5.A827Ap0", "0x8.00000p0", "0xB.504F3p0",
                "0x10.00000p0", "0x16.A09E6p0", "0x20.00000p0", "0x2D.413CDp0",
                "0x40.00000p0", "0x5A.8279Ap0", "0x80.00000p0", "0xB5.04F33p0",
                "0x100.00000p0", "0x16A.09E66p0", "0x200.00000p0", "0x2D4.13CCDp0",
                "0x400.00000p0", "0x5A8.2799Ap0", "0x800.00000p0", "0xB50.4F334p0",
                "0x1000.00000p0", "0x16A0.9E668p0", "0x2000.00000p0", "0x2D41.3CCD0p0",
                "0x4000.00000p0", "0x5A82.799A0p0", "0x8000.00000p0", "0xB504.F3340p0",
                "0x0.00010p0", "0x0.00017p0", "0x0.00020p0", "0x0.0002Dp0",
                "0x0.00040p0", "0x0.0005Bp0", "0x0.00080p0", "0x0.000B5p0",
                "0x0.00100p0", "0x0.0016Ap0", "0x0.00200p0", "0x0.002D4p0",
                "0x0.00400p0", "0x0.005A8p0", "0x0.00800p0", "0x0.00B50p0",
                "0x0.01000p0", "0x0.016A1p0", "0x0.02000p0", "0x0.02D41p0",
                "0x0.04000p0", "0x0.05A82p0", "0x0.08000p0", "0x0.0B505p0",
                "0x0.10000p0", "0x0.16A0Ap0", "0x0.20000p0", "0x0.2D414p0",
                "0x0.40000p0", "0x0.5A828p0", "0x0.80000p0", "0x0.B504Fp0"
            };
            ap_ufixed<36,16> exp2_x_msb_1 = exp2_x_msb_1_table[x_msb_ind_1];
            ap_ufixed<72,16> y_lo = exp2_x_msb_1 * exp2_x_msb_2_3_lsb_m_1;
            ap_ufixed<36,16> y_lo_s = y_lo;
            ap_ufixed<36,16> y_l = y_lo_s + exp2_x_msb_1;
            y = y_l;
        }

        if(I<17) {
            bool overf_2 = 0;
            VITIS_LOOP_2479_12: for(int j=31; j>=I+15; j--) {
#pragma HLS unroll
 if(y[j]) {
                    overf_2 = 1;
                }
            }
            if(overf_2) {
                VITIS_LOOP_2486_13: for(int j=31; j>=I+15; j--) {
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_2490_14: for(int j=I+14; j>=0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        }
        r = y;

    } else {
        ap_fixed<65,33> x_l = 0;
        VITIS_LOOP_2500_15: for(int j=32-F; j<32+I; j++) {
#pragma HLS unroll
 x_l[j] = x[j-(32-F)];
        }
        VITIS_LOOP_2504_16: for(int j=32+I; j<=64; j++) {
#pragma HLS unroll
 x_l[j] = x[W-1];
        }
        ap_ufixed<64,32> y = 0;
        ap_fixed<6,6> x_l_int;
        x_l_int(5,0) = x_l(37,32);
        ap_ufixed<32,0> x_l_fract;
        x_l_fract(31,0) = x_l(31,0);

        bool overf_1 = 0;
        VITIS_LOOP_2515_17: for(int j=37; j<64; j++) {
#pragma HLS unroll
 if(x_l[j]!=x_l[64]) {
                overf_1 = 1;
            }
        }
        if(overf_1) {
            if(!x_l[64]) {
                VITIS_LOOP_2523_18: for(int j=0; j<64; j++) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        } else {
            ap_uint<8> x_msb_ind_1;
            x_msb_ind_1(7,0) = x_l(37,30);
            ap_uint<8> x_msb_ind_2;
            x_msb_ind_2(7,0) = x_l(29,22);
            ap_uint<8> x_msb_ind_3;
            x_msb_ind_3(7,0) = x_l(21,14);
            ap_uint<8> x_msb_ind_4;
            x_msb_ind_4(7,0) = x_l(13,6);
            ap_uint<6> x_lsb_ind;
            x_lsb_ind(5,0) = x_l(5,0);

            const static ap_ufixed<42,-26> exp2_x_lsb_m_1_table[64] = {
                "0x0.0p0", "0x0.00000000B17217F81p0", "0x0.0000000162E42FF0Ap0", "0x0.00000002145647E9Ap0",
                "0x0.00000002C5C85FE32p0", "0x0.00000003773A77DD2p0", "0x0.0000000428AC8FD79p0", "0x0.00000004DA1EA7D28p0",
                "0x0.000000058B90BFCDFp0", "0x0.000000063D02D7C9Dp0", "0x0.00000006EE74EFC63p0", "0x0.000000079FE707C31p0",
                "0x0.0000000851591FC07p0", "0x0.0000000902CB37BE4p0", "0x0.00000009B43D4FBC9p0", "0x0.0000000A65AF67BB6p0",
                "0x0.0000000B17217FBAAp0", "0x0.0000000BC89397BA6p0", "0x0.0000000C7A05AFBA9p0", "0x0.0000000D2B77C7BB5p0",
                "0x0.0000000DDCE9DFBC8p0", "0x0.0000000E8E5BF7BE2p0", "0x0.0000000F3FCE0FC05p0", "0x0.0000000FF14027C2Fp0",
                "0x0.00000010A2B23FC61p0", "0x0.00000011542457C9Ap0", "0x0.0000001205966FCDBp0", "0x0.00000012B70887D24p0",
                "0x0.00000013687A9FD75p0", "0x0.0000001419ECB7DCDp0", "0x0.00000014CB5ECFE2Dp0", "0x0.000000157CD0E7E94p0",
                "0x0.000000162E42FFF03p0", "0x0.00000016DFB517F7Ap0", "0x0.0000001791272FFF9p0", "0x0.0000001842994807Fp0",
                "0x0.00000018F40B6010Dp0", "0x0.00000019A57D781A3p0", "0x0.0000001A56EF90240p0", "0x0.0000001B0861A82E6p0",
                "0x0.0000001BB9D3C0392p0", "0x0.0000001C6B45D8447p0", "0x0.0000001D1CB7F0503p0", "0x0.0000001DCE2A085C7p0",
                "0x0.0000001E7F9C20692p0", "0x0.0000001F310E38765p0", "0x0.0000001FE28050840p0", "0x0.0000002093F268923p0",
                "0x0.00000021456480A0Dp0", "0x0.00000021F6D698AFFp0", "0x0.00000022A848B0BF9p0", "0x0.0000002359BAC8CFAp0",
                "0x0.000000240B2CE0E03p0", "0x0.00000024BC9EF8F14p0", "0x0.000000256E111102Cp0", "0x0.000000261F832914Cp0",
                "0x0.00000026D0F541274p0", "0x0.000000278267593A3p0", "0x0.0000002833D9714DBp0", "0x0.00000028E54B89619p0",
                "0x0.0000002996BDA1760p0", "0x0.0000002A482FB98AEp0", "0x0.0000002AF9A1D1A04p0", "0x0.0000002BAB13E9B61p0"
            };
            ap_ufixed<42,-26> exp2_x_lsb_m_1 = exp2_x_lsb_m_1_table[x_lsb_ind];

            const static ap_ufixed<50,-18> exp2_x_msb_4_m_1_table[256] = {
                "0x0.0p0", "0x0.0000002C5C8601CC7p0", "0x0.00000058B90C0B48Cp0", "0x0.0000008515921C751p0",
                "0x0.000000B1721835515p0", "0x0.000000DDCE9E55DD7p0", "0x0.0000010A2B247E199p0", "0x0.0000013687AAAE059p0",
                "0x0.00000162E430E5A19p0", "0x0.0000018F40B724ED7p0", "0x0.000001BB9D3D6BE95p0", "0x0.000001E7F9C3BA951p0",
                "0x0.00000214564A10F0Dp0", "0x0.00000240B2D06EFC7p0", "0x0.0000026D0F56D4B80p0", "0x0.000002996BDD42239p0",
                "0x0.000002C5C863B73F0p0", "0x0.000002F224EA340A6p0", "0x0.0000031E8170B885Cp0", "0x0.0000034ADDF744B10p0",
                "0x0.000003773A7DD88C3p0", "0x0.000003A3970474175p0", "0x0.000003CFF38B17526p0", "0x0.000003FC5011C23D6p0",
                "0x0.00000428AC9874D86p0", "0x0.00000455091F2F234p0", "0x0.0000048165A5F11E1p0", "0x0.000004ADC22CBAC8Dp0",
                "0x0.000004DA1EB38C238p0", "0x0.000005067B3A652E2p0", "0x0.00000532D7C145E8Bp0", "0x0.0000055F34482E533p0",
                "0x0.0000058B90CF1E6D9p0", "0x0.000005B7ED561637Fp0", "0x0.000005E449DD15B24p0", "0x0.00000610A6641CDC8p0",
                "0x0.0000063D02EB2BB6Bp0", "0x0.000006695F724240Dp0", "0x0.00000695BBF9607AEp0", "0x0.000006C218808664Dp0",
                "0x0.000006EE7507B3FECp0", "0x0.0000071AD18EE948Ap0", "0x0.000007472E1626427p0", "0x0.000007738A9D6AEC2p0",
                "0x0.0000079FE724B745Dp0", "0x0.000007CC43AC0B4F7p0", "0x0.000007F8A0336708Fp0", "0x0.00000824FCBACA727p0",
                "0x0.000008515942358BEp0", "0x0.0000087DB5C9A8553p0", "0x0.000008AA125122CE8p0", "0x0.000008D66ED8A4F7Bp0",
                "0x0.00000902CB602ED0Ep0", "0x0.0000092F27E7C059Fp0", "0x0.0000095B846F59930p0", "0x0.00000987E0F6FA7C0p0",
                "0x0.000009B43D7EA314Ep0", "0x0.000009E09A06535DCp0", "0x0.00000A0CF68E0B568p0", "0x0.00000A395315CAFF3p0",
                "0x0.00000A65AF9D9257Ep0", "0x0.00000A920C2561607p0", "0x0.00000ABE68AD38190p0", "0x0.00000AEAC53516817p0",
                "0x0.00000B1721BCFC99Ep0", "0x0.00000B437E44EA623p0", "0x0.00000B6FDACCDFDA7p0", "0x0.00000B9C3754DD02Bp0",
                "0x0.00000BC893DCE1DADp0", "0x0.00000BF4F064EE62Fp0", "0x0.00000C214CED029AFp0", "0x0.00000C4DA9751E82Ep0",
                "0x0.00000C7A05FD421ADp0", "0x0.00000CA662856D62Ap0", "0x0.00000CD2BF0DA05A6p0", "0x0.00000CFF1B95DB022p0",
                "0x0.00000D2B781E1D59Cp0", "0x0.00000D57D4A667615p0", "0x0.00000D84312EB918Dp0", "0x0.00000DB08DB712805p0",
                "0x0.00000DDCEA3F7397Bp0", "0x0.00000E0946C7DC5F0p0", "0x0.00000E35A3504CD65p0", "0x0.00000E61FFD8C4FD8p0",
                "0x0.00000E8E5C6144D4Ap0", "0x0.00000EBAB8E9CC5BBp0", "0x0.00000EE715725B92Cp0", "0x0.00000F1371FAF279Bp0",
                "0x0.00000F3FCE8391109p0", "0x0.00000F6C2B0C37576p0", "0x0.00000F988794E54E3p0", "0x0.00000FC4E41D9AF4Ep0",
                "0x0.00000FF140A6584B8p0", "0x0.0000101D9D2F1D521p0", "0x0.00001049F9B7EA08Ap0", "0x0.000010765640BE6F1p0",
                "0x0.000010A2B2C99A857p0", "0x0.000010CF0F527E4BCp0", "0x0.000010FB6BDB69C21p0", "0x0.00001127C8645CE84p0",
                "0x0.0000115424ED57BE6p0", "0x0.0000118081765A447p0", "0x0.000011ACDDFF647A7p0", "0x0.000011D93A8876607p0",
                "0x0.0000120597118FF65p0", "0x0.00001231F39AB13C2p0", "0x0.0000125E5023DA31Ep0", "0x0.0000128AACAD0AD7Ap0",
                "0x0.000012B70936432D4p0", "0x0.000012E365BF8332Dp0", "0x0.0000130FC248CAE85p0", "0x0.0000133C1ED21A4DDp0",
                "0x0.000013687B5B71633p0", "0x0.00001394D7E4D0288p0", "0x0.000013C1346E369DDp0", "0x0.000013ED90F7A4C30p0",
                "0x0.00001419ED811A982p0", "0x0.000014464A0A981D4p0", "0x0.00001472A6941D524p0", "0x0.0000149F031DAA373p0",
                "0x0.000014CB5FA73ECC1p0", "0x0.000014F7BC30DB10Fp0", "0x0.0000152418BA7F05Bp0", "0x0.0000155075442AAA6p0",
                "0x0.0000157CD1CDDDFF1p0", "0x0.000015A92E579903Ap0", "0x0.000015D58AE15BB83p0", "0x0.00001601E76B261CAp0",
                "0x0.0000162E43F4F8310p0", "0x0.0000165AA07ED1F56p0", "0x0.00001686FD08B369Ap0", "0x0.000016B359929C8DEp0",
                "0x0.000016DFB61C8D620p0", "0x0.0000170C12A685E62p0", "0x0.000017386F30861A2p0", "0x0.00001764CBBA8DFE1p0",
                "0x0.0000179128449D920p0", "0x0.000017BD84CEB4D5Dp0", "0x0.000017E9E158D3C9Ap0", "0x0.000018163DE2FA6D6p0",
                "0x0.000018429A6D28C10p0", "0x0.0000186EF6F75EC4Ap0", "0x0.0000189B53819C782p0", "0x0.000018C7B00BE1DBAp0",
                "0x0.000018F40C962EEF0p0", "0x0.00001920692083B26p0", "0x0.0000194CC5AAE025Bp0", "0x0.0000197922354448Ep0",
                "0x0.000019A57EBFB01C1p0", "0x0.000019D1DB4A239F3p0", "0x0.000019FE37D49ED23p0", "0x0.00001A2A945F21B53p0",
                "0x0.00001A56F0E9AC482p0", "0x0.00001A834D743E8B0p0", "0x0.00001AAFA9FED87DCp0", "0x0.00001ADC06897A208p0",
                "0x0.00001B08631423733p0", "0x0.00001B34BF9ED475Dp0", "0x0.00001B611C298D286p0", "0x0.00001B8D78B44D8ADp0",
                "0x0.00001BB9D53F159D4p0", "0x0.00001BE631C9E55FAp0", "0x0.00001C128E54BCD1Fp0", "0x0.00001C3EEADF9BF43p0",
                "0x0.00001C6B476A82C66p0", "0x0.00001C97A3F571488p0", "0x0.00001CC40080677A9p0", "0x0.00001CF05D0B655C9p0",
                "0x0.00001D1CB9966AEE8p0", "0x0.00001D49162178306p0", "0x0.00001D7572AC8D223p0", "0x0.00001DA1CF37A9C40p0",
                "0x0.00001DCE2BC2CE15Bp0", "0x0.00001DFA884DFA175p0", "0x0.00001E26E4D92DC8Ep0", "0x0.00001E534164692A6p0",
                "0x0.00001E7F9DEFAC3BEp0", "0x0.00001EABFA7AF6FD4p0", "0x0.00001ED85706496E9p0", "0x0.00001F04B391A38FEp0",
                "0x0.00001F31101D05611p0", "0x0.00001F5D6CA86EE23p0", "0x0.00001F89C933E0135p0", "0x0.00001FB625BF58F45p0",
                "0x0.00001FE2824AD9855p0", "0x0.0000200EDED661C63p0", "0x0.0000203B3B61F1B71p0", "0x0.0000206797ED8957Dp0",
                "0x0.00002093F47928A89p0", "0x0.000020C05104CFA93p0", "0x0.000020ECAD907E59Dp0", "0x0.000021190A1C34BA6p0",
                "0x0.0000214566A7F2CAEp0", "0x0.00002171C333B88B4p0", "0x0.0000219E1FBF85FBAp0", "0x0.000021CA7C4B5B1BFp0",
                "0x0.000021F6D8D737EC3p0", "0x0.0000222335631C6C6p0", "0x0.0000224F91EF089C7p0", "0x0.0000227BEE7AFC7C8p0",
                "0x0.000022A84B06F80C8p0", "0x0.000022D4A792FB4C7p0", "0x0.00002301041F063C5p0", "0x0.0000232D60AB18DC3p0",
                "0x0.00002359BD37332BFp0", "0x0.0000238619C3552BAp0", "0x0.000023B2764F7EDB4p0", "0x0.000023DED2DBB03ADp0",
                "0x0.0000240B2F67E94A5p0", "0x0.000024378BF42A09Dp0", "0x0.00002463E88072793p0", "0x0.00002490450CC2988p0",
                "0x0.000024BCA1991A67Dp0", "0x0.000024E8FE2579E70p0", "0x0.000025155AB1E1163p0", "0x0.00002541B73E4FF54p0",
                "0x0.0000256E13CAC6845p0", "0x0.0000259A705744C34p0", "0x0.000025C6CCE3CAB23p0", "0x0.000025F3297058511p0",
                "0x0.0000261F85FCED9FDp0", "0x0.0000264BE2898A9E9p0", "0x0.000026783F162F4D4p0", "0x0.000026A49BA2DBABEp0",
                "0x0.000026D0F82F8FBA7p0", "0x0.000026FD54BC4B78Fp0", "0x0.00002729B1490EE75p0", "0x0.000027560DD5DA05Bp0",
                "0x0.000027826A62ACD41p0", "0x0.000027AEC6EF87525p0", "0x0.000027DB237C69808p0", "0x0.000028078009535EAp0",
                "0x0.00002833DC9644ECBp0", "0x0.0000286039233E2ABp0", "0x0.0000288C95B03F18Bp0", "0x0.000028B8F23D47B69p0",
                "0x0.000028E54ECA58046p0", "0x0.00002911AB5770023p0", "0x0.0000293E07E48FAFEp0", "0x0.0000296A6471B70D9p0",
                "0x0.00002996C0FEE61B2p0", "0x0.000029C31D8C1CD8Bp0", "0x0.000029EF7A195B463p0", "0x0.00002A1BD6A6A1639p0",
                "0x0.00002A483333EF30Fp0", "0x0.00002A748FC144AE4p0", "0x0.00002AA0EC4EA1DB8p0", "0x0.00002ACD48DC06B8Bp0",
                "0x0.00002AF9A5697345Dp0", "0x0.00002B2601F6E782Ep0", "0x0.00002B525E84636FEp0", "0x0.00002B7EBB11E70CDp0",
                "0x0.00002BAB179F7259Bp0", "0x0.00002BD7742D05568p0", "0x0.00002C03D0BAA0035p0", "0x0.00002C302D4842600p0"
            };
            ap_ufixed<50,-18> exp2_x_msb_4_m_1 = exp2_x_msb_4_m_1_table[x_msb_ind_4];
            ap_ufixed<92,-44> f_x_msb_4_lsb = exp2_x_lsb_m_1 * exp2_x_msb_4_m_1;
            ap_ufixed<24,-44> f_x_msb_4_lsb_s = f_x_msb_4_lsb;
            ap_ufixed<50,-18> exp2_x_msb_4_lsb_m_1 = f_x_msb_4_lsb_s + exp2_x_msb_4_m_1 + exp2_x_lsb_m_1;

            const static ap_ufixed<58,-10> exp2_x_msb_3_m_1_table[256] = {
                "0x0.0p0", "0x0.00002C5C89D5EC6CAp0", "0x0.000058B91B5BC9AE3p0", "0x0.00008515B4919919Ap0",
                "0x0.0000B17255775C040p0", "0x0.0000DDCEFE0D13C26p0", "0x0.00010A2BAE52C1A9Bp0", "0x0.000136886648670F0p0",
                "0x0.000162E525EE05475p0", "0x0.00018F41ED439DA7Bp0", "0x0.0001BB9EBC4931853p0", "0x0.0001E7FB92FEC234Bp0",
                "0x0.000214587164510B6p0", "0x0.000240B55779DF5E3p0", "0x0.00026D12453F6E823p0", "0x0.0002996F3AB4FFCC6p0",
                "0x0.0002C5CC37DA9491Dp0", "0x0.0002F2293CB02E278p0", "0x0.00031E864935CDE29p0", "0x0.00034AE35D6B7517Ep0",
                "0x0.000377407951251C9p0", "0x0.0003A39D9CE6DF45Bp0", "0x0.0003CFFAC82CA4E84p0", "0x0.0003FC57FB2277595p0",
                "0x0.000428B535C857EDDp0", "0x0.00045512781E47FAFp0", "0x0.0004816FC22448D5Ap0", "0x0.0004ADCD13DA5BD2Fp0",
                "0x0.0004DA2A6D408247Ep0", "0x0.00050687CE56BD89Ap0", "0x0.000532E5371D0EED1p0", "0x0.00055F42A79377C75p0",
                "0x0.00058BA01FB9F96D7p0", "0x0.0005B7FD9F9095347p0", "0x0.0005E45B27174C716p0", "0x0.000610B8B64E20794p0",
                "0x0.00063D164D3512A14p0", "0x0.00066973EBCC243E4p0", "0x0.000695D1921356A57p0", "0x0.0006C22F400AAB2BCp0",
                "0x0.0006EE8CF5B223266p0", "0x0.00071AEAB309BFEA4p0", "0x0.00074748781182CC7p0", "0x0.000773A644C96D221p0",
                "0x0.0007A004193180402p0", "0x0.0007CC61F549BD7BCp0", "0x0.0007F8BFD9122629Ep0", "0x0.0008251DC48ABB9FAp0",
                "0x0.0008517BB7B37F322p0", "0x0.00087DD9B28C72365p0", "0x0.0008AA37B51596015p0", "0x0.0008D695BF4EEBE83p0",
                "0x0.000902F3D13875400p0", "0x0.00092F51EAD2335DCp0", "0x0.00095BB00C1C2796Ap0", "0x0.0009880E3516533FAp0",
                "0x0.0009B46C65C0B7ADCp0", "0x0.0009E0CA9E1B56363p0", "0x0.000A0D28DE26302DFp0", "0x0.000A398725E146EA2p0",
                "0x0.000A65E5754C9BBFBp0", "0x0.000A9243CC683003Ep0", "0x0.000ABEA22B34050BAp0", "0x0.000AEB0091B01C2C1p0",
                "0x0.000B175EFFDC76BA4p0", "0x0.000B43BD75B9160B4p0", "0x0.000B701BF345FB742p0", "0x0.000B9C7A7883284A1p0",
                "0x0.000BC8D905709DE20p0", "0x0.000BF5379A0E5D912p0", "0x0.000C2196365C68AC6p0", "0x0.000C4DF4DA5AC0890p0",
                "0x0.000C7A538609667C0p0", "0x0.000CA6B239685BDA6p0", "0x0.000CD310F477A1F96p0", "0x0.000CFF6FB7373A2DFp0",
                "0x0.000D2BCE81A725CD4p0", "0x0.000D582D53C7662C6p0", "0x0.000D848C2D97FCA05p0", "0x0.000DB0EB0F18EA7E4p0",
                "0x0.000DDD49F84A311B4p0", "0x0.000E09A8E92BD1CC6p0", "0x0.000E3607E1BDCDE6Cp0", "0x0.000E6266E20026BF7p0",
                "0x0.000E8EC5E9F2DDAB9p0", "0x0.000EBB24F995F4003p0", "0x0.000EE78410E96B126p0", "0x0.000F13E32FED44375p0",
                "0x0.000F404256A180C40p0", "0x0.000F6CA18506220D9p0", "0x0.000F9900BB1B29692p0", "0x0.000FC55FF8E0982BDp0",
                "0x0.000FF1BF3E566FAAAp0", "0x0.00101E1E8B7CB13ACp0", "0x0.00104A7DE0535E314p0", "0x0.001076DD3CDA77E34p0",
                "0x0.0010A33CA111FFA5Dp0", "0x0.0010CF9C0CF9F6CE1p0", "0x0.0010FBFB80925EB11p0", "0x0.0011285AFBDB38A40p0",
                "0x0.001154BA7ED485FC0p0", "0x0.0011811A097E480E0p0", "0x0.0011AD799BD8802F5p0", "0x0.0011D9D935E32FB4Fp0",
                "0x0.00120638D79E57F3Fp0", "0x0.001232988109FA419p0", "0x0.00125EF8322617F2Dp0", "0x0.00128B57EAF2B25CDp0",
                "0x0.0012B7B7AB6FCAD4Bp0", "0x0.0012E417739D62AFAp0", "0x0.00131077437B7B42Ap0", "0x0.00133CD71B0A15E2Ep0",
                "0x0.00136936FA4933E58p0", "0x0.00139596E138D69F9p0", "0x0.0013C1F6CFD8FF663p0", "0x0.0013EE56C629AF8E9p0",
                "0x0.00141AB6C42AE86DBp0", "0x0.00144716C9DCAB58Dp0", "0x0.00147376D73EF9A50p0", "0x0.00149FD6EC51D4A76p0",
                "0x0.0014CC3709153DB51p0", "0x0.0014F8972D8936234p0", "0x0.001524F759ADBF46Fp0", "0x0.001551578D82DA755p0",
                "0x0.00157DB7C90889038p0", "0x0.0015AA180C3ECC46Bp0", "0x0.0015D6785725A593Fp0", "0x0.001602D8A9BD16406p0",
                "0x0.00162F3904051FA13p0", "0x0.00165B9965FDC30B7p0", "0x0.001687F9CFA701D45p0", "0x0.0016B45A4100DD50Ep0",
                "0x0.0016E0BABA0B56D66p0", "0x0.00170D1B3AC66FB9Ep0", "0x0.0017397BC33229508p0", "0x0.001765DC534E84EF7p0",
                "0x0.0017923CEB1B83EBCp0", "0x0.0017BE9D8A99279ABp0", "0x0.0017EAFE31C771515p0", "0x0.0018175EE0A66264Cp0",
                "0x0.001843BF9735FC2A3p0", "0x0.0018702055763FF6Cp0", "0x0.00189C811B672F1FAp0", "0x0.0018C8E1E908CAF9Ep0",
                "0x0.0018F542BE5B14DABp0", "0x0.001921A39B5E0E174p0", "0x0.00194E048011B804Ap0", "0x0.00197A656C7613F81p0",
                "0x0.0019A6C6608B2346Ap0", "0x0.0019D3275C50E7458p0", "0x0.0019FF885FC76149Dp0", "0x0.001A2BE96AEE92A8Cp0",
                "0x0.001A584A7DC67CB77p0", "0x0.001A84AB984F20CB1p0", "0x0.001AB10CBA888038Cp0", "0x0.001ADD6DE4729C55Ap0",
                "0x0.001B09CF160D7676Fp0", "0x0.001B36304F590FF1Dp0", "0x0.001B629190556A1B5p0", "0x0.001B8EF2D9028648Cp0",
                "0x0.001BBB54296065CF2p0", "0x0.001BE7B5816F0A03Cp0", "0x0.001C1416E12E743BBp0", "0x0.001C4078489EA5CC2p0",
                "0x0.001C6CD9B7BFA00A4p0", "0x0.001C993B2E91644B3p0", "0x0.001CC59CAD13F3E42p0", "0x0.001CF1FE3347502A4p0",
                "0x0.001D1E5FC12B7A72Bp0", "0x0.001D4AC156C07412Ap0", "0x0.001D7722F4063E5F4p0", "0x0.001DA38498FCDAADBp0",
                "0x0.001DCFE645A44A533p0", "0x0.001DFC47F9FC8EA4Dp0", "0x0.001E28A9B605A8F7Dp0", "0x0.001E550B79BF9AA16p0",
                "0x0.001E816D452A64F6Ap0", "0x0.001EADCF1846094CCp0", "0x0.001EDA30F31288F8Ep0", "0x0.001F0692D58FE5505p0",
                "0x0.001F32F4BFBE1FA82p0", "0x0.001F5F56B19D39559p0", "0x0.001F8BB8AB2D33ADCp0", "0x0.001FB81AAC6E1005Ep0",
                "0x0.001FE47CB55FCFB33p0", "0x0.002010DEC602740ACp0", "0x0.00203D40DE55FE61Ep0", "0x0.002069A2FE5A700DAp0",
                "0x0.00209605260FCA635p0", "0x0.0020C26755760EB80p0", "0x0.0020EEC98C8D3E60Fp0", "0x0.00211B2BCB555AB35p0",
                "0x0.0021478E11CE65045p0", "0x0.002173F05FF85EA93p0", "0x0.0021A052B5D348F70p0", "0x0.0021CCB5135F25430p0",
                "0x0.0021F917789BF4E26p0", "0x0.00222579E589B92A6p0", "0x0.002251DC5A2873702p0", "0x0.00227E3ED6782508Ep0",
                "0x0.0022AAA15A78CF49Cp0", "0x0.0022D703E62A73880p0", "0x0.00230366798D1318Dp0", "0x0.00232FC914A0AF516p0",
                "0x0.00235C2BB7654986Fp0", "0x0.0023888E61DAE30EAp0", "0x0.0023B4F114017D3DBp0", "0x0.0023E153CDD919695p0",
                "0x0.00240DB68F61B8E6Cp0", "0x0.00243A19589B5D0B2p0", "0x0.0024667C2986072BAp0", "0x0.002492DF0221B89D9p0",
                "0x0.0024BF41E26E72B62p0", "0x0.0024EBA4CA6C36CA7p0", "0x0.00251807BA1B062FDp0", "0x0.0025446AB17AE23B5p0",
                "0x0.002570CDB08BCC425p0", "0x0.00259D30B74DC599Fp0", "0x0.0025C993C5C0CF977p0", "0x0.0025F5F6DBE4EB900p0",
                "0x0.00262259F9BA1AD8Dp0", "0x0.00264EBD1F405EC72p0", "0x0.00267B204C77B8B03p0", "0x0.0026A783816029E92p0",
                "0x0.0026D3E6BDF9B3C74p0", "0x0.0027004A0244579FCp0", "0x0.00272CAD4E4016C7Dp0", "0x0.00275910A1ECF294Bp0",
                "0x0.00278573FD4AEC5BAp0", "0x0.0027B1D7605A0571Cp0", "0x0.0027DE3ACB1A3F2C6p0", "0x0.00280A9E3D8B9AE0Cp0",
                "0x0.00283701B7AE19E40p0", "0x0.002863653981BD8B6p0", "0x0.00288FC8C306872C3p0", "0x0.0028BC2C543C781B9p0",
                "0x0.0028E88FED2391AECp0", "0x0.002914F38DBBD53B1p0", "0x0.0029415736054415Ap0", "0x0.00296DBAE5FFDF93Cp0",
                "0x0.00299A1E9DABA90A9p0", "0x0.0029C6825D08A1CF7p0", "0x0.0029F2E62416CB378p0", "0x0.002A1F49F2D626981p0",
                "0x0.002A4BADC946B5464p0", "0x0.002A7811A76878977p0", "0x0.002AA4758D3B71E0Cp0", "0x0.002AD0D97ABFA2778p0",
                "0x0.002AFD3D6FF50BB0Ep0", "0x0.002B29A16CDBAEE23p0", "0x0.002B560571738D609p0", "0x0.002B82697DBCA8816p0",
                "0x0.002BAECD91B70199Cp0", "0x0.002BDB31AD6299FF0p0", "0x0.002C0795D0BF73066p0", "0x0.002C33F9FBCD8E052p0"
            };
            ap_ufixed<58,-10> exp2_x_msb_3_m_1 = exp2_x_msb_3_m_1_table[x_msb_ind_3];
            ap_ufixed<108,-28> f_x_msb_3_lsb = exp2_x_msb_3_m_1 * exp2_x_msb_4_lsb_m_1;
            ap_ufixed<40, -28> f_x_msb_3_lsb_s = f_x_msb_3_lsb;
            ap_ufixed<58, -10> exp2_x_msb_3_4_lsb_m_1 = f_x_msb_3_lsb_s + exp2_x_msb_3_m_1 + exp2_x_msb_4_lsb_m_1;

            const static ap_ufixed<68,0> exp2_x_msb_2_m_1_table[256] = {
                "0x0.0p0", "0x0.002C605E2E8CEC507p0", "0x0.0058C86DA1C09EA20p0", "0x0.0085382FAEF831DA9p0",
                "0x0.00B1AFA5ABCBED613p0", "0x0.00DE2ED0EE0F4F5FDp0", "0x0.010AB5B2CBD117074p0", "0x0.0137444C9B5B4ED49p0",
                "0x0.0163DA9FB33356D85p0", "0x0.019078AD6A19EEFF7p0", "0x0.01BD1E77170B415E7p0", "0x0.01E9CBFE113EEC7DCp0",
                "0x0.02168143B0280DA82p0", "0x0.02433E494B754B3ADp0", "0x0.027003103B10DEF7Dp0", "0x0.029CCF99D720A0593p0",
                "0x0.02C9A3E778060EE6Fp0", "0x0.02F67FFA765E5C8E5p0", "0x0.032363D42B0277FAAp0", "0x0.03504F75EF0716F0Cp0",
                "0x0.037D42E11BBCC0AB4p0", "0x0.03AA3E170AAFD8396p0", "0x0.03D7411915A8A6DF0p0", "0x0.04044BE896AB66771p0",
                "0x0.04315E86E7F84BD74p0", "0x0.045E78F5640B9135Cp0", "0x0.048B9B35659D8090Ep0", "0x0.04B8C54847A27E186p0",
                "0x0.04E5F72F654B12987p0", "0x0.051330EC1A03F5E6Ap0", "0x0.0540727FC1761950Dp0", "0x0.056DBBEBB786B20D9p0",
                "0x0.059B0D31585743AE8p0", "0x0.05C866520045AA948p0", "0x0.05F5C74F0BEC2665Bp0", "0x0.06233029D82164855p0",
                "0x0.0650A0E3C1F88A8D2p0", "0x0.067E197E26C140C90p0", "0x0.06AB99FA6407BCB43p0", "0x0.06D92259D794CB783p0",
                "0x0.0706B29DDF6DDC6DCp0", "0x0.07344AC7D9D50B9FCp0", "0x0.0761EAD925492C4F5p0", "0x0.078F92D32085D37A9p0",
                "0x0.07BD42B72A8362646p0", "0x0.07EAFA86A277111EFp0", "0x0.0818BA42E7D2F916Ep0", "0x0.084681ED5A461FA1Ap0",
                "0x0.0874518759BC808C3p0", "0x0.08A22912465F18AD3p0", "0x0.08D0088F8093F0774p0", "0x0.08FDF00068FE268ECp0",
                "0x0.092BDF66607DFA5FEp0", "0x0.0959D6C2C830D6B7Fp0", "0x0.0987D61701715C5F5p0", "0x0.09B5DD646DD76CB61p0",
                "0x0.09E3ECAC6F3834522p0", "0x0.0A1203F067A6359F1p0", "0x0.0A402331B97153804p0", "0x0.0A6E4A71C726DBF42p0",
                "0x0.0A9C79B1F39192BA3p0", "0x0.0ACAB0F3A1B9BBF9Fp0", "0x0.0AF8F03834E526EC8p0", "0x0.0B273781109738876p0",
                "0x0.0B5586CF9890F6299p0", "0x0.0B83DE2530D1104A2p0", "0x0.0BB23D833D93ED290p0", "0x0.0BE0A4EB2353B3818p0",
                "0x0.0C0F145E46C8553E6p0", "0x0.0C3D8BDE0CE79A306p0", "0x0.0C6C0B6BDAE52AC5Dp0", "0x0.0C9A930916329AC51p0",
                "0x0.0CC922B7247F7407Bp0", "0x0.0CF7BA776BB94138Ap0", "0x0.0D265A4B520B98932p0", "0x0.0D5502343DE026A4Bp0",
                "0x0.0D83B23395DEB90FBp0", "0x0.0DB26A4AC0ED4950Dp0", "0x0.0DE12A7B263007860p0", "0x0.0E0FF2C62D0965371p0",
                "0x0.0E3EC32D3D1A20207p0", "0x0.0E6D9BB1BE414CFFDp0", "0x0.0E9C7C55189C62628p0", "0x0.0ECB6518B4874375Bp0",
                "0x0.0EFA55FDFA9C4AD89p0", "0x0.0F294F0653B45570Ap0", "0x0.0F58503328E6CD3F5p0", "0x0.0F875985E389B439Ep0",
                "0x0.0FB66AFFED31AF232p0", "0x0.0FE584A2AFB210670p0", "0x0.1014A66F951CE2F7Ep0", "0x0.1043D06807C2F52E1p0",
                "0x0.1073028D7233E3A8Ep0", "0x0.10A23CE13F3E2431Dp0", "0x0.10D17F64D9EF10A19p0", "0x0.1100CA19AD92F1C6Bp0",
                "0x0.11301D0125B50A4ECp0", "0x0.115F781CAE1FA1B08p0", "0x0.118EDB6DB2DC0F18Dp0", "0x0.11BE46F5A032C458Fp0",
                "0x0.11EDBAB5E2AB58D6Fp0", "0x0.121D36AFE70C947FBp0", "0x0.124CBAE51A5C7ABB5p0", "0x0.127C4756E9E055631p0",
                "0x0.12ABDC06C31CBFB93p0", "0x0.12DB78F613D5B162Dp0", "0x0.130B1E264A0E8963Cp0", "0x0.133ACB98D40A191C1p0",
                "0x0.136A814F204AAF478p0", "0x0.139A3F4A9D9222FF2p0", "0x0.13CA058CBAE1DEBC9p0", "0x0.13F9D416E77AEB5F6p0",
                "0x0.1429AAEA92DDFB341p0", "0x0.14598A092CCB74FD3p0", "0x0.1489717425437EFE9p0", "0x0.14B9612CEC860A09Ep0",
                "0x0.14E95934F312DC8DCp0", "0x0.1519598DA9A99DA67p0", "0x0.154962388149E0304p0", "0x0.15797336EB332DDCAp0",
                "0x0.15A98C8A58E512481p0", "0x0.15D9AE343C1F26130p0", "0x0.1609D83606E119FBFp0", "0x0.163A0A912B6AC1FBBp0",
                "0x0.166A45471C3C2063Dp0", "0x0.169A88594C1570FE6p0", "0x0.16CAD3C92DF734306p0", "0x0.16FB279835223A1D7p0",
                "0x0.172B83C7D517ADCDFp0", "0x0.175BE85981992056Cp0", "0x0.178C554EAEA894030p0", "0x0.17BCCAA8D088877FCp0",
                "0x0.17ED48695BBC0109Ep0", "0x0.181DCE91C506999D8p0", "0x0.184E5D23816C88275p0", "0x0.187EF4200632ACB89p0",
                "0x0.18AF9388C8DE9BBBFp0", "0x0.18E03B5F3F36A92D4p0", "0x0.1910EBA4DF41F3D2Ap0", "0x0.1941A45B1F487077Ap0",
                "0x0.1972658375D2F52ABp0", "0x0.19A32F1F59AB447C4p0", "0x0.19D4013041DC18BF8p0", "0x0.1A04DBB7A5B12F4DCp0",
                "0x0.1A35BEB6FCB753CB7p0", "0x0.1A66AA2FBEBC6B6ECp0", "0x0.1A979E2363CF8048Fp0", "0x0.1AC89A936440CC90Dp0",
                "0x0.1AF99F8138A1C5EFEp0", "0x0.1B2AACEE59C528D0Dp0", "0x0.1B5BC2DC40BF03B07p0", "0x0.1B8CE14C66E4C2704p0",
                "0x0.1BBE084045CD39AB2p0", "0x0.1BEF37B95750B20C0p0", "0x0.1C206FB91588F3A67p0", "0x0.1C51B040FAD151512p0",
                "0x0.1C82F95281C6B4026p0", "0x0.1CB44AEF2547A62ECp0", "0x0.1CE5A51860745F298p0", "0x0.1D1707CFAEAECE86Cp0",
                "0x0.1D4873168B9AA7806p0", "0x0.1D79E6EE731D6C5BDp0", "0x0.1DAB6358E15E79D2Fp0", "0x0.1DDCE85752C7127E2p0",
                "0x0.1E0E75EB44026A409p0", "0x0.1E400C1631FDB1B6Ap0", "0x0.1E71AAD999E821A64p0", "0x0.1EA35236F9330670Ep0",
                "0x0.1ED5022FCD91CB882p0", "0x0.1F06BAC594FA06E38p0", "0x0.1F387BF9CDA384793p0", "0x0.1F6A45CDF60851B7Cp0",
                "0x0.1F9C18438CE4C902Bp0", "0x0.1FCDF35C11379D307p0", "0x0.1FFFD7190241E50A9p0", "0x0.2031C37BDF8726CFFp0",
                "0x0.2063B88628CD63B8Fp0", "0x0.2095B6395E1D237DAp0", "0x0.20C7BC96FFC17FDDEp0", "0x0.20F9CBA08E48302B7p0",
                "0x0.212BE3578A8194D65p0", "0x0.215E03BD7580C2FABp0", "0x0.21902CD3D09B8FF15p0", "0x0.21C25E9C1D6A9CE17p0",
                "0x0.21F49917DDC962553p0", "0x0.2226DC4893D63BCFAp0", "0x0.2259282FC1F273650p0", "0x0.228B7CCEEAC24D54Fp0",
                "0x0.22BDDA27912D13A6Ap0", "0x0.22F0403B385D21C70p0", "0x0.2322AF0B63BFF0291p0", "0x0.2355269997061FE83p0",
                "0x0.2387A6E75623866C2p0", "0x0.23BA2FF6254F390FBp0", "0x0.23ECC1C7890398C8Ap0", "0x0.241F5C5D05FE5DD26p0",
                "0x0.2451FFB82140A35A0p0", "0x0.2484ABDA600EF32CEp0", "0x0.24B760C547F15168Fp0", "0x0.24EA1E7A5EB3482F4p0",
                "0x0.251CE4FB2A63F3583p0", "0x0.254FB44931560C2A2p0", "0x0.25828C65FA1FF511Fp0", "0x0.25B56D530B9BC55D9p0",
                "0x0.25E85711ECE754F87p0", "0x0.261B49A42564482A2p0", "0x0.264E450B3CB81B573p0", "0x0.26814948BACC2EC3Ap0",
                "0x0.26B4565E27CDD257Ap0", "0x0.26E76C4D0C2E51669p0", "0x0.271A8B16F0A2FE778p0", "0x0.274DB2BD5E253F101p0",
                "0x0.2780E341DDF29781Ap0", "0x0.27B41CA5F98CB6B7Ep0", "0x0.27E75EEB3AB9820A2p0", "0x0.281AAA132B83210E1p0",
                "0x0.284DFE1F5638096CFp0", "0x0.28815B11456B0ABADp0", "0x0.28B4C0EA83F35A4FAp0", "0x0.28E82FAC9CEC9F225p0",
                "0x0.291BA7591BB6FDA67p0", "0x0.294F27F18BF723AB3p0", "0x0.2982B1777996543D0p0", "0x0.29B643EC70C273890p0",
                "0x0.29E9DF51FDEE12C26p0", "0x0.2A1D83A9ADD07C0A3p0", "0x0.2A5130F50D65BE58Dp0", "0x0.2A84E735A9EEB96A0p0",
                "0x0.2AB8A66D10F129AA3p0", "0x0.2AEC6E9CD037B426Bp0", "0x0.2B203FC675D1F27F9p0", "0x0.2B5419EB90147EDB7p0",
                "0x0.2B87FD0DAD98FFDDFp0", "0x0.2BBBE92E5D3E349F5p0", "0x0.2BEFDE4F2E2800A73p0", "0x0.2C23DC71AFBF77E86p0",
                "0x0.2C57E39771B2EABFBp0", "0x0.2C8BF3C203F5F1F3Fp0", "0x0.2CC00CF2F6C17AB8Dp0", "0x0.2CF42F2BDA93D2B35p0",
                "0x0.2D285A6E4030B4009p0", "0x0.2D5C8EBBB8A1513E7p0", "0x0.2D90CC15D53461967p0", "0x0.2DC5127E277E2CCAFp0",
                "0x0.2DF961F641589745Bp0", "0x0.2E2DBA7FB4E32E298p0", "0x0.2E621C1C148333651p0", "0x0.2E9686CCF2E3A9C88p0",
                "0x0.2ECAFA93E2F5611CAp0", "0x0.2EFF777277EF023C8p0", "0x0.2F33FD6A454D1B313p0", "0x0.2F688C7CDED22B4F1p0",
                "0x0.2F9D24ABD886AF562p0", "0x0.2FD1C5F8C6B92D937p0", "0x0.300670653DFE42058p0", "0x0.303B23F2D330AA821p0"
            };
            ap_ufixed<68,0> exp2_x_msb_2_m_1 = exp2_x_msb_2_m_1_table[x_msb_ind_2];
            ap_ufixed<126,-10> f_x_msb_2_lsb = exp2_x_msb_2_m_1 * exp2_x_msb_3_4_lsb_m_1;
            ap_ufixed<58, -10> f_x_msb_2_lsb_s = f_x_msb_2_lsb;
            ap_ufixed<68,0> exp2_x_msb_2_3_4_lsb_m_1 = f_x_msb_2_lsb_s + exp2_x_msb_2_m_1 + exp2_x_msb_3_4_lsb_m_1;

            const static ap_ufixed<68,32> exp2_x_msb_1_table[256] = {
                "0x1.000000000p0", "0x1.306FE0A32p0", "0x1.6A09E667Fp0", "0x1.AE89F995Bp0",
                "0x2.000000000p0", "0x2.60DFC1463p0", "0x2.D413CCCFEp0", "0x3.5D13F32B6p0",
                "0x4.000000000p0", "0x4.C1BF828C7p0", "0x5.A827999FDp0", "0x6.BA27E656Bp0",
                "0x8.000000000p0", "0x9.837F0518Ep0", "0xB.504F333FAp0", "0xD.744FCCAD7p0",
                "0x10.000000000p0", "0x13.06FE0A31Bp0", "0x16.A09E667F4p0", "0x1A.E89F995ADp0",
                "0x20.000000000p0", "0x26.0DFC14637p0", "0x2D.413CCCFE7p0", "0x35.D13F32B5Ap0",
                "0x40.000000000p0", "0x4C.1BF828C6Ep0", "0x5A.827999FCFp0", "0x6B.A27E656B5p0",
                "0x80.000000000p0", "0x98.37F0518DCp0", "0xB5.04F333F9Ep0", "0xD7.44FCCAD6Ap0",
                "0x100.000000000p0", "0x130.6FE0A31B7p0", "0x16A.09E667F3Cp0", "0x1AE.89F995AD4p0",
                "0x200.000000000p0", "0x260.DFC14636Ep0", "0x2D4.13CCCFE78p0", "0x35D.13F32B5A7p0",
                "0x400.000000000p0", "0x4C1.BF828C6DCp0", "0x5A8.27999FCEFp0", "0x6BA.27E656B4Fp0",
                "0x800.000000000p0", "0x983.7F0518DB9p0", "0xB50.4F333F9DEp0", "0xD74.4FCCAD69Dp0",
                "0x1000.000000000p0", "0x1306.FE0A31B71p0", "0x16A0.9E667F3BDp0", "0x1AE8.9F995AD3Bp0",
                "0x2000.000000000p0", "0x260D.FC14636E3p0", "0x2D41.3CCCFE77Ap0", "0x35D1.3F32B5A76p0",
                "0x4000.000000000p0", "0x4C1B.F828C6DC5p0", "0x5A82.7999FCEF3p0", "0x6BA2.7E656B4EBp0",
                "0x8000.000000000p0", "0x9837.F0518DB8Bp0", "0xB504.F333F9DE6p0", "0xD744.FCCAD69D7p0",
                "0x10000.000000000p0", "0x1306F.E0A31B715p0", "0x16A09.E667F3BCDp0", "0x1AE89.F995AD3ADp0",
                "0x20000.000000000p0", "0x260DF.C14636E2Ap0", "0x2D413.CCCFE7799p0", "0x35D13.F32B5A75Bp0",
                "0x40000.000000000p0", "0x4C1BF.828C6DC55p0", "0x5A827.999FCEF32p0", "0x6BA27.E656B4EB5p0",
                "0x80000.000000000p0", "0x9837F.0518DB8A9p0", "0xB504F.333F9DE65p0", "0xD744F.CCAD69D6Bp0",
                "0x100000.000000000p0", "0x1306FE.0A31B7153p0", "0x16A09E.667F3BCC9p0", "0x1AE89F.995AD3AD6p0",
                "0x200000.000000000p0", "0x260DFC.14636E2A6p0", "0x2D413C.CCFE77992p0", "0x35D13F.32B5A75ACp0",
                "0x400000.000000000p0", "0x4C1BF8.28C6DC54Bp0", "0x5A8279.99FCEF324p0", "0x6BA27E.656B4EB58p0",
                "0x800000.000000000p0", "0x9837F0.518DB8A97p0", "0xB504F3.33F9DE648p0", "0xD744FC.CAD69D6AFp0",
                "0x1000000.000000000p0", "0x1306FE0.A31B7152Ep0", "0x16A09E6.67F3BCC91p0", "0x1AE89F9.95AD3AD5Fp0",
                "0x2000000.000000000p0", "0x260DFC1.4636E2A5Cp0", "0x2D413CC.CFE779921p0", "0x35D13F3.2B5A75ABDp0",
                "0x4000000.000000000p0", "0x4C1BF82.8C6DC54B8p0", "0x5A82799.9FCEF3242p0", "0x6BA27E6.56B4EB57Ap0",
                "0x8000000.000000000p0", "0x9837F05.18DB8A96Fp0", "0xB504F33.3F9DE6484p0", "0xD744FCC.AD69D6AF4p0",
                "0x10000000.000000000p0", "0x1306FE0A.31B7152DFp0", "0x16A09E66.7F3BCC909p0", "0x1AE89F99.5AD3AD5E8p0",
                "0x20000000.000000000p0", "0x260DFC14.636E2A5BDp0", "0x2D413CCC.FE7799211p0", "0x35D13F32.B5A75ABD1p0",
                "0x40000000.000000000p0", "0x4C1BF828.C6DC54B7Ap0", "0x5A827999.FCEF32423p0", "0x6BA27E65.6B4EB57A2p0",
                "0x80000000.000000000p0", "0x9837F051.8DB8A96F4p0", "0xB504F333.F9DE64846p0", "0xD744FCCA.D69D6AF44p0",
                "0x0.000000010p0", "0x0.000000013p0", "0x0.000000017p0", "0x0.00000001Bp0",
                "0x0.000000020p0", "0x0.000000026p0", "0x0.00000002Dp0", "0x0.000000036p0",
                "0x0.000000040p0", "0x0.00000004Cp0", "0x0.00000005Bp0", "0x0.00000006Cp0",
                "0x0.000000080p0", "0x0.000000098p0", "0x0.0000000B5p0", "0x0.0000000D7p0",
                "0x0.000000100p0", "0x0.000000130p0", "0x0.00000016Ap0", "0x0.0000001AFp0",
                "0x0.000000200p0", "0x0.000000261p0", "0x0.0000002D4p0", "0x0.00000035Dp0",
                "0x0.000000400p0", "0x0.0000004C2p0", "0x0.0000005A8p0", "0x0.0000006BAp0",
                "0x0.000000800p0", "0x0.000000983p0", "0x0.000000B50p0", "0x0.000000D74p0",
                "0x0.000001000p0", "0x0.000001307p0", "0x0.0000016A1p0", "0x0.000001AE9p0",
                "0x0.000002000p0", "0x0.00000260Ep0", "0x0.000002D41p0", "0x0.0000035D1p0",
                "0x0.000004000p0", "0x0.000004C1Cp0", "0x0.000005A82p0", "0x0.000006BA2p0",
                "0x0.000008000p0", "0x0.000009838p0", "0x0.00000B505p0", "0x0.00000D745p0",
                "0x0.000010000p0", "0x0.000013070p0", "0x0.000016A0Ap0", "0x0.00001AE8Ap0",
                "0x0.000020000p0", "0x0.0000260E0p0", "0x0.00002D414p0", "0x0.000035D14p0",
                "0x0.000040000p0", "0x0.00004C1C0p0", "0x0.00005A828p0", "0x0.00006BA28p0",
                "0x0.000080000p0", "0x0.00009837Fp0", "0x0.0000B504Fp0", "0x0.0000D7450p0",
                "0x0.000100000p0", "0x0.0001306FEp0", "0x0.00016A09Ep0", "0x0.0001AE8A0p0",
                "0x0.000200000p0", "0x0.000260DFCp0", "0x0.0002D413Dp0", "0x0.00035D13Fp0",
                "0x0.000400000p0", "0x0.0004C1BF8p0", "0x0.0005A827Ap0", "0x0.0006BA27Ep0",
                "0x0.000800000p0", "0x0.0009837F0p0", "0x0.000B504F3p0", "0x0.000D744FDp0",
                "0x0.001000000p0", "0x0.001306FE1p0", "0x0.0016A09E6p0", "0x0.001AE89FAp0",
                "0x0.002000000p0", "0x0.00260DFC1p0", "0x0.002D413CDp0", "0x0.0035D13F3p0",
                "0x0.004000000p0", "0x0.004C1BF83p0", "0x0.005A8279Ap0", "0x0.006BA27E6p0",
                "0x0.008000000p0", "0x0.009837F05p0", "0x0.00B504F33p0", "0x0.00D744FCDp0",
                "0x0.010000000p0", "0x0.01306FE0Ap0", "0x0.016A09E66p0", "0x0.01AE89F99p0",
                "0x0.020000000p0", "0x0.0260DFC14p0", "0x0.02D413CCDp0", "0x0.035D13F33p0",
                "0x0.040000000p0", "0x0.04C1BF829p0", "0x0.05A82799Ap0", "0x0.06BA27E65p0",
                "0x0.080000000p0", "0x0.09837F052p0", "0x0.0B504F334p0", "0x0.0D744FCCBp0",
                "0x0.100000000p0", "0x0.1306FE0A3p0", "0x0.16A09E668p0", "0x0.1AE89F996p0",
                "0x0.200000000p0", "0x0.260DFC146p0", "0x0.2D413CCD0p0", "0x0.35D13F32Bp0",
                "0x0.400000000p0", "0x0.4C1BF828Cp0", "0x0.5A82799A0p0", "0x0.6BA27E657p0",
                "0x0.800000000p0", "0x0.9837F0519p0", "0x0.B504F3340p0", "0x0.D744FCCADp0"
            };
            ap_ufixed<68,32> exp2_x_msb_1 = exp2_x_msb_1_table[x_msb_ind_1];
            ap_ufixed<136,32> y_lo = exp2_x_msb_1 * exp2_x_msb_2_3_4_lsb_m_1;
            ap_ufixed<68,32> y_lo_s = y_lo;
            ap_ufixed<68,32> y_l = y_lo_s + exp2_x_msb_1;
            y = y_l;
        }

        if(I<33) {
            bool overf_2 = 0;
            VITIS_LOOP_2848_19: for(int j=63; j>=I+31; j--) {
#pragma HLS unroll
 if(y[j]) {
                    overf_2 = 1;
                }
            }
            if(overf_2) {
                VITIS_LOOP_2855_20: for(int j=63; j>=I+31; j--) {
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_2859_21: for(int j=I+30; j>=0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        }
        r = y;
    }
    return r;
}

template<int W, int I>
ap_ufixed<W,I> exp2(ap_ufixed<W,I> x) {
    ap_fixed<W+1,I+1> xf = x;
    return exp2(xf);
}

template<int I>
ap_int<I> exp2(ap_int<I> x) {
    ap_fixed<I,I> xf = x;
    return exp2(xf);
}

template<int I>
ap_uint<I> exp2(ap_uint<I> x) {
    ap_fixed<I+1,I+1> xf = x;
    return exp2(xf);
}


template<int W_, int I_>
ap_fixed<W_,I_> exp10(ap_fixed<W_,I_> x) {

 int F_ = W_ - I_;
    if (I_>33) return 0;
    else if (F_>32) return 0;

 int I_s_;
    int M_ = (I_-1>F_) ? (I_-1) : F_;
 if (M_==1) I_s_ = 0;
    else if (M_<4) I_s_ = 1;
    else if (M_<7) I_s_ = 2;
    else if (M_<14) I_s_ = 3;
    else if (M_<27) I_s_ = 4;
    else I_s_ = 5;

 ap_fixed<W_,I_> r;
 if(I_s_==0) {
  ap_fixed<3,2> x_l = x;
  ap_ufixed<2,1> y = 0;
  if(x_l[2]) {
   if(x_l[1]&x_l[0]) {
    y = ap_ufixed<2,1>("0x0.8p0");
   }
  } else {
   if(x_l[1]|x_l[0]) {
    y = ap_ufixed<2,1>("0x1.8p0");
   } else {
    y = ap_ufixed<2,1>("0x1.0p0");
   }
  }
  if(I_<2) {
   bool overf = 0;
   if(y[1]) {
    y[1] = 0;
    y[0] = 1;
   }
  }
  r = y;
 } else if (I_s_==1) {
  ap_fixed<7,4> x_l = x;
  ap_ufixed<6,3> y = 0;
  if((x_l[6]!=x_l[5])||(x_l[5]!=x_l[4])||(x_l[4]!=x_l[3])) {
   if(!x_l[6]) {
    y = ap_ufixed<6,3>("0x7.Ep0");
   }
  } else {
   ap_uint<4> x_ind;
   x_ind[3] = x_l[6];
   x_ind(2,0) = x_l(2,0);
   const static ap_ufixed<6,3> exp_x_ind_table[16] = {
    "0x1.000p0", "0x1.600p0", "0x1.C00p0", "0x2.600p0", "0x3.200p0", "0x4.400p0", "0x5.A00p0", "0x7.800p0",
    "0x0.200p0", "0x0.200p0", "0x0.200p0", "0x0.400p0", "0x0.600p0", "0x0.600p0", "0x0.800p0", "0x0.C00p0"
   };
   y = exp_x_ind_table[x_ind];
  }
  if(I_<4){
   bool overf = 0;
   VITIS_LOOP_2947_1: for(int j = 5; j>=I_+2; j--) {
#pragma HLS unroll
 if(y[j]) {
     overf = 1;
    }
   }
   if(overf) {
    VITIS_LOOP_2954_2: for(int j = 5; j>=I_+2; j--) {
#pragma HLS unroll
 y[j] = 0;
    }
    VITIS_LOOP_2958_3: for(int j = I_+1; j>=0; j--) {
#pragma HLS unroll
 y[j] = 1;
    }
   }
  }
  r = y;
 } else if (I_s_==2) {
  ap_fixed<13,7> x_l = x;
  ap_ufixed<12,6> y = 0;
  ap_fixed<2,2> x_l_int;
  x_l_int(1,0) = x_l(7,6);
  ap_ufixed<6,0> x_l_fract;
  x_l_fract(5,0) = x_l(5,0);
  bool overf = 0;
  VITIS_LOOP_2973_4: for(int j = 11; j >=7; j--) {
#pragma HLS unroll
 if(x_l[12]!=x_l[j]) {
    overf = 1;
   }
  }
  if(overf||((x_l_int==1)&&(x_l_fract>ap_ufixed<5,0>("0x.D0p0")))) {
   if(!x_l[12]) {
    y = ap_ufixed<12,6>("0x3F.FCp0");
   }
  } else {
   ap_uint<4> x_msb_ind;
   x_msb_ind(3,0) = x_l(7,4);
   ap_uint<4> x_lsb_ind;
   x_lsb_ind(3,0) = x_l(3,0);
   const static ap_ufixed<14,6> exp_x_msb_table[16] = {
    "0x1.00p0", "0x1.C7p0", "0x3.2Ap0", "0x5.A0p0", "0xA.00p0", "0x11.C8p0", "0x1F.9Fp0", "0x38.3Cp0",
    "0x0.03p0", "0x0.05p0", "0x0.08p0", "0x0.0Ep0", "0x0.1Ap0", "0x0.2Ep0", "0x0.51p0", "0x0.90p0"
   };
   const static ap_ufixed<14,0> exp_x_lsb_m_1_table[16] = {
    "0x0.0p0", "0x0.0960p0", "0x0.1318p0", "0x0.1D2Cp0", "0x0.27A0p0", "0x0.3274p0", "0x0.3DB0p0", "0x0.4950p0",
    "0x0.5560p0", "0x0.61E4p0", "0x0.6ED8p0", "0x0.7C4Cp0", "0x0.8A38p0", "0x0.98A8p0", "0x0.A7A4p0", "0x0.B728p0"
   };
   ap_ufixed<14,6> exp_x_msb = exp_x_msb_table[x_msb_ind];
   ap_ufixed<14,0> exp_x_lsb_m_1 = exp_x_lsb_m_1_table[x_lsb_ind];
   ap_ufixed<28,6> y_lo = exp_x_msb * exp_x_lsb_m_1;
   ap_ufixed<14,6> y_lo_s = y_lo;
   ap_ufixed<14,6> y_l = y_lo_s + exp_x_msb;
   y = y_l;
  }
  if(I_<7) {
   bool overf = 0;
   VITIS_LOOP_3005_5: for(int j = 11; j >= I_+5; j--) {
#pragma HLS unroll
 if(y[j]) {
     overf = 1;
    }
   }
   if(overf) {
    VITIS_LOOP_3012_6: for(int j = 11; j>= I_+5; j--) {
#pragma HLS unroll
 y[j] = 0;
    }
    VITIS_LOOP_3016_7: for(int j = I_+4; j>=0; j--) {
#pragma HLS unroll
 y[j] = 1;
    }
   }
  }
  r = y;
 } else if (I_s_==3) {
  ap_fixed<27,14> x_l = x;
  ap_ufixed<26,13> y = 0;
  ap_fixed<3,3> x_l_int;
  x_l_int(2,0) = x_l(15,13);
  ap_ufixed<13,0> x_l_fract;
  x_l_fract(12,0) = x_l(12,0);
  bool overf = 0;
  VITIS_LOOP_3031_8: for(int j = 25; j>=15; j--) {
#pragma HLS unroll
 if(x_l[26]!=x_l[j]) {
    overf = 1;
   }
  }
  if(overf||((x_l_int==3)&&(x_l_fract>ap_ufixed<12,0>("0x3.E9D0p0")))) {
   if(!x_l[26]) {
    y = ap_ufixed<26,13>("0x1FFF.FFF8p0");
   }
  } else {
   ap_uint<6> x_msb_ind_1;
   x_msb_ind_1[5] = x_l[26];
   x_msb_ind_1(4,0) = x_l(14,10);
   ap_uint<5> x_msb_ind_2;
   x_msb_ind_2(4,0) = x_l(9,5);
   ap_uint<5> x_lsb_ind;
   x_lsb_ind(4,0) = x_l(4,0);
   const static ap_ufixed<24,-6> exp_lsb_ind_m_1_table[32] = {
    "0x0p0", "0x0.00126C5Cp0", "0x0.0024DA0Cp0", "0x0.0037490Cp0", "0x0.0049B964p0", "0x0.005C2B0Cp0", "0x0.006E9E08p0", "0x0.0081125Cp0",
    "0x0.00938800p0", "0x0.00A5FEF8p0", "0x0.00B87748p0", "0x0.00CAF0E8p0", "0x0.00DD6BE0p0", "0x0.00EFE82Cp0", "0x0.010265C8p0", "0x0.0114E4BCp0",
    "0x0.01276508p0", "0x0.0139E6A4p0", "0x0.014C6998p0", "0x0.015EEDDCp0", "0x0.0171737Cp0", "0x0.0183FA6Cp0", "0x0.019682B4p0", "0x0.01A90C50p0",
    "0x0.01BB9744p0", "0x0.01CE238Cp0", "0x0.01E0B128p0", "0x0.01F3401Cp0", "0x0.0205D064p0", "0x0.02186204p0", "0x0.022AF4F8p0", "0x0.023D8944p0"
   };
   ap_ufixed<24,-6> exp_lsb_ind_m_1 = exp_lsb_ind_m_1_table[x_lsb_ind];
   const static ap_ufixed<29,-1> exp_msb_ind_2_m_1_table[32] = {
    "0x0p0", "0x0.02501EE8p0", "0x0.04A5975Cp0", "0x0.070075C0p0", "0x0.0960C68Cp0", "0x0.0BC69660p0", "0x0.0E31F1F0p0", "0x0.10A2E60Cp0",
    "0x0.13197FA8p0", "0x0.1595CBD4p0", "0x0.1817D7BCp0", "0x0.1A9FB0ACp0", "0x0.1D2D6410p0", "0x0.1FC0FF74p0", "0x0.225A9080p0", "0x0.24FA24F8p0",
    "0x0.279FCACCp0", "0x0.2A4B8FFCp0", "0x0.2CFD82BCp0", "0x0.2FB5B150p0", "0x0.32742A20p0", "0x0.3538FBC0p0", "0x0.380434D8p0", "0x0.3AD5E43Cp0",
    "0x0.3DAE18DCp0", "0x0.408CE1CCp0", "0x0.43724E48p0", "0x0.465E6DA8p0", "0x0.49514F68p0", "0x0.4C4B0330p0", "0x0.4F4B98C4p0", "0x0.5253200Cp0"
   };
   ap_ufixed<29,-1> exp_msb_ind_2_m1 = exp_msb_ind_2_m_1_table[x_msb_ind_2];
   ap_ufixed<53,-7> f_x_msb_2_lsb = exp_lsb_ind_m_1 * exp_msb_ind_2_m1;
   ap_ufixed<27,-1> exp_msb_2_lsb_m_1 = f_x_msb_2_lsb + exp_msb_ind_2_m1 + exp_lsb_ind_m_1;
   const static ap_ufixed<28,13> exp_msb_ind_1_table[64] = {
    "0x1.0000p0", "0x1.5562p0", "0x1.C73Ep0", "0x2.5F12p0", "0x3.298Cp0", "0x4.378Cp0", "0x5.9F98p0", "0x7.7FBAp0",
    "0xA.0000p0", "0xD.55D0p0", "0x11.C866p0", "0x17.B6B8p0", "0x1F.9F6Ep0", "0x2A.2B6Ep0", "0x38.3BF0p0", "0x4A.FD4Ap0",
    "0x64.0000p0", "0x85.5A26p0", "0xB1.D3F4p0", "0xED.232Ap0", "0x13C.3A4Ep0", "0x1A5.B24Ep0", "0x232.5762p0", "0x2ED.E4EAp0",
    "0x3E8.0000p0", "0x535.857Cp0", "0x6F2.4788p0", "0x943.5FACp0", "0xC5A.4714p0", "0x1078.F70Cp0", "0x15F7.69CAp0", "0x1D4A.F12Ep0",
    "0x0.0006p0", "0x0.0008p0", "0x0.000Cp0", "0x0.0010p0", "0x0.0014p0", "0x0.001Cp0", "0x0.0024p0", "0x0.0032p0",
    "0x0.0042p0", "0x0.0058p0", "0x0.0074p0", "0x0.009Cp0", "0x0.00D0p0", "0x0.0114p0", "0x0.0170p0", "0x0.01ECp0",
    "0x0.0290p0", "0x0.036Ap0", "0x0.048Ep0", "0x0.0612p0", "0x0.0818p0", "0x0.0ACCp0", "0x0.0E66p0", "0x0.1332p0",
    "0x0.199Ap0", "0x0.2224p0", "0x0.2D86p0", "0x0.3CB6p0", "0x0.50F4p0", "0x0.6BF4p0", "0x0.8FF6p0", "0x0.BFFAp0"
   };
   ap_ufixed<28,13> exp_msb_ind_1 = exp_msb_ind_1_table[x_msb_ind_1];
   ap_ufixed<28,13> f_x_msb_1_msb_2_lsb_l = exp_msb_ind_1 * exp_msb_2_lsb_m_1;
   y = f_x_msb_1_msb_2_lsb_l + exp_msb_ind_1;
  }
  if(I_<14) {
   bool overf = 0;
   VITIS_LOOP_3081_9: for(int j = 25; j>= I_+12; j--) {
#pragma HLS unroll
 if(y[j]) {
     overf = 1;
    }
   }
   if(overf) {
    VITIS_LOOP_3088_10: for(int j = 25; j>=I_+12; j--) {
#pragma HLS unroll
 y[j] = 0;
    }
    VITIS_LOOP_3092_11: for(int j = I_+11; j>=0; j--) {
#pragma HLS unroll
 y[j] = 1;
    }
   }
  }
  r = y;
 } else if (I_s_==4) {
  ap_fixed<53,27> x_l = x;
  ap_ufixed<52,26> y = 0;
  ap_fixed<4,4> x_l_int;
  x_l_int(3,0) = x_l(29,26);
  ap_ufixed<26,0> x_l_fract;
  x_l_fract(25,0) = x_l(25,0);
  bool overf = 0;
  VITIS_LOOP_3107_12: for(int j = 51; j >= 29; j--) {
#pragma HLS unroll
 if(x_l[52]!=x_l[j]) {
    overf = 1;
   }
  }
  if(overf||((x_l_int==7)&&(x_l_fract>ap_ufixed<26,0>("0x0.D3A7D8C")))) {
   if(!x_l[52]) {
    y = ap_ufixed<52,26>("0x3FFFFFF.FFFFFFCp0");
   }
  } else {
   ap_uint<8> x_msb_ind_1;
   x_msb_ind_1[7] = x_l[52];
   x_msb_ind_1(6,0) = x_l(28,22);
   ap_uint<8> x_msb_ind_2;
   x_msb_ind_2(7,0) = x_l(21,14);
   ap_uint<7> x_msb_ind_3;
   x_msb_ind_3(6,0) = x_l(13,7);
   ap_uint<7> x_lsb_ind;
   x_lsb_ind(6,0) = x_l(6,0);
   const static ap_ufixed<41,-17> exp_lsb_ind_m_1_table[128] = {
    "0x0.0p0", "0x0.000000935D8E080p0", "0x0.00000126BB1C650p0", "0x0.000001BA18AB16Cp0", "0x0.0000024D763A1D4p0", "0x0.000002E0D3C978Cp0", "0x0.000003743159290p0", "0x0.000004078EE92E0p0",
    "0x0.0000049AEC79880p0", "0x0.0000052E4A0A368p0", "0x0.000005C1A79B3A4p0", "0x0.00000655052C928p0", "0x0.000006E862BE3FCp0", "0x0.0000077BC05041Cp0", "0x0.0000080F1DE298Cp0", "0x0.000008A27B75448p0",
    "0x0.00000935D908450p0", "0x0.000009C9369B9A4p0", "0x0.00000A5C942F448p0", "0x0.00000AEFF1C3438p0", "0x0.00000B834F57978p0", "0x0.00000C16ACEC400p0", "0x0.00000CAA0A813D8p0", "0x0.00000D3D6816900p0",
    "0x0.00000DD0C5AC370p0", "0x0.00000E642342334p0", "0x0.00000EF780D8840p0", "0x0.00000F8ADE6F29Cp0", "0x0.0000101E3C06244p0", "0x0.000010B1999D738p0", "0x0.00001144F73517Cp0", "0x0.000011D854CD10Cp0",
    "0x0.0000126BB2655E8p0", "0x0.000012FF0FFE010p0", "0x0.000013926D96F88p0", "0x0.00001425CB30450p0", "0x0.000014B928C9E60p0", "0x0.0000154C8663DC0p0", "0x0.000015DFE3FE26Cp0", "0x0.000016734198C68p0",
    "0x0.000017069F33BB0p0", "0x0.00001799FCCF044p0", "0x0.0000182D5A6AA24p0", "0x0.000018C0B806954p0", "0x0.0000195415A2DD0p0", "0x0.000019E7733F79Cp0", "0x0.00001A7AD0DC6B4p0", "0x0.00001B0E2E79B18p0",
    "0x0.00001BA18C174C8p0", "0x0.00001C34E9B53C8p0", "0x0.00001CC84753814p0", "0x0.00001D5BA4F21B0p0", "0x0.00001DEF0291094p0", "0x0.00001E8260304C8p0", "0x0.00001F15BDCFE4Cp0", "0x0.00001FA91B6FD18p0",
    "0x0.0000203C7910134p0", "0x0.000020CFD6B0AA0p0", "0x0.000021633451954p0", "0x0.000021F691F2D58p0", "0x0.00002289EF946ACp0", "0x0.0000231D4D36548p0", "0x0.000023B0AAD8934p0", "0x0.00002444087B270p0",
    "0x0.000024D7661E0F4p0", "0x0.0000256AC3C14C8p0", "0x0.000025FE2164DE8p0", "0x0.000026917F08C58p0", "0x0.00002724DCAD014p0", "0x0.000027B83A5191Cp0", "0x0.0000284B97F6774p0", "0x0.000028DEF59BB14p0",
    "0x0.000029725341408p0", "0x0.00002A05B0E7244p0", "0x0.00002A990E8D5D0p0", "0x0.00002B2C6C33EA8p0", "0x0.00002BBFC9DACD0p0", "0x0.00002C532782040p0", "0x0.00002CE68529900p0", "0x0.00002D79E2D1710p0",
    "0x0.00002E0D4079A6Cp0", "0x0.00002EA09E22314p0", "0x0.00002F33FBCB108p0", "0x0.00002FC7597444Cp0", "0x0.0000305AB71DCDCp0", "0x0.000030EE14C7AB8p0", "0x0.000031817271DE4p0", "0x0.00003214D01C65Cp0",
    "0x0.000032A82DC7420p0", "0x0.0000333B8B72734p0", "0x0.000033CEE91DF94p0", "0x0.0000346246C9D40p0", "0x0.000034F5A47603Cp0", "0x0.000035890222884p0", "0x0.0000361C5FCF618p0", "0x0.000036AFBD7C8FCp0",
    "0x0.000037431B2A12Cp0", "0x0.000037D678D7EA8p0", "0x0.00003869D686170p0", "0x0.000038FD3434988p0", "0x0.0000399091E36ECp0", "0x0.00003A23EF929A0p0", "0x0.00003AB74D421A0p0", "0x0.00003B4AAAF1EECp0",
    "0x0.00003BDE08A2188p0", "0x0.00003C71665296Cp0", "0x0.00003D04C4036A0p0", "0x0.00003D9821B4924p0", "0x0.00003E2B7F660F4p0", "0x0.00003EBEDD17E10p0", "0x0.00003F523ACA078p0", "0x0.00003FE5987C830p0",
    "0x0.00004078F62F534p0", "0x0.0000410C53E2788p0", "0x0.0000419FB195F24p0", "0x0.000042330F49C10p0", "0x0.000042C66CFDE4Cp0", "0x0.00004359CAB25D0p0", "0x0.000043ED28672A4p0", "0x0.00004480861C4C8p0",
    "0x0.00004513E3D1C34p0", "0x0.000045A741878F0p0", "0x0.0000463A9F3DAFCp0", "0x0.000046CDFCF4250p0", "0x0.000047615AAAEF4p0", "0x0.000047F4B8620E8p0", "0x0.000048881619824p0", "0x0.0000491B73D14B0p0"
   };
   ap_ufixed<41,-17> exp_lsb_ind_m_1 = exp_lsb_ind_m_1_table[x_lsb_ind];
   const static ap_ufixed<48,-10> exp_msb_ind_3_m_1_table[128] = {
    "0x0.0p0", "0x0.000049AED18968Cp0", "0x0.0000935DB847FC4p0", "0x0.0000DD0CB43BC10p0", "0x0.000126BBC564BCCp0", "0x0.0001706AEBC2F58p0", "0x0.0001BA1A275671Cp0", "0x0.000203C9781F374p0",
    "0x0.00024D78DE1D4C8p0", "0x0.000297285950B74p0", "0x0.0002E0D7E9B97D8p0", "0x0.00032A878F57A5Cp0", "0x0.000374374A2B360p0", "0x0.0003BDE71A34344p0", "0x0.00040796FF72A68p0", "0x0.00045146F9E6930p0",
    "0x0.00049AF70990000p0", "0x0.0004E4A72E6EF34p0", "0x0.00052E576883734p0", "0x0.00057807B7CD85Cp0", "0x0.0005C1B81C4D314p0", "0x0.00060B6896027B4p0", "0x0.0006551924ED6A8p0", "0x0.00069EC9C90E04Cp0",
    "0x0.0006E87A8264500p0", "0x0.0007322B50F052Cp0", "0x0.00077BDC34B2130p0", "0x0.0007C58D2DA9968p0", "0x0.00080F3E3BD6E3Cp0", "0x0.000858EF5F3A008p0", "0x0.0008A2A097D2F34p0", "0x0.0008EC51E5A1C1Cp0",
    "0x0.0009360348A6724p0", "0x0.00097FB4C0E10B0p0", "0x0.0009C9664E51920p0", "0x0.000A1317F0F80D4p0", "0x0.000A5CC9A8D4830p0", "0x0.000AA67B75E6F94p0", "0x0.000AF02D582F764p0", "0x0.000B39DF4FADFFCp0",
    "0x0.000B83915C629C4p0", "0x0.000BCD437E4D51Cp0", "0x0.000C16F5B56E268p0", "0x0.000C60A801C5200p0", "0x0.000CAA5A6352450p0", "0x0.000CF40CDA159B8p0", "0x0.000D3DBF660F294p0", "0x0.000D8772073EF4Cp0",
    "0x0.000DD124BDA5040p0", "0x0.000E1AD789415CCp0", "0x0.000E648A6A1405Cp0", "0x0.000EAE3D601D048p0", "0x0.000EF7F06B5C5F8p0", "0x0.000F41A38BD21CCp0", "0x0.000F8B56C17E424p0", "0x0.000FD50A0C60D64p0",
    "0x0.00101EBD6C79DECp0", "0x0.00106870E1C9620p0", "0x0.0010B2246C4F660p0", "0x0.0010FBD80C0BF0Cp0", "0x0.0011458BC0FF088p0", "0x0.00118F3F8B28B34p0", "0x0.0011D8F36A88F74p0", "0x0.001222A75F1FDA8p0",
    "0x0.00126C5B68ED630p0", "0x0.0012B60F87F1974p0", "0x0.0012FFC3BC2C7D0p0", "0x0.00134978059E1A8p0", "0x0.0013932C644675Cp0", "0x0.0013DCE0D82594Cp0", "0x0.00142695613B7E0p0", "0x0.00147049FF88374p0",
    "0x0.0014B9FEB30BC70p0", "0x0.001503B37BC632Cp0", "0x0.00154D6859B7810p0", "0x0.0015971D4CDFB80p0", "0x0.0015E0D2553EDD8p0", "0x0.00162A8772D4F7Cp0", "0x0.0016743CA5A20D0p0", "0x0.0016BDF1EDA6230p0",
    "0x0.001707A74AE1404p0", "0x0.0017515CBD536ACp0", "0x0.00179B1244FCA88p0", "0x0.0017E4C7E1DCFF8p0", "0x0.00182E7D93F4760p0", "0x0.001878335B43124p0", "0x0.0018C1E937C8DA4p0", "0x0.00190B9F2985D40p0",
    "0x0.00195555307A05Cp0", "0x0.00199F0B4CA5758p0", "0x0.0019E8C17E08294p0", "0x0.001A3277C4A2278p0", "0x0.001A7C2E2073760p0", "0x0.001AC5E4917C1ACp0", "0x0.001B0F9B17BC1C4p0", "0x0.001B5951B333808p0",
    "0x0.001BA30863E24D8p0", "0x0.001BECBF29C8894p0", "0x0.001C367604E63A4p0", "0x0.001C802CF53B664p0", "0x0.001CC9E3FAC8134p0", "0x0.001D139B158C47Cp0", "0x0.001D5D52458809Cp0", "0x0.001DA7098ABB5F4p0",
    "0x0.001DF0C0E5264E4p0", "0x0.001E3A7854C8DD0p0", "0x0.001E842FD9A311Cp0", "0x0.001ECDE773B4F24p0", "0x0.001F179F22FE850p0", "0x0.001F6156E77FCFCp0", "0x0.001FAB0EC138D90p0", "0x0.001FF4C6B029A68p0",
    "0x0.00203E7EB4523E8p0", "0x0.00208836CDB2A70p0", "0x0.0020D1EEFC4AE68p0", "0x0.00211BA7401B028p0", "0x0.0021655F9923018p0", "0x0.0021AF180762E98p0", "0x0.0021F8D08ADAC0Cp0", "0x0.00224289238A8D4p0",
    "0x0.00228C41D172550p0", "0x0.0022D5FA94921E4p0", "0x0.00231FB36CE9EF0p0", "0x0.0023696C5A79CD8p0", "0x0.0023B3255D41BFCp0", "0x0.0023FCDE7541CC0p0", "0x0.00244697A279F80p0", "0x0.00249050E4EA4A4p0"
   };
   ap_ufixed<48,-10> exp_msb_ind_3_m_1 = exp_msb_ind_3_m_1_table[x_msb_ind_3];
   ap_ufixed<89,-27> f_x_msb_ind_3_lsb = exp_lsb_ind_m_1 * exp_msb_ind_3_m_1;
   ap_ufixed<46,-10> exp_msb_ind_3_lsb_ind_m_1 = f_x_msb_ind_3_lsb + exp_lsb_ind_m_1 + exp_msb_ind_3_m_1;
   const static ap_ufixed<54,-2> exp_msb_ind_2_m_1_table[256] = {
    "0x0.0p0", "0x0.0024DA0A3C92C9p0", "0x0.0049B96285BC0Ap0", "0x0.006E9E099EFA37p0", "0x0.009388004BE7E5p0", "0x0.00B87747503BD4p0", "0x0.00DD6BDF6FC8EEp0", "0x0.010265C96E7E4Fp0",
    "0x0.01276506106748p0", "0x0.014C699619AB60p0", "0x0.0171737A4E8E5Ep0", "0x0.019682B3737048p0", "0x0.01BB97424CCD67p0", "0x0.01E0B1279F3E51p0", "0x0.0205D0642F77E5p0", "0x0.022AF4F8C24B54p0",
    "0x0.02501EE61CA626p0", "0x0.02754E2D03923Bp0", "0x0.029A82CE3C35CEp0", "0x0.02BFBCCA8BD37Fp0", "0x0.02E4FC22B7CA50p0", "0x0.030A40D78595AFp0", "0x0.032F8AE9BACD76p0", "0x0.0354DA5A1D25F2p0",
    "0x0.037A2F29726FE5p0", "0x0.039F895880988Ap0", "0x0.03C4E8E80DA99Bp0", "0x0.03EA4DD8DFC955p0", "0x0.040FB82BBD3A78p0", "0x0.043527E16C5C51p0", "0x0.045A9CFAB3AABBp0", "0x0.0480177859BE22p0",
    "0x0.04A5975B254B8Bp0", "0x0.04CB1CA3DD2493p0", "0x0.04F0A753483778p0", "0x0.0516376A2D8F1Ap0", "0x0.053BCCE95452FFp0", "0x0.056167D183C75Bp0", "0x0.05870823834D0Ep0", "0x0.05ACADE01A61AEp0",
    "0x0.05D25908109F88p0", "0x0.05F8099C2DBDA3p0", "0x0.061DBF9D398FC8p0", "0x0.06437B0BFC0683p0", "0x0.06693BE93D2F28p0", "0x0.068F0235C533D7p0", "0x0.06B4CDF25C5B83p0", "0x0.06DA9F1FCB09EFp0",
    "0x0.070075BED9BFBBp0", "0x0.072651D0511A61p0", "0x0.074C3354F9D43Dp0", "0x0.07721A4D9CC491p0", "0x0.079806BB02DF87p0", "0x0.07BDF89DF53637p0", "0x0.07E3EFF73CF6ACp0", "0x0.0809ECC7A36BE3p0",
    "0x0.082FEF0FF1FDD7p0", "0x0.0855F6D0F23180p0", "0x0.087C040B6DA8D8p0", "0x0.08A216C02E22DFp0", "0x0.08C82EEFFD7BA0p0", "0x0.08EE4C9BA5AC35p0", "0x0.09146FC3F0CACCp0", "0x0.093A9869A90AA9p0",
    "0x0.0960C68D98BC2Cp0", "0x0.0986FA308A4CD4p0", "0x0.09AD3353484744p0", "0x0.09D371F69D5348p0", "0x0.09F9B61B5435D7p0", "0x0.0A1FFFC237D119p0", "0x0.0A464EEC13246Bp0", "0x0.0A6CA399B14C61p0",
    "0x0.0A92FDCBDD82CEp0", "0x0.0AB95D83631EC5p0", "0x0.0ADFC2C10D94A0p0", "0x0.0B062D85A87601p0", "0x0.0B2C9DD1FF71D8p0", "0x0.0B5313A6DE5467p0", "0x0.0B798F05110749p0", "0x0.0BA00FED63916Fp0",
    "0x0.0BC69660A2172Dp0", "0x0.0BED225F98DA36p0", "0x0.0C13B3EB1439A8p0", "0x0.0C3A4B03E0B20Ap0", "0x0.0C60E7AACADD54p0", "0x0.0C8789E09F72F1p0", "0x0.0CAE31A62B47C4p0", "0x0.0CD4DEFC3B4E2Dp0",
    "0x0.0CFB91E39C960Dp0", "0x0.0D224A5D1C4CC9p0", "0x0.0D49086987BD4Fp0", "0x0.0D6FCC09AC501Cp0", "0x0.0D96953E578B3Ep0", "0x0.0DBD6408571257p0", "0x0.0DE4386878A6A5p0", "0x0.0E0B125F8A2704p0",
    "0x0.0E31F1EE598FF3p0", "0x0.0E58D715B4FB98p0", "0x0.0E7FC1D66AA1C4p0", "0x0.0EA6B23148D7F6p0", "0x0.0ECDA8271E1164p0", "0x0.0EF4A3B8B8DEF8p0", "0x0.0F1BA4E6E7EF5Dp0", "0x0.0F42ABB27A0EFAp0",
    "0x0.0F69B81C3E27FEp0", "0x0.0F90CA25034260p0", "0x0.0FB7E1CD9883E5p0", "0x0.0FDEFF16CD3022p0", "0x0.1006220170A885p0", "0x0.102D4A8E526C53p0", "0x0.105478BE4218B3p0", "0x0.107BAC920F68ACp0",
    "0x0.10A2E60A8A352Ep0", "0x0.10CA2528827515p0", "0x0.10F169ECC83D2Ap0", "0x0.1118B4582BC02Dp0", "0x0.1140046B7D4ED5p0", "0x0.11675A278D57D7p0", "0x0.118EB58D2C67E8p0", "0x0.11B6169D2B29C2p0",
    "0x0.11DD7D585A662Bp0", "0x0.1204E9BF8B03F4p0", "0x0.122C5BD38E0803p0", "0x0.1253D395349553p0", "0x0.127B51054FECFBp0", "0x0.12A2D424B16E31p0", "0x0.12CA5CF42A964Fp0", "0x0.12F1EB748D00D7p0",
    "0x0.13197FA6AA6777p0", "0x0.1341198B54A20Dp0", "0x0.1368B9235DA6AEp0", "0x0.13905E6F9789A8p0", "0x0.13B80970D47D86p0", "0x0.13DFBA27E6D314p0", "0x0.14077095A0F967p0", "0x0.142F2CBAD57DDEp0",
    "0x0.1456EE98570C27p0", "0x0.147EB62EF86E43p0", "0x0.14A6837F8C8C8Cp0", "0x0.14CE568AE66DB7p0", "0x0.14F62F51D936DBp0", "0x0.151E0DD5382B74p0", "0x0.1545F215D6AD66p0", "0x0.156DDC14883D04p0",
    "0x0.1595CBD2207913p0", "0x0.15BDC14F731ECFp0", "0x0.15E5BC8D5409EEp0", "0x0.160DBD8C9734A6p0", "0x0.1635C44E10B7B0p0", "0x0.165DD0D294CA4Ep0", "0x0.1685E31AF7C24Ep0", "0x0.16ADFB280E140Fp0",
    "0x0.16D618FAAC5286p0", "0x0.16FE3C93A72F41p0", "0x0.172665F3D37A6Cp0", "0x0.174E951C0622D6p0", "0x0.1776CA0D1435F4p0", "0x0.179F04C7D2DFE7p0", "0x0.17C7454D176B81p0", "0x0.17EF8B9DB74247p0",
    "0x0.1817D7BA87EC75p0", "0x0.184029A45F1107p0", "0x0.1868815C1275B9p0", "0x0.1890DEE277FF0Dp0", "0x0.18B9423865B04Fp0", "0x0.18E1AB5EB1AB9Ap0", "0x0.190A1A563231DCp0", "0x0.19328F1FBDA2DCp0",
    "0x0.195B09BC2A7D3Ap0", "0x0.19838A2C4F5E7Ap0", "0x0.19AC1071030303p0", "0x0.19D49C8B1C4625p0", "0x0.19FD2E7B722220p0", "0x0.1A25C642DBB023p0", "0x0.1A4E63E2302857p0", "0x0.1A77075A46E1DEp0",
    "0x0.1A9FB0ABF752DBp0", "0x0.1AC85FD8191074p0", "0x0.1AF114DF83CED8p0", "0x0.1B19CFC30F6145p0", "0x0.1B42908393BA07p0", "0x0.1B6B5721E8EA82p0", "0x0.1B94239EE72334p0", "0x0.1BBCF5FB66B3BCp0",
    "0x0.1BE5CE38400AD8p0", "0x0.1C0EAC564BB672p0", "0x0.1C37905662639Fp0", "0x0.1C607A395CDEA5p0", "0x0.1C896A001412FEp0", "0x0.1CB25FAB610B61p0", "0x0.1CDB5B3C1CF1BFp0", "0x0.1D045CB3210F50p0",
    "0x0.1D2D641146CC91p0", "0x0.1D56715767B14Cp0", "0x0.1D7F84865D649Ap0", "0x0.1DA89D9F01ACEBp0", "0x0.1DD1BCA22E7006p0", "0x0.1DFAE190BDB311p0", "0x0.1E240C6B899A96p0", "0x0.1E4D3D336C6A83p0",
    "0x0.1E7673E9408633p0", "0x0.1E9FB08DE07072p0", "0x0.1EC8F32226CB7Ep0", "0x0.1EF23BA6EE590Fp0", "0x0.1F1B8A1D11FA5Cp0", "0x0.1F44DE856CB01Dp0", "0x0.1F6E38E0D99A90p0", "0x0.1F97993033F980p0",
    "0x0.1FC0FF74572C45p0", "0x0.1FEA6BAE1EB1CEp0", "0x0.2013DDDE6628A0p0", "0x0.203D5606094EE1p0", "0x0.2066D425E40256p0", "0x0.2090583ED2406Ap0", "0x0.20B9E251B02636p0", "0x0.20E3725F59F080p0",
    "0x0.210D0868ABFBC3p0", "0x0.2136A46E82C433p0", "0x0.21604671BAE5C1p0", "0x0.2189EE73311C20p0", "0x0.21B39C73C242C8p0", "0x0.21DD50744B54FDp0", "0x0.22070A75A96DD4p0", "0x0.2230CA78B9C835p0",
    "0x0.225A907E59BEDFp0", "0x0.22845C8766CC70p0", "0x0.22AE2E94BE8B69p0", "0x0.22D806A73EB62Fp0", "0x0.2301E4BFC52713p0", "0x0.232BC8DF2FD857p0", "0x0.2355B3065CE42Fp0", "0x0.237FA3362A84CAp0",
    "0x0.23A9996F771453p0", "0x0.23D395B3210CF7p0", "0x0.23FD98020708EAp0", "0x0.2427A05D07C26Dp0", "0x0.2451AEC50213CEp0", "0x0.247BC33AD4F771p0", "0x0.24A5DDBF5F87D3p0", "0x0.24CFFE5380FF8Fp0",
    "0x0.24FA24F818B962p0", "0x0.252451AE063030p0", "0x0.254E847628FF09p0", "0x0.2578BD5160E12Cp0", "0x0.25A2FC408DB20Fp0", "0x0.25CD41448F6D5Fp0", "0x0.25F78C5E462F0Ap0", "0x0.2621DD8E92333Fp0",
    "0x0.264C34D653D674p0", "0x0.267692366B956Dp0", "0x0.26A0F5AFBA0D3Cp0", "0x0.26CB5F431FFB4Cp0", "0x0.26F5CEF17E3D5Fp0", "0x0.272044BBB5D196p0", "0x0.274AC0A2A7D678p0", "0x0.277542A7358AF1p0"
   };
   ap_ufixed<54,-2> exp_msb_ind_2_m_1 = exp_msb_ind_2_m_1_table[x_msb_ind_2];
   ap_ufixed<100,-12> f_x_msb_ind_2_msb_ind3_lsb = exp_msb_ind_3_lsb_ind_m_1 * exp_msb_ind_2_m_1;
   ap_ufixed<52,-2> exp_msb_ind2_msb_ind3_lsb_ind_m_1 = f_x_msb_ind_2_msb_ind3_lsb + exp_msb_ind_3_lsb_ind_m_1 + exp_msb_ind_2_m_1;
   const static ap_ufixed<54,26> exp_msb_ind_1_table[256] = {
    "0x1.0000000p0", "0x1.279FCADp0", "0x1.5561A92p0", "0x1.8A389FFp0", "0x1.C73D51Cp0", "0x2.0DB3D0Fp0", "0x2.5F1258Ep0", "0x2.BD0911Bp0",
    "0x3.298B076p0", "0x3.A6D8842p0", "0x4.378B054p0", "0x4.DEA3099p0", "0x5.9F9802Dp0", "0x6.7E6ABF0p0", "0x7.7FBAAB4p0", "0x8.A8DE610p0",
    "0xA.0000000p0", "0xB.8C3DEBEp0", "0xD.55D09B1p0", "0xF.66363F8p0", "0x11.C86531Bp0", "0x14.8906295p0", "0x17.B6B778Cp0", "0x1B.625AB10p0",
    "0x1F.9F6E499p0", "0x24.8475291p0", "0x2A.2B6E347p0", "0x30.B25E5F8p0", "0x38.3BF01BEp0", "0x40.F02B75Fp0", "0x4A.FD4AB0Bp0", "0x56.98AFCA2p0",
    "0x64.0000000p0", "0x73.7A6B370p0", "0x85.5A260EDp0", "0x99.FE1E7B3p0", "0xB1.D3F3F11p0", "0xCD.5A3D9D0p0", "0xED.232AB7Bp0", "0x111.D78AEA4p0",
    "0x13C.3A4EDFBp0", "0x16D.2C939A9p0", "0x1A5.B24E0C7p0", "0x1E6.F7AFBABp0", "0x232.5761167p0", "0x289.61B29B6p0", "0x2ED.E4EAE72p0", "0x361.F6DDE55p0",
    "0x3E8.0000000p0", "0x482.C830261p0", "0x535.857C941p0", "0x603.ED30CFDp0", "0x6F2.47876A9p0", "0x805.8668224p0", "0x943.5FAB2CAp0", "0xAB2.6B6D26Bp0",
    "0xC5A.4714BCAp0", "0xE43.BDC409Bp0", "0x1078.F70C7CBp0", "0x1305.ACDD4AFp0", "0x15F7.69CAE07p0", "0x195D.D0FA11Ep0", "0x1D4A.F12D073p0", "0x21D3.A4AAF51p0",
    "0x2710.0000000p0", "0x2D1B.D1E17C7p0", "0x3417.36DDC85p0", "0x3C27.43E81E5p0", "0x4576.CB4A29Cp0", "0x5037.401156Cp0", "0x5CA1.BCAFBE1p0", "0x6AF8.324382Fp0",
    "0x7B86.C6CF5E3p0", "0x8EA5.69A8609p0", "0xA4B9.A67CDEAp0", "0xBE38.C0A4ED5p0", "0xDBAA.21ECC48p0", "0xFDAA.29C4B2Ap0", "0x124ED.6BC2480p0", "0x15244.6EAD929p0",
    "0x186A0.0000000p0", "0x1C316.32CEDC6p0", "0x208E8.24A9D35p0", "0x25988.A7112F0p0", "0x2B6A3.F0E5A19p0", "0x32228.80AD63Cp0", "0x39E51.5EDD6CAp0", "0x42DB1.F6A31D7p0",
    "0x4D343.C419ADFp0", "0x59276.2093C5Ep0", "0x66F40.80E0B21p0", "0x76E37.8671452p0", "0x894A5.533FACCp0", "0x9E8A5.A1AEFA8p0", "0xB7146.3596CFDp0", "0xD36AC.52C7B9Bp0",
    "0xF4240.0000000p0", "0x119EDD.FC149BCp0", "0x145911.6EA2417p0", "0x177F56.86ABD5Cp0", "0x1B2267.68F84F9p0", "0x1F5595.06C5E54p0", "0x242F2D.B4A63E0p0", "0x29C8F3.A25F263p0",
    "0x3040A5.A900CB8p0", "0x37B89D.45C5BB0p0", "0x405885.08C6F4Ap0", "0x4A4E2B.406CB33p0", "0x55CE75.407CBF4p0", "0x631678.50D5C93p0", "0x726CBE.17E41E4p0", "0x8422BB.3BCD40Ap0",
    "0x989680.0000000p0", "0xB034AB.D8CE155p0", "0xCB7AAE.52568E6p0", "0xEAF961.42B6594p0", "0x10F580A.19B31BCp0", "0x13957D2.43BAF49p0", "0x169D7C9.0E7E6C2p0", "0x1A1D984.57B77DEp0",
    "0x1E28678.9A07F2Fp0", "0x22D3624.B9B94DFp0", "0x2837532.57C58E8p0", "0x2E70DB0.843F002p0", "0x35A1094.84DF78Cp0", "0x3DEE0B3.2859DBCp0", "0x4783F6C.EEE92ECp0", "0x5295B50.5604864p0",
    "0x0.0000003p0", "0x0.0000003p0", "0x0.0000004p0", "0x0.0000004p0", "0x0.0000005p0", "0x0.0000006p0", "0x0.0000006p0", "0x0.0000007p0",
    "0x0.0000008p0", "0x0.000000Ap0", "0x0.000000Bp0", "0x0.000000Dp0", "0x0.000000Fp0", "0x0.0000011p0", "0x0.0000014p0", "0x0.0000017p0",
    "0x0.000001Bp0", "0x0.000001Fp0", "0x0.0000024p0", "0x0.0000029p0", "0x0.0000030p0", "0x0.0000037p0", "0x0.0000040p0", "0x0.000004Ap0",
    "0x0.0000055p0", "0x0.0000062p0", "0x0.0000071p0", "0x0.0000083p0", "0x0.0000097p0", "0x0.00000AEp0", "0x0.00000C9p0", "0x0.00000E8p0",
    "0x0.000010Cp0", "0x0.0000136p0", "0x0.0000166p0", "0x0.000019Dp0", "0x0.00001DDp0", "0x0.0000227p0", "0x0.000027Dp0", "0x0.00002DFp0",
    "0x0.0000351p0", "0x0.00003D4p0", "0x0.000046Cp0", "0x0.000051Bp0", "0x0.00005E6p0", "0x0.00006CFp0", "0x0.00007DDp0", "0x0.0000915p0",
    "0x0.0000A7Cp0", "0x0.0000C1Cp0", "0x0.0000DFCp0", "0x0.0001026p0", "0x0.00012A6p0", "0x0.0001588p0", "0x0.00018DEp0", "0x0.0001CB7p0",
    "0x0.0002129p0", "0x0.000264Bp0", "0x0.0002C38p0", "0x0.0003310p0", "0x0.0003AF7p0", "0x0.0004418p0", "0x0.0004EA2p0", "0x0.0005ACEp0",
    "0x0.00068DCp0", "0x0.0007916p0", "0x0.0008BD4p0", "0x0.000A179p0", "0x0.000BA77p0", "0x0.000D754p0", "0x0.000F8A8p0", "0x0.0011F25p0",
    "0x0.0014B97p0", "0x0.0017EEAp0", "0x0.001BA2Ep0", "0x0.001FE9Fp0", "0x0.0024DA8p0", "0x0.002A8EDp0", "0x0.0031252p0", "0x0.0038C08p0",
    "0x0.0041893p0", "0x0.004BAE0p0", "0x0.005764Cp0", "0x0.0064EBBp0", "0x0.00748A9p0", "0x0.0086947p0", "0x0.009B691p0", "0x0.00B3771p0",
    "0x0.00CF3E3p0", "0x0.00EF521p0", "0x0.01145CFp0", "0x0.013F239p0", "0x0.0170894p0", "0x0.01A9943p0", "0x0.01EB736p0", "0x0.023784Bp0",
    "0x0.028F5C3p0", "0x0.02F4CC4p0", "0x0.0369EFCp0", "0x0.03F134Dp0", "0x0.048D69Cp0", "0x0.0541CC5p0", "0x0.06121A8p0", "0x0.0702A69p0",
    "0x0.08186E2p0", "0x0.0959348p0", "0x0.0ACBA15p0", "0x0.0C7763Fp0", "0x0.0E655C3p0", "0x0.109FC99p0", "0x0.133281Bp0", "0x0.162B2F1p0",
    "0x0.199999Ap0", "0x0.1D8FFABp0", "0x0.22235DBp0", "0x0.276C100p0", "0x0.2D8621Cp0", "0x0.3491FB5p0", "0x0.3CB508Ep0", "0x0.461A81Cp0",
    "0x0.50F44D9p0", "0x0.5D7C0D3p0", "0x0.6BF44D5p0", "0x0.7CA9E76p0", "0x0.8FF599Ep0", "0x0.A63DDFEp0", "0x0.BFF9112p0", "0x0.DDAFD68p0"
   };
   ap_ufixed<54,26> exp_msb_ind_1 = exp_msb_ind_1_table[x_msb_ind_1];
   ap_ufixed<106,24> f_x_msb_ind_1_ind_2_ind_1_lsb = exp_msb_ind_1 * exp_msb_ind2_msb_ind3_lsb_ind_m_1;
   y = f_x_msb_ind_1_ind_2_ind_1_lsb + exp_msb_ind_1;
  }
  if(I_<27) {
   bool overf = 0;
   VITIS_LOOP_3244_13: for(int j = 51; j >= 25 + I_; j--) {
#pragma HLS unroll
 if(y[j]) {
     overf = 1;
    }
   }
   if(overf) {
    VITIS_LOOP_3251_14: for(int j = 51; j>=25 + I_; j--) {
#pragma HLS unroll
 y[j] = 0;
    }
    VITIS_LOOP_3255_15: for(int j = 24 + I_; j >= 0; j--) {
#pragma HLS unroll
 y[j] = 1;
    }
   }
  }
  r = y;
 } else {
  ap_fixed<65,33> x_l = x;
  ap_ufixed<64,32> y = 0;
  ap_fixed<5,5> x_l_int;
  x_l_int(4,0) = x_l(36,32);
  ap_ufixed<32,0> x_l_fract;
  x_l_fract(31,0) = x_l(31,0);
  bool overf = 0;
  VITIS_LOOP_3270_16: for(int j = 63; j >= 36; j--) {
#pragma HLS unroll
 if(x_l[64]!=x_l[j]) {
    overf = 1;
   }
  }
  if(overf||(x_l_int >= 10)||((x_l_int==9)&&(x_l_fract>ap_fixed<32,0>("0x0.A209A84F")))) {
   if(!x_l[64]) {
    y = ap_ufixed<64,32>("0xFFFFFFFF.FFFFFFFFp0");
   }
  } else {
   ap_uint<8> x_msb_ind_1;
   x_msb_ind_1[7] = x_l[64];
   x_msb_ind_1(6,0) = x_l(35,29);
   ap_uint<8> x_msb_ind_2;
   x_msb_ind_2(7,0) = x_l(28,21);
   ap_uint<7> x_msb_ind_3;
   x_msb_ind_3(6,0) = x_l(20,14);
   ap_uint<7> x_msb_ind_4;
   x_msb_ind_4(6,0) = x_l(13,7);
   ap_uint<7> x_lsb_ind;
   x_lsb_ind(6,0) = x_l(6,0);
   const static ap_ufixed<49,-23> exp_x_lsb_ind_m_1_table[128] = {
    "0x0.0p0", "0x0.000000024D76377927p0", "0x0.000000049AEC6EF79Cp0", "0x0.00000006E862A67B5Dp0", "0x0.0000000935D8DE046Dp0", "0x0.0000000B834F1592C9p0", "0x0.0000000DD0C54D2672p0", "0x0.000000101E3B84BF69p0",
    "0x0.000000126BB1BC5DAEp0", "0x0.00000014B927F4013Fp0", "0x0.00000017069E2BAA1Ep0", "0x0.00000019541463584Ap0", "0x0.0000001BA18A9B0BC3p0", "0x0.0000001DEF00D2C48Ap0", "0x0.000000203C770A829Ep0", "0x0.0000002289ED4245FFp0",
    "0x0.00000024D7637A0EAEp0", "0x0.0000002724D9B1DCA9p0", "0x0.00000029724FE9AFF2p0", "0x0.0000002BBFC6218889p0", "0x0.0000002E0D3C59666Cp0", "0x0.000000305AB291499Dp0", "0x0.00000032A828C9321Bp0", "0x0.00000034F59F011FE7p0",
    "0x0.000000374315391300p0", "0x0.00000039908B710B66p0", "0x0.0000003BDE01A90919p0", "0x0.0000003E2B77E10C1Ap0", "0x0.0000004078EE191468p0", "0x0.00000042C664512203p0", "0x0.0000004513DA8934EBp0", "0x0.000000476150C14D21p0",
    "0x0.00000049AEC6F96AA4p0", "0x0.0000004BFC3D318D75p0", "0x0.0000004E49B369B592p0", "0x0.000000509729A1E2FDp0", "0x0.00000052E49FDA15B5p0", "0x0.000000553216124DBBp0", "0x0.000000577F8C4A8B0Ep0", "0x0.00000059CD0282CDAEp0",
    "0x0.0000005C1A78BB159Bp0", "0x0.0000005E67EEF362D6p0", "0x0.00000060B5652BB55Ep0", "0x0.0000006302DB640D33p0", "0x0.0000006550519C6A55p0", "0x0.000000679DC7D4CCC5p0", "0x0.00000069EB3E0D3482p0", "0x0.0000006C38B445A18Dp0",
    "0x0.0000006E862A7E13E4p0", "0x0.00000070D3A0B68B89p0", "0x0.000000732116EF087Bp0", "0x0.000000756E8D278ABBp0", "0x0.00000077BC03601248p0", "0x0.0000007A0979989F22p0", "0x0.0000007C56EFD13149p0", "0x0.0000007EA46609C8BEp0",
    "0x0.00000080F1DC426580p0", "0x0.000000833F527B078Fp0", "0x0.000000858CC8B3AEEBp0", "0x0.00000087DA3EEC5B95p0", "0x0.0000008A27B5250D8Cp0", "0x0.0000008C752B5DC4D1p0", "0x0.0000008EC2A1968162p0", "0x0.000000911017CF4341p0",
    "0x0.000000935D8E080A6Dp0", "0x0.00000095AB0440D6E7p0", "0x0.00000097F87A79A8AEp0", "0x0.0000009A45F0B27FC2p0", "0x0.0000009C9366EB5C23p0", "0x0.0000009EE0DD243DD2p0", "0x0.000000A12E535D24CEp0", "0x0.000000A37BC9961117p0",
    "0x0.000000A5C93FCF02ADp0", "0x0.000000A816B607F991p0", "0x0.000000AA642C40F5C2p0", "0x0.000000ACB1A279F741p0", "0x0.000000AEFF18B2FE0Cp0", "0x0.000000B14C8EEC0A25p0", "0x0.000000B39A05251B8Bp0", "0x0.000000B5E77B5E323Fp0",
    "0x0.000000B834F1974E40p0", "0x0.000000BA8267D06F8Ep0", "0x0.000000BCCFDE099629p0", "0x0.000000BF1D5442C212p0", "0x0.000000C16ACA7BF348p0", "0x0.000000C3B840B529CBp0", "0x0.000000C605B6EE659Bp0", "0x0.000000C8532D27A6B9p0",
    "0x0.000000CAA0A360ED24p0", "0x0.000000CCEE199A38DDp0", "0x0.000000CF3B8FD389E2p0", "0x0.000000D189060CE035p0", "0x0.000000D3D67C463BD5p0", "0x0.000000D623F27F9CC3p0", "0x0.000000D87168B902FEp0", "0x0.000000DABEDEF26E86p0",
    "0x0.000000DD0C552BDF5Bp0", "0x0.000000DF59CB65557Ep0", "0x0.000000E1A7419ED0EEp0", "0x0.000000E3F4B7D851ABp0", "0x0.000000E6422E11D7B6p0", "0x0.000000E88FA44B630Dp0", "0x0.000000EADD1A84F3B2p0", "0x0.000000ED2A90BE89A5p0",
    "0x0.000000EF7806F824E4p0", "0x0.000000F1C57D31C571p0", "0x0.000000F412F36B6B4Cp0", "0x0.000000F66069A51673p0", "0x0.000000F8ADDFDEC6E8p0", "0x0.000000FAFB56187CAAp0", "0x0.000000FD48CC5237B9p0", "0x0.000000FF96428BF816p0",
    "0x0.00000101E3B8C5BDC0p0", "0x0.00000104312EFF88B7p0", "0x0.000001067EA53958FCp0", "0x0.00000108CC1B732E8Ep0", "0x0.0000010B1991AD096Dp0", "0x0.0000010D6707E6E999p0", "0x0.0000010FB47E20CF13p0", "0x0.0000011201F45AB9DAp0",
    "0x0.000001144F6A94A9EEp0", "0x0.000001169CE0CE9F4Fp0", "0x0.00000118EA570899FEp0", "0x0.0000011B37CD4299FAp0", "0x0.0000011D85437C9F44p0", "0x0.0000011FD2B9B6A9DAp0", "0x0.00000122202FF0B9BEp0", "0x0.000001246DA62ACEEFp0"
   };
   ap_ufixed<49,-23> exp_x_lsb_ind_m_1 = exp_x_lsb_ind_m_1_table[x_lsb_ind];
   const static ap_ufixed<56,-16> exp_x_msb_ind_4_m_1_table[128] = {
    "0x0.0p0", "0x0.00000126BB1C64FE3Ep0", "0x0.0000024D763A1D4ECAp0", "0x0.00000374315928F1A6p0", "0x0.0000049AEC7987E6D2p0", "0x0.000005C1A79B3A2E51p0", "0x0.000006E862BE3FC825p0", "0x0.0000080F1DE298B44Dp0",
    "0x0.00000935D90844F2CDp0", "0x0.00000A5C942F4483A6p0", "0x0.00000B834F579766D9p0", "0x0.00000CAA0A813D9C67p0", "0x0.00000DD0C5AC372453p0", "0x0.00000EF780D883FE9Ep0", "0x0.0000101E3C06242B48p0", "0x0.00001144F73517AA55p0",
    "0x0.0000126BB2655E7BC5p0", "0x0.000013926D96F89F9Ap0", "0x0.000014B928C9E615D5p0", "0x0.000015DFE3FE26DE78p0", "0x0.000017069F33BAF985p0", "0x0.0000182D5A6AA266FCp0", "0x0.0000195415A2DD26E0p0", "0x0.00001A7AD0DC6B3932p0",
    "0x0.00001BA18C174C9DF4p0", "0x0.00001CC84753815527p0", "0x0.00001DEF0291095ECCp0", "0x0.00001F15BDCFE4BAE6p0", "0x0.0000203C7910136975p0", "0x0.000021633451956A7Bp0", "0x0.00002289EF946ABDFAp0", "0x0.000023B0AAD89363F3p0",
    "0x0.000024D7661E0F5C68p0", "0x0.000025FE2164DEA75Ap0", "0x0.00002724DCAD0144CCp0", "0x0.0000284B97F67734BDp0", "0x0.000029725341407730p0", "0x0.00002A990E8D5D0C27p0", "0x0.00002BBFC9DACCF3A2p0", "0x0.00002CE68529902DA4p0",
    "0x0.00002E0D4079A6BA2Ep0", "0x0.00002F33FBCB109942p0", "0x0.0000305AB71DCDCAE0p0", "0x0.000031817271DE4F0Bp0", "0x0.000032A82DC74225C5p0", "0x0.000033CEE91DF94F0Dp0", "0x0.000034F5A47603CAE7p0", "0x0.0000361C5FCF619954p0",
    "0x0.000037431B2A12BA54p0", "0x0.00003869D686172DEBp0", "0x0.0000399091E36EF418p0", "0x0.00003AB74D421A0CDFp0", "0x0.00003BDE08A218783Fp0", "0x0.00003D04C4036A363Cp0", "0x0.00003E2B7F660F46D5p0", "0x0.00003F523ACA07AA0Ep0",
    "0x0.00004078F62F535FE7p0", "0x0.0000419FB195F26862p0", "0x0.000042C66CFDE4C380p0", "0x0.000043ED28672A7144p0", "0x0.00004513E3D1C371ADp0", "0x0.0000463A9F3DAFC4BFp0", "0x0.000047615AAAEF6A7Ap0", "0x0.0000488816198262E1p0",
    "0x0.000049AED18968ADF4p0", "0x0.00004AD58CFAA24BB5p0", "0x0.00004BFC486D2F3C26p0", "0x0.00004D2303E10F7F48p0", "0x0.00004E49BF5643151Cp0", "0x0.00004F707ACCC9FDA5p0", "0x0.000050973644A438E4p0", "0x0.000051BDF1BDD1C6DAp0",
    "0x0.000052E4AD3852A788p0", "0x0.0000540B68B426DAF1p0", "0x0.0000553224314E6116p0", "0x0.00005658DFAFC939F8p0", "0x0.0000577F9B2F976599p0", "0x0.000058A656B0B8E3FBp0", "0x0.000059CD12332DB51Ep0", "0x0.00005AF3CDB6F5D905p0",
    "0x0.00005C1A893C114FB1p0", "0x0.00005D4144C2801924p0", "0x0.00005E68004A42355Fp0", "0x0.00005F8EBBD357A463p0", "0x0.000060B5775DC06632p0", "0x0.000061DC32E97C7ACEp0", "0x0.00006302EE768BE238p0", "0x0.00006429AA04EE9C72p0",
    "0x0.000065506594A4A97Dp0", "0x0.000066772125AE095Ap0", "0x0.0000679DDCB80ABC0Cp0", "0x0.000068C4984BBAC194p0", "0x0.000069EB53E0BE19F3p0", "0x0.00006B120F7714C52Bp0", "0x0.00006C38CB0EBEC33Ep0", "0x0.00006D5F86A7BC142Cp0",
    "0x0.00006E8642420CB7F8p0", "0x0.00006FACFDDDB0AEA2p0", "0x0.000070D3B97AA7F82Dp0", "0x0.000071FA7518F2949Ap0", "0x0.0000732130B89083EBp0", "0x0.00007447EC5981C621p0", "0x0.0000756EA7FBC65B3Dp0", "0x0.00007695639F5E4341p0",
    "0x0.000077BC1F44497E2Fp0", "0x0.000078E2DAEA880C08p0", "0x0.00007A09969219ECCEp0", "0x0.00007B30523AFF2082p0", "0x0.00007C570DE537A726p0", "0x0.00007D7DC990C380BBp0", "0x0.00007EA4853DA2AD43p0", "0x0.00007FCB40EBD52CBFp0",
    "0x0.000080F1FC9B5AFF31p0", "0x0.00008218B84C34249Ap0", "0x0.0000833F73FE609CFCp0", "0x0.000084662FB1E06859p0", "0x0.0000858CEB66B386B2p0", "0x0.000086B3A71CD9F808p0", "0x0.000087DA62D453BC5Dp0", "0x0.000089011E8D20D3B2p0",
    "0x0.00008A27DA47413E0Ap0", "0x0.00008B4E9602B4FB65p0", "0x0.00008C7551BF7C0BC5p0", "0x0.00008D9C0D7D966F2Cp0", "0x0.00008EC2C93D04259Bp0", "0x0.00008FE984FDC52F14p0", "0x0.0000911040BFD98B98p0", "0x0.00009236FC83413B29p0"
   };
   ap_ufixed<56,-16> exp_x_msb_ind_4_m_1 = exp_x_msb_ind_4_m_1_table[x_msb_ind_4];
   ap_ufixed<105,-39> f_x_msb_ind_4_lsb_ind = exp_x_msb_ind_4_m_1 * exp_x_lsb_ind_m_1;
   ap_ufixed<54,-16> exp_x_msb_ind_4_lsb_ind_m_1 = f_x_msb_ind_4_lsb_ind + exp_x_msb_ind_4_m_1 + exp_x_lsb_ind_m_1;
   const static ap_ufixed<61,-9> exp_x_msb_ind_3_m_1_table[128] = {
    "0x0.0p0", "0x0.0000935DB847FC5AA8p0", "0x0.000126BBC564BCA768p0", "0x0.0001BA1A275671BB78p0", "0x0.00024D78DE1D4C6C2Cp0", "0x0.0002E0D7E9B97D8EFCp0", "0x0.000374374A2B35F970p0", "0x0.00040796FF72A6813Cp0",
    "0x0.00049AF7098FFFFC24p0", "0x0.00052E57688373400Cp0", "0x0.0005C1B81C4D3122F0p0", "0x0.0006551924ED6A7AF0p0", "0x0.0006E87A8264501E44p0", "0x0.00077BDC34B212E340p0", "0x0.00080F3E3BD6E3A04Cp0", "0x0.0008A2A097D2F32C00p0",
    "0x0.0009360348A6725D00p0", "0x0.0009C9664E51920A0Cp0", "0x0.000A5CC9A8D4830A0Cp0", "0x0.000AF02D582F7633F4p0", "0x0.000B83915C629C5EE4p0", "0x0.000C16F5B56E266210p0", "0x0.000CAA5A63524514C8p0", "0x0.000D3DBF660F294E74p0",
    "0x0.000DD124BDA503E6A8p0", "0x0.000E648A6A1405B500p0", "0x0.000EF7F06B5C5F9140p0", "0x0.000F8B56C17E425348p0", "0x0.00101EBD6C79DED310p0", "0x0.0010B2246C4F65E8ACp0", "0x0.0011458BC0FF086C50p0", "0x0.0011D8F36A88F7364Cp0",
    "0x0.00126C5B68ED631F08p0", "0x0.0012FFC3BC2C7CFF0Cp0", "0x0.0013932C644675AEF4p0", "0x0.00142695613B7E0788p0", "0x0.0014B9FEB30BC6E19Cp0", "0x0.00154D6859B7811628p0", "0x0.0015E0D2553EDD7E44p0", "0x0.0016743CA5A20CF314p0",
    "0x0.001707A74AE1404DF0p0", "0x0.00179B1244FCA86834p0", "0x0.00182E7D93F4761B6Cp0", "0x0.0018C1E937C8DA4134p0", "0x0.00195555307A05B348p0", "0x0.0019E8C17E08294B7Cp0", "0x0.001A7C2E207375E3C8p0", "0x0.001B0F9B17BC1C563Cp0",
    "0x0.001BA30863E24D7D04p0", "0x0.001C367604E63A3268p0", "0x0.001CC9E3FAC81350CCp0", "0x0.001D5D52458809B2ACp0", "0x0.001DF0C0E5264E32ACp0", "0x0.001E842FD9A311AB84p0", "0x0.001F179F22FE84F804p0", "0x0.001FAB0EC138D8F320p0",
    "0x0.00203E7EB4523E77E4p0", "0x0.0020D1EEFC4AE66178p0", "0x0.0021655F9923018B24p0", "0x0.0021F8D08ADAC0D048p0", "0x0.00228C41D172550C64p0", "0x0.00231FB36CE9EF1B0Cp0", "0x0.0023B3255D41BFD7FCp0", "0x0.00244697A279F81F04p0",
    "0x0.0024DA0A3C92C8CC10p0", "0x0.00256D7D2B8C62BB2Cp0", "0x0.002600F06F66F6C880p0", "0x0.002694640822B5D04Cp0", "0x0.002727D7F5BFD0AEECp0", "0x0.0027BB4C383E7840E0p0", "0x0.00284EC0CF9EDD62C0p0", "0x0.0028E235BBE130F138p0",
    "0x0.002975AAFD05A3C918p0", "0x0.002A0920930C66C754p0", "0x0.002A9C967DF5AAC8E8p0", "0x0.002B300CBDC1A0AB00p0", "0x0.002BC3835270794AD4p0", "0x0.002C56FA3C026585C8p0", "0x0.002CEA717A77963950p0", "0x0.002D7DE90DD03C4300p0",
    "0x0.002E1160F60C888084p0", "0x0.002EA4D9332CABCFB0p0", "0x0.002F3851C530D70E68p0", "0x0.002FCBCAAC193B1AB0p0", "0x0.00305F43E7E608D2ACp0", "0x0.0030F2BD7897711494p0", "0x0.003186375E2DA4BEC4p0", "0x0.003219B198A8D4AFB0p0",
    "0x0.0032AD2C280931C5ECp0", "0x0.003340A70C4EECE020p0", "0x0.0033D422457A36DD1Cp0", "0x0.0034679DD38B409BBCp0", "0x0.0034FB19B6823AFB0Cp0", "0x0.00358E95EE5F56DA24p0", "0x0.003622127B22C51840p0", "0x0.0036B58F5CCCB694B4p0",
    "0x0.0037490C935D5C2EF8p0", "0x0.0037DC8A1ED4E6C690p0", "0x0.00387007FF33873B30p0", "0x0.0039038634796E6C9Cp0", "0x0.00399704BEA6CD3AB4p0", "0x0.003A2A839DBBD48578p0", "0x0.003ABE02D1B8B52D04p0", "0x0.003B51825A9DA01190p0",
    "0x0.003BE502386AC6136Cp0", "0x0.003C78826B2058130Cp0", "0x0.003D0C02F2BE86F0F8p0", "0x0.003D9F83CF45838DD8p0", "0x0.003E330500B57ECA74p0", "0x0.003EC686870EA987A4p0", "0x0.003F5A08625134A66Cp0", "0x0.003FED8A927D5107E4p0",
    "0x0.0040810D17932F8D38p0", "0x0.0041148FF1930117C0p0", "0x0.0041A813207CF688E8p0", "0x0.00423B96A45140C234p0", "0x0.0042CF1A7D1010A550p0", "0x0.0043629EAAB99713F8p0", "0x0.0043F6232D4E04F00Cp0", "0x0.004489A804CD8B1B80p0",
    "0x0.00451D2D31385A7870p0", "0x0.0045B0B2B28EA3E90Cp0", "0x0.0046443888D0984FA0p0", "0x0.0046D7BEB3FE688E98p0", "0x0.00476B453418458878p0", "0x0.0047FECC091E601FE4p0", "0x0.004892533310E93798p0", "0x0.004925DAB1F011B270p0"
   };
   ap_ufixed<61,-9> exp_x_msb_ind_3_m_1 = exp_x_msb_ind_3_m_1_table[x_msb_ind_3];
   ap_ufixed<115,-25> f_x_msb_ind_3_msb_ind_4_lsb_ind = exp_x_msb_ind_3_m_1 * exp_x_msb_ind_4_lsb_ind_m_1;
   ap_ufixed<59,-9> exp_x_msb_ind_3_msb_ind_4_lsb_ind_m_1 = f_x_msb_ind_3_msb_ind_4_lsb_ind + exp_x_msb_ind_3_m_1 + exp_x_msb_ind_4_lsb_ind_m_1;
   const static ap_ufixed<67,-1> exp_x_msb_ind_2_m_1_table[256] = {
    "0x0.0p0", "0x0.0049B96285BC0A736p0", "0x0.009388004BE7E5593p0", "0x0.00DD6BDF6FC8EDEABp0", "0x0.01276506106747AA4p0", "0x0.0171737A4E8E5E346p0", "0x0.01BB97424CCD67360p0", "0x0.0205D0642F77E4885p0",
    "0x.02501EE61CA62671Ep0", "0x0.029A82CE3C35CE0DBp0", "0x0.02E4FC22B7CA4FD73p0", "0x0.032F8AE9BACD765C6p0", "0x0.037A2F29726FE5154p0", "0x0.03C4E8E80DA99B612p0", "0x0.040FB82BBD3A77A9Ap0", "0x0.045A9CFAB3AABAAB4p0",
    "0x.04A5975B254B8AE40p0", "0x0.04F0A75348377827Fp0", "0x0.053BCCE95452FF5B2p0", "0x0.05870823834D0E520p0", "0x0.05D25908109F87D7Ap0", "0x0.061DBF9D398FC7D9Dp0", "0x0.06693BE93D2F27BB7p0", "0x0.06B4CDF25C5B82CCDp0",
    "0x.070075BED9BFBAEA4p0", "0x0.074C3354F9D43D40Ap0", "0x0.079806BB02DF8738Ap0", "0x0.07E3EFF73CF6AB87Ap0", "0x0.082FEF0FF1FDD767Bp0", "0x0.087C040B6DA8D7F50p0", "0x0.08C82EEFFD7B9FB28p0", "0x0.09146FC3F0CACC34Cp0",
    "0x.0960C68D98BC2BF2Ep0", "0x0.09AD33534847443EAp0", "0x0.09F9B61B5435D762Cp0", "0x0.0A464EEC13246AE7Ep0", "0x0.0A92FDCBDD82CE006p0", "0x0.0ADFC2C10D94A01AAp0", "0x0.0B2C9DD1FF71D79A4p0", "0x0.0B798F05110748B7Fp0",
    "0x.0BC69660A2172C887p0", "0x0.0C13B3EB1439A82A1p0", "0x0.0C60E7AACADD54194p0", "0x0.0CAE31A62B47C3AC7p0", "0x0.0CFB91E39C960CB66p0", "0x0.0D49086987BD4F4FEp0", "0x0.0D96953E578B3DC88p0", "0x0.0DE4386878A6A4BEAp0",
    "0x.0E31F1EE598FF35E7p0", "0x0.0E7FC1D66AA1C3C87p0", "0x0.0ECDA8271E11639EAp0", "0x0.0F1BA4E6E7EF5CBA0p0", "0x0.0F69B81C3E27FE069p0", "0x0.0FB7E1CD9883E4871p0", "0x0.1006220170A884803p0", "0x0.105478BE4218B2CB7p0",
    "0x.10A2E60A8A352E513p0", "0x0.10F169ECC83D29AA6p0", "0x0.1140046B7D4ED4EA6p0", "0x0.118EB58D2C67E78FCp0", "0x0.11DD7D585A662A9D7p0", "0x0.122C5BD38E0802DB1p0", "0x0.127B51054FECFB3DBp0", "0x0.12CA5CF42A964F780p0",
    "0x.13197FA6AA6776B28p0", "0x0.1368B9235DA6AE6BAp0", "0x0.13B80970D47D85804p0", "0x0.14077095A0F9675B6p0", "0x0.1456EE98570C274EEp0", "0x0.14A6837F8C8C8C138p0", "0x0.14F62F51D936DB71Dp0", "0x0.1545F215D6AD6612Fp0",
    "0x.1595CBD2207913796p0", "0x0.15E5BC8D5409EE22Bp0", "0x0.1635C44E10B7AFD11p0", "0x0.1685E31AF7C24DFD9p0", "0x0.16D618FAAC528672Ap0", "0x0.172665F3D37A6C0F3p0", "0x0.1776CA0D1435F3B24p0", "0x0.17C7454D176B814F4p0",
    "0x.1817D7BA87EC752AAp0", "0x0.1868815C1275B93F8p0", "0x0.18B9423865B04ECDCp0", "0x0.190A1A563231DC114p0", "0x0.195B09BC2A7D3A217p0", "0x0.19AC1071030302FA1p0", "0x0.19FD2E7B72221FACBp0", "0x0.1A4E63E2302856BB6p0",
    "0x.1A9FB0ABF752DA9BEp0", "0x0.1AF114DF83CED8647p0", "0x0.1B42908393BA06A18p0", "0x0.1B94239EE72334542p0", "0x0.1BE5CE38400AD81A5p0", "0x0.1C37905662639F7FEp0", "0x0.1C896A001412FE793p0", "0x0.1CDB5B3C1CF1BF06Bp0",
    "0x.1D2D641146CC91022p0", "0x0.1D7F84865D649A153p0", "0x0.1DD1BCA22E7005D96p0", "0x0.1E240C6B899A96219p0", "0x0.1E7673E94086336D2p0", "0x0.1EC8F32226CB7D849p0", "0x0.1F1B8A1D11FA5C3FAp0", "0x0.1F6E38E0D99A9075Cp0",
    "0x.1FC0FF74572C45177p0", "0x0.2013DDDE6628A071Cp0", "0x0.2066D425E402559C1p0", "0x0.20B9E251B026360EFp0", "0x0.210D0868ABFBC3658p0", "0x0.21604671BAE5C1485p0", "0x0.21B39C73C242C7830p0", "0x0.22070A75A96DD4433p0",
    "0x.225A907E59BEDE81Cp0", "0x0.22AE2E94BE8B6896Ap0", "0x0.2301E4BFC52712F67p0", "0x0.2355B3065CE42F1A7p0", "0x0.23A9996F77145292Cp0", "0x0.23FD98020708EA434p0", "0x0.2451AEC50213CDCA7p0", "0x0.24A5DDBF5F87D312Ep0",
    "0x.24FA24F818B9620F7p0", "0x0.254E847628FF08A1Bp0", "0x0.25A2FC408DB20EAB1p0", "0x0.25F78C5E462F0A48Bp0", "0x0.264C34D653D67439Bp0", "0x0.26A0F5AFBA0D3C70Bp0", "0x0.26F5CEF17E3D5ECF9p0", "0x0.274AC0A2A7D6780E4p0",
    "0x.279FCACA404E5ACCBp0", "0x0.27F4ED6F5321A4CF5p0", "0x0.284A2898EDD45466Ap0", "0x0.289F7C4E1FF25E01Ep0", "0x0.28F4E895FB1041ECEp0", "0x0.294A6D7792CBA238Bp0", "0x0.29A00AF9FCCBD8CFCp0", "0x0.29F5C12450C28DB50p0",
    "0x.2A4B8FFDA86C4D6E8p0", "0x0.2AA1778D1F911F9B4p0", "0x0.2AF777D9D4051DB44p0", "0x0.2B4D90EAE5A909F93p0", "0x0.2BA3C2C7766AE6888p0", "0x0.2BFA0D76AA468CA2Fp0", "0x0.2C5070FFA746441ACp0", "0x0.2CA6ED6995835AEE4p0",
    "0x.2CFD82BB9F26BD0EAp0", "0x0.2D5430FCF0698C518p0", "0x0.2DAAF834B795B88F5p0", "0x0.2E01D86A250697ECCp0", "0x0.2E58D1A46B297F504p0", "0x0.2EAFE3EABE7E5B03Bp0", "0x0.2F070F44559847819p0", "0x0.2F5E53B8691E2A6E5p0",
    "0x.2FB5B14E33CB4BBE3p0", "0x0.300D280CF26FEF065p0", "0x0.3064B7FBE3F1ECFAEp0", "0x0.30BC6122494D4D18Bp0", "0x0.311423876594DF7B7p0", "0x0.316BFF327DF2D6E06p0", "0x0.31C3F42AD9A962D4Ep0", "0x0.321C0277C2134A11Dp0",
    "0x.32742A2082A485035p0", "0x0.32CC6B2C68EAD87CAp0", "0x0.3324C5A2C48E70995p0", "0x0.337D398AE7527BCA2p0", "0x0.33D5C6EC2515C60F8p0", "0x0.342E6DCDD3D3545FDp0", "0x0.34872E374BA3003AFp0", "0x0.34E0082FE6BA136ADp0",
    "0x.3538FBBF016BE3F00p0", "0x0.359208EBFA2A701C4p0", "0x0.35EB2FBE3186FAD90p0", "0x0.3644703D0A32A81BDp0", "0x0.369DCA6FE8FF1986Fp0", "0x0.36F73E5E34DF0B37Bp0", "0x0.3750CC0F56E6F0C1Ep0", "0x0.37AA738ABA4D92580p0",
    "0x.380434D7CC6CAA213p0", "0x0.385E0FFDFCC181BC3p0", "0x0.38B80504BCED8FF00p0", "0x0.391213F380B716895p0", "0x0.396C3CD1BE09C0665p0", "0x0.39C67FA6ECF73FAF1p0", "0x0.3A20DC7A87B7EC3C5p0", "0x0.3A7B53540AAB622AFp0",
    "0x.3AD5E43AF459209E5p0", "0x0.3B308F36C57128AF1p0", "0x0.3B8B544F00CC9C88Ap0", "0x0.3BE6338B2B6E5EB41p0", "0x0.3C412CF2CC83B1910p0", "0x0.3C9C408D6D64D6FC5p0", "0x0.3CF76E629995B0251p0", "0x0.3D52B679DEC65D8F1p0",
    "0x.3DAE18DACCD3DF440p0", "0x0.3E09958CF5C8B5321p0", "0x0.3E652C97EDDD7FB9Bp0", "0x0.3EC0DE034B79A0686p0", "0x0.3F1CA9D6A733DAE2Ep0", "0x0.3F7890199BD2F5FCFp0", "0x0.3FD490D3C64E5D001p0", "0x0.4030AC0CC5CEC11FFp0",
    "0x.408CE1CC3BAEBB1E6p0", "0x0.40E93219CB7B6D1CCp0", "0x0.41459CFD1AF5249CFp0", "0x0.41A2227DD20FFCB02p0", "0x0.41FEC2A39AF480553p0", "0x0.425B7D7622004D04Dp0", "0x0.42B852FD15C6B56D6p0", "0x0.431543402711645D2p0",
    "0x.43724E4708E0FFDB7p0", "0x0.43CF7419706DCC711p0", "0x0.442CB4BF1528509F4p0", "0x0.448A103FB0B9F8866p0", "0x0.44E786A2FF05B9BB0p0", "0x0.454517F0BE28B74ACp0", "0x0.45A2C430AE7AE5F03p0", "0x0.46008B6A928FB075Ep0",
    "0x.465E6DA62F369C48Ep0", "0x0.46BC6AEB4B7BEE3AAp0", "0x0.471A8341B0A94F727p0", "0x0.4778B6B12A46728E1p0", "0x0.47D705418619B8F25p0", "0x0.48356EFA9428D84B1p0", "0x0.4893F3E426B9803ABp0", "0x0.48F2940612520039Ap0",
    "0x.49514F682DB9EDA59p0", "0x0.49B0261251FACA004p0", "0x0.4A0F180C5A60A95E7p0", "0x0.4A6E255E247AD906Ap0", "0x0.4ACD4E0F901C863FEp0", "0x0.4B2C92287F5D65507p0", "0x0.4B8BF1B0D69A58AD0p0", "0x0.4BEB6CB07C7618574p0",
    "0x.4C4B032F59D9D96D8p0", "0x0.4CAAB53559F5F5E9Fp0", "0x0.4D0A82CA6A429492Bp0", "0x0.4D6A6BF67A8051199p0", "0x0.4DCA70C17CB8E46D2p0", "0x0.4E2A9133653FCD395p0", "0x0.4E8ACD542AB2F8995p0", "0x0.4EEB252BC5FB6AF99p0",
    "0x.4F4B98C2324DE92ACp0", "0x0.4FAC281F6D2BA1A4Fp0", "0x0.500CD34B7662D5FC3p0", "0x0.506D9A4E500F84855p0", "0x0.50CE7D2FFE9C122BEp0", "0x0.512F7BF888C1F4791p0", "0x0.519096AFF78A5BCB5p0", "0x0.51F1CD5E564EDDBF2p0",
    "0x.5253200BB2BA1FC90p0", "0x0.52B48EC01CC882005p0", "0x0.53161983A6C8CA1BBp0", "0x0.5377C05E655CCE9E1p0", "0x0.53D983586F7A2235Ep0", "0x0.543B6279DE6ABF4CAp0", "0x0.549D5DCACDCDB3C8Dp0", "0x0.54FF75535B97CD007p0"
   };
   ap_ufixed<67,-1> exp_x_msb_ind_2_m_1 = exp_x_msb_ind_2_m_1_table[x_msb_ind_2];
   ap_ufixed<126,-10> f_x_msb_ind_2_msb_ind_3_msb_ind_4_lsb_ind = exp_x_msb_ind_2_m_1 * exp_x_msb_ind_3_msb_ind_4_lsb_ind_m_1;
   ap_ufixed<65,-1> exp_x_msb_ind_2_msb_ind_3_msb_ind_4_lsb_ind_m_1 = f_x_msb_ind_2_msb_ind_3_msb_ind_4_lsb_ind + exp_x_msb_ind_2_m_1 + exp_x_msb_ind_3_msb_ind_4_lsb_ind_m_1;
   const static ap_ufixed<66,32> exp_x_msb_ind_1_table[256] = {
    "0x1.000000000p0", "0x1.5561A91BCp0", "0x1.C73D51C54p0", "0x2.5F1258E08p0", "0x3.298B075B4p0", "0x4.378B053ECp0", "0x5.9F9802C8Cp0", "0x7.7FBAAB458p0",
    "0xA.000000000p0", "0xD.55D09B148p0", "0x11.C86531B4Cp0", "0x17.B6B778C40p0", "0x1F.9F6E49910p0", "0x2A.2B6E34724p0", "0x38.3BF01BD84p0", "0x4A.FD4AB0B64p0",
    "0x64.000000000p0", "0x85.5A260ECDCp0", "0xB1.D3F3F10ECp0", "0xED.232AB7A90p0", "0x13C.3A4EDFA98p0", "0x1A5.B24E0C774p0", "0x232.57611671Cp0", "0x2ED.E4EAE71ECp0",
    "0x3E8.000000000p0", "0x535.857C94088p0", "0x6F2.47876A934p0", "0x943.5FAB2C9B4p0", "0xC5A.4714BC9E8p0", "0x1078.F70C7CA94p0", "0x15F7.69CAE0728p0", "0x1D4A.F12D0732Cp0",
    "0x2710.000000000p0", "0x3417.36DDC8558p0", "0x4576.CB4A29C18p0", "0x5CA1.BCAFBE0F8p0", "0x7B86.C6CF5E320p0", "0xA4B9.A67CDE9B4p0", "0xDBAA.21ECC4790p0", "0x124ED.6BC247FB8p0",
    "0x186A0.000000000p0", "0x208E8.24A9D3580p0", "0x2B6A3.F0E5A18ECp0", "0x39E51.5EDD6C9A0p0", "0x4D343.C419ADF30p0", "0x66F40.80E0B210Cp0", "0x894A5.533FACBA4p0", "0xB7146.3596CFD3Cp0",
    "0xF4240.000000000p0", "0x145911.6EA2416F4p0", "0x1B2267.68F84F938p0", "0x242F2D.B4A63E038p0", "0x3040A5.A900CB7F0p0", "0x405885.08C6F4A64p0", "0x55CE75.407CBF46Cp0", "0x726CBE.17E41E45Cp0",
    "0x989680.000000000p0", "0xCB7AAE.52568E584p0", "0x10F580A.19B31BC34p0", "0x169D7C9.0E7E6C220p0", "0x1E28678.9A07F2F6Cp0", "0x2837532.57C58E7F0p0", "0x35A1094.84DF78C38p0", "0x4783F6C.EEE92EB90p0",
    "0x5F5E100.000000000p0", "0x7F2CACF.37618F720p0", "0xA997065.00FF159FCp0", "0xE226DDA.90F039530p0", "0x12D940B6.044F7DA48p0", "0x192293F7.6DB790F54p0", "0x2184A5CD.30BAB7A30p0", "0x2CB27A41.551BD339Cp0",
    "0x3B9ACA00.000000000p0", "0x4F7BEC18.29CF9A750p0", "0x69FE63F2.09F6D83E4p0", "0x8D584A89.A9623D3E0p0", "0xBC7C871C.2B1AE86C4p0", "0xFB59C7AA.492BA9948p0", "0x14F2E7A03.E74B2C5F4p0", "0x1BEF8C68D.531640404p0",
    "0x2540BE400.000000000p0", "0x31AD738F1.A21C08914p0", "0x423EFE774.63A4726F4p0", "0x58572E960.9DD6646C4p0", "0x75CDD4719.AF0D143A8p0", "0x9D181CCA6.DBB49FCD0p0", "0xD17D0C427.08EFBBB80p0", "0x1175B7C185.3EDE8282Cp0",
    "0x174876E800.000000000p0", "0x1F0C683970.551855AD0p0", "0x29675F0A8B.E46C78594p0", "0x37367D1DC6.2A5FEC3A0p0", "0x49A0A4C700.D682CA49Cp0", "0x622F11FE84.950E3E020p0", "0x82EE27A986.595D55300p0", "0xAE992D8F34.74B1191B8p0",
    "0xE8D4A51000.000000000p0", "0x1367C123E63.52F358C14p0", "0x19E09B66976.EC3CB37C0p0", "0x22820E329BD.A7BF3A448p0", "0x2E0466FC608.611BE6E18p0", "0x3D5D6B3F12D.D28E6C148p0", "0x51D4D8C9F3F.7DA553E00p0", "0x6D1FBC7980C.8EEAFB130p0",
    "0x9184E72A000.000000000p0", "0xC20D8B66FE1.3D81778C0p0", "0x102C61201EA5.3A5F02D70p0", "0x159148DFA168.8D7846AE0p0", "0x1CC2C05DBC53.CB1704CFCp0", "0x265A63076BCA.399038CD8p0", "0x3325077E387A.E87546BF0p0", "0x4433D5CBF07D.952DCEBE8p0",
    "0x5AF3107A4000.000000000p0", "0x794877205ECC.670EAB770p0", "0xA1BBCB413274.47B61C654p0", "0xD7ACD8BC4E15.86B2C2CC0p0", "0x11F9B83A95B45.EEE6301D8p0", "0x17F87DE4A35E6.3FA238074p0", "0x1FF724AEE34CD.1494C3758p0", "0x2AA0659F764E7.D3CA13714p0",
    "0x38D7EA4C68000.000000000p0", "0x4BCD4A743B3FC.0692B2A70p0", "0x65155F08BF88A.CD1D1BF4Cp0", "0x86CC0775B0CD7.42FB9BF90p0", "0xB3C13249D90BB.54FDE1260p0", "0xEFB4EAEE61AFE.7C563047Cp0", "0x13FA76ED4E1002.CDCFA296Cp0", "0x1AA43F83A9F10E.45E4C26DCp0",
    "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0",
    "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0",
    "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0",
    "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0",
    "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0",
    "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x.000000004p0", "0x.000000004p0", "0x.000000004p0", "0x.000000004p0",
    "0x0.000000008p0", "0x.000000008p0", "0x.00000000Cp0", "0x.000000010p0", "0x.000000014p0", "0x.00000001Cp0", "0x.000000028p0", "0x.000000034p0",
    "0x0.000000044p0", "0x.00000005Cp0", "0x.00000007Cp0", "0x.0000000A4p0", "0x.0000000D8p0", "0x.000000120p0", "0x.000000184p0", "0x.000000204p0",
    "0x0.0000002B0p0", "0x.000000394p0", "0x.0000004C8p0", "0x.00000065Cp0", "0x.00000087Cp0", "0x.000000B50p0", "0x.000000F18p0", "0x.000001420p0",
    "0x0.000001AD8p0", "0x.0000023CCp0", "0x.000002FBCp0", "0x.000003FA8p0", "0x.0000054E4p0", "0x.000007134p0", "0x.0000096F4p0", "0x.00000C94Cp0",
    "0x0.000010C70p0", "0x.0000165F8p0", "0x.00001DD5Cp0", "0x.000027C90p0", "0x.0000350E0p0", "0x.000046BFCp0", "0x.00005E588p0", "0x.00007DCFCp0",
    "0x0.0000A7C5Cp0", "0x.0000DFBA4p0", "0x.00012A588p0", "0x.00018DD9Cp0", "0x.0002128ACp0", "0x.0002C37D4p0", "0x.0003AF73Cp0", "0x.0004EA1D0p0",
    "0x0.00068DB8Cp0", "0x.0008BD470p0", "0x.000BA7754p0", "0x.000F8A814p0", "0x.0014B96C0p0", "0x.001BA2E4Cp0", "0x.0024DA858p0", "0x.003125230p0",
    "0x0.004189374p0", "0x.005764C70p0", "0x.00748A940p0", "0x.009B690C8p0", "0x.00CF3E374p0", "0x.01145CEF0p0", "0x.017089380p0", "0x.01EB735F0p0",
    "0x0.028F5C290p0", "0x.0369EFC58p0", "0x.048D69C70p0", "0x.06121A7D0p0", "0x.08186E274p0", "0x.0ACBA1550p0", "0x.0E655C300p0", "0x.133281B68p0",
    "0x0.199999998p0", "0x.22235DB60p0", "0x.2D8621C70p0", "0x.3CB508E34p0", "0x.50F44D894p0", "0x.6BF44D530p0", "0x.8FF599E10p0", "0x.BFF911208p0"
   };
   ap_ufixed<66,32> exp_x_msb_ind_1 = exp_x_msb_ind_1_table[x_msb_ind_1];
   ap_ufixed<131,31> f_x_msb_ind_1_msb_ind_2_msb_ind_3_msb_ind_4_lsb_ind = exp_x_msb_ind_1 * exp_x_msb_ind_2_msb_ind_3_msb_ind_4_lsb_ind_m_1;
   y = f_x_msb_ind_1_msb_ind_2_msb_ind_3_msb_ind_4_lsb_ind + exp_x_msb_ind_1;
  }
  if(I_<33) {
   bool overf = 0;
   VITIS_LOOP_3430_17: for(int j = 63; j >= 31 + I_; j--) {
#pragma HLS unroll
 if(y[j]) {
     overf = 1;
    }
   }
   if(overf) {
    VITIS_LOOP_3437_18: for(int j = 63; j >= 31 + I_; j--) {
#pragma HLS unroll
 y[j] = 0;
    }
    VITIS_LOOP_3441_19: for(int j = 30 + I_; j >= 0; j--) {
#pragma HLS unroll
 y[j] = 1;
    }
   }
  }
  r = y;
 }
 return r;
}

template<int W, int I>
ap_ufixed<W,I> exp10(ap_ufixed<W,I> x) {
    ap_fixed<W+1,I+1> xf = x;
    return exp10(xf);
}

template<int I>
ap_int<I> exp10(ap_int<I> x) {
    ap_fixed<I,I> xf = x;
    return exp10(xf);
}

template<int I>
ap_uint<I> exp10(ap_uint<I> x) {
    ap_fixed<I+1,I+1> xf = x;
    return exp10(xf);
}

}
# 1068 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_math.h" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_log_apfixed.h" 1
# 39 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_log_apfixed.h"
namespace log_apfixed_reduce {


template <typename T, int p, int alpha, int size> class log_lut_table { public:
log_lut_table<T,p,alpha,size>();
static const T array [size];};
template <> class log_lut_table<ap_fixed<29, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<29, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<29, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
template <> class log_lut_table<ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
template <> class log_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
template <> class log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
template <> class log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
template <> class log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
template <> class log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};

template <> class log_lut_table<ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64> { public:
log_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>();
static const ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64> { public:
log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>();
static const ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64> { public:
log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>();
static const ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64> { public:
log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>();
static const ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64> { public:
log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};

template <> class log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64> { public:
log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64>();
static const ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64> { public:
log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64>();
static const ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64> { public:
log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64>();
static const ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64> { public:
log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};

template <> class log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64> { public:
log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64>();
static const ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64> { public:
log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64>();
static const ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64> { public:
log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};

template <> class log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,27,6,64> { public:
log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,27,6,64>();
static const ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,27,6,64> { public:
log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,27,6,64>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};

template <> class log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,32,6,64> { public:
log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,32,6,64>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};

template <typename T, int p, int alpha, int size> class log0_lut_table { public:
log0_lut_table<T,p,alpha,size>();
static const T array[size];};
template <> class log0_lut_table<ap_fixed<20, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<20, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();

static const ap_fixed<20, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log0_lut_table<ap_fixed<29, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<29, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();
static const ap_fixed<29, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log0_lut_table<ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();
static const ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log0_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();
static const ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log0_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();
static const ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log0_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();
static const ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log0_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();
static const ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log0_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};

class log_inverse_lut_table { public:
log_inverse_lut_table();
static const ap_ufixed<6, 1, (ap_q_mode)5, (ap_o_mode)3, 0> array[64];};


template <typename LOG_TYPE, int p, int alpha, int size, int sizeout>
void range_reduce(ap_ufixed<size, -p> zN, LOG_TYPE &log, ap_ufixed<sizeout, -(p+alpha-1)> &zN1)
{

    const int T1size = 1 << alpha;




    ap_ufixed<alpha, -p> a = zN;
    ap_ufixed<size-alpha, -p-alpha> b = zN;
    ap_ufixed<size+p+2*p+1, 1> zNext = 1+zN;
    int e_shift = (p!=4 || a[a.wl()-1]==1) ? 2*p : 2*p+1;
    ap_ufixed<size+p+1, 1-2*p> eZ = zNext >> e_shift;

    zN1 = ((b + eZ) - a*zN);
    ap_uint<alpha> index = a(alpha-1,0);
    log = log_lut_table<LOG_TYPE, p,alpha,T1size>::array[index];


}




const int p0 = 0;
const int alpha0 = 5;
const int p1 = (alpha0 == 5) ? 4 : (alpha0-2);
const int alpha1 = 4;
const int p2 = p1 + alpha1 - 1;
const int alpha2 = 6;
const int p3 = p2 + alpha2 - 1;
const int alpha3 = 6;
const int p4 = p3 + alpha3 - 1;
const int alpha4 = 6;
const int p5 = p4 + alpha4 - 1;
const int alpha5 = 6;
const int p6 = p5 + alpha5 - 1;
const int alpha6 = 6;
const int p7 = p6 + alpha6 - 1;
const int alpha7 = 6;
const int p8 = p7 + alpha7 - 1;

template <int W_s_> class log_traits{};

template <>
class log_traits<1>{
public:
    const static int we = 6;
    const static int wf = 11;
    const static int org_wf = wf;

    const static int gbits = 1;
    const static int p_generic = p1;
    const static int MaxPrecision = wf+gbits+1;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        (void)(log_sum);
        return z1;
    }
};

template <>
class log_traits<2>{
public:
    const static int we = 6;
    const static int wf = 19;
    const static int org_wf = wf;

    const static int gbits = 2;
    const static int p_generic = p2;
    const static int MaxPrecision =wf+gbits+1;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        return z2;
    }
};

template <>
class log_traits<3>{
public:
    const static int we = 6;
    const static int wf = 33;
    const static int org_wf = wf;

    const static int gbits = 3;
    const static int p_generic = p3;
    const static int MaxPrecision = wf+gbits+1;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        return z3;
    }
};

template <>
class log_traits<4>{
public:
    const static int we = 6;
    const static int wf = 48;
    const static int org_wf = wf;

    const static int gbits = 3;
    const static int p_generic = p4;
    const static int MaxPrecision = wf+gbits+1;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);
    const static int w4 = w3+2*p3+1-(alpha3-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        ap_ufixed<(w4 < MaxPrecision-p4) ? w4 : (MaxPrecision-p4), -p4> z4;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        range_reduce<LOG_TYPE, p3, alpha3> (z3, logn, z4);
        log_sum += logn;
        return z4;
    }
};

template <>
class log_traits<5>{
public:
    const static int we = 6;
    const static int wf = 63;
    const static int org_wf = wf;

    const static int gbits = 3;
    const static int p_generic = p5;
    const static int MaxPrecision = wf+gbits+1;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);
    const static int w4 = w3+2*p3+1-(alpha3-1);
    const static int w5 = w4+2*p4+1-(alpha4-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        ap_ufixed<(w4 < MaxPrecision-p4) ? w4 : (MaxPrecision-p4), -p4> z4;
        ap_ufixed<(w5 < MaxPrecision-p5) ? w5 : (MaxPrecision-p5), -p5> z5;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        range_reduce<LOG_TYPE, p3, alpha3> (z3, logn, z4);
        log_sum += logn;
        range_reduce<LOG_TYPE, p4, alpha4> (z4, logn, z5);
        log_sum += logn;
        return z5;
    }
};

template <>
class log_traits<6>{
public:
    const static int we = 6;
    const static int wf = 76;
    const static int org_wf = wf;

    const static int gbits = 4;
    const static int p_generic = p6;
    const static int MaxPrecision = wf+gbits+2;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);
    const static int w4 = w3+2*p3+1-(alpha3-1);
    const static int w5 = w4+2*p4+1-(alpha4-1);
    const static int w6 = w5+2*p5+1-(alpha5-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        ap_ufixed<(w4 < MaxPrecision-p4) ? w4 : (MaxPrecision-p4), -p4> z4;
        ap_ufixed<(w5 < MaxPrecision-p5) ? w5 : (MaxPrecision-p5), -p5> z5;
        ap_ufixed<(w6 < MaxPrecision-p6) ? w6 : (MaxPrecision-p6), -p6> z6;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        range_reduce<LOG_TYPE, p3, alpha3> (z3, logn, z4);
        log_sum += logn;
        range_reduce<LOG_TYPE, p4, alpha4> (z4, logn, z5);
        log_sum += logn;
        range_reduce<LOG_TYPE, p5, alpha5> (z5, logn, z6);
        log_sum += logn;
        return z6;
    }
};

template <>
class log_traits<7>{
public:
    const static int we = 6;
    const static int wf = 91;
    const static int org_wf = wf;

    const static int gbits = 4;
    const static int p_generic = p7;
    const static int MaxPrecision = wf+gbits+2;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);
    const static int w4 = w3+2*p3+1-(alpha3-1);
    const static int w5 = w4+2*p4+1-(alpha4-1);
    const static int w6 = w5+2*p5+1-(alpha5-1);
    const static int w7 = w6+2*p6+1-(alpha6-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        ap_ufixed<(w4 < MaxPrecision-p4) ? w4 : (MaxPrecision-p4), -p4> z4;
        ap_ufixed<(w5 < MaxPrecision-p5) ? w5 : (MaxPrecision-p5), -p5> z5;
        ap_ufixed<(w6 < MaxPrecision-p6) ? w6 : (MaxPrecision-p6), -p6> z6;
        ap_ufixed<(w7 < MaxPrecision-p7) ? w7 : (MaxPrecision-p7), -p7> z7;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        range_reduce<LOG_TYPE, p3, alpha3> (z3, logn, z4);
        log_sum += logn;
        range_reduce<LOG_TYPE, p4, alpha4> (z4, logn, z5);
        log_sum += logn;
        range_reduce<LOG_TYPE, p5, alpha5> (z5, logn, z6);
        log_sum += logn;
        range_reduce<LOG_TYPE, p6, alpha6> (z6, logn, z7);
        log_sum += logn;
        return z7;
    }
};

template <>
class log_traits<8>{
public:
    const static int we = 6;
    const static int wf = 106;
    const static int org_wf = wf;

    const static int gbits = 4;
    const static int p_generic = p8;
    const static int MaxPrecision = wf+gbits+2;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);
    const static int w4 = w3+2*p3+1-(alpha3-1);
    const static int w5 = w4+2*p4+1-(alpha4-1);
    const static int w6 = w5+2*p5+1-(alpha5-1);
    const static int w7 = w6+2*p6+1-(alpha6-1);
    const static int w8 = w7+2*p7+1-(alpha7-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        ap_ufixed<(w4 < MaxPrecision-p4) ? w4 : (MaxPrecision-p4), -p4> z4;
        ap_ufixed<(w5 < MaxPrecision-p5) ? w5 : (MaxPrecision-p5), -p5> z5;
        ap_ufixed<(w6 < MaxPrecision-p6) ? w6 : (MaxPrecision-p6), -p6> z6;
        ap_ufixed<(w7 < MaxPrecision-p7) ? w7 : (MaxPrecision-p7), -p7> z7;
        ap_ufixed<(w8 < MaxPrecision-p8) ? w8 : (MaxPrecision-p8), -p8> z8;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        range_reduce<LOG_TYPE, p3, alpha3> (z3, logn, z4);
        log_sum += logn;
        range_reduce<LOG_TYPE, p4, alpha4> (z4, logn, z5);
        log_sum += logn;
        range_reduce<LOG_TYPE, p5, alpha5> (z5, logn, z6);
        log_sum += logn;
        range_reduce<LOG_TYPE, p6, alpha6> (z6, logn, z7);
        log_sum += logn;
        range_reduce<LOG_TYPE, p7, alpha7> (z7, logn, z8);
        log_sum += logn;
        return z8;
    }
};
template<int W_, int I_>
ap_fixed<W_,I_> log(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline


 const static int F_ = W_ - I_;
    if (I_>34) return 0;
    else if (F_>100) return 0;


    ap_fixed<W_,I_> r = 0;
    ap_ufixed<W_-1,I_-1> x_s = x;

    if (F_==0) {
        if (I_<=7) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else r = 4;
        } else if (I_<=10) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5ap0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf4p0")) r = 5;
            else r = 6;
        } else if (I_<=13) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5ap0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf4p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x299p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x710p0")) r = 7;
            else r = 8;
        } else if (I_<=17) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5ap0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf4p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x299p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x710p0")) r = 7;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1332p0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x342fp0")) r = 9;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8ddbp0")) r = 10;
            else r = 11;
        } else if (I_<=19) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5ap0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf4p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x299p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x710p0")) r = 7;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1332p0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x342fp0")) r = 9;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8ddbp0")) r = 10;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1819bp0")) r = 11;
            else r = 12;
        } else if (I_<=26) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5ap0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf4p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x299p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x710p0")) r = 7;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1332p0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x342fp0")) r = 9;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8ddbp0")) r = 10;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1819bp0")) r = 11;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x41831p0")) r = 12;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xb2148p0")) r = 13;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1e4127p0")) r = 14;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x523d82p0")) r = 15;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xdf8d5fp0")) r = 16;
            else r = 17;
        } else if (I_<=32) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5ap0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf4p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x299p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x710p0")) r = 7;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1332p0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x342fp0")) r = 9;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8ddbp0")) r = 10;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1819bp0")) r = 11;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x41831p0")) r = 12;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xb2148p0")) r = 13;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1e4127p0")) r = 14;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x523d82p0")) r = 15;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xdf8d5fp0")) r = 16;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x25fad90p0")) r = 17;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x673d70bp0")) r = 18;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x118a2aaep0")) r = 19;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2fad89e1p0")) r = 20;
            else r = 21;
        } else {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5ap0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf4p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x299p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x710p0")) r = 7;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1332p0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x342fp0")) r = 9;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8ddbp0")) r = 10;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1819bp0")) r = 11;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x41831p0")) r = 12;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xb2148p0")) r = 13;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1e4127p0")) r = 14;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x523d82p0")) r = 15;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xdf8d5fp0")) r = 16;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x25fad90p0")) r = 17;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x673d70bp0")) r = 18;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x118a2aaep0")) r = 19;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2fad89e1p0")) r = 20;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x819a1801p0")) r = 21;
            else r = 22;
        }
    } else if (F_<=4 && I_<=5) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.1p0")) r = "-0x2.cp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.2p0")) r = "-0x2.1p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.3p0")) r = "-0x1.bp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.4p0")) r = "-0x1.6p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.5p0")) r = "-0x1.3p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.6p0")) r = "-0x1p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.7p0")) r = "-0x0.dp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.8p0")) r = "-0x0.bp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.9p0")) r = "-0x0.9p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.ap0")) r = "-0x0.8p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.bp0")) r = "-0x0.6p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.cp0")) r = "-0x0.5p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.dp0")) r = "-0x0.3p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.ep0")) r = "-0x0.2p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.fp0")) r = "-0x0.1p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x1p0")) r = "0x0p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.1p0")) r = "0x0.1p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.2p0")) r = "0x0.2p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.3p0")) r = "0x0.3p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.5p0")) r = "0x0.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.6p0")) r = "0x0.5p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.8p0")) r = "0x0.6p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.9p0")) r = "0x0.7p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.bp0")) r = "0x0.8p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.cp0")) r = "0x0.9p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.ep0")) r = "0x0.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = "0x0.bp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.2p0")) r = "0x0.cp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.5p0")) r = "0x0.dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.7p0")) r = "0x0.ep0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.ap0")) r = "0x0.fp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.cp0")) r = "0x1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.fp0")) r = "0x1.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.2p0")) r = "0x1.2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.6p0")) r = "0x1.3p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.9p0")) r = "0x1.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.dp0")) r = "0x1.5p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.1p0")) r = "0x1.6p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.5p0")) r = "0x1.7p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.9p0")) r = "0x1.8p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.ep0")) r = "0x1.9p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.3p0")) r = "0x1.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.9p0")) r = "0x1.bp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.ep0")) r = "0x1.cp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.5p0")) r = "0x1.dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.bp0")) r = "0x1.ep0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.2p0")) r = "0x1.fp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.9p0")) r = "0x2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.1p0")) r = "0x2.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.ap0")) r = "0x2.2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.3p0")) r = "0x2.3p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.cp0")) r = "0x2.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xa.6p0")) r = "0x2.5p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xb.1p0")) r = "0x2.6p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xb.cp0")) r = "0x2.7p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc.9p0")) r = "0x2.8p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xd.6p0")) r = "0x2.9p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xe.3p0")) r = "0x2.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf.2p0")) r = "0x2.bp0";
            else r = "0x2.cp0";
    } else {

        if (x<=0) {r[W_-1] = 1;}
        else {


            const static int W_s_ = (F_+F_/77*2+12)/15-(100+F_)/133+(99+F_)/133-(100+F_)/118+(98+F_)/118+1;
# 717 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_log_apfixed.h"
            const static int wf = log_traits<W_s_>::wf;
            const static int I_s= I_>0? I_:-I_;
            const static int org_wf = log_traits<W_s_>::org_wf+I_s;
            const static int MaxPrecision = log_traits<W_s_>::MaxPrecision;




            ap_int<7> b_exp;
            ap_ufixed<1 + org_wf,1> b_frac=0;
            b_frac[org_wf] = 0;
            b_frac(org_wf-1,org_wf-W_+1) = x(W_-2,0);
            VITIS_LOOP_729_1: for (b_exp = I_-1; b_exp >= -F_; b_exp--) {
#pragma HLS unroll
 if ((!b_frac[org_wf]&b_frac[org_wf-1]&b_frac[org_wf-2])|(b_frac[org_wf]&!b_frac[org_wf-1]))
                    break;
                b_frac <<= 1;
            }



            const ap_ufixed<MaxPrecision,0> LOG2 = "0x0.B17217F7D1CF79ABC9E3B39803p0";
            ap_fixed<MaxPrecision,6> Elog2 = LOG2 * b_exp;



            typedef typename log_traits<W_s_>::LOG_TYPE LOG_TYPE;
            const static int bypass_threshold = log_traits<W_s_>::p_generic;


            ap_uint<1+alpha0> index0;
            if (b_frac[org_wf]) index0 = b_frac(org_wf-1,org_wf-6);
            else index0 = b_frac(org_wf-2,org_wf-7);

            const int T0size = 1 << (1+alpha0);




            ap_ufixed<1 + alpha0, 1> b_frac_tilde_inverse = log_inverse_lut_table::array[index0];


            LOG_TYPE log_sum = log0_lut_table<LOG_TYPE,p0,alpha0,T0size>::array[index0];

            ap_ufixed<1 + org_wf+1+(1+alpha0), 1> b_frac1 = b_frac * b_frac_tilde_inverse;





            const int z1_width = 1+wf+1+(1+alpha0)-p1+1;
            ap_ufixed<z1_width, -p1> z1 = b_frac1;


            ap_fixed<1-bypass_threshold+1+MaxPrecision, -bypass_threshold+1> zk;
            zk = log_traits<W_s_>::range_reduction(z1,log_sum);


            ap_fixed<1-2*bypass_threshold+1+MaxPrecision, -bypass_threshold+1> zk_trunc = zk;
            LOG_TYPE sum = zk-(zk_trunc*zk_trunc/2);

            LOG_TYPE log_base;
            log_base = Elog2 + log_sum + sum;



            ap_fixed<2 + F_, 1> delta = 0;
            delta[delta.wl()-1] = log_base[log_base.wl()-1];
            delta[delta.wl()-delta.iwl()-1] = 1;
            log_base = log_base + ( delta >> F_ );

            r = log_base;
        }

    }

    return r;
}

template<int W_, int I_>
ap_ufixed<W_,I_> log(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return log(xf);
}

template<int I_>
ap_int<I_> log(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return log(xf);
}

template<int I_>
ap_uint<I_> log(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return log(xf);
}


template<int W_, int I_>
ap_fixed<W_,I_> log10(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline


 const static int F_ = W_ - I_;
    if (I_>33) return 0;
    else if (F_>32) return 0;


    ap_fixed<W_,I_> r = 0;
    ap_ufixed<W_-1,I_-1> x_s = x;

    if (F_==0) {
        if (I_<=9) {
            if (x<=0) {r[W_-1] = 1;}
            else {
                ap_ufixed<8,8> x_s_l = x_s;
                if (x_s_l(7,2)==0) r = 0;
                else if (x_s_l(7,5)==0) r = 1;
                else r = 2;
            }
        } else if (I_<=15) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1fp0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x13cp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc5ap0")) r = 3;
            else r = 4;
        } else if (I_<=19) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1fp0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x13cp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc5ap0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7b86p0")) r = 4;
            else r = 5;
        } else if (I_<=25) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1fp0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x13cp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc5ap0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7b86p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4d343p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3040a5p0")) r = 6;
            else r = 7;
        } else if (I_<=32) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1fp0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x13cp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc5ap0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7b86p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4d343p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3040a5p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1e28678p0")) r = 7;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x12d940b6p0")) r = 8;
            else r = 9;
        } else {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1fp0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x13cp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc5ap0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7b86p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4d343p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3040a5p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1e28678p0")) r = 7;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x12d940b6p0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xbc7c871cp0")) r = 9;
            else r = 10;
        }
    } else if (F_<=4 && I_<=5) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.1p0")) r = "-0x1.3p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.2p0")) r = "-0x0.ep0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.3p0")) r = "-0x0.cp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.4p0")) r = "-0x0.ap0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.5p0")) r = "-0x0.8p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.6p0")) r = "-0x0.7p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.7p0")) r = "-0x0.6p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.8p0")) r = "-0x0.5p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.9p0")) r = "-0x0.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x0.bp0")) r = "-0x0.3p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.cp0")) r = "-0x0.2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x0.ep0")) r = "-0x0.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.1p0")) r = "0x0p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.3p0")) r = "0x0.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.6p0")) r = "0x0.2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.ap0")) r = "0x0.3p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.ep0")) r = "0x0.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.3p0")) r = "0x0.5p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.8p0")) r = "0x0.6p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.fp0")) r = "0x0.7p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.6p0")) r = "0x0.8p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.ep0")) r = "0x0.9p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.8p0")) r = "0x0.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.3p0")) r = "0x0.bp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6p0")) r = "0x0.cp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.fp0")) r = "0x0.dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8p0")) r = "0x0.ep0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.4p0")) r = "0x0.fp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xa.bp0")) r = "0x1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc.6p0")) r = "0x1.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xe.5p0")) r = "0x1.2p0";
            else r = "0x1.3p0";
    } else {

        if (x<=0) {r[W_-1] = 1;}
        else {
            const static int W_s_= (F_+F_/77*2+12)/15-(100+F_)/133+(99+F_)/133-(100+F_)/118+(98+F_)/118+1;






            const static int wf = log_traits<W_s_>::wf;
            const static int I_s= I_>0? I_:-I_;
            const static int org_wf = log_traits<W_s_>::org_wf+I_s;
            const static int MaxPrecision = log_traits<W_s_>::MaxPrecision;





            ap_int<7> b_exp=0;
            ap_ufixed<1 + org_wf,1> b_frac=0;
            b_frac[org_wf] = 0;
            b_frac(org_wf-1,org_wf-W_+1) = x(W_-2,0);
            VITIS_LOOP_947_1: for (b_exp = I_-1; b_exp >= -F_; b_exp--) {
#pragma HLS unroll
 if ((!b_frac[org_wf]&b_frac[org_wf-1]&b_frac[org_wf-2])|(b_frac[org_wf]&!b_frac[org_wf-1]))
                    break;
                b_frac <<= 1;
            }

            const ap_ufixed<25,0> LOG1_35_s = 0.3010300099849700927734375;
            const ap_ufixed<43,0> LOG1_35_l = 0.30102999566395283181918784976006;
            ap_fixed<30,5> Elog2_s = LOG1_35_s * b_exp;
            ap_fixed<48,5> Elog2_l = LOG1_35_l * b_exp;


            typedef typename log_traits<W_s_>::LOG_TYPE LOG_TYPE;
            const static int bypass_threshold = log_traits<W_s_>::p_generic;

            ap_uint<1+alpha0> index0;
            if (b_frac[org_wf]) index0 = b_frac(org_wf-1,org_wf-6);
            else index0 = b_frac(org_wf-2,org_wf-7);

            const int T0size = 1 << (1+alpha0);




            ap_ufixed<1 + alpha0, 1> b_frac_tilde_inverse = log_inverse_lut_table::array[index0];

            LOG_TYPE log_sum = log0_lut_table<LOG_TYPE,p0,alpha0,T0size>::array[index0];

            ap_ufixed<1 + org_wf+1+(1+alpha0), 1> b_frac1 = b_frac * b_frac_tilde_inverse;




            const int z1_width = 1+wf+1+(1+alpha0)-p1+1;
            ap_ufixed<z1_width, -p1> z1 = b_frac1;

            ap_fixed<1-bypass_threshold+1+MaxPrecision, -bypass_threshold+1> zk;
            zk = log_traits<W_s_>::range_reduction(z1,log_sum);

            ap_fixed<1-2*bypass_threshold+1+MaxPrecision, -bypass_threshold+1> zk_trunc = zk;
            LOG_TYPE sum = zk-(zk_trunc*zk_trunc/2);

            LOG_TYPE log_base = log_sum + sum;

            const ap_ufixed<25,0> LOG1_54_s = 0.4342944920063018798828125;
            const ap_ufixed<43,0> LOG1_54_l = 0.43429448190329367207596078515053;

            if (F_<=16) log_base = Elog2_s + log_base * LOG1_54_s;
            else log_base = Elog2_l + log_base * LOG1_54_l;
# 1005 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_log_apfixed.h"
            r = log_base;
        }

    }

    return r;
}

template<int W_, int I_>
ap_ufixed<W_,I_> log10(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return log10(xf);
}

template<int I_>
ap_int<I_> log10(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return log10(xf);
}

template<int I_>
ap_uint<I_> log10(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return log10(xf);
}

template<int W, int I>
ap_fixed<W,I> log1p(ap_fixed<W,I> x) {
    ap_ufixed<1,1> inc = 1;
    ap_fixed<W+1,I+1> xp1 = x + inc;
    return log(xp1);
}

template<int W, int I>
ap_ufixed<W,I> log1p(ap_ufixed<W,I> x) {
    ap_fixed<W+1,I+1> xf = x;
    return log1p(xf);
}

template<int I>
ap_int<I> log1p(ap_int<I> x) {
    ap_fixed<I,I> xf = x;
    return log1p(xf);
}

template<int I>
ap_uint<I> log1p(ap_uint<I> x) {
    ap_fixed<I+1,I+1> xf = x;
    return log1p(xf);
}

template<int W,int I>
ap_fixed<W,I> ilogb(ap_fixed<W,I> x) {
    int F = W - I;
    if(F>32 || I>33) {
        return 0;
    }
    ap_fixed<W+1,I+1> xf;
    if(x>0) {
        xf = x;
    }
    else {
        xf = -x;
    }
    return I + 1 - xf.countLeadingZeros() - 1;
}

template<int W,int I>
ap_ufixed<W,I> ilogb(ap_ufixed<W,I> x) {
    ap_fixed<W+1,I+1> xf = x;
    return ilogb(xf);
}

template<int I>
ap_int<I> ilogb(ap_int<I> x) {
    ap_fixed<I,I> xf = x;
    return ilogb(xf);
}

template<int I>
ap_uint<I> ilogb(ap_uint<I> x) {
    ap_fixed<I+1,I+1> xf = x;
    return ilogb(xf);
}


template<int W_, int I_>
ap_fixed<W_,I_> log2(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline


 const static int F_ = W_ - I_;
    if (I_>33) return 0;
    else if (F_>32) return 0;


    ap_fixed<W_,I_> r = 0;
    ap_ufixed<W_-1,I_-1> x_s = x;

    if (F_==0) {
        if (I_<=5) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = 1;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5p0")) r = 2;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xBp0")) r = 3;
            else r = 4;
  } else if (I_<=9) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = 1;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5p0")) r = 2;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xBp0")) r = 3;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2Dp0")) r = 5;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5Ap0")) r = 6;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB5p0")) r = 7;
            else r = 8;
        } else if (I_<=13) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = 1;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5p0")) r = 2;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xBp0")) r = 3;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2Dp0")) r = 5;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5Ap0")) r = 6;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB5p0")) r = 7;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16Ap0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D4p0")) r = 9;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8p0")) r = 10;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB50p0")) r = 11;
            else r = 12;
  } else if (I_<=17) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = 1;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5p0")) r = 2;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xBp0")) r = 3;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2Dp0")) r = 5;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5Ap0")) r = 6;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB5p0")) r = 7;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16Ap0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D4p0")) r = 9;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8p0")) r = 10;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB50p0")) r = 11;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A0p0")) r = 12;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D41p0")) r = 13;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A82p0")) r = 14;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504p0")) r = 15;
            else r = 16;
        } else if (I_<=21) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = 1;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5p0")) r = 2;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xBp0")) r = 3;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2Dp0")) r = 5;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5Ap0")) r = 6;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB5p0")) r = 7;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16Ap0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D4p0")) r = 9;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8p0")) r = 10;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB50p0")) r = 11;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A0p0")) r = 12;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D41p0")) r = 13;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A82p0")) r = 14;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504p0")) r = 15;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09p0")) r = 16;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413p0")) r = 17;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A827p0")) r = 18;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504Fp0")) r = 19;
            else r = 20;
        } else if (I_<=25) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = 1;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5p0")) r = 2;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xBp0")) r = 3;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2Dp0")) r = 5;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5Ap0")) r = 6;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB5p0")) r = 7;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16Ap0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D4p0")) r = 9;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8p0")) r = 10;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB50p0")) r = 11;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A0p0")) r = 12;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D41p0")) r = 13;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A82p0")) r = 14;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504p0")) r = 15;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09p0")) r = 16;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413p0")) r = 17;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A827p0")) r = 18;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504Fp0")) r = 19;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09Ep0")) r = 20;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413Cp0")) r = 21;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8279p0")) r = 22;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504F3p0")) r = 23;
            else r = 24;
        } else if (I_<=29) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = 1;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5p0")) r = 2;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xBp0")) r = 3;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2Dp0")) r = 5;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5Ap0")) r = 6;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB5p0")) r = 7;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16Ap0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D4p0")) r = 9;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8p0")) r = 10;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB50p0")) r = 11;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A0p0")) r = 12;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D41p0")) r = 13;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A82p0")) r = 14;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504p0")) r = 15;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09p0")) r = 16;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413p0")) r = 17;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A827p0")) r = 18;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504Fp0")) r = 19;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09Ep0")) r = 20;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413Cp0")) r = 21;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8279p0")) r = 22;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504F3p0")) r = 23;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09E6p0")) r = 24;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413CCp0")) r = 25;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A82799p0")) r = 26;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504F33p0")) r = 27;
            else r = 28;
        } else {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = 1;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5p0")) r = 2;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xBp0")) r = 3;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2Dp0")) r = 5;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5Ap0")) r = 6;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB5p0")) r = 7;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16Ap0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D4p0")) r = 9;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8p0")) r = 10;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB50p0")) r = 11;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A0p0")) r = 12;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D41p0")) r = 13;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A82p0")) r = 14;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504p0")) r = 15;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09p0")) r = 16;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413p0")) r = 17;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A827p0")) r = 18;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504Fp0")) r = 19;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09Ep0")) r = 20;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413Cp0")) r = 21;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8279p0")) r = 22;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504F3p0")) r = 23;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09E6p0")) r = 24;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413CCp0")) r = 25;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A82799p0")) r = 26;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504F33p0")) r = 27;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09E66p0")) r = 28;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413CCCp0")) r = 29;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A827999p0")) r = 30;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504F333p0")) r = 31;
            else r = 32;
        }
    } else if (F_<=4 && I_<=5) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.1p0")) r = "-0x4.0p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.2p0")) r = "-0x3.0p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.3p0")) r = "-0x2.7p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.4p0")) r = "-0x2.0p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.5p0")) r = "-0x1.Bp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.6p0")) r = "-0x1.7p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.7p0")) r = "-0x1.3p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.8p0")) r = "-0x1.0p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.9p0")) r = "-0x0.Dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x0.Ap0")) r = "-0x0.Bp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.Bp0")) r = "-0x0.9p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.Cp0")) r = "-0x0.7p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.Dp0")) r = "-0x0.5p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.Ep0")) r = "-0x0.3p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.Fp0")) r = "-0x0.1p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.0p0")) r = "0x0.0p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.1p0")) r = "0x0.1p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.2p0")) r = "0x0.3p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.3p0")) r = "0x0.4p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.4p0")) r = "0x0.5p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.5p0")) r = "0x0.6p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.6p0")) r = "0x0.7p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.7p0")) r = "0x0.8p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.8p0")) r = "0x0.9p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.9p0")) r = "0x0.Ap0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.Ap0")) r = "0x0.Bp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.Bp0")) r = "0x0.Cp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.Cp0")) r = "0x0.Dp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.Dp0")) r = "0x0.Ep0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.Fp0")) r = "0x0.Fp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.0p0")) r = "0x1.0p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.2p0")) r = "0x1.1p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.3p0")) r = "0x1.2p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.5p0")) r = "0x1.3p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.6p0")) r = "0x1.4p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.8p0")) r = "0x1.5p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.Ap0")) r = "0x1.6p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.Cp0")) r = "0x1.7p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.Ep0")) r = "0x1.8p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.0p0")) r = "0x1.9p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.2p0")) r = "0x1.Ap0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.4p0")) r = "0x1.Bp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.6p0")) r = "0x1.Cp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.9p0")) r = "0x1.Dp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.Bp0")) r = "0x1.Ep0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.Ep0")) r = "0x1.Fp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.1p0")) r = "0x2.0p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.4p0")) r = "0x2.1p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.7p0")) r = "0x2.2p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.Ap0")) r = "0x2.3p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.Dp0")) r = "0x2.4p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.1p0")) r = "0x2.5p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.4p0")) r = "0x2.6p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.8p0")) r = "0x2.7p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.Cp0")) r = "0x2.8p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.0p0")) r = "0x2.9p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.4p0")) r = "0x2.Ap0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.9p0")) r = "0x2.Bp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.Dp0")) r = "0x2.Cp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.2p0")) r = "0x2.Dp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.7p0")) r = "0x2.Ep0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.Dp0")) r = "0x2.Fp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.2p0")) r = "0x3.0p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.8p0")) r = "0x3.1p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.Ep0")) r = "0x3.2p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.4p0")) r = "0x3.3p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.Bp0")) r = "0x3.4p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xA.2p0")) r = "0x3.5p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xA.9p0")) r = "0x3.6p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB.1p0")) r = "0x3.7p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB.8p0")) r = "0x3.8p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xC.1p0")) r = "0x3.9p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xC.9p0")) r = "0x3.Ap0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xD.2p0")) r = "0x3.Bp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xD.Bp0")) r = "0x3.Cp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xE.5p0")) r = "0x3.Dp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xE.Fp0")) r = "0x3.Ep0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xF.Ap0")) r = "0x3.Fp0";
            else r = "0x4.0p0";
    } else {

        if (x<=0) {r[W_-1] = 1;}
        else {
            const static int W_s_= (F_+F_/77*2+12)/15-(100+F_)/133+(99+F_)/133-(100+F_)/118+(98+F_)/118+1;

            const static int wf = log_traits<W_s_>::wf;
            const static int I_s= I_>0? I_:-I_;
            const static int org_wf = log_traits<W_s_>::org_wf+I_s;
            const static int MaxPrecision = log_traits<W_s_>::MaxPrecision;

            ap_int<7> b_exp=0;
            ap_ufixed<1 + org_wf,1> b_frac=0;
            b_frac[org_wf] = 0;
            b_frac(org_wf-1,org_wf-W_+1) = x(W_-2,0);
            VITIS_LOOP_1371_1: for (b_exp = I_-1; b_exp >= -F_; b_exp--) {
#pragma HLS unroll
 if ((!b_frac[org_wf]&b_frac[org_wf-1]&b_frac[org_wf-2])|(b_frac[org_wf]&!b_frac[org_wf-1]))
                    break;
                b_frac <<= 1;
            }

            ap_fixed<30,5> Elog2_s = b_exp;
            ap_fixed<48,5> Elog2_l = b_exp;


            typedef typename log_traits<W_s_>::LOG_TYPE LOG_TYPE;
            const static int bypass_threshold = log_traits<W_s_>::p_generic;

            ap_uint<1+alpha0> index0;
            if (b_frac[org_wf]) index0 = b_frac(org_wf-1,org_wf-6);
            else index0 = b_frac(org_wf-2,org_wf-7);

            const int T0size = 1 << (1+alpha0);




            ap_ufixed<1 + alpha0, 1> b_frac_tilde_inverse = log_inverse_lut_table::array[index0];

            LOG_TYPE log_sum = log0_lut_table<LOG_TYPE,p0,alpha0,T0size>::array[index0];

            ap_ufixed<1 + org_wf+1+(1+alpha0), 1> b_frac1 = b_frac * b_frac_tilde_inverse;




            const int z1_width = 1+wf+1+(1+alpha0)-p1+1;
            ap_ufixed<z1_width, -p1> z1 = b_frac1;

            ap_fixed<1-bypass_threshold+1+MaxPrecision, -bypass_threshold+1> zk;
            zk = log_traits<W_s_>::range_reduction(z1,log_sum);

            ap_fixed<1-2*bypass_threshold+1+MaxPrecision, -bypass_threshold+1> zk_trunc = zk;
            LOG_TYPE sum = zk-(zk_trunc*zk_trunc/2);

            LOG_TYPE log_base = log_sum + sum;

            const ap_ufixed<26,1> LOG1_54_s = "0x1.7154765p0";
            const ap_ufixed<44,1> LOG1_54_l = "0x1.71547652B82Fp0";

            if (F_<=16) log_base = Elog2_s + log_base * LOG1_54_s;
            else log_base = Elog2_l + log_base * LOG1_54_l;



            r = log_base;
        }

    }

    return r;
}

template<int W_, int I_>
ap_ufixed<W_,I_> log2(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return log2(xf);
}

template<int I_>
ap_int<I_> log2(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return log2(xf);
}

template<int I_>
ap_uint<I_> log2(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return log2(xf);
}

template<int W_, int I_>
ap_fixed<W_,I_> logb(ap_fixed<W_,I_> x) {
 return log2(x);
}

template<int W_, int I_>
ap_ufixed<W_,I_> logb(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return logb(xf);
}

template<int I_>
ap_int<I_> logb(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return logb(xf);
}

template<int I_>
ap_uint<I_> logb(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return logb(xf);
}

}
# 1069 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_math.h" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_sqrt_apfixed.h" 1
# 34 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_sqrt_apfixed.h"
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/ap_int.h" 1
# 35 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_sqrt_apfixed.h" 2






template <int W_, int I_>
ap_fixed<W_,I_> sqrt_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline


 const int F_ = W_ - I_;
    if (I_>34) return 0;
    else if (F_>32) return 0;


    ap_ufixed<F_+(I_+1)/2,(I_+1)/2> r;
    ap_ufixed<W_-1,I_-1> x_s = x;

    if ((F_==0)&&(I_==2)) {
            r = x_s;
    } else if ((F_==0)&&(I_<=13)) {
        ap_ufixed<W_,I_> x_s_l = x_s + 1;
        ap_ufixed<W_-1,I_-1> x_s_1;
        x_s_1(W_-2,0) = x_s_l(W_-1,1);
        if (I_<=8) {
            if (x_s_1==ap_ufixed<W_-1,I_-1>("0x0p0")) r = 0;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 1;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 2;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x6p0")) r = 3;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xap0")) r = 4;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xfp0")) r = 5;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x15p0")) r = 6;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x1cp0")) r = 7;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x24p0")) r = 8;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x2dp0")) r = 9;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x37p0")) r = 10;
            else r = 11;
        } else if (I_<=9) {
            if (x_s_1==ap_ufixed<W_-1,I_-1>("0x0p0")) r = 0;
            else if (x_s_1==ap_ufixed<W_-1,I_-1>("0x1p0")) r = 1;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 2;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x6p0")) r = 3;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xap0")) r = 4;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xfp0")) r = 5;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x15p0")) r = 6;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x1cp0")) r = 7;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x24p0")) r = 8;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x2dp0")) r = 9;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x37p0")) r = 10;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x42p0")) r = 11;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x4ep0")) r = 12;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x5bp0")) r = 13;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x69p0")) r = 14;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x78p0")) r = 15;
            else r = 16;
        } else {
            if (x_s_1==ap_ufixed<W_-1,I_-1>("0x0p0")) r = 0;
            else if (x_s_1==ap_ufixed<W_-1,I_-1>("0x1p0")) r = 1;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 2;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x6p0")) r = 3;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xap0")) r = 4;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xfp0")) r = 5;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x15p0")) r = 6;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x1cp0")) r = 7;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x24p0")) r = 8;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x2dp0")) r = 9;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x37p0")) r = 10;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x42p0")) r = 11;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x4ep0")) r = 12;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x5bp0")) r = 13;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x69p0")) r = 14;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x78p0")) r = 15;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x88p0")) r = 16;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x99p0")) r = 17;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xabp0")) r = 18;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xbep0")) r = 19;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xd2p0")) r = 20;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xe7p0")) r = 21;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xfdp0")) r = 22;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x114p0")) r = 23;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x12cp0")) r = 24;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x145p0")) r = 25;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x15fp0")) r = 26;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x17ap0")) r = 27;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x196p0")) r = 28;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x1b3p0")) r = 29;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x1d1p0")) r = 30;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x1f0p0")) r = 31;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x210p0")) r = 32;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x231p0")) r = 33;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x253p0")) r = 34;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x276p0")) r = 35;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x29ap0")) r = 36;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x2bfp0")) r = 37;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x2e5p0")) r = 38;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x30cp0")) r = 39;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x334p0")) r = 40;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x35dp0")) r = 41;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x387p0")) r = 42;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x3b2p0")) r = 43;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x3dep0")) r = 44;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x40bp0")) r = 45;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x439p0")) r = 46;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x468p0")) r = 47;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x498p0")) r = 48;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x4c9p0")) r = 49;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x4fbp0")) r = 50;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x52ep0")) r = 51;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x562p0")) r = 52;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x597p0")) r = 53;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x5cdp0")) r = 54;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x604p0")) r = 55;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x63cp0")) r = 56;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x675p0")) r = 57;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x6afp0")) r = 58;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x6eap0")) r = 59;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x726p0")) r = 60;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x763p0")) r = 61;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x7a1p0")) r = 62;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x7e0p0")) r = 63;
            else r = 64;
        }
    } else if (F_<=4 && I_<=5) {
            if (x_s==ap_ufixed<W_-1,I_-1>("0x0.0p0")) r = "0x0.0p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.1p0")) r = "0x0.4p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.2p0")) r = "0x0.6p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.3p0")) r = "0x0.7p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.4p0")) r = "0x0.8p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.5p0")) r = "0x0.9p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.6p0")) r = "0x0.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x0.8p0")) r = "0x0.bp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.9p0")) r = "0x0.cp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x0.bp0")) r = "0x0.dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x0.dp0")) r = "0x0.ep0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x0.fp0")) r = "0x0.fp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.1p0")) r = "0x1.0p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.3p0")) r = "0x1.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.5p0")) r = "0x1.2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.7p0")) r = "0x1.3p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.ap0")) r = "0x1.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.cp0")) r = "0x1.5p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.fp0")) r = "0x1.6p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.2p0")) r = "0x1.7p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.5p0")) r = "0x1.8p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.8p0")) r = "0x1.9p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.bp0")) r = "0x1.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.fp0")) r = "0x1.bp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.2p0")) r = "0x1.cp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.6p0")) r = "0x1.dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.ap0")) r = "0x1.ep0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.ep0")) r = "0x1.fp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.2p0")) r = "0x2.0p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.6p0")) r = "0x2.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.ap0")) r = "0x2.2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.ep0")) r = "0x2.3p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.3p0")) r = "0x2.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.7p0")) r = "0x2.5p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.cp0")) r = "0x2.6p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.1p0")) r = "0x2.7p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.6p0")) r = "0x2.8p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.bp0")) r = "0x2.9p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.0p0")) r = "0x2.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.6p0")) r = "0x2.bp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.bp0")) r = "0x2.cp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.1p0")) r = "0x2.dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.7p0")) r = "0x2.ep0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.dp0")) r = "0x2.fp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.3p0")) r = "0x3.0p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.9p0")) r = "0x3.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.fp0")) r = "0x3.2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xa.5p0")) r = "0x3.3p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xa.cp0")) r = "0x3.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xb.2p0")) r = "0x3.5p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xb.9p0")) r = "0x3.6p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc.0p0")) r = "0x3.7p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc.7p0")) r = "0x3.8p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc.ep0")) r = "0x3.9p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xd.5p0")) r = "0x3.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xd.dp0")) r = "0x3.bp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xe.4p0")) r = "0x3.cp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xe.cp0")) r = "0x3.dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf.4p0")) r = "0x3.ep0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf.cp0")) r = "0x3.fp0";
            else r = "0x4.0p0";
    } else {

        if (x[W_-1]) return 0;
        if (I_<=0) {
            const static int lsbx = (-I_+2<=W_) ? (W_+I_-2) : 0;
            if ( x(W_-1,lsbx) != 0 ) return 0;
        }

        const static int prcs = (F_+1)*2;
        const static int msbr = (I_>0) ? (I_+1)/2 : 1;
        const static int msbx = (I_>0) ? I_+3 : 4;
        const static int msbm = (I_>0) ? I_+1 : 2;


        ap_ufixed<msbx , msbx> x_l_I = x;
        ap_ufixed< prcs/2, 0> x_l_FH = x;
        ap_ufixed< prcs/2, -prcs/2> x_l_FL = 0;
        ap_ufixed<msbr + prcs , msbr> res = 0;
        ap_ufixed<msbr , msbr> res_I = 0;
        ap_ufixed< prcs/2, 0> res_FH = 0;
# 265 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_sqrt_apfixed.h"
    if (I_>0)
        VITIS_LOOP_266_1: for ( int pos = msbr-1; pos >= 0; pos-- ) {
#pragma HLS unroll
 ap_ufixed<msbm , msbm> mul_I = 0;



            mul_I ( msbr+pos , pos*2+1 ) = res_I ( msbr-1 , pos );



            mul_I [ pos*2 ] = 1;




            if ( x_l_I ( msbr+pos+1 , pos*2 ) >= mul_I ( msbr+pos , pos*2 ) ) {



                ap_ufixed<msbx,msbx> x_l_I_ = x_l_I;
                x_l_I ( msbr+pos+1 , pos*2 ) = x_l_I ( msbr+pos+1 , pos*2 ) - mul_I ( msbr+pos , pos*2 );




                res_I [ pos ] = 1;
            }
        }
        VITIS_LOOP_294_2: for ( int pos = -1; pos >= -F_-1; pos-- ) {
#pragma HLS unroll
 ap_ufixed<msbm + prcs , msbm> mul = 0;




            mul ( msbr+pos + prcs , pos +1 + prcs ) = res_I ( msbr-1 , 0 );
            mul ( pos + prcs , pos*2+1 + prcs ) = res_FH ( -1+prcs/2 , pos+prcs/2 );



            mul [ pos*2 + prcs ] = 1;
            ap_ufixed<msbm , msbm> mul_I = mul;
            ap_ufixed< prcs/2, 0> mul_FH = mul;
            ap_ufixed< prcs/2, -prcs/2> mul_FL = mul;

            ap_ufixed<msbx + prcs , msbx> x_l;
            x_l ( -1+msbx + prcs , prcs ) = x_l_I ( -1+msbx , 0 );
            x_l ( -1 + prcs , prcs/2 ) = x_l_FH ( -1+prcs/2 , 0 );
            x_l ( -1 + prcs/2 , 0 ) = x_l_FL ( -1+prcs/2 , 0 );



            if ( (x_l_I>mul_I) || ((x_l_I==mul_I)&&(x_l_FH>mul_FH)) || ((x_l_I==mul_I)&&(x_l_FH==mul_FH)&&(x_l_FL>=mul_FL)) ) {




                ap_ufixed< prcs/2+1 , -prcs/2+1 > x_l_FL_l = x_l_FL;
                if ( x_l_FL < mul_FL ) x_l_FL_l[prcs/2] = 1;
                                                  x_l_FL_l -= mul_FL;




                ap_ufixed< prcs/2+1 , 1 > x_l_FH_l = x_l_FH;
                if ( (x_l_FH<mul_FH)||((x_l_FH==mul_FH)&&(x_l_FL<mul_FL)) ) x_l_FH_l[prcs/2] = 1;
                ap_ufixed< 1 , -prcs/2+1 > delta = 0;
                if ( x_l_FL < mul_FL ) delta[0] = 1;
                                                                             x_l_FH_l -= delta;
                                                                             x_l_FH_l -= mul_FH;



                if ( (x_l_FH<mul_FH)||((x_l_FH==mul_FH)&&(x_l_FL<mul_FL)) ) x_l_I --;
                                                                             x_l_I -= mul_I;

                                                                             x_l_FH = x_l_FH_l;
                                                                             x_l_FL = x_l_FL_l;

                ap_ufixed<msbx + prcs , msbx> x_l_ = x_l;
                x_l ( -1+msbx + prcs , prcs ) = x_l_I ( -1+msbx , 0 );
                x_l ( -1 + prcs , prcs/2 ) = x_l_FH ( -1+prcs/2 , 0 );
                x_l ( -1 + prcs/2 , 0 ) = x_l_FL ( -1+prcs/2 , 0 );



                res_FH [ pos+prcs/2 ] = 1;
            }
        }



        ap_ufixed< prcs/2+1 , 1 > res_FH_l = res_FH;
        ap_ufixed< prcs/2 , 0 > delta;
                                  delta[delta.wl()-1] = 1;
                                  res_FH_l += ( delta >> F_ );
                                  res_FH = res_FH_l;
        if (res_FH_l[prcs/2]) res_I ++;

        res ( msbr-1 + prcs , prcs ) = res_I ( msbr-1 , 0 );
        res ( -1 + prcs , prcs/2 ) = res_FH ( -1+prcs/2 , 0 );

        r = res;
    }

    return r;
}
template<int W_, int I_>
ap_ufixed<W_,I_> sqrt_fixed(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return sqrt_fixed(xf);
}
template<int I_>
ap_int<I_> sqrt_fixed(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return sqrt_fixed(xf);
}
template<int I_>
ap_uint<I_> sqrt_fixed(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return sqrt_fixed(xf);
}


template <int W_, int I_>
ap_fixed<W_,I_> rsqrt_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline
 ap_ufixed<W_-1,I_-1> xs = x;
    const int Ix = ( I_ > 1 )? I_-1 : 1;
    ap_ufixed<Ix,Ix> xs_I = xs;
    ap_ufixed<W_-1,I_-1> r;
    const int I = ( I_-1 > W_-I_+1 ) ? I_-1 : W_-I_+1;
    ap_ufixed<I+W_-I_,I> y1;
    ap_ufixed<I+W_-I_,I> y2;
    if ( xs == 0 ) {
        return 0;
    } else if ( xs_I != 0 ) {
        y1 = xs;
    } else {
        y1 = 1;
        y1 = y1/xs;
    }
    y2 = sqrt_fixed(y1);
    if ( y2 == 0 ) {
        return 0;
    } else if ( xs_I != 0 ) {
        r = 1;
        r = r/y2;
    } else {
        r = y2;
    }
    return r;
}
template<int W_, int I_>
ap_ufixed<W_,I_> rsqrt_fixed(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return rsqrt_fixed(xf);
}
template<int I_>
ap_int<I_> rsqrt_fixed(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return rsqrt_fixed(xf);
}
template<int I_>
ap_uint<I_> rsqrt_fixed(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return rsqrt_fixed(xf);
}


template<int W_, int I_>
ap_fixed<W_,I_> recip_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline
 if ( x == 0 ) return 0;
    ap_fixed<W_,I_> r = 1;
    return r/x;
}
template<int W_, int I_>
ap_ufixed<W_,I_> recip_fixed(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return recip_fixed(xf);
}
template<int I_>
ap_int<I_> recip_fixed(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return recip_fixed(xf);
}
template<int I_>
ap_uint<I_> recip_fixed(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return recip_fixed(xf);
}
# 1070 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_math.h" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_round_copysign_apfixed.h" 1
# 35 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_round_copysign_apfixed.h"
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/ap_int.h" 1
# 36 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_round_copysign_apfixed.h" 2

template <int W_, int I_>
ap_fixed<W_,I_> ceil_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline
 if(W_ == I_) {
        return x;
    } else {
        if(I_<0) return 0;
        else {
           if ( x(W_-I_-1,0) != 0 ) {
               x(W_-I_-1,0) = 0;
               x += 1;
           }
           return x;
        }
    }
}
template <int W_, int I_>
ap_ufixed<W_,I_> ceil_fixed(ap_ufixed<W_,I_> x)
{
#pragma HLS pipeline
 if(W_ == I_) {
        return x;
    }
    else {
        if(I_ < 0) return 0;
        else {
           if ( x(W_-I_-1,0) != 0 ) {
               x(W_-I_-1,0) = 0;
               x += 1;
           }
           return x;
        }
    }
}
template <int I_>
ap_int<I_> ceil_fixed(ap_int<I_> x)
{
    return x;
}
template <int I_>
ap_uint<I_> ceil_fixed(ap_uint<I_> x)
{
    return x;
}

template <int W_, int I_>
ap_fixed<W_,I_> floor_fixed(ap_fixed<W_,I_> x)
{
    if(W_ == I_) {
        return x;
    }
    else {
        if(I_<0) return 0;
        else {
            if ( x(W_-I_-1,0) != 0 ) x(W_-I_-1,0) = 0;
            return x;
        }
    }
}
template <int W_, int I_>
ap_ufixed<W_,I_> floor_fixed(ap_ufixed<W_,I_> x)
{
    ap_fixed<W_+1,I_+1> xi = x;
    return floor_fixed(xi);
}
template <int I_>
ap_int<I_> floor_fixed(ap_int<I_> x)
{
    return x;
}
template <int I_>
ap_uint<I_> floor_fixed(ap_uint<I_> x)
{
    return x;
}

template <int W_, int I_>
ap_fixed<W_,I_> trunc_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline
 if(W_ == I_) {
        return x;
    }
    else {
        if(I_<0) return 0;
        else {
            if ( x(W_-I_-1,0) != 0 ) {
                x(W_-I_-1,0) = 0;
                if ( x[W_-1] )
                    x += 1;
            }
            return x;
        }
    }
}
template <int W_, int I_>
ap_ufixed<W_,I_> trunc_fixed(ap_ufixed<W_,I_> x)
{
    ap_fixed<W_+1,I_+1> xi = x;
    return trunc_fixed(xi);
}
template <int I_>
ap_int<I_> trunc_fixed(ap_int<I_> x)
{
    return x;
}
template <int I_>
ap_uint<I_> trunc_fixed(ap_uint<I_> x)
{
    return x;
}

template <int W_, int I_>
ap_fixed<W_,I_> copysign_fixed(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y)
{
    x[W_-1] = y[W_-1];
    return x;
}
template <int W_, int I_>
ap_ufixed<W_,I_> copysign_fixed(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y)
{
    (void)(y);
    return x;
}
template <int I_>
ap_int<I_> copysign_fixed(ap_int<I_> x, ap_int<I_> y)
{
    x[I_-1] = y[I_-1];
    return x;
}
template <int I_>
ap_uint<I_> copysign_fixed(ap_uint<I_> x, ap_uint<I_> y)
{
    (void)(y);
    return x;
}

template <int W_, int I_>
ap_fixed<W_,I_> fabs_fixed(ap_fixed<W_,I_> x)
{
    ap_fixed<W_,I_> xs = -x;
                    xs[W_-1] = 0;
    return ( ( x[W_-1] ) ? xs : x );
}
template <int W_, int I_>
ap_ufixed<W_,I_> fabs_fixed(ap_ufixed<W_,I_> x)
{
    return x;
}
template <int I_>
ap_int<I_> fabs_fixed(ap_int<I_> x)
{
    ap_int<I_> xs = -x;
               xs[I_-1] = 0;
    return ( ( x[I_-1] ) ? xs : x );
}
template <int I_>
ap_uint<I_> fabs_fixed(ap_uint<I_> x)
{
    return x;
}

template <int W_, int I_>
ap_fixed<W_,I_> round_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline
 if(W_ == I_) {
        return x;
    }
    else {
        if(I_<0) return 0;
        else {
            ap_ufixed<1, 0> half_val = 0.5;
            ap_ufixed<W_,I_> x_pos = fabs_fixed(x);
            ap_ufixed<W_+1,I_+1> r = x_pos + half_val;
            r(W_-I_-1,0) = 0;
            if(x[W_-1]) return -r;
            else return r;
        }
    }
}
template <int W_, int I_>
ap_ufixed<W_,I_> round_fixed(ap_ufixed<W_,I_> x)
{
    ap_fixed<W_+1,I_+1> xi = x;
    return round_fixed(xi);
}
template <int I_>
ap_int<I_> round_fixed(ap_int<I_> x)
{
    return x;
}
template <int I_>
ap_uint<I_> round_fixed(ap_uint<I_> x)
{
    return x;
}

template <int W_, int I_>
ap_fixed<W_,I_> rint_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline
 if(W_ == I_) {
        return x;
    }
    else {
        if(I_<0) return 0;
        else {
            ap_ufixed<W_, I_> x_p = fabs_fixed((ap_fixed<W_+1,I_+1>)x);
            ap_ufixed<1,0> half_val = 0.5;
            ap_ufixed<W_+1,I_+1> xUp = x_p + half_val;

            if(xUp(W_-I_-1,0) == 0) {

               xUp[W_-I_] = 0;
            } else {
               xUp(W_-I_-1,0) = 0;
            }
            if(x[W_-1]) return -xUp;
            else return xUp;
        }
# 289 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_round_copysign_apfixed.h"
    }
}
template <int W_, int I_>
ap_ufixed<W_,I_> rint_fixed(ap_ufixed<W_,I_> x)
{
   ap_fixed<W_+1, I_+1> xi = x;
   return rint_fixed(xi);
}
template <int I_>
ap_int<I_> rint_fixed(ap_int<I_> x)
{
    return x;
}
template <int I_>
ap_uint<I_> rint_fixed(ap_uint<I_> x)
{
    return x;
}

template <int W_, int I_>
ap_fixed<W_,I_> nearbyint_fixed(ap_fixed<W_,I_> x)
{

    return rint_fixed(x);
}
template <int W_, int I_>
ap_ufixed<W_,I_> nearbyint_fixed(ap_ufixed<W_,I_> x)
{
    ap_fixed<W_+1,I_+1> xi = x;
    return nearbyint_fixed(xi);
}
template <int I_>
ap_int<I_> nearbyint_fixed(ap_int<I_> x)
{
    return x;
}
template <int I_>
ap_uint<I_> nearbyint_fixed(ap_uint<I_> x)
{
    return x;
}

template <int W_, int I_>
bool signbit_fixed(ap_fixed<W_, I_> x){
    if(x[W_-1]) return true;
    else return false;
}
template <int W_, int I_>
bool signbit_fixed(ap_ufixed<W_, I_> x){
    (void)(x);
    return false;
}

template <int I_>
bool signbit_fixed(ap_int<I_> x){
    if(x[I_-1]) return true;
    else return false;
}

template <int I_>
bool signbit_fixed(ap_uint<I_> x){
    (void)(x);
    return false;
}
namespace fp_internal {
  template<int W, int I>
  ap_fixed<W, I> nextafter(ap_fixed<W, I> x, ap_fixed<W, I> y){
     const static int F = W - I;
     ap_ufixed<1, -F+1> ulp = 0;
     ulp[0] = 1;
     ap_fixed<W, I> r = 0;
     if(x == y) r = y;
     else if(x < y) r = x + ulp;
     else r = x - ulp;
     return r;
  }
  template<int W, int I>
  ap_ufixed<W, I> nextafter(ap_ufixed<W, I> x, ap_ufixed<W, I> y) {
     ap_fixed<W+1, I+1> xi = x;
     ap_fixed<W+1, I+1> yi = y;
     return nextafter(xi, yi);

  }
  template<int I>
  ap_int<I> nextafter(ap_int<I> x, ap_int<I> y) {
     ap_fixed<I, I> xi = x;
     ap_fixed<I, I> yi = y;
     return nextafter(xi, yi);
  }
  template<int I>
  ap_uint<I> nextafter(ap_uint<I> x, ap_uint<I> y) {
     ap_fixed<I+1, I+1> xi = x;
     ap_fixed<I+1, I+1> yi = y;
     return nextafter(xi, yi);
  }
  template<int W, int I>
  ap_fixed<W, I> nexttoward(ap_fixed<W, I> x, ap_fixed<W, I> y){
     return nextafter(x,y);
  }
  template<int W, int I>
  ap_ufixed<W, I> nexttoward(ap_ufixed<W, I> x, ap_ufixed<W, I> y){
     return nextafter(x,y);
  }
  template<int I>
  ap_int<I> nexttoward(ap_int<I> x, ap_int<I> y){
     return nextafter(x,y);
  }
  template<int I>
  ap_uint<I> nexttoward(ap_uint<I> x, ap_uint<I> y){
     return nextafter(x,y);
  }
}


template <int W, int I>
long long int llround_fixed(ap_fixed<W,I> x){
    return round_fixed<W+1,I+1>(ap_fixed<W+1,I+1> (x));
}


template <int W, int I>
long long int llround_fixed(ap_ufixed<W,I> x){
    return round_fixed<W+1,I+1>(ap_ufixed<W+1,I+1> (x));
}


template <int I>
long long int llround_fixed(ap_int<I> x){
    return x;
}


template <int I>
long long int llround_fixed(ap_uint<I> x){
    return x;
}


template <int W, int I>
long int lround_fixed(ap_fixed<W,I> x){
    ap_int<8*sizeof(long int)> minval = 0;
    minval[8*sizeof(long int)-1] = 1;
    ap_int<8*sizeof(long int)> maxval = -1;
    maxval[8*sizeof(long int)-1] = 0;
    if((x>maxval) || (x<minval)) {
        return (x[W-1])? minval : maxval;
    }
    else {
        return round_fixed<W+1,I+1>(ap_fixed<W+1,I+1> (x));
    }
}


template <int W, int I>
long int lround_fixed(ap_ufixed<W,I> x){
    ap_int<8*sizeof(long int)> maxval = -1;
    maxval[8*sizeof(long int)-1] = 0;
    if((x>maxval) ) {
        return maxval;
    }
    else {
        return round_fixed<W+1,I+1>(ap_ufixed<W+1,I+1> (x));
    }
}


template <int I>
long int lround_fixed(ap_int<I> x){
    ap_int<8*sizeof(long int)> minval = 0;
    minval[8*sizeof(long int)-1] = 1;
    ap_int<8*sizeof(long int)> maxval = -1;
    maxval[8*sizeof(long int)-1] = 0;
    if((x>maxval) || (x<minval)) {
        return (x[I-1])? minval : maxval;
    }
    else {
        return x;
    }
}


template <int I>
long int lround_fixed(ap_uint<I> x){
    ap_int<8*sizeof(long int)> maxval = -1;
    maxval[8*sizeof(long int)-1] = 0;
    if((x>maxval) ) {
        return maxval;
    }
    else {
        return x;
    }
}


template <int W, int I>
long long int llrint_fixed(ap_fixed<W,I> x){
    return rint_fixed<W+1,I+1>(ap_fixed<W+1,I+1> (x));
}


template <int W, int I>
long long int llrint_fixed(ap_ufixed<W,I> x){
    return rint_fixed<W+1,I+1>(ap_ufixed<W+1,I+1> (x));
}


template <int I>
long long int llrint_fixed(ap_int<I> x){
    return x;
}


template <int I>
long long int llrint_fixed(ap_uint<I> x){
    return x;
}


template <int W, int I>
long int lrint_fixed(ap_fixed<W,I> x){
    ap_int<8*sizeof(long int)> minval = 0;
    minval[8*sizeof(long int)-1] = 1;
    ap_int<8*sizeof(long int)> maxval = -1;
    maxval[8*sizeof(long int)-1] = 0;
    if((x>maxval) || (x<minval)) {
        return (x[W-1])? minval : maxval;
    }
    else {
        return rint_fixed<W+1, I+1>(ap_fixed<W+1,I+1> (x));
    }
}



template <int W, int I>
long int lrint_fixed(ap_ufixed<W,I> x){
    ap_int<8*sizeof(long int)> maxval = -1;
    maxval[8*sizeof(long int)-1] = 0;
    if(x>maxval){
        return maxval;
    }
    else {
        return rint_fixed<W+1, I+1>(ap_ufixed<W+1,I+1> (x));
    }
}


template <int I>
long int lrint_fixed(ap_int<I> x){
    ap_int<8*sizeof(long int)> minval = 0;
    minval[8*sizeof(long int)-1] = 1;
    ap_int<8*sizeof(long int)> maxval = -1;
    maxval[8*sizeof(long int)-1] = 0;
    if((x>maxval) || (x>minval)) {
        return (x[I-1])? minval : maxval;
    }
    else {
        return x;
    }
}


template <int I>
long int lrint_fixed(ap_uint<I> x){
    ap_int<8*sizeof(long int)> maxval = -1;
    maxval[8*sizeof(long int)-1] = 0;
    if(x>maxval) {
        return maxval;
    }
    else {
        return x;
    }
}
# 1071 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_math.h" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_pow_apfixed.h" 1
# 37 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_pow_apfixed.h"
namespace pow_apfixed_reduce{
# 52 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_pow_apfixed.h"
template<int W_,int I_>
ap_fixed<W_,I_> pow(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y) {
    const static int F_ = W_ - I_;

    if (I_>34) return 0;
    else if (F_>33) return 0;
    ap_fixed<W_,I_> r = 0;

    bool r_is_neg = 0;
    bool y_is_frac = 0;

    if (F_>0&&y(F_-1,0)>0)
        y_is_frac =1;
    if (x==0) {

        if (y==0&&I_>1) {
            return 1;

        } else if (y>0) {
            return 0;
        } else {

            VITIS_LOOP_74_1: for (int j = 0; j < W_-1; j++){
#pragma HLS unroll
 r[j] = 1;
            }
               r[W_-1] = 0;
            return r;
        }
    } else if (x<0) {

        if (y_is_frac) return 0;

        else {
            if (y==0||(I_>1&&y[F_]==0))
                r_is_neg = 0;
            else
                r_is_neg = 1;
        }
    }

    ap_fixed<W_+1,I_+1> x_e_1 = x;

    ap_fixed<W_+1,I_+1> x_p = 0;
    x_p = fabs_fixed(x_e_1);


    const static int E_l = I_+2;
    const static int F_l = W_+E_l;

    const static int I_l = I_+1>6?I_+1:6;
    const static int W_l = F_l + I_l;

    ap_fixed<W_l,I_l> x_l = x_p;


    ap_fixed<W_l,I_l> ln_x = log_apfixed_reduce::log(x_l);


    ap_fixed<F_l+6,6> ln_x_s = ln_x;


    const static int FI_m = W_+2;

    const static int I_m = I_>6 ? I_ : 6;
    const static int WI_m = FI_m + I_m;
    const static int WO_m = F_ + I_m;
    ap_fixed<F_l+W_+6,6+I_> mul_y_ln = ln_x_s * y;
# 129 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_pow_apfixed.h"
    ap_fixed<WO_m,I_m> exp_r = 0;
    ap_fixed<W_,I_> r_1 = 0;
    bool m_overf = 0;
    bool e_overf = 0;
    bool overf = 0;

    VITIS_LOOP_135_2: for (int j = F_l+F_+I_m-1; j < F_l+W_+5; j++){
#pragma HLS unroll
 if (mul_y_ln[F_l+W_+5]!=mul_y_ln[j])
            m_overf = 1;
    }

    if (!m_overf) {

        ap_fixed<WI_m,I_m> mul_y_ln_s = mul_y_ln;

        exp_r = exp_reduce::exp_core<WO_m,I_m,WI_m>(mul_y_ln_s);


        if (I_<I_m) {
            VITIS_LOOP_149_3: for (int j = WO_m-1; j >= W_-1; j--) {
#pragma HLS unroll
 if (exp_r[j])
                    e_overf=1;
            }
        }
        r_1 = exp_r;
    }

    if (e_overf||(m_overf&&!mul_y_ln[F_l+W_+5])) {
        overf = 1;
    }

    if (r_is_neg) {

        if (overf) {
            r=0;
            r[W_-1]=1;

        } else {
            if (r_1!=0) {
                r = -r_1;
                r[W_-1] = 1;
            }
        }

    } else {

        if(overf) {
            r[W_-1] = 0;
            VITIS_LOOP_179_4: for (int j = W_-2; j >= 0; j--){
#pragma HLS unroll
 r[j] = 1;
            }

        } else {
            r = r_1;
        }
    }

    return r;
}
# 210 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_pow_apfixed.h"
template<int W_, int I_>
ap_fixed<W_,I_> pown(ap_fixed<W_,I_> x, int n) {






    const static int F_ = W_ - I_;

    if (I_>34) return 0;
    else if (F_>33) return 0;

    ap_fixed<W_,I_> r = 0;
    ap_fixed<32,32> n_fix = n;

    bool x_sig = x[W_-1];
    bool n_sig = n_fix[31];
    bool n_is_odd = n_fix[0];
    bool x_gt_0 = 0;

    if (x == 0 && n_fix != 0) r = 0;
    else if(n_fix == 0) r = 1;
    else if(n_fix == 1) r = x;

    else if(x == 1) r = 1;
    else if(x == -1) {
        if(n_is_odd) r = -1;
        else r = 1;
    }else {
# 266 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_pow_apfixed.h"
       const static int we_n = F_ > 26? 32 : 6 + F_;

       const static int wf_log = I_ == F_>26 ? (31+F_+I_) : (we_n-1+F_+I_);
       const static int I_e = I_>6 ? I_ : 6;
       const static int WI_e = I_e + wf_log - we_n;
       const static int WO_e = F_ + I_e;
       ap_fixed<33,33> max_n = 0;
       max_n[we_n-1] = 1;
       ap_ufixed<32,32> n_pos = fabs_fixed(ap_fixed<33,33>(n));
       ap_ufixed<WO_e,I_e> exp_r=0;
       bool ovf = 0;
       ap_ufixed<W_,I_> x_pos = fabs_fixed((ap_fixed<W_+1,I_+1>)x);
       if(x_pos>1) x_gt_0 = 1;
       ap_fixed<32,32> min_n = -max_n;
       if(n_fix != -1 && ((n >= max_n) || (n < min_n))){

           ovf = 1;
       }else {
           ap_fixed<we_n, we_n> n_s = n;





           const static int I_l = I_+1 < 6? 6 : I_+1;
           ap_fixed<wf_log+I_l,I_l> x_e = x_pos;
           const static int we_log = 6;
           ap_fixed<wf_log+we_log,we_log> x_log = log_apfixed_reduce::log(x_e);






           ap_fixed<wf_log+we_log, we_log+we_n> x_log_mul_n = n_s * x_log;






           VITIS_LOOP_307_1: for(int i = wf_log+we_log-2; i > WI_e - 2; --i) {
#pragma HLS unroll
 if(x_log_mul_n[i] != x_log_mul_n[wf_log+we_log-1]){

                    ovf = 1;
                }
           }
           ap_fixed<WI_e, I_e> x_log_mul_n_1 = x_log_mul_n ;





           exp_r = exp_reduce::exp_core<WO_e,I_e,WI_e>(x_log_mul_n_1);





           if (I_<I_e) {
               VITIS_LOOP_327_2: for (int j = WO_e-1; j >= W_-1; j--) {
#pragma HLS unroll

 if (exp_r[j])
                       ovf=1;
               }
           }
       }
       if(ovf) {
           if(x_gt_0 ^ n_sig) {

               if(x_sig && !n_is_odd) {
                   r[W_-1] = 1;
               } else {
                   VITIS_LOOP_341_3: for(int i = 0; i < W_-1; ++i) {
#pragma HLS unroll
 r[W_-1] = 1;
                   }
               }
           }
       } else {
           if(x_sig && n_is_odd) r = -exp_r;
           else r = exp_r;
       }
   }
   return r;
}
# 380 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_pow_apfixed.h"
template<int W_,int I_>
ap_fixed<W_,I_> rootn(ap_fixed<W_,I_> x, int n) {






    const static int F_ = W_ - I_;

    if (I_ > 34) return 0;
    else if (F_ > 33) return 0;

    ap_fixed<W_,I_> r = 0;
    ap_fixed<32,32> n_fix = n;
    bool n_is_odd = 0;
    if(n_fix[0]) n_is_odd = 1;

    if (x == 0) r = 0;
    else if(n_fix == 0) r = 0;
    else if(n_fix == 1) r = x;
    else if(n_fix == -1) r = ap_fixed<W_, I_>(1)/x;
    else if(x<0 && !n_is_odd) r = 0;
    else if(x==1) r = 1;
    else if(x==-1 && n_is_odd) r = -1;
    else {

        ap_ufixed<W_,I_> x_p = fabs_fixed((ap_fixed<W_+1,I_+1>)x);


        const static int m_we = (F_+1)/2 > (I_+1)/2? (F_+1)/2:(I_+1)/2;
        const static int we = I_ > m_we ? m_we : I_;
        const static int E_l = we - 1;
        const static int F_l = F_ + E_l;

        const static int I_l = I_ + 1 > 6 ? I_ + 1 : 6;
        const static int W_l = F_l + I_l;

        ap_fixed<W_l,I_l> x_l = x_p;


        ap_fixed<W_l,I_l> ln_x = log_apfixed_reduce::log(x_l);






        ap_fixed<F_l+6,6> ln_x_s = ln_x;


        const static int FI_d = F_l + 1;

        const static int I_d = we+1 > 5? we+1 : 5;
        const static int WI_d = FI_d + I_d;
        const static int WO_d = F_ + I_d;
        ap_fixed<F_l+6,5> divd_n_ln = ln_x_s / n_fix;







        ap_fixed<WI_d,I_d> divd_n_ln_s = divd_n_ln;





        ap_ufixed<WO_d, I_d> exp_r = exp_reduce::exp_core<WO_d,I_d,WI_d>(divd_n_ln_s);





        bool ovf = 0;

        if(I_ < I_d) {
           VITIS_LOOP_459_1: for (int j =WO_d-1; j >= W_-1; j--) {
#pragma HLS unroll

 if (exp_r[j])
                   ovf=1;
           }
        }
        if(!ovf) {
           if(x[W_-1]&&n_is_odd) r = -exp_r;
           else r = exp_r;
        }else {
           if(x[W_-1]&&n_is_odd) {
              r[W_-1] = 1;
           } else {
              VITIS_LOOP_473_2: for(int i = 0; i < W_-1; ++i) {
#pragma HLS unroll
 r[i] = 1;
              }
           }
        }
   }
   return r;
}


template<int W_, int I_>
ap_ufixed<W_,I_> pow(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y) {
    ap_fixed<W_+1,I_+1> xf = x;
    ap_fixed<W_+1,I_+1> yf = y;
    return pow(xf,yf);
}

template<int I_>
ap_int<I_> pow(ap_int<I_> x, ap_int<I_> y) {
    ap_fixed<I_,I_> xf = x;
    ap_fixed<I_,I_> yf = y;
    return pow(xf,yf);
}

template<int I_>
ap_uint<I_> pow(ap_uint<I_> x,ap_uint<I_> y) {
    ap_fixed<I_+1,I_+1> xf = x;
    ap_fixed<I_+1,I_+1> yf = y;
    return pow(xf,yf);
}


template<int W_, int I_>
ap_fixed<W_,I_> powr(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y) {
    return pow(x,y);
}

template<int W_, int I_>
ap_ufixed<W_,I_> powr(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y) {
    ap_fixed<W_+1,I_+1> xf = x;
    ap_fixed<W_+1,I_+1> yf = y;
    return pow(xf,yf);
}

template<int I_>
ap_int<I_> powr(ap_int<I_> x, ap_int<I_> y) {
    ap_fixed<I_,I_> xf = x;
    ap_fixed<I_,I_> yf = y;
    return pow(xf,yf);
}

template<int I_>
ap_uint<I_> powr(ap_uint<I_> x,ap_uint<I_> y) {
    ap_fixed<I_+1,I_+1> xf = x;
    ap_fixed<I_+1,I_+1> yf = y;
    return pow(xf,yf);
}

template<int W_, int I_>
ap_ufixed<W_,I_> pown(ap_ufixed<W_, I_> x, int n) {
    ap_fixed<W_+1,I_+1> xi = x;
    return pown(xi, n);
}

template<int I_>
ap_int<I_> pown(ap_int<I_> x, int n) {
   ap_fixed<I_, I_> xi = x;
   return pown(xi, n);
}

template<int I_>
ap_uint<I_> pown(ap_uint<I_> x, int n) {
   ap_fixed<I_+1, I_+1> xi = x;
   return pown(xi, n);
}
template<int W_, int I_>
ap_ufixed<W_,I_> rootn(ap_ufixed<W_, I_> x, int n) {
    ap_fixed<W_+1,I_+1> xi = x;
    return rootn(xi, n);
}

template<int I_>
ap_int<I_> rootn(ap_int<I_> x, int n) {
   ap_fixed<I_, I_> xi = x;
   return rootn(xi, n);
}

template<int I_>
ap_uint<I_> rootn(ap_uint<I_> x, int n) {
   ap_fixed<I_+1, I_+1> xi = x;
   return rootn(xi, n);
}
}
# 1072 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_math.h" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_diff_apfixed.h" 1
# 35 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_diff_apfixed.h"
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/ap_int.h" 1
# 36 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_diff_apfixed.h" 2
# 46 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_diff_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> fdim_fixed(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y )
{
#pragma HLS PIPELINE II=1
 ap_fixed<W_+1,I_+1> x_overf = 0;
    ap_fixed<W_ ,I_ > xs = 0;
        bool overf = 0;

    if(x > y)
    {
        x_overf = x - y;
        overf = x_overf[W_-1];
        if(overf) {
            VITIS_LOOP_59_1: for (int i = 0; i < W_-1; i++){
#pragma HLS UNROLL
 xs[i] = 1;
            }
            xs[W_-1] = 0;
        }
        else{
            x_overf[W_] = 0;
            xs = x_overf;
        }
    }
    return xs;
}
template <int W_, int I_>
ap_ufixed<W_,I_> fdim_fixed(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y)
{
    ap_ufixed<W_ ,I_ > xs = 0;
    if(x > y){ xs = x - y; }
    return xs;
}
template <int I_>
ap_int<I_> fdim_fixed(ap_int<I_> x, ap_int<I_> y)
{
    ap_fixed<I_,I_> xs = x;
    ap_fixed<I_,I_> ys = y;
    return fdim_fixed(xs, ys);
}
template <int I_>
ap_uint<I_> fdim_fixed(ap_uint<I_> x, ap_uint<I_> y)
{
    ap_uint<I_ > xs = 0;
    if(x > y) { xs = x - y; }
    return xs;
}
# 102 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_diff_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> fmax_fixed(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y )
{
    ap_fixed<W_ ,I_ > xs = 0;
    if(x >= y) xs = x ;
        else xs = y ;
    return xs;
}
template <int W_, int I_>
ap_ufixed<W_,I_> fmax_fixed(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y)
{
    ap_ufixed<W_ ,I_ > xs = 0;
    if(x >= y) xs = x;
        else xs = y ;
    return xs;
}
template <int I_>
ap_int<I_> fmax_fixed(ap_int<I_> x, ap_int<I_> y)
{
    ap_int<I_ > xs = 0;
    if(x >= y) xs = x;
        else xs = y ;
    return xs;
}
template <int I_>
ap_uint<I_> fmax_fixed(ap_uint<I_> x, ap_uint<I_> y)
{
    ap_uint<I_ > xs = 0;
    if(x >= y) xs = x;
        else xs = y ;
    return xs;
}
# 143 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_diff_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> fmin_fixed(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y )
{
    ap_fixed<W_ ,I_ > xs = 0;
    if(x <= y) xs = x ;
        else xs = y ;
    return xs;
}
template <int W_, int I_>
ap_ufixed<W_,I_> fmin_fixed(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y)
{
    ap_ufixed<W_ ,I_ > xs = 0;
    if(x <= y) xs = x;
        else xs = y ;
    return xs;
}
template <int I_>
ap_int<I_> fmin_fixed(ap_int<I_> x, ap_int<I_> y)
{
    ap_int<I_ > xs = 0;
    if(x <= y) xs = x;
        else xs = y ;
    return xs;
}
template <int I_>
ap_uint<I_> fmin_fixed(ap_uint<I_> x, ap_uint<I_> y)
{
    ap_uint<I_ > xs = 0;
    if(x <= y) xs = x;
        else xs = y ;
    return xs;
}
# 186 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_diff_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> maxmag_fixed(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y )
{
#pragma HLS PIPELINE II=1
 ap_fixed<W_+1,I_+1> xm = -x;
    ap_fixed<W_+1,I_+1> ym = -y;
    ap_fixed<W_+1,I_+1> x_fabs = ( x[W_-1] ) ? xm : ap_fixed<W_+1,I_+1>(x);
    ap_fixed<W_+1,I_+1> y_fabs = ( y[W_-1] ) ? ym : ap_fixed<W_+1,I_+1>(y);

    ap_fixed<W_+1,I_+1> xs_t = 0;
    ap_fixed<W_,I_> xs = 0;
    if(x_fabs >= y_fabs)
    {
     xs_t = x_fabs ;
     xs = x;
    }
    else{
     xs_t = y_fabs ;
     xs = y;
    }

    if(xs_t[W_-1])
    {
            VITIS_LOOP_209_1: for (int i = 0; i < W_-1; i++){
#pragma HLS UNROLL
 xs[i] = 1;
            }
            xs[W_-1] = 0;
    }

    return xs;
}
template <int W_, int I_>
ap_ufixed<W_,I_> maxmag_fixed(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y)
{
    ap_ufixed<W_ ,I_ > xs = 0;
    if(x >= y) xs = x;
        else xs = y ;
    return xs;
}
template <int I_>
ap_int<I_> maxmag_fixed(ap_int<I_> x, ap_int<I_> y)
{
    ap_fixed<I_,I_> xs = x;
    ap_fixed<I_,I_> ys = y;
    return maxmag_fixed(xs, ys);
}
template <int I_>
ap_uint<I_> maxmag_fixed(ap_uint<I_> x, ap_uint<I_> y)
{
    ap_uint<I_ > xs = 0;
    if(x >= y) xs = x;
        else xs = y ;
    return xs;
}
# 252 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_diff_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> minmag_fixed(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y )
{
#pragma HLS PIPELINE II=1
 ap_fixed<W_+1,I_+1> xm = -x;
    ap_fixed<W_+1,I_+1> ym = -y;
    ap_fixed<W_+1,I_+1> x_fabs = ( x[W_-1] ) ? xm : ap_fixed<W_+1,I_+1>(x);
    ap_fixed<W_+1,I_+1> y_fabs = ( y[W_-1] ) ? ym : ap_fixed<W_+1,I_+1>(y);

    ap_fixed<W_+1,I_+1> xs_t = 0;
    ap_fixed<W_,I_> xs = 0;
    if(x_fabs <= y_fabs)
    {
     xs_t = x_fabs ;
     xs = x;
    }
    else{
     xs_t = y_fabs ;
     xs = y;
    }
    if(xs_t[W_-1])
    {
            VITIS_LOOP_274_1: for (int i = 0; i < W_-1; i++){
#pragma HLS UNROLL
 xs[i] = 1;
            }
            xs[W_-1] = 0;
    }

    return xs;
}
template <int W_, int I_>
ap_ufixed<W_,I_> minmag_fixed(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y)
{
    ap_ufixed<W_ ,I_ > xs = 0;
    if(x <= y) xs = x;
        else xs = y ;
    return xs;
}
template <int I_>
ap_int<I_> minmag_fixed(ap_int<I_> x, ap_int<I_> y)
{
    ap_fixed<I_,I_> xs = x;
    ap_fixed<I_,I_> ys = y;
    return minmag_fixed(xs, ys);
}
template <int I_>
ap_uint<I_> minmag_fixed(ap_uint<I_> x, ap_uint<I_> y)
{
    ap_uint<I_ > xs = 0;
    if(x <= y) xs = x;
        else xs = y ;
    return xs;
}
# 1073 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_math.h" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_comparison_apfixed.h" 1
# 35 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_comparison_apfixed.h"
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/ap_int.h" 1
# 36 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_comparison_apfixed.h" 2



template<int W, int I>
bool isgreater_fixed(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    if(x1 > x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int W, int I>
bool isgreater_fixed(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    if(x1 > x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool isgreater_fixed(ap_int<I> x1, ap_int<I> x2){
    if(x1 > x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool isgreater_fixed(ap_uint<I> x1, ap_uint<I> x2){
    if(x1 > x2) {
        return true;
    }
    else {
        return false;
    }
}


template<int W, int I>
bool isgreaterequal_fixed(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    if(x1 >= x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int W, int I>
bool isgreaterequal_fixed(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    if(x1 >= x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool isgreaterequal_fixed(ap_int<I> x1, ap_int<I> x2){
    if(x1 >= x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool isgreaterequal_fixed(ap_uint<I> x1, ap_uint<I> x2){
    if(x1 >= x2) {
        return true;
    }
    else {
        return false;
    }
}


template<int W, int I>
bool isless_fixed(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    if(x1 < x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int W, int I>
bool isless_fixed(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    if(x1 < x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool isless_fixed(ap_int<I> x1, ap_int<I> x2){
    if(x1 < x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool isless_fixed(ap_uint<I> x1, ap_uint<I> x2){
    if(x1 < x2) {
        return true;
    }
    else {
        return false;
    }
}


template<int W, int I>
bool islessequal_fixed(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    if(x1 <= x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int W, int I>
bool islessequal_fixed(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    if(x1 <= x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool islessequal_fixed(ap_int<I> x1, ap_int<I> x2){
    if(x1 <= x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool islessequal_fixed(ap_uint<I> x1, ap_uint<I> x2){
    if(x1 <= x2) {
        return true;
    }
    else {
        return false;
    }
}


template<int W, int I>
bool islessgreater_fixed(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    if((x1 < x2) || (x1 > x2)) {
        return true;
    }
    else {
        return false;
    }
}
template<int W, int I>
bool islessgreater_fixed(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    if((x1 < x2) || (x1 > x2)) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool islessgreater_fixed(ap_int<I> x1, ap_int<I> x2){
    if((x1 < x2) || (x1 > x2)) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool islessgreater_fixed(ap_uint<I> x1, ap_uint<I> x2){
    if((x1 < x2) || (x1 > x2)) {
        return true;
    }
    else {
        return false;
    }
}
# 1074 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_math.h" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_frexp_apfixed.h" 1
# 41 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_frexp_apfixed.h"
namespace frexp_internal {

template<int W, int I>
ap_fixed<W,I> frexp(ap_fixed<W,I> x,
                    ap_fixed<W,I>* exp){
    if(I<0) {
           *exp = 0;
           return x;
    }
    static const int F = W - I;
    static const int we = W > 5 ? W/2 : 3;

    ap_int<we> e = 0;
    ap_ufixed<W, I> r_p = 0;

    ap_fixed<W+1, I+1> xi = x;
    ap_ufixed<W, I> x_p = fabs_fixed(xi);

    static const ap_uint<3> clz_table_6bit[64] = {7, 6, 5, 5, 4, 4, 4, 4,
                                                  3, 3, 3, 3, 3, 3, 3, 3,
                                                  2, 2, 2, 2, 2, 2, 2, 2,
                                                  2, 2, 2, 2, 2, 2, 2, 2,
                                                  1, 1, 1, 1, 1, 1, 1, 1,
                                                  1, 1, 1, 1, 1, 1, 1, 1,
                                                  1, 1, 1, 1, 1, 1, 1, 1,
                                                  1, 1, 1, 1, 1, 1, 1, 1};
    int pos = 0;

    static const int loop_nm = W > 6 ? (W + 5)/6 : 1;
    CLZ_LOOP:
    for(int l = loop_nm; l > 0; --l){
#pragma HLS pipeline II=1
 ap_uint<6> t = 0;
       if(l*6 > W) t = x_p(W - 1, (l - 1) * 6);
       else t = x_p(l * 6 - 1, (l - 1) * 6);
       if((t & 0x3f) != 0) {
          pos = l * 6 - clz_table_6bit[t];
          break;
       }
    }
    if(pos >= 0) {
        e = pos + 1 - F;
        if(F > 0) {
           ap_uint<we> w_f = (pos + 1) < F ? (pos + 1) : F;
           r_p(F - 1,F - w_f) = x_p(pos, pos + 1 - w_f);
        }
    } else {
        e = 0;
        r_p = 0;
    }
    ap_fixed<W, I> r = 0;
    if(xi[W-1]) r = -r_p;
    else r = r_p;



    *exp = e;
    return r;
}
template<int W, int I>
ap_ufixed<W,I> frexp(ap_ufixed<W,I> x,
                     ap_ufixed<W,I>* exp){
    ap_fixed<W+1, I+1> xe = x;
    ap_fixed<W+1, I+1> ee = 0;
    ap_fixed<W+1, I+1> r = frexp(xe,&ee);
    *exp = ee;
    return r;
}
template<int I>
ap_uint<I> frexp(ap_uint<I> x,
                 ap_uint<I>* exp) {
   ap_fixed<I, I> xe = x;
   ap_fixed<I, I> ee = 0;
   ap_fixed<I, I> r = frexp(xe,&ee);
   *exp = ee;
   return r;
}
template<int I>
ap_int<I> frexp(ap_int<I> x,
                ap_int<I>* exp) {
   ap_fixed<I+1, I+1> xe = x;
   ap_fixed<I+1, I+1> ee = 0;
   ap_fixed<I+1, I+1> r = frexp(xe,&ee);
   *exp = ee;
   return r;
}
}
# 1075 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_math.h" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_modf_apfixed.h" 1
# 40 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_modf_apfixed.h"
namespace modf_internal {
template<int W, int I>
ap_fixed<W,I> modf(ap_fixed<W, I> x,
                   ap_fixed<W, I>* int_part){
    ap_fixed<W, I> frac_part = 0;
    if(W == I) {
        *int_part = x;
        frac_part = 0;
    } else if(I > 0) {
        ap_fixed<W+1, I+1> xi = x;
        ap_ufixed<W, I> x_p = fabs_fixed(xi);
        frac_part(W - I - 1,0) = x_p(W - I - 1,0);
        if(xi[W-1]) frac_part = - frac_part;
        *int_part = x_p(W-1, W-I);
        if(xi[W-1]) *int_part = -*int_part;
    } else {
       *int_part = 0;
       frac_part = x;
    }
    return frac_part;
}
template<int W, int I>
ap_ufixed<W,I> modf(ap_ufixed<W, I> x,
                    ap_ufixed<W, I>* int_part){
    ap_fixed<W+1, I+1> xi = x;
    ap_fixed<W+1, I+1> ii = 0;
    ap_fixed<W+1, I+1> r = modf(xi, &ii);
    *int_part = ii;
    return r;
}
template<int I>
ap_int<I> modf(ap_int<I> x,
               ap_int<I>* int_part){
    *int_part = x;
    return 0;
}
template<int I>
ap_uint<I> modf(ap_uint<I> x,
                ap_uint<I>* int_part){
    *int_part = x;
    return 0;
}
}
# 1076 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_math.h" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_isequal_isnotequal_apfixed.h" 1
# 40 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_isequal_isnotequal_apfixed.h"
template <int W_, int I_>
bool generic_isequal(ap_fixed<W_,I_> x,ap_fixed<W_,I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int W_, int I_>
bool generic_isnotequal(ap_fixed<W_,I_> x,ap_fixed<W_,I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}


template <int W_, int I_>
bool generic_isequal(ap_ufixed<W_,I_> x,ap_fixed<W_,I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int W_, int I_>
bool generic_isnotequal(ap_ufixed<W_,I_> x,ap_fixed<W_,I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}


template <int W_, int I_>
bool generic_isequal(ap_fixed<W_,I_> x,ap_ufixed<W_,I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int W_, int I_>
bool generic_isnotequal(ap_fixed<W_,I_> x,ap_ufixed<W_,I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}


template <int W_, int I_>
bool generic_isequal(ap_ufixed<W_,I_> x,ap_ufixed<W_,I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int W_, int I_>
bool generic_isnotequal(ap_ufixed<W_,I_> x,ap_ufixed<W_,I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}



template <int I_>
bool generic_isequal(ap_int<I_> x,ap_int<I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int I_>
bool generic_isnotequal(ap_int<I_> x,ap_int<I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}


template <int I_>
bool generic_isequal(ap_uint<I_> x,ap_int<I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int I_>
bool generic_isnotequal(ap_uint<I_> x,ap_int<I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}


template <int I_>
bool generic_isequal(ap_int<I_> x,ap_uint<I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int I_>
bool generic_isnotequal(ap_int<I_> x,ap_uint<I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}


template <int I_>
bool generic_isequal(ap_uint<I_> x,ap_uint<I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int I_>
bool generic_isnotequal(ap_uint<I_> x,ap_uint<I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}
# 1077 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_math.h" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_all_any_apfixed.h" 1
# 35 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_all_any_apfixed.h"
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/ap_int.h" 1
# 36 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_all_any_apfixed.h" 2


template <int W_, int I_>
bool generic_all(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline II=1
 VITIS_LOOP_42_1: for (int i=0; i<W_;i++)
     if (x[i]==0)
      return false;
    return true;
}


template <int W_, int I_>
bool generic_all(ap_ufixed<W_,I_> x)
{
#pragma HLS pipeline II=1
 VITIS_LOOP_53_1: for (int i=0; i<W_;i++)
     if (x[i]==0)
      return false;
    return true;
}


template <int I_>
bool generic_all(ap_int<I_> x)
{
#pragma HLS pipeline II=1
 VITIS_LOOP_64_1: for (int i=0; i<I_;i++)
     if (x[i]==0)
      return false;
    return true;
}


template <int I_>
bool generic_all(ap_uint<I_> x)
{
#pragma HLS pipeline II=1
 VITIS_LOOP_75_1: for (int i=0; i<I_;i++)
     if (x[i]==0)
      return false;
    return true;
}


template <int W_, int I_>
bool generic_any(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline II=1
 VITIS_LOOP_86_1: for (int i=0; i<W_;i++)
     if (x[i]==1)
      return true;
    return false;
}


template <int W_, int I_>
bool generic_any(ap_ufixed<W_,I_> x)
{
#pragma HLS pipeline II=1
 VITIS_LOOP_97_1: for (int i=0; i<W_;i++)
     if (x[i]==1)
      return true;
    return false;
}


template <int I_>
bool generic_any(ap_int<I_> x)
{
#pragma HLS pipeline II=1
 VITIS_LOOP_108_1: for (int i=0; i<I_;i++)
     if (x[i]==1)
      return true;
    return false;
}


template <int I_>
bool generic_any(ap_uint<I_> x)
{
#pragma HLS pipeline II=1
 VITIS_LOOP_119_1: for (int i=0; i<I_;i++)
     if (x[i]==1)
      return true;
    return false;
}
# 1078 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_math.h" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_select_bitselect_apfixed.h" 1
# 35 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_select_bitselect_apfixed.h"
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/ap_int.h" 1
# 36 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_select_bitselect_apfixed.h" 2
# 62 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_select_bitselect_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> generic_bitselect(ap_fixed<W_,I_> x,ap_fixed<W_,I_> y, ap_fixed<W_,I_> z)
{
#pragma HLS pipeline
 return (z & y)|(~z & x);
}


template <int W_, int I_>
ap_ufixed<W_,I_> generic_bitselect(ap_ufixed<W_,I_> x,ap_ufixed<W_,I_> y, ap_ufixed<W_,I_> z)
{
#pragma HLS pipeline
 return (z & y)|(~z & x);
}


template <int I_>
ap_int<I_> generic_bitselect(ap_int<I_> x,ap_int<I_> y, ap_int<I_> z)
{
#pragma HLS pipeline
 return (z & y)|(~z & x);
}

template <int I_>
ap_uint<I_> generic_bitselect(ap_uint<I_> x,ap_uint<I_> y, ap_uint<I_> z)
{
#pragma HLS pipeline
 return (z & y)|(~z & x);
}
# 1079 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_math.h" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_erf_apfixed.h" 1
# 35 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_erf_apfixed.h"
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/ap_int.h" 1
# 36 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_erf_apfixed.h" 2

# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/utils/x_hls_utils.h" 1
# 38 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_erf_apfixed.h" 2

namespace erf_erfc_fixed {

    namespace {
 template <typename T> class coeff { };

 template <> class coeff<double> {

 public:
   static const double tiny;
   static const double one_over_two;
   static const double one;
   static const double two;
   static const double erx;
   static const double efx;
   static const double efx8;
   static const double pp[5];
   static const double qq[6];
   static const double pa[7];
   static const double qa[7];
   static const double ra[8];
   static const double sa[9];
   static const double rb[7];
   static const double sb[8];
 };
 const double coeff<double>::tiny = 1e-300;
 const double coeff<double>::one_over_two= 5.00000000000000000000e-01;
 const double coeff<double>::one = 1.00000000000000000000e+00;
 const double coeff<double>::two = 2.00000000000000000000e+00;

 const double coeff<double>::erx = 8.45062911510467529297e-01;



 const double coeff<double>::efx = 1.28379167095512586316e-01;
 const double coeff<double>::efx8= 1.02703333676410069053e+00;
 const double coeff<double>::pp[] =
   {1.28379167095512558561e-01,
    -3.25042107247001499370e-01,
    -2.84817495755985104766e-02,
    -5.77027029648944159157e-03,
    -2.37630166566501626084e-05};
 const double coeff<double>::qq[] =
   {0.0, 3.97917223959155352819e-01,
    6.50222499887672944485e-02,
    5.08130628187576562776e-03,
    1.32494738004321644526e-04,
    -3.96022827877536812320e-06};



 const double coeff<double>::pa[] =
   {-2.36211856075265944077e-03,
    4.14856118683748331666e-01,
    -3.72207876035701323847e-01,
    3.18346619901161753674e-01,
    -1.10894694282396677476e-01,
    3.54783043256182359371e-02,
    -2.16637559486879084300e-03};
 const double coeff<double>::qa[] =
   {0.0, 1.06420880400844228286e-01,
    5.40397917702171048937e-01,
    7.18286544141962662868e-02,
    1.26171219808761642112e-01,
    1.36370839120290507362e-02,
    1.19844998467991074170e-02};



 const double coeff<double>::ra[] =
   {-9.86494403484714822705e-03,
    -6.93858572707181764372e-01,
    -1.05586262253232909814e+01,
    -6.23753324503260060396e+01,
    -1.62396669462573470355e+02,
    -1.84605092906711035994e+02,
    -8.12874355063065934246e+01,
    -9.81432934416914548592e+00};
 const double coeff<double>::sa[] =
   {0.0,1.96512716674392571292e+01,
    1.37657754143519042600e+02,
    4.34565877475229228821e+02,
    6.45387271733267880336e+02,
    4.29008140027567833386e+02,
    1.08635005541779435134e+02,
    6.57024977031928170135e+00,
    -6.04244152148580987438e-02};



 const double coeff<double>::rb[] =
   {-9.86494292470009928597e-03,
    -7.99283237680523006574e-01,
    -1.77579549177547519889e+01,
    -1.60636384855821916062e+02,
    -6.37566443368389627722e+02,
    -1.02509513161107724954e+03,
    -4.83519191608651397019e+02};
 const double coeff<double>::sb[] =
   {0.0,3.03380607434824582924e+01,
    3.25792512996573918826e+02,
    1.53672958608443695994e+03,
    3.19985821950859553908e+03,
    2.55305040643316442583e+03,
    4.74528541206955367215e+02,
    -2.24409524465858183362e+01};
# 245 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_erf_apfixed.h"
 template<typename T> class erf_traits{ };
# 267 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_erf_apfixed.h"
 template<> class erf_traits<double> {
 public:
   static const uint64_t mask;
   static const uint32_t segment[10];
 };
 const uint64_t erf_traits<double>::mask = 0xffffffff00000000;
 const uint32_t erf_traits<double>::segment[10] =
   {
  0x7fffffff,
  0x7ff00000,
  0x3feb0000,
  0x3e300000,
  0x00800000,
  0x3ff40000,
  0x40180000,
  0x4006DB6E,
  63,
  32
   };

 template<typename T> class erfc_traits{};
# 308 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_erf_apfixed.h"
 template<> class erfc_traits<double>{
 public:
   static const uint32_t segment[11];
 };
 const uint32_t erfc_traits<double>::segment[11] =
   {
  0x7fffffff,
  0x7ff00000,
  0x3feb0000,
  0x3c700000,
  0x3fd00000,
  0x3ff40000,
  0x403c0000,
  0x4006DB6D,
  0x40180000,
  63,
  32
   };
  }
# 346 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_erf_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> erf(ap_fixed<W_,I_> x_fixed )
{
    int F_ = W_ - I_;

    if (I_>33) return 0;
    else if (F_>32) return 0;

    double x = x_fixed.to_double();
 int32_t hx;
    uint32_t ix;
 double R,S,P,Q,s,y,z,r;

    fp_struct<double> fp_abs(x);
      fp_abs.sign=0;
    fp_struct<double> fp_x(x);
    ap_uint<32> tmp = fp_x.data()(erf_traits<double>::segment[8],erf_traits<double>::segment[9]);
    hx = tmp.to_int();
 ix = hx & erf_traits<double>::segment[0];






    if(fp_x.exp == 0x0 && fp_x.sign!= 0x0){
   return 0;
 }

 if(ix>=erf_traits<double>::segment[1]) {

   if(hx>0)
  return ap_fixed<W_,I_>((double)1.0 +coeff<double>::one/x);
   else
  return ap_fixed<W_,I_>(coeff<double>::one/x-(double)1.0);
 }

 if(ix < erf_traits<double>::segment[2]) {
   double r1,r2,s1,s2,s3,z2,z4;
   if(ix < erf_traits<double>::segment[3]) {
  if (ix < erf_traits<double>::segment[2])
    return ap_fixed<W_,I_>(((double)0.125)*((double)8.0*x+coeff<double>::efx8*x));
  return ap_fixed<W_,I_>(x + coeff<double>::efx*x);
   }
   z = x*x;




   r1 = coeff<double>::pp[0]+z*coeff<double>::pp[1]; z2=z*z;
   r2 = coeff<double>::pp[2]+z*coeff<double>::pp[3]; z4=z2*z2;
   s1 = coeff<double>::one+z* coeff<double>::qq[1];
   s2 = coeff<double>::qq[2]+z*coeff<double>::qq[3];
   s3 = coeff<double>::qq[4]+z*coeff<double>::qq[5];
   r = r1 + z2*r2 + z4*coeff<double>::pp[4];
   s = s1 + z2*s2 + z4*s3;

   y = r/s;
   return ap_fixed<W_,I_>(x + x*y);
 }
 if(ix < erf_traits<double>::segment[5]) {
   double s2,s4,s6,P1,P2,P3,P4,Q1,Q2,Q3,Q4;

      s = fp_abs.to_ieee()-coeff<double>::one;




   P1 = coeff<double>::pa[0]+s*coeff<double>::pa[1]; s2=s*s;
   Q1 = coeff<double>::one+s*coeff<double>::qa[1]; s4=s2*s2;
   P2 = coeff<double>::pa[2]+s*coeff<double>::pa[3]; s6=s4*s2;
   Q2 = coeff<double>::qa[2]+s*coeff<double>::qa[3];
   P3 = coeff<double>::pa[4]+s*coeff<double>::pa[5];
   Q3 = coeff<double>::qa[4]+s*coeff<double>::qa[5];
   P4 = coeff<double>::pa[6];
   Q4 = coeff<double>::qa[6];
   P = P1 + s2*P2 + s4*P3 + s6*P4;
   Q = Q1 + s2*Q2 + s4*Q3 + s6*Q4;

   if(hx>=0) return ap_fixed<W_,I_>(coeff<double>::erx + P/Q);
      else return ap_fixed<W_,I_>(-coeff<double>::erx - P/Q);
 }
 if (ix >= erf_traits<double>::segment[6]) {
   if(hx>=0) return ap_fixed<W_,I_>(coeff<double>::one-coeff<double>::tiny);
      else return ap_fixed<W_,I_>(coeff<double>::tiny-coeff<double>::one);
 }
 x = fp_abs.to_ieee();
  s = coeff<double>::one/(x*x);
 if(ix< erf_traits<double>::segment[7]) {






   double R1,R2,R3,R4,S1,S2,S3,S4,s2,s4,s6,s8;
   R1 = coeff<double>::ra[0]+s*coeff<double>::ra[1];s2 = s*s;
   S1 = coeff<double>::one+ s*coeff<double>::sa[1]; s4 = s2*s2;
   R2 = coeff<double>::ra[2]+s*coeff<double>::ra[3];s6 = s4*s2;
   S2 = coeff<double>::sa[2]+s*coeff<double>::sa[3];s8 = s4*s4;
   R3 = coeff<double>::ra[4]+s*coeff<double>::ra[5];
   S3 = coeff<double>::sa[4]+s*coeff<double>::sa[5];
   R4 = coeff<double>::ra[6]+s*coeff<double>::ra[7];
   S4 = coeff<double>::sa[6]+s*coeff<double>::sa[7];
   R = R1 + s2*R2 + s4*R3 + s6*R4;
   S = S1 + s2*S2 + s4*S3 + s6*S4 + s8*coeff<double>::sa[8];

 } else {






   double R1,R2,R3,S1,S2,S3,S4,s2,s4,s6;
   R1 = coeff<double>::rb[0]+s*coeff<double>::rb[1];s2 = s*s;
   S1 = coeff<double>::one+ s*coeff<double>::sb[1]; s4 = s2*s2;
   R2 = coeff<double>::rb[2]+s*coeff<double>::rb[3];s6 = s4*s2;
   S2 = coeff<double>::sb[2]+s*coeff<double>::sb[3];
   R3 = coeff<double>::rb[4]+s*coeff<double>::rb[5];
   S3 = coeff<double>::sb[4]+s*coeff<double>::sb[5];
   S4 = coeff<double>::sb[6]+s*coeff<double>::sb[7];
   R = R1 + s2*R2 + s4*R3 + s6*coeff<double>::rb[6];
   S = S1 + s2*S2 + s4*S3 + s6*S4;

 }
 z = x;

    fp_struct<double> fp_z(z);
    ap_uint<Type_BitWidth<double>::Value> data = fp_z.data() & erf_traits<double>::mask;
    fp_struct<double> fp_z_new(data);
    z = fp_z_new.to_ieee();


    ap_fixed<W_, I_> r_fixed = exp_reduce::exp(ap_fixed<W_, I_>(-z*z-(double)0.5625))*exp_reduce::exp(ap_fixed<W_, I_>((z-x)*(z+x)+R/S));
 r = r_fixed.to_double();

 if(hx>=0) return ap_fixed<W_,I_>(coeff<double>::one-r/x);
    else return ap_fixed<W_,I_>(r/x-coeff<double>::one);
  }


template <int W_, int I_>
ap_ufixed<W_,I_> erf(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xs = x;
    return erf(xs);
}

template <int I_>
ap_int<I_> erf(ap_int<I_> x) {
    ap_fixed<I_,I_> xs = x;
    return erf(xs);
}

template <int I_>
ap_uint<I_> erf(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xs = x;
    return erf(xs);
}
# 513 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_erf_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> erfc(ap_fixed<W_,I_> x_fixed)
{
#pragma HLS PIPELINE II=1
 int F_ = W_ - I_;

    if (I_>33) return 0;
    else if (F_>32) return 0;

    double x = x_fixed.to_double();
    int32_t hx;
    uint32_t ix;
 double R,S,P,Q,s,y,z,r;

    fp_struct<double> fp_abs(x);
    fp_abs.sign=0;
    fp_struct<double> fp_x(x);
    ap_uint<32> tmp = fp_x.data()(erfc_traits<double>::segment[9],erfc_traits<double>::segment[10]);
    hx = tmp.to_int();
 ix = hx & erfc_traits<double>::segment[0];
 if(ix>=erfc_traits<double>::segment[1]) {

   if(hx>0)
  return ap_fixed<W_,I_>(coeff<double>::one/x);
   else
  return ap_fixed<W_,I_>(coeff<double>::two + coeff<double>::one/x);

 }

 if(ix < erfc_traits<double>::segment[2]) {
   double r1,r2,s1,s2,s3,z2,z4;
   if(ix < erfc_traits<double>::segment[3])
  return ap_fixed<W_,I_>(coeff<double>::one-x);
   z = x*x;




   r1 = coeff<double>::pp[0]+z*coeff<double>::pp[1]; z2=z*z;
   r2 = coeff<double>::pp[2]+z*coeff<double>::pp[3]; z4=z2*z2;
   s1 = coeff<double>::one+z*coeff<double>::qq[1];
   s2 = coeff<double>::qq[2]+z*coeff<double>::qq[3];
   s3 = coeff<double>::qq[4]+z*coeff<double>::qq[5];
   r = r1 + z2*r2 + z4*coeff<double>::pp[4];
   s = s1 + z2*s2 + z4*s3;

   y = r/s;
   if(ix < erfc_traits<double>::segment[4]) {
  return ap_fixed<W_,I_>(coeff<double>::one-(x+x*y));
   } else {
  r = x*y;
  r += (x-coeff<double>::one_over_two);
  return ap_fixed<W_,I_>(coeff<double>::one_over_two - r) ;
   }
 }
 if(ix < erfc_traits<double>::segment[5]) {
   double s2,s4,s6,P1,P2,P3,P4,Q1,Q2,Q3,Q4;
   s =fp_abs.to_ieee()-coeff<double>::one;




   P1 = coeff<double>::pa[0]+s*coeff<double>::pa[1]; s2=s*s;
   Q1 = coeff<double>::one+s*coeff<double>::qa[1]; s4=s2*s2;
   P2 = coeff<double>::pa[2]+s*coeff<double>::pa[3]; s6=s4*s2;
   Q2 = coeff<double>::qa[2]+s*coeff<double>::qa[3];
   P3 = coeff<double>::pa[4]+s*coeff<double>::pa[5];
   Q3 = coeff<double>::qa[4]+s*coeff<double>::qa[5];
   P4 = coeff<double>::pa[6];
   Q4 = coeff<double>::qa[6];
   P = P1 + s2*P2 + s4*P3 + s6*P4;
   Q = Q1 + s2*Q2 + s4*Q3 + s6*Q4;

   if(hx>=0) {
  z = coeff<double>::one-coeff<double>::erx;
        return ap_fixed<W_,I_>(z - P/Q);
   } else {
  z = coeff<double>::erx+P/Q; return ap_fixed<W_,I_>(coeff<double>::one+z);
   }
 }
 if (ix < erfc_traits<double>::segment[6]) {
   x = fp_abs.to_ieee();
   s = coeff<double>::one/(x*x);
   if(ix< erfc_traits<double>::segment[7]) {






  double R1,R2,R3,R4,S1,S2,S3,S4,s2,s4,s6,s8;
     R1 = coeff<double>::ra[0]+s*coeff<double>::ra[1];s2 = s*s;
     S1 = coeff<double>::one+s*coeff<double>::sa[1]; s4 = s2*s2;
     R2 = coeff<double>::ra[2]+s*coeff<double>::ra[3];s6 = s4*s2;
     S2 = coeff<double>::sa[2]+s*coeff<double>::sa[3];s8 = s4*s4;
     R3 = coeff<double>::ra[4]+s*coeff<double>::ra[5];
     S3 = coeff<double>::sa[4]+s*coeff<double>::sa[5];
     R4 = coeff<double>::ra[6]+s*coeff<double>::ra[7];
     S4 = coeff<double>::sa[6]+s*coeff<double>::sa[7];
     R = R1 + s2*R2 + s4*R3 + s6*R4;
     S = S1 + s2*S2 + s4*S3 + s6*S4 + s8*coeff<double>::sa[8];

   } else {
  double R1,R2,R3,S1,S2,S3,S4,s2,s4,s6;
  if(hx<0&&ix>=erfc_traits<double>::segment[8]) return ap_fixed<W_,I_>(coeff<double>::two-coeff<double>::tiny);






  R1 = coeff<double>::rb[0]+s*coeff<double>::rb[1];s2 = s*s;
  S1 = coeff<double>::one+s*coeff<double>::sb[1]; s4 = s2*s2;
  R2 = coeff<double>::rb[2]+s*coeff<double>::rb[3];s6 = s4*s2;
  S2 = coeff<double>::sb[2]+s*coeff<double>::sb[3];
  R3 = coeff<double>::rb[4]+s*coeff<double>::rb[5];
  S3 = coeff<double>::sb[4]+s*coeff<double>::sb[5];
  S4 = coeff<double>::sb[6]+s*coeff<double>::sb[7];
  R = R1 + s2*R2 + s4*R3 + s6*coeff<double>::rb[6];
  S = S1 + s2*S2 + s4*S3 + s6*S4;

   }
   z = x;

   fp_struct<double> fp_z(z);
   ap_uint<Type_BitWidth<double>::Value> data = fp_z.data() & erf_traits<double>::mask;
   fp_struct<double> fp_z_new(data);
   z = fp_z_new.to_ieee();


   ap_fixed<W_, I_> r_fixed = exp_reduce::exp((ap_fixed<W_, I_>)(-z*z-(double)0.5625))*exp_reduce::exp((ap_fixed<W_, I_>)((z-x)*(z+x)+R/S));
   double r = r_fixed.to_double();
   double r_x = r/x;
   if(hx>0) {





        if(fp_x.exp == 0x0 && fp_x.sign!= 0x0){
   return 0;
        }
  return ap_fixed<W_,I_>(r_x);
   } else
  return ap_fixed<W_,I_>(coeff<double>::two-r_x);
 } else {
   if(hx>0) return ap_fixed<W_,I_>(coeff<double>::tiny*coeff<double>::tiny);
      else return ap_fixed<W_,I_>(coeff<double>::two-coeff<double>::tiny);
 }

}
template <int W_, int I_>
ap_ufixed<W_,I_> erfc(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xs = x;
    return erfc(xs);
}

template <int I_>
ap_int<I_> erfc(ap_int<I_> x) {
    ap_fixed<I_,I_> xs = x;
    return erfc(xs);
}

template <int I_>
ap_uint<I_> erfc(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xs = x;
    return erfc(xs);
}

}
# 1080 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_math.h" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_fmod_rem_quo_remainder_divide_apfixed.h" 1
# 40 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_fmod_rem_quo_remainder_divide_apfixed.h"
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/ap_int.h" 1
# 41 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_fmod_rem_quo_remainder_divide_apfixed.h" 2



namespace hls_internal{

    template <int W_, int I_>
    ap_fixed<W_,I_> generic_divide(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y){
        if(y==0){




                return 0;

        } else{
     return(x/y);
        }
    }

    template <int W_, int I_>
    ap_ufixed<W_,I_> generic_divide(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y){
     ap_fixed<W_+1,I_+1> x1 = x;
     ap_fixed<W_+1,I_+1> y1 = y;
     return generic_divide(x1,y1);
    }

    template <int I_>
    ap_int<I_> generic_divide(ap_int<I_> x, ap_int<I_> y){
     ap_fixed<I_,I_> x1 = x;
     ap_fixed<I_,I_> y1 = y;
     return generic_divide(x1,y1);
    }

    template <int I_>
    ap_uint<I_> generic_divide(ap_uint<I_> x, ap_uint<I_> y){
     ap_ufixed<I_,I_> x1 = x;
     ap_ufixed<I_,I_> y1 = y;
     return generic_divide(x1,y1);
    }

    template <int W_, int I_>
    ap_fixed<W_,I_> generic_fmod(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y){
        ap_ufixed<W_,I_> x_pos = fabs_fixed((ap_fixed<W_+1,I_+1>)x);
        ap_ufixed<W_,I_> y_pos = fabs_fixed((ap_fixed<W_+1,I_+1>)y);


        if(x_pos==0 || y_pos==0) return 0;
     else if(x_pos == y_pos) return 0;
        else if(x_pos < y_pos) return x;
        else {
            ap_uint<W_> x_int = 0;
            ap_uint<W_> y_int = 0;
            x_int(W_-1,0) = x_pos(W_-1,0);
            y_int(W_-1,0) = y_pos(W_-1,0);






            ap_uint<W_> d = x_int/y_int;

            ap_uint<W_> rem = x_int - d*y_int;

            ap_fixed<W_,I_> r = 0;
            r(W_-1,0) = rem(W_-1,0);
            if(x[W_-1]) return -r;
            else return r;
        }
    }


    template <int W_, int I_>
    ap_ufixed<W_,I_> generic_fmod(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y){
        ap_fixed<W_+1,I_+1> xi = x;
        ap_fixed<W_+1,I_+1> yi = y;
        return generic_fmod(xi,yi);
    }

    template <int I_>
    ap_int<I_> generic_fmod(ap_int<I_> x, ap_int<I_> y){
     ap_fixed<I_,I_> xi = x;
     ap_fixed<I_,I_> yi = y;
     return generic_fmod(xi,yi);
    }

    template <int I_>
    ap_uint<I_> generic_fmod(ap_uint<I_> x, ap_uint<I_> y){
     ap_fixed<I_+1,I_+1> xi = x;
     ap_fixed<I_+1,I_+1> yi = y;
     return generic_fmod(xi,yi);
    }


    template <int W_, int I_>
    ap_fixed<W_,I_> generic_remquo(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y, int* quo){
        ap_ufixed<W_,I_> x_pos = fabs_fixed((ap_fixed<W_+1,I_+1>)x);
        ap_ufixed<W_,I_> y_pos = fabs_fixed((ap_fixed<W_+1,I_+1>)y);
        if(x_pos==0 || y_pos==0) {
           *quo = 0;
           return 0;
        } else if(x_pos == y_pos) {
           if(x[W_-1]==y[W_-1]) *quo = 1;
           else *quo = -1;
           return 0;
        }

        else {
            ap_uint<W_> x_int = 0;
            ap_uint<W_> y_int = 0;
            x_int(W_-1,0) = x_pos(W_-1,0);
            y_int(W_-1,0) = y_pos(W_-1,0);





            ap_uint<W_> d = x_int/y_int;
            ap_uint<W_> rem = x_int - d*y_int;

            ap_uint<W_> y_half = 0;
            y_half(W_-2,0) = y_int(W_-1,1);
            ap_uint<1> r_sig = x[W_-1];
            if(rem > y_half) {
                rem = y_int - rem;
                d++;
                if(x[W_-1]) r_sig = 0;
                else r_sig = 1;
            }

            if(x[W_-1]==y[W_-1]) *quo = d;
            else *quo = -d;
            ap_fixed<W_,I_> r = 0;
            r(W_-1,0) = rem(W_-1,0);
            if(r_sig) return -r;
            else return r;
        }
    }

    template <int W_, int I_>
    ap_ufixed<W_,I_> generic_remquo(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y, int* quo){
     ap_fixed<W_+1,I_+1> xi = x;
     ap_fixed<W_+1,I_+1> yi = y;
     return generic_remquo(xi,yi,quo);
    }

    template <int I_>
    ap_int<I_> generic_remquo(ap_int<I_> x, ap_int<I_> y, int* quo){
     ap_fixed<I_,I_> xi = x;
     ap_fixed<I_,I_> yi = y;
     return generic_remquo(xi,yi,quo);
    }

    template <int I_>
    ap_uint<I_> generic_remquo(ap_uint<I_> x, ap_uint<I_> y, int* quo){
     ap_fixed<I_+1,I_+1> xi = x;
     ap_fixed<I_+1,I_+1> yi = y;
     return generic_remquo(xi,yi,quo);
    }


    template <int W_, int I_>
    ap_fixed<W_,I_> generic_remainder(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y){
        int quo = 0;
        return generic_remquo(x, y, &quo);
    }

    template <int W_, int I_>
    ap_ufixed<W_,I_> generic_remainder(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y){
        ap_fixed<W_+1, I_+1> xi = x;
        ap_fixed<W_+1, I_+1> yi = y;
        return generic_remainder(xi,yi);
    }

    template <int I_>
    ap_int<I_> generic_remainder(ap_int<I_> x, ap_int<I_> y){
     ap_fixed<I_,I_> xi = x;
     ap_fixed<I_,I_> yi = y;
     return generic_remainder(xi,yi);
    }

    template <int I_>
    ap_uint<I_> generic_remainder(ap_uint<I_> x, ap_uint<I_> y){
     ap_fixed<I_+1,I_+1> xi = x;
     ap_fixed<I_+1,I_+1> yi = y;
     return generic_remainder(xi,yi);
    }
}
# 1081 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_math.h" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_lgamma_apfixed.h" 1
# 35 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_lgamma_apfixed.h"
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/ap_int.h" 1
# 36 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_lgamma_apfixed.h" 2

# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/utils/x_hls_traits.h" 1
# 37 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/utils/x_hls_traits.h"
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/ap_int.h" 1
# 38 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/utils/x_hls_traits.h" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_x_complex.h" 1
# 42 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_x_complex.h"
namespace std {
template<typename _Tp> class complex;
}

namespace hls {
# 59 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_x_complex.h"
template<typename T> class x_complex {

  private:
    T re, im;

  public:

    typedef x_complex<T> MULT_RT;

    x_complex() {};
    x_complex(const T& r, const T& i) { re = r; im = i; };
    x_complex(const T& r) { re = r; im = 0; };
    x_complex(const std::complex<T> &z) : re(z.real()),im(z.imag()) {}
    template<typename T2>
    x_complex(const x_complex<T2> &z) : re(z.real()),im(z.imag()) {};


    inline T real() const { return(re); };
    inline T& real() { return(re); };

    inline void real(const T& r) { re = r; };

    inline T imag() const { return(im); };
    inline T& imag() { return(im); };

    inline void imag(const T& i) { im = i; };


    inline x_complex<T>& operator= (const T& rhs) {
      re = rhs; im = 0; return *this; };
    inline x_complex<T>& operator= (const x_complex<T>& rhs) {
      re = rhs.real(); im = rhs.imag(); return *this; };
    template<typename T2>
    inline x_complex<T>& operator= (const x_complex<T2>& rhs) {
      re = rhs.real(); im = rhs.imag(); return *this; };


    inline x_complex<T>& operator*= (const T& rhs) {
      re *= rhs;
      im *= rhs;
      return *this;
    };
    inline x_complex<T>& operator*= (const x_complex<T>& rhs) {
      T tmp1 = re*rhs.real();
      T tmp2 = im*rhs.imag();
      T tmp3 = re*rhs.imag();
      T tmp4 = im*rhs.real();
      re = tmp1 - tmp2;
      im = tmp3 + tmp4;
      return *this;
    };
    template<typename T2>
    inline x_complex<T>& operator*= (const x_complex<T2>& rhs) {
      x_complex<T> tmp(rhs.real(), rhs.imag());
      *this *= tmp;
      return *this;
    };

    inline MULT_RT operator* (const T& rhs) {
      x_complex_mult_real:;
      x_complex<T> tmp(*this);
      tmp *= rhs;
      return tmp;
    };
    inline MULT_RT operator* (const x_complex<T>& rhs) {
      x_complex_mult_complex:;
      x_complex<T> tmp(*this);
      tmp *= rhs;
      return tmp;
    }
    template<typename T2>
    inline MULT_RT operator* (const x_complex<T2>& rhs) {
      x_complex_mult_complex:;
      x_complex<T> tmp(rhs.real(), rhs.imag());
      MULT_RT res = *this * tmp;
      return res;
    };


    inline x_complex<T>& operator/= (const T& rhs) {;
      re /= rhs;
      im /= rhs;
      return *this;
    };
    inline x_complex<T>& operator/= (const x_complex<T>& rhs) {
      x_complex<T> conj ( rhs.real(), -rhs.imag());
      x_complex<T> a = (*this)*conj;
      x_complex<T> b = conj*rhs;
      re = a.real() / b.real();
      im = a.imag() / b.real();
      return *this;
    };
    template<typename T2>
    inline x_complex<T>& operator/= (const x_complex<T2>& rhs) {
      x_complex<T> tmp(rhs.real(), rhs.imag());
      *this /= tmp;
      return *this;
    };

    inline x_complex<T> operator/ (const T& rhs) {
      x_complex<T> tmp(*this);
      tmp /= rhs; return tmp;
    };
    inline x_complex<T> operator/ (const x_complex<T>& rhs) {
      x_complex<T> tmp(*this);
      tmp /= rhs;
      return tmp;
    };
    template<typename T2>
    inline x_complex<T> operator/ (const x_complex<T2>& rhs) {
      x_complex<T> tmp(*this);
      tmp /= rhs;
      return tmp;
    };


    inline x_complex<T>& operator+= (const T& rhs) {
      re += rhs;
      return *this;
    };
    inline x_complex<T> operator+= (const x_complex<T>& rhs) {
      re += rhs.real();
      im += rhs.imag();
      return *this;
    };
    template<typename T2>
    inline x_complex<T> operator+= (const x_complex<T2>& rhs) {
      re += rhs.real();
      im += rhs.imag();
      return *this; };

    inline x_complex<T> operator+ (const T& rhs) {
      x_complex<T> tmp ;
      tmp = *this;
      tmp += rhs;
      return tmp;
    };
    inline x_complex<T> operator+ (const x_complex<T>& rhs) {
       x_complex<T> tmp ;
       tmp = *this;
       tmp += rhs;
       return tmp;
    };
    template<typename T2>
    inline x_complex<T> operator+ (const x_complex<T2>& rhs) {
       x_complex<T> tmp ;
       tmp = *this;
       tmp += rhs;
       return tmp;
    };



    inline x_complex<T>& operator-= (const T& rhs) {
      re -= rhs;
      return *this;
    }
    inline x_complex<T>& operator-= (const x_complex<T>& rhs) {
      re -= rhs.real();
      im -= rhs.imag();
      return *this;
    };
    template<typename T2>
    inline x_complex<T>& operator-= (const x_complex<T2>& rhs) {
      re -= rhs.real();
      im -= rhs.imag();
      return *this;
    };

    inline x_complex<T> operator- (const T& rhs) {
      x_complex<T> tmp ;
      tmp = *this;
      tmp -= rhs;
      return tmp;
    };
    inline x_complex<T> operator- (const x_complex<T>& rhs) {
      x_complex<T> tmp ;
      tmp = *this;
      tmp -= rhs;
      return tmp;
    };
    template<typename T2>
    inline x_complex<T> operator- (const x_complex<T2>& rhs) {
      x_complex<T> tmp ;
      tmp = *this;
      tmp -= rhs;
      return tmp;
    };

    inline x_complex<T> operator- () {
      x_complex<T> tmp(*this);
      tmp.real(-real());
      tmp.imag(-imag());
      return tmp;
    };


  x_complex<T> &operator=(const std::complex<T> &t) {
    re = t.real();
    im = t.imag();
    return *this;
  }

  operator std::complex<T> () const {
    return std::complex<T>(re, im);
  }

  std::complex<T> to_std_complex(){
     return std::complex<T>(re ,im);
  }
# 281 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_x_complex.h"
  };


  template<typename T>
  inline bool operator== (const T& lhs, const x_complex<T>& rhs) {
    return (lhs == rhs.real()) && (0 == rhs.imag());
  }
  template<typename T>
  inline bool operator== (const x_complex<T>& lhs, const T& rhs) {
    return (lhs.real() == rhs) && (lhs.imag() == 0);
  }
  template<typename T>
  inline bool operator== (const x_complex<T>& lhs, const x_complex<T>& rhs) {
    return (lhs.real() == rhs.real()) && (lhs.imag() == rhs.imag());
  }

  template<typename T>
  inline bool operator!= (const T& lhs, const x_complex<T>& rhs) {
    return (lhs != rhs.real()) || (0 != rhs.imag());
  }
  template<typename T>
  inline bool operator!= (const x_complex<T>& lhs, const T& rhs) {
    return (lhs.real() != rhs) || (lhs.imag() != 0);
  }
  template<typename T>
  inline bool operator!= (const x_complex<T>& lhs, const x_complex<T>& rhs) {
    return (lhs.real() != rhs.real()) || (lhs.imag() != rhs.imag());
  }

  template<typename T>
  x_complex<T> x_neg(x_complex<T> &din) {
    x_complex<T> tmp;
    tmp.real(-din.real());
    tmp.imag(-din.imag());
    return(tmp);
  }

  template<typename T>
  x_complex<T> x_conj_sq(x_complex<T> &din) {
    x_conj_sq_complex:;
    return ( (din.real()*din.real()) + (din.imag()*din.imag()));
  }

  template<typename T>
  x_complex<T> x_conj(const x_complex<T> &din) {
    x_conj_complex:;
    x_complex<T> tmp;
    tmp.real(din.real());
    tmp.imag(-din.imag());
    return(tmp);
  }



  template<typename T>
  x_complex<T> x_conj(x_complex<T> &din) {
    const x_complex<T> tmp = din;
    return(x_conj(tmp));
  }

  template<int W, int I> void set_to_one(x_complex<ap_fixed<W,I> > &a) {
    ap_int<W> tmp_sat = ((ap_int<W-I+1>)1<<(W-I)) - 1;
    ap_fixed<W,I> tmp;
    tmp.range() = tmp_sat;
    a = tmp;
  }

  template<typename T>
  T x_real(const x_complex<T> &din) {
    return(din.real());
  }

  template<typename T>
  T x_imag(const x_complex<T> &din) {
    return(din.imag());
  }

  template<typename T1>
  typename x_complex<T1>::MULT_RT operator* (const T1& lhs, x_complex<T1>& rhs) {
    return (rhs*lhs);
  }

}
# 39 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/utils/x_hls_traits.h" 2

# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/utils/x_hls_utils.h" 1
# 41 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/utils/x_hls_traits.h" 2



namespace hls
{

template<typename T>
struct x_traits_default {
  typedef T ADD_T;
  typedef T SUB_T;
  typedef T SAT_T;
  typedef T MULT_T;
  typedef T MADD_T;
};

template<typename T1, typename T2>
struct x_traits {
# 69 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/utils/x_hls_traits.h"
};
template<typename T2>
struct x_traits<double, T2> : public x_traits_default<double> { };

template<typename T1>
struct x_traits<T1, double> : public x_traits_default<double> { };

template<typename T2>
struct x_traits<float, T2> : public x_traits_default<float> { };

template<typename T1>
struct x_traits<T1, float> : public x_traits_default<float> { };

template<typename T2>
struct x_traits<half, T2> : public x_traits_default<float> { };

template<typename T1>
struct x_traits<T1, half> : public x_traits_default<float> { };
# 102 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/utils/x_hls_traits.h"
template<>
struct x_traits< char , char > : public x_traits_default< char > {};

template<>
struct x_traits< char , signed char > : public x_traits_default< signed char > {};

template<>
struct x_traits< char , unsigned char > : public x_traits_default< unsigned char > {};

template<>
struct x_traits< char , short > : public x_traits_default< short > {};

template<>
struct x_traits< char , unsigned short > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< char , int > : public x_traits_default< int > {};

template<>
struct x_traits< char , unsigned int > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< char , long > : public x_traits_default< long > {};

template<>
struct x_traits< char , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< char , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< char , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< char , half > : public x_traits_default< float > {};

template<>
struct x_traits< char , float > : public x_traits_default< float > {};

template<>
struct x_traits< char , double > : public x_traits_default< double > {};

template<>
struct x_traits< signed char , char > : public x_traits_default< signed char > {};

template<>
struct x_traits< signed char , signed char > : public x_traits_default< signed char > {};

template<>
struct x_traits< signed char , unsigned char > : public x_traits_default< unsigned char > {};

template<>
struct x_traits< signed char , short > : public x_traits_default< short > {};

template<>
struct x_traits< signed char , unsigned short > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< signed char , int > : public x_traits_default< int > {};

template<>
struct x_traits< signed char , unsigned int > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< signed char , long > : public x_traits_default< long > {};

template<>
struct x_traits< signed char , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< signed char , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< signed char , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< signed char , half > : public x_traits_default< float > {};

template<>
struct x_traits< signed char , float > : public x_traits_default< float > {};

template<>
struct x_traits< signed char , double > : public x_traits_default< double > {};

template<>
struct x_traits< unsigned char , char > : public x_traits_default< unsigned char > {};

template<>
struct x_traits< unsigned char , signed char > : public x_traits_default< unsigned char > {};

template<>
struct x_traits< unsigned char , unsigned char > : public x_traits_default< unsigned char > {};

template<>
struct x_traits< unsigned char , short > : public x_traits_default< short > {};

template<>
struct x_traits< unsigned char , unsigned short > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< unsigned char , int > : public x_traits_default< int > {};

template<>
struct x_traits< unsigned char , unsigned int > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned char , long > : public x_traits_default< long > {};

template<>
struct x_traits< unsigned char , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned char , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< unsigned char , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< unsigned char , half > : public x_traits_default< float > {};

template<>
struct x_traits< unsigned char , float > : public x_traits_default< float > {};

template<>
struct x_traits< unsigned char , double > : public x_traits_default< double > {};

template<>
struct x_traits< short , char > : public x_traits_default< short > {};

template<>
struct x_traits< short , signed char > : public x_traits_default< short > {};

template<>
struct x_traits< short , unsigned char > : public x_traits_default< short > {};

template<>
struct x_traits< short , short > : public x_traits_default< short > {};

template<>
struct x_traits< short , unsigned short > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< short , int > : public x_traits_default< int > {};

template<>
struct x_traits< short , unsigned int > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< short , long > : public x_traits_default< long > {};

template<>
struct x_traits< short , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< short , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< short , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< short , half > : public x_traits_default< float > {};

template<>
struct x_traits< short , float > : public x_traits_default< float > {};

template<>
struct x_traits< short , double > : public x_traits_default< double > {};

template<>
struct x_traits< unsigned short , char > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< unsigned short , signed char > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< unsigned short , unsigned char > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< unsigned short , short > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< unsigned short , unsigned short > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< unsigned short , int > : public x_traits_default< int > {};

template<>
struct x_traits< unsigned short , unsigned int > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned short , long > : public x_traits_default< long > {};

template<>
struct x_traits< unsigned short , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned short , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< unsigned short , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< unsigned short , half > : public x_traits_default< float > {};

template<>
struct x_traits< unsigned short , float > : public x_traits_default< float > {};

template<>
struct x_traits< unsigned short , double > : public x_traits_default< double > {};

template<>
struct x_traits< int , char > : public x_traits_default< int > {};

template<>
struct x_traits< int , signed char > : public x_traits_default< int > {};

template<>
struct x_traits< int , unsigned char > : public x_traits_default< int > {};

template<>
struct x_traits< int , short > : public x_traits_default< int > {};

template<>
struct x_traits< int , unsigned short > : public x_traits_default< int > {};

template<>
struct x_traits< int , int > : public x_traits_default< int > {};

template<>
struct x_traits< int , unsigned int > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< int , long > : public x_traits_default< long > {};

template<>
struct x_traits< int , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< int , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< int , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< int , half > : public x_traits_default< float > {};

template<>
struct x_traits< int , float > : public x_traits_default< float > {};

template<>
struct x_traits< int , double > : public x_traits_default< double > {};

template<>
struct x_traits< unsigned int , char > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned int , signed char > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned int , unsigned char > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned int , short > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned int , unsigned short > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned int , int > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned int , unsigned int > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned int , long > : public x_traits_default< long > {};

template<>
struct x_traits< unsigned int , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned int , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< unsigned int , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< unsigned int , half > : public x_traits_default< float > {};

template<>
struct x_traits< unsigned int , float > : public x_traits_default< float > {};

template<>
struct x_traits< unsigned int , double > : public x_traits_default< double > {};

template<>
struct x_traits< long , char > : public x_traits_default< long > {};

template<>
struct x_traits< long , signed char > : public x_traits_default< long > {};

template<>
struct x_traits< long , unsigned char > : public x_traits_default< long > {};

template<>
struct x_traits< long , short > : public x_traits_default< long > {};

template<>
struct x_traits< long , unsigned short > : public x_traits_default< long > {};

template<>
struct x_traits< long , int > : public x_traits_default< long > {};

template<>
struct x_traits< long , unsigned int > : public x_traits_default< long > {};

template<>
struct x_traits< long , long > : public x_traits_default< long > {};

template<>
struct x_traits< long , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< long , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< long , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< long , half > : public x_traits_default< float > {};

template<>
struct x_traits< long , float > : public x_traits_default< float > {};

template<>
struct x_traits< long , double > : public x_traits_default< double > {};

template<>
struct x_traits< unsigned long , char > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , signed char > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , unsigned char > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , short > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , unsigned short > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , int > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , unsigned int > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< unsigned long , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< unsigned long , half > : public x_traits_default< float > {};

template<>
struct x_traits< unsigned long , float > : public x_traits_default< float > {};

template<>
struct x_traits< unsigned long , double > : public x_traits_default< double > {};

template<>
struct x_traits< ap_slong , char > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , signed char > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , unsigned char > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , short > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , unsigned short > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , int > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , unsigned int > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , long > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , unsigned long > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_slong , half > : public x_traits_default< float > {};

template<>
struct x_traits< ap_slong , float > : public x_traits_default< float > {};

template<>
struct x_traits< ap_slong , double > : public x_traits_default< double > {};

template<>
struct x_traits< ap_ulong , char > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , signed char > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , unsigned char > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , short > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , unsigned short > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , int > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , unsigned int > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , long > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , unsigned long > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , ap_slong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , half > : public x_traits_default< float > {};

template<>
struct x_traits< ap_ulong , float > : public x_traits_default< float > {};

template<>
struct x_traits< ap_ulong , double > : public x_traits_default< double > {};

template<>
struct x_traits< half , char > : public x_traits_default< float > {};

template<>
struct x_traits< half , signed char > : public x_traits_default< float > {};

template<>
struct x_traits< half , unsigned char > : public x_traits_default< float > {};

template<>
struct x_traits< half , short > : public x_traits_default< float > {};

template<>
struct x_traits< half , unsigned short > : public x_traits_default< float > {};

template<>
struct x_traits< half , int > : public x_traits_default< float > {};

template<>
struct x_traits< half , unsigned int > : public x_traits_default< float > {};

template<>
struct x_traits< half , long > : public x_traits_default< float > {};

template<>
struct x_traits< half , unsigned long > : public x_traits_default< float > {};

template<>
struct x_traits< half , ap_slong > : public x_traits_default< float > {};

template<>
struct x_traits< half , ap_ulong > : public x_traits_default< float > {};

template<>
struct x_traits< half , half > : public x_traits_default< half > {};

template<>
struct x_traits< half , float > : public x_traits_default< float > {};

template<>
struct x_traits< half , double > : public x_traits_default< double > {};

template<>
struct x_traits< float , char > : public x_traits_default< float > {};

template<>
struct x_traits< float , signed char > : public x_traits_default< float > {};

template<>
struct x_traits< float , unsigned char > : public x_traits_default< float > {};

template<>
struct x_traits< float , short > : public x_traits_default< float > {};

template<>
struct x_traits< float , unsigned short > : public x_traits_default< float > {};

template<>
struct x_traits< float , int > : public x_traits_default< float > {};

template<>
struct x_traits< float , unsigned int > : public x_traits_default< float > {};

template<>
struct x_traits< float , long > : public x_traits_default< float > {};

template<>
struct x_traits< float , unsigned long > : public x_traits_default< float > {};

template<>
struct x_traits< float , ap_slong > : public x_traits_default< float > {};

template<>
struct x_traits< float , ap_ulong > : public x_traits_default< float > {};

template<>
struct x_traits< float , half > : public x_traits_default< float > {};

template<>
struct x_traits< float , float > : public x_traits_default< float > {};

template<>
struct x_traits< float , double > : public x_traits_default< double > {};

template<>
struct x_traits< double , char > : public x_traits_default< double > {};

template<>
struct x_traits< double , signed char > : public x_traits_default< double > {};

template<>
struct x_traits< double , unsigned char > : public x_traits_default< double > {};

template<>
struct x_traits< double , short > : public x_traits_default< double > {};

template<>
struct x_traits< double , unsigned short > : public x_traits_default< double > {};

template<>
struct x_traits< double , int > : public x_traits_default< double > {};

template<>
struct x_traits< double , unsigned int > : public x_traits_default< double > {};

template<>
struct x_traits< double , long > : public x_traits_default< double > {};

template<>
struct x_traits< double , unsigned long > : public x_traits_default< double > {};

template<>
struct x_traits< double , ap_slong > : public x_traits_default< double > {};

template<>
struct x_traits< double , ap_ulong > : public x_traits_default< double > {};

template<>
struct x_traits< double , half > : public x_traits_default< double > {};

template<>
struct x_traits< double , float > : public x_traits_default< double > {};

template<>
struct x_traits< double , double > : public x_traits_default< double > {};





template<int A,int B> class MAX{
  public:
    const static int value = (A > B) ? A : B;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_fixed<W2,I2,Q2,O2> > {
    typedef typename ap_fixed<W1,I1>::template RType<W2,I2,true> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
 typedef ap_fixed<W1,I1,AP_RND,AP_SAT> SAT_T;
 typedef ap_fixed<W1+W2+1,I1+I2+1> MADD_T;
 typedef ap_fixed<W1+W2+2,I1+I2+2> CMADD_T;
 typedef ap_fixed<(2*W1)+1,(2*I1)> CONJ_SQ_T;
 typedef ap_fixed<(2*W1)+2,(2*I1)+1> CONJ_SQ_2_T;
    typedef ap_fixed<2*(MAX<I1,W1-I1>::value+1),(MAX<I1,W1-I1>::value+1)> INV_T;
    typedef int INT_T;
    typedef float_struct<24,8> FLOAT_STRUCT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_ufixed<W2,I2,Q2,O2> > {
    typedef typename ap_fixed<W1,I1>::template RType<W2,I2,false> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_fixed<W2,I2,Q2,O2> > {
    typedef typename ap_ufixed<W1,I1>::template RType<W2,I2,true> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_ufixed<W2,I2,Q2,O2> > {
    typedef typename ap_ufixed<W1,I1>::template RType<W2,I2,false> RTYPE;
    typedef ap_ufixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_ufixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
 typedef ap_ufixed<W1,I1,AP_RND,AP_SAT> SAT_T;
 typedef ap_ufixed<W1+W2+1,I1+I2+1> MADD_T;
 typedef ap_ufixed<W1+W2+2,I1+I2+2> CMADD_T;
 typedef ap_ufixed<(2*W1)+1,(2*I1)> CONJ_SQ_T;
 typedef ap_ufixed<(2*W1)+2,(2*I1)+1> CONJ_SQ_2_T;
    typedef ap_ufixed<2*(MAX<I1,W1-I1>::value+1),(MAX<I1,W1-I1>::value+1)> INV_T;
    typedef int INT_T;
    typedef float_struct<24,8> FLOAT_STRUCT_T;
};

template<int W1, int W2>
struct x_traits<ap_int<W1>,ap_int<W2> > {
 typedef ap_int<MAX<W1,W2>::value + 1> ADD_T;
 typedef ap_int<MAX<W1,W2>::value + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
 typedef ap_int<(W1 > W2)? W1:W2> MADD_T;
};

template<int W1, int W2>
struct x_traits<ap_int<W1>,ap_uint<W2> > {
 typedef ap_int<MAX<W1,W2+1>::value + 1> ADD_T;
 typedef ap_int<MAX<W1,W2+1>::value + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
};

template<int W1, int W2>
struct x_traits<ap_uint<W1>,ap_int<W2> > {
 typedef ap_int<MAX<W1+1,W2>::value + 1> ADD_T;
 typedef ap_int<MAX<W1+1,W2>::value + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
};

template<int W1, int W2>
struct x_traits<ap_uint<W1>,ap_uint<W2> > {
 typedef ap_uint<MAX<W1,W2>::value + 1> ADD_T;
 typedef ap_int<MAX<W1,W2>::value + 1> SUB_T;
 typedef ap_uint<W1+W2> MULT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_int<W2> > : public x_traits<ap_fixed<W1,I1>, ap_fixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_uint<W2> > : public x_traits<ap_fixed<W1,I1>, ap_ufixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_int<W2> > : public x_traits<ap_ufixed<W1,I1>, ap_fixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_uint<W2> > : public x_traits<ap_ufixed<W1,I1>, ap_ufixed<W2,W2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_int<W1>, ap_fixed<W2,I2,Q2,O2> > : public x_traits<ap_fixed<W1,W1>, ap_fixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_int<W1>, ap_ufixed<W2,I2,Q2,O2> > : public x_traits<ap_fixed<W1,W1>, ap_ufixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_uint<W1>, ap_fixed<W2,I2,Q2,O2> > : public x_traits<ap_ufixed<W1,W1>, ap_fixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_uint<W1>, ap_ufixed<W2,I2,Q2,O2> > : public x_traits<ap_ufixed<W1,W1>, ap_ufixed<W2,I2> > {};




    template<typename T> struct fixed_type { };
    template<> struct fixed_type<char> { typedef ap_fixed<8,8> T; };
    template<> struct fixed_type<unsigned char> { typedef ap_ufixed<8,8> T; };
    template<> struct fixed_type<short> { typedef ap_fixed<16,16> T; };
    template<> struct fixed_type<unsigned short> { typedef ap_ufixed<16,16> T; };
    template<> struct fixed_type<int> { typedef ap_fixed<32,32> T; };
    template<> struct fixed_type<unsigned int> { typedef ap_ufixed<32,32> T; };
    template<> struct fixed_type<float> { typedef ap_ufixed<64,32> T; };
    template<int W> struct fixed_type<ap_int<W> > { typedef ap_fixed<W,W> T; };
    template<int W> struct fixed_type<ap_uint<W> > { typedef ap_ufixed<W,W> T; };
    template<int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O> struct fixed_type<ap_fixed<W,I, _AP_Q, _AP_O> > { typedef ap_fixed<W,I> T; };
    template<int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O> struct fixed_type<ap_ufixed<W,I, _AP_Q, _AP_O> > { typedef ap_ufixed<W,I> T; };

template<typename T1, int DIM>
struct x_traits_d_default {
    typedef T1 ACCUM_T;
    typedef T1 ACCUM2_T;
    typedef T1 ADD_TREE_T;
};

template<typename T1, int DIM>
struct x_traits_d {};

template<int DIM>
struct x_traits_d <int,DIM>:x_traits_d_default<int, DIM> {};

template<int DIM>
struct x_traits_d <float,DIM>:x_traits_d_default<float, DIM> {};

template<int DIM>
struct x_traits_d <double,DIM>:x_traits_d_default<double, DIM> {};

template<int DIM>
struct x_traits_d <half,DIM>:x_traits_d_default<half, DIM> {};

template<int W, int DIM>
struct x_traits_d <ap_int<W>,DIM> {
    typedef ap_int<W> ACCUM_T;
    typedef ap_int<2*W> ACCUM2_T;
    typedef ap_int<25+W> ADD_TREE_T;
};

template<int W, int DIM>
struct x_traits_d <ap_uint<W>,DIM> {
    typedef ap_uint<W> ACCUM_T;
    typedef ap_uint<2*W> ACCUM2_T;
    typedef ap_uint<25+W> ADD_TREE_T;
};

template<int W, int I, ap_q_mode Q, ap_o_mode O, int DIM>
struct x_traits_d <ap_fixed<W,I,Q,O>,DIM> {
    typedef ap_fixed<W+BitWidth<DIM>::Value,I+BitWidth<DIM>::Value,Q,O> ACCUM_T;
    typedef ap_fixed<(2*W)+BitWidth<DIM>::Value,(2*I)+BitWidth<DIM>::Value,Q,O> ACCUM2_T;
    typedef ap_fixed<25+W+BitWidth<DIM>::Value,25+I+BitWidth<DIM>::Value,Q,O> ADD_TREE_T;
};

template<int W, int I, ap_q_mode Q, ap_o_mode O, int DIM>
struct x_traits_d <ap_ufixed<W,I,Q,O>,DIM> {
    typedef ap_ufixed<W+BitWidth<DIM>::Value,I+BitWidth<DIM>::Value,Q,O> ACCUM_T;
    typedef ap_ufixed<(2*W)+BitWidth<DIM>::Value,(2*I)+BitWidth<DIM>::Value,Q,O> ACCUM2_T;
    typedef ap_ufixed<25+W+BitWidth<DIM>::Value,25+I+BitWidth<DIM>::Value,Q,O> ADD_TREE_T;
};

template<typename T>
struct x_traits<x_complex<T>, x_complex<T> > {
    typedef x_complex<T> ADD_T;
    typedef x_complex<T> SAT_T;
    typedef x_complex<T> MULT_T;
    typedef x_complex<T> MADD_T;
    typedef x_complex<int> INT_T;
    typedef x_complex<float_struct<24,8> > FLOAT_STRUCT_T;
};



template<int W1, int I1, int W2, int I2>
struct x_traits<x_complex<ap_fixed<W1,I1> >,x_complex<ap_fixed<W2,I2> > > {
    typedef x_complex<ap_fixed<((I1) > (I2) ? (I1) : (I2))+1+((W1-I1) > (W2-I2) ? (W1-I1) : (W2-I2)),((I1) > (I2) ? (I1) : (I2))+1> > ADD_T;
    typedef x_complex<ap_fixed<W1,I1,AP_RND,AP_SAT> > SAT_T;
    typedef x_complex<ap_fixed<W1+W2+1,I1+I2+1> > MULT_T;
    typedef x_complex<ap_fixed<W1+W2+2,I1+I2+2> > MADD_T;
    typedef x_complex<ap_fixed<(2*W1)+1,(2*I1)+1> > CONJ_SQ_T;
    typedef x_complex<int> INT_T;
    typedef x_complex<float_struct<24,8> > FLOAT_STRUCT_T;
};

template<int W1, int W2>
struct x_traits<x_complex<ap_int<W1> >,x_complex<ap_int<W2> > > {
    typedef x_complex<ap_int<((W1) > (W2) ? (W1) : (W2))+1> > ADD_T;
    typedef x_complex<ap_int<W1> > SAT_T;
    typedef x_complex<ap_int<W1+W2+1> > MULT_T;
    typedef x_complex<ap_int<W1+W2+2> > MADD_T;
    typedef x_complex<ap_int<(2*W1)+1> > CONJ_SQ_T;
    typedef x_complex<int> INT_T;
    typedef x_complex<float_struct<24,8> > FLOAT_STRUCT_T;
};



template<int DIM, typename T>
struct x_traits_d <x_complex<T>,DIM> {
    typedef x_complex<T> ACCUM_T;
    typedef x_complex<T> ACCUM2_T;
    typedef x_complex<ap_int<25+DIM> > ADD_TREE_T;
};

template<int DIM, int W, int I>
struct x_traits_d <x_complex<ap_fixed<W,I> >,DIM> {
    typedef x_complex<ap_fixed<W+BitWidth<DIM>::Value,I+BitWidth<DIM>::Value> > ACCUM_T;
    typedef x_complex<ap_fixed<(2*W)+BitWidth<DIM>::Value,(2*I)+BitWidth<DIM>::Value> > ACCUM2_T;
};

}



namespace hlstmp
{

template<typename T>
struct x_traits_default {
  typedef T ADD_T;
  typedef T SUB_T;
  typedef T SAT_T;
  typedef T MULT_T;
  typedef T MADD_T;
};

template<typename T1, typename T2>
struct x_traits {
# 944 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/utils/x_hls_traits.h"
};

template<>
struct x_traits<double, double> : public x_traits_default<double> { };

template<typename T2>
struct x_traits<double, T2> : public x_traits_default<double> { };

template<typename T1>
struct x_traits<T1, double> : public x_traits_default<double> { };

template<>
struct x_traits<float, float> : public x_traits_default<float> { };

template<typename T2>
struct x_traits<float, T2> : public x_traits_default<float> { };

template<typename T1>
struct x_traits<T1, float> : public x_traits_default<float> { };

template<>
struct x_traits<half, half> : public x_traits_default<half> { };

template<typename T2>
struct x_traits<half, T2> : public x_traits_default<float> { };

template<typename T1>
struct x_traits<T1, half> : public x_traits_default<float> { };

template<>
struct x_traits<double, float> : public x_traits_default<double> { };

template<>
struct x_traits<float, double> : public x_traits_default<double> { };

template<>
struct x_traits<double, half> : public x_traits_default<double> { };

template<>
struct x_traits<half, double> : public x_traits_default<double> { };

template<>
struct x_traits<int, int> : public x_traits_default<int> { };

template<>
struct x_traits<unsigned int, unsigned int> : public x_traits_default<unsigned int> { };

template<>
struct x_traits<int64_t, int64_t> : public x_traits_default<int64_t> { };

template<int A,int B> class MAX{
  public:
    const static int value = (A > B) ? A : B;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_fixed<W2,I2,Q2,O2> > {
    typedef typename ap_fixed<W1,I1>::template RType<W2,I2,true> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
 typedef ap_fixed<W1,I1,AP_RND,AP_SAT> SAT_T;
 typedef ap_fixed<W1+W2+1,I1+I2+1> MADD_T;
 typedef ap_fixed<W1+W2+2,I1+I2+2> CMADD_T;
 typedef ap_fixed<(2*W1)+1,(2*I1)> CONJ_SQ_T;
 typedef ap_fixed<(2*W1)+2,(2*I1)+1> CONJ_SQ_2_T;
    typedef ap_fixed<2*(MAX<I1,W1-I1>::value+1),(MAX<I1,W1-I1>::value+1)> INV_T;
    typedef int INT_T;
    typedef float_struct<24,8> FLOAT_STRUCT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_ufixed<W2,I2,Q2,O2> > {
    typedef typename ap_fixed<W1,I1>::template RType<W2,I2,false> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_fixed<W2,I2,Q2,O2> > {
    typedef typename ap_ufixed<W1,I1>::template RType<W2,I2,true> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_ufixed<W2,I2,Q2,O2> > {
    typedef typename ap_ufixed<W1,I1>::template RType<W2,I2,false> RTYPE;
    typedef ap_ufixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_ufixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
 typedef ap_ufixed<W1,I1,AP_RND,AP_SAT> SAT_T;
 typedef ap_ufixed<W1+W2+1,I1+I2+1> MADD_T;
 typedef ap_ufixed<W1+W2+2,I1+I2+2> CMADD_T;
 typedef ap_ufixed<(2*W1)+1,(2*I1)> CONJ_SQ_T;
 typedef ap_ufixed<(2*W1)+2,(2*I1)+1> CONJ_SQ_2_T;
    typedef ap_ufixed<2*(MAX<I1,W1-I1>::value+1),(MAX<I1,W1-I1>::value+1)> INV_T;
    typedef int INT_T;
    typedef float_struct<24,8> FLOAT_STRUCT_T;
};

template<int W1, int W2>
struct x_traits<ap_int<W1>,ap_int<W2> > {
 typedef ap_int<MAX<W1,W2>::value + 1> ADD_T;
 typedef ap_int<MAX<W1,W2>::value + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
 typedef ap_int<(W1 > W2)? W1:W2> MADD_T;
};

template<int W1, int W2>
struct x_traits<ap_int<W1>,ap_uint<W2> > {
 typedef ap_int<MAX<W1,W2+1>::value + 1> ADD_T;
 typedef ap_int<MAX<W1,W2+1>::value + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
};

template<int W1, int W2>
struct x_traits<ap_uint<W1>,ap_int<W2> > {
 typedef ap_int<MAX<W1+1,W2>::value + 1> ADD_T;
 typedef ap_int<MAX<W1+1,W2>::value + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
};

template<int W1, int W2>
struct x_traits<ap_uint<W1>,ap_uint<W2> > {
 typedef ap_uint<MAX<W1,W2>::value + 1> ADD_T;
 typedef ap_int<MAX<W1,W2>::value + 1> SUB_T;
 typedef ap_uint<W1+W2> MULT_T;
};

template<typename T>
struct x_traits<std::complex<T>, std::complex<T> > {
    typedef std::complex<T> ADD_T;
    typedef std::complex<T> SAT_T;
    typedef std::complex<T> MULT_T;
    typedef std::complex<T> MADD_T;
    typedef std::complex<int> INT_T;
    typedef std::complex<float_struct<24,8> > FLOAT_STRUCT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_int<W2> > : public x_traits<ap_fixed<W1,I1>, ap_fixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_uint<W2> > : public x_traits<ap_fixed<W1,I1>, ap_ufixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_int<W2> > : public x_traits<ap_ufixed<W1,I1>, ap_fixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_uint<W2> > : public x_traits<ap_ufixed<W1,I1>, ap_ufixed<W2,W2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_int<W1>, ap_fixed<W2,I2,Q2,O2> > : public x_traits<ap_fixed<W1,W1>, ap_fixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_int<W1>, ap_ufixed<W2,I2,Q2,O2> > : public x_traits<ap_fixed<W1,W1>, ap_ufixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_uint<W1>, ap_fixed<W2,I2,Q2,O2> > : public x_traits<ap_ufixed<W1,W1>, ap_fixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_uint<W1>, ap_ufixed<W2,I2,Q2,O2> > : public x_traits<ap_ufixed<W1,W1>, ap_ufixed<W2,I2> > {};




    template<typename T> struct fixed_type { };
    template<> struct fixed_type<char> { typedef ap_fixed<8,8> T; };
    template<> struct fixed_type<unsigned char> { typedef ap_ufixed<8,8> T; };
    template<> struct fixed_type<short> { typedef ap_fixed<16,16> T; };
    template<> struct fixed_type<unsigned short> { typedef ap_ufixed<16,16> T; };
    template<> struct fixed_type<int> { typedef ap_fixed<32,32> T; };
    template<> struct fixed_type<unsigned int> { typedef ap_ufixed<32,32> T; };
    template<> struct fixed_type<float> { typedef ap_ufixed<64,32> T; };
    template<int W> struct fixed_type<ap_int<W> > { typedef ap_fixed<W,W> T; };
    template<int W> struct fixed_type<ap_uint<W> > { typedef ap_ufixed<W,W> T; };
    template<int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O> struct fixed_type<ap_fixed<W,I, _AP_Q, _AP_O> > { typedef ap_fixed<W,I> T; };
    template<int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O> struct fixed_type<ap_ufixed<W,I, _AP_Q, _AP_O> > { typedef ap_ufixed<W,I> T; };

template<typename T1, int DIM>
struct x_traits_d_default {
    typedef T1 ACCUM_T;
    typedef T1 ACCUM2_T;
    typedef T1 ADD_TREE_T;
};

template<typename T1, int DIM>
struct x_traits_d {};

template<int DIM>
struct x_traits_d <int,DIM>:x_traits_d_default<int, DIM> {};

template<int DIM>
struct x_traits_d <float,DIM>:x_traits_d_default<float, DIM> {};

template<int DIM>
struct x_traits_d <double,DIM>:x_traits_d_default<double, DIM> {};

template<int DIM>
struct x_traits_d <half,DIM>:x_traits_d_default<half, DIM> {};

template<int W, int DIM>
struct x_traits_d <ap_int<W>,DIM> {
    typedef ap_int<W> ACCUM_T;
    typedef ap_int<2*W> ACCUM2_T;
    typedef ap_int<25+W> ADD_TREE_T;
};

template<int W, int DIM>
struct x_traits_d <ap_uint<W>,DIM> {
    typedef ap_uint<W> ACCUM_T;
    typedef ap_uint<2*W> ACCUM2_T;
    typedef ap_uint<25+W> ADD_TREE_T;
};

template<int DIM, typename T>
struct x_traits_d <std::complex<T>, DIM> {
    typedef std::complex<T> ACCUM_T;
    typedef std::complex<T> ACCUM2_T;
    typedef std::complex<ap_int<25+DIM> > ADD_TREE_T;
};

template<int W, int I, ap_q_mode Q, ap_o_mode O, int DIM>
struct x_traits_d <ap_fixed<W,I,Q,O>,DIM> {
    typedef ap_fixed<W+BitWidth<DIM>::Value,I+BitWidth<DIM>::Value,Q,O> ACCUM_T;
    typedef ap_fixed<(2*W)+BitWidth<DIM>::Value,(2*I)+BitWidth<DIM>::Value,Q,O> ACCUM2_T;
    typedef ap_fixed<25+W+BitWidth<DIM>::Value,25+I+BitWidth<DIM>::Value,Q,O> ADD_TREE_T;
};

template<int W, int I, ap_q_mode Q, ap_o_mode O, int DIM>
struct x_traits_d <ap_ufixed<W,I,Q,O>,DIM> {
    typedef ap_ufixed<W+BitWidth<DIM>::Value,I+BitWidth<DIM>::Value,Q,O> ACCUM_T;
    typedef ap_ufixed<(2*W)+BitWidth<DIM>::Value,(2*I)+BitWidth<DIM>::Value,Q,O> ACCUM2_T;
    typedef ap_ufixed<25+W+BitWidth<DIM>::Value,25+I+BitWidth<DIM>::Value,Q,O> ADD_TREE_T;
};

}
# 38 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_lgamma_apfixed.h" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/utils/x_hls_utils.h" 1
# 39 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_lgamma_apfixed.h" 2

namespace lgamma_fixed {

template <int W, int I> ap_fixed<W, I> lgamma_generic(ap_fixed<W, I> x_fixed) {
#pragma HLS pipeline

 double x = x_fixed.to_double();
  double r = hls::lgamma(x);
  fp_struct<double> out(r);
  ap_ufixed<W+1, I+1> ret = 1;
  int F = W - I;
  if (F > 52) F = 52;
  if (W > I) ret(F - 1, 0) = out.sig(52 - 1, 52 - F);
  ret = (ret << (out.exp - fp_struct<double>::EXP_BIAS));
  return ap_fixed<W, I>(ret);
}

template <int W, int I> ap_ufixed<W, I> lgamma_generic(ap_ufixed<W, I> x) {
  ap_fixed<W + 1, I + 1> xf = x;
  return lgamma_generic(xf);
}
template <int I_> ap_int<I_> lgamma_generic(ap_int<I_> x) {
  ap_fixed<I_, I_> xf = x;
  return lgamma_generic(xf);
}
template <int I_> ap_uint<I_> lgamma_generic(ap_uint<I_> x) {
  ap_fixed<I_ + 1, I_ + 1> xf = x;
  return lgamma_generic(xf);
}


template <int W, int I> ap_fixed<W, I> lgamma_r_generic(ap_fixed<W, I> x, int *signgamp) {
  *signgamp = 1;
  return lgamma_generic(x);
}

template <int W, int I> ap_ufixed<W, I> lgamma_r_generic(ap_ufixed<W, I> x, int *signgamp) {
  ap_fixed<W + 1, I + 1> xf = x;
  return lgamma_r_generic(xf, signgamp);
}

template <int I_> ap_int<I_> lgamma_r_generic(ap_int<I_> x, int *signgamp) {
  ap_fixed<I_, I_> xf = x;
  return lgamma_r_generic(xf, signgamp);
}

template <int I_> ap_uint<I_> lgamma_r_generic(ap_uint<I_> x, int *signgamp) {
  ap_fixed<I_ + 1, I_ + 1> xf = x;
  return lgamma_r_generic(xf, signgamp);
}

}
# 1082 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_math.h" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_tgamma_apfixed.h" 1
# 35 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_tgamma_apfixed.h"
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/ap_int.h" 1
# 36 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_tgamma_apfixed.h" 2



# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/utils/x_hls_utils.h" 1
# 40 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_tgamma_apfixed.h" 2

namespace tgamma_fixed {

template <int W, int I> ap_fixed<W, I> tgamma_generic(ap_fixed<W, I> x_fixed) {
#pragma HLS pipeline

 double x = x_fixed.to_double();
  double r = hls::tgamma(x);
  fp_struct<double> out(r);
  ap_ufixed<W+1, I+1> ret = 1;
  int F = W - I;
  if (F > 52) F = 52;
  if (W > I) ret(F - 1, 0) = out.sig(52 - 1, 52 - F);
  ret = (ret << (out.exp - fp_struct<double>::EXP_BIAS));
  return ap_fixed<W, I>(ret);
}

template <int W, int I> ap_ufixed<W, I> tgamma_generic(ap_ufixed<W, I> x) {
  ap_fixed<W + 1, I + 1> xf = x;
  return tgamma_generic(xf);
}
template <int I_> ap_int<I_> tgamma_generic(ap_int<I_> x) {
  ap_fixed<I_, I_> xf = x;
  return tgamma_generic(xf);
}
template <int I_> ap_uint<I_> tgamma_generic(ap_uint<I_> x) {
  ap_fixed<I_ + 1, I_ + 1> xf = x;
  return tgamma_generic(xf);
}

}
# 1083 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_math.h" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_fract_apfixed.h" 1





# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/utils/x_hls_utils.h" 1
# 7 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_fract_apfixed.h" 2


namespace hls_fract {

template <int W_, int I_>
ap_fixed<W_,I_> generic_fract(ap_fixed<W_,I_> x){
 if (W_==I_)return 0;
 ap_fixed<W_-I_+1,1> x1=x;
 ap_fixed<W_-I_+1,1> x2=x1+ap_int<2>(1);
 return x[W_-1]?x2:x1;
}

template <int W_, int I_>
ap_ufixed<W_,I_> generic_fract(ap_ufixed<W_,I_> x){
 ap_fixed<W_+1,I_+1> x1=x;
 return generic_fract(x1);
}

template <int I_>
ap_int<I_> generic_fract(ap_int<I_> x){
 ap_fixed<I_,I_> x1 = x;
 return generic_fract(x1);
}

template <int I_>
ap_uint<I_> generic_fract(ap_uint<I_> x){
 ap_ufixed<I_,I_> x1 = x;
 return generic_fract(x1);
}
}
# 1084 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_math.h" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_mad_apfixed.h" 1




namespace hls_mad {

    template <int W_, int I_>
    ap_fixed<W_,I_> generic_mad(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y, ap_fixed<W_,I_> z){
        const unsigned int F_ = W_ - I_;
        ap_fixed<2*W_, 2*I_> mul = x * y;

        ap_fixed<2, -F_> delta = 0;
        delta[0] = 1;
        delta[1] = mul[2*W_-1];

        mul += delta;

        ap_fixed<W_+1, I_+1> mul_s = mul;
        ap_fixed<W_+1, I_+1> sum = mul_s + z;
        ap_fixed<W_,I_> r = 0;

        if(sum[W_-1]!=sum[W_]) {
           VITIS_LOOP_23_1: for(int i = 0; i < W_-1; ++i) {
#pragma HLS unroll
 r[i] = !sum[W_];
           }
           r[W_-1] = sum[W_];
        } else {
           r = sum;
        }
        return r;
    }

    template <int W_, int I_>
    ap_ufixed<W_,I_> generic_mad(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y, ap_ufixed<W_,I_> z){
        ap_fixed<W_+1, I_+1> xi = x;
        ap_fixed<W_+1, I_+1> yi = y;
        ap_fixed<W_+1, I_+1> zi = z;
        return generic_mad(xi, yi, zi);
    }

    template <int I_>
    ap_int<I_> generic_mad(ap_int<I_> x, ap_int<I_> y, ap_int<I_> z){
        ap_fixed<I_, I_> xi = x;
        ap_fixed<I_, I_> yi = y;
        ap_fixed<I_, I_> zi = z;
        return generic_mad(xi, yi, zi);
    }

    template <int I_>
    ap_uint<I_> generic_mad(ap_uint<I_> x, ap_uint<I_> y, ap_uint<I_> z){
        ap_fixed<I_+1,I_+1> xi = x;
        ap_fixed<I_+1,I_+1> yi = y;
        ap_fixed<I_+1,I_+1> zi = z;
        return generic_mad(xi,yi,zi);
    }
}
# 1085 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_math.h" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_cbrt_apfixed.h" 1
# 40 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_cbrt_apfixed.h"
namespace cbrt_internal{
template <int W, int I>
ap_fixed<W, I> cbrt_fixed(ap_fixed<W,I> x) {






   const int F = W - I;
   if(I > 33) return 0;
   else if(F > 32) return 0;

   ap_fixed<W+1, I+1> xi = x;
   ap_ufixed<W, I> x_p = fabs_fixed(xi);





   ap_ufixed<F +(I+2)/3, (I+2)/3> r = 0;;
      const static int prcs = (F+1)*3;
      const static int msbr = (I>0)? (I+2)/3 : 1;
      ap_ufixed<2*msbr+prcs+2,2*msbr+2> resq = 0;
      ap_ufixed<msbr+prcs+1, msbr+1> res = 0;
      ap_ufixed<3*msbr+prcs+4, 3*msbr+4> x_rem = x_p;
      VITIS_LOOP_66_1: for(int pos = msbr - 1 ; pos >= -F-1; pos--) {
          ap_ufixed<3*msbr+prcs+2, 3*msbr+2> mul1a = 0;
          ap_ufixed<3*msbr+prcs+1, 3*msbr+1> mul1b = 0;




          mul1a(pos+2*msbr+prcs+2, prcs+3*pos+3) = resq(prcs+2*msbr+1, prcs+2*pos+2);

          mul1b(pos+2*msbr+prcs+1, prcs+3*pos+2) = resq(prcs+2*msbr+1, prcs+2*pos+2);



          ap_ufixed<3*msbr+prcs, 3*msbr> mul2a = 0;
          ap_ufixed<3*msbr+prcs-1, 3*msbr-1> mul2b = 0;

          mul2a(pos*2+msbr+prcs+1, pos*3+2+prcs) = res(msbr+prcs, pos+1+prcs);

          mul2b(pos*2+msbr+prcs, pos*3+1+prcs) = res(msbr+prcs, pos+1+prcs);

          ap_ufixed<3*msbr+prcs+3, 3*msbr+3> mulL = 0;
          ap_ufixed<3*msbr+prcs+3, 3*msbr+3> mulH = 0;


          mulL(pos*2+msbr+prcs+3, pos*3+1+prcs) = mul2b(pos*2+msbr+prcs, pos*3+1+prcs) + mul2a(pos*2+msbr+prcs+1, pos*3+1+prcs) + mul1a(pos*2+msbr+prcs+1, pos*3+1+prcs) + mul1b(pos*2+msbr+prcs+1,pos*3+1+prcs);

          mulH(pos+2*msbr+prcs+3, pos*2+msbr+prcs+2) = mulL(pos*2+msbr+prcs+3, pos*2+msbr+prcs+2) + mul1a(pos+2*msbr+prcs+2,pos*2+msbr+prcs+2) + mul1b(pos+2*msbr+prcs+1,pos*2+msbr+prcs+2);
          mulL[3*pos+prcs] = 1;







          bool cond1 = (x_rem(pos+2*msbr+prcs+4,pos*2+msbr+prcs+2) > mulH(pos+2*msbr+prcs+3,pos*2+msbr+prcs+2));
          bool cond2 = (x_rem(pos+2*msbr+prcs+4,pos*2+msbr+prcs+2) == mulH(pos+2*msbr+prcs+3,pos*2+msbr+prcs+2));
          bool cond3 = (x_rem(pos*2+msbr+prcs+1,pos*3+prcs) >= mulL(pos*2+msbr+prcs+1,pos*3+prcs));
          if(cond1 | (cond2 & cond3)) {
             ap_ufixed<3*msbr+prcs+3,3*msbr+3> x_rem_L = 0;
             x_rem_L(pos*2+msbr+prcs+1, pos*3+prcs) = x_rem(pos*2+msbr+prcs+1, pos*3+prcs);

             x_rem_L[pos*2+msbr+prcs+2] = cond3? 0 : 1;
             x_rem(pos+2*msbr+prcs+4,pos*2+msbr+prcs+2) = x_rem(pos+2*msbr+prcs+4, pos*2+msbr+prcs+2) - mulH(pos+2*msbr+prcs+3,pos*2+msbr+prcs+2) - x_rem_L(pos*2+msbr+prcs+2,pos*2+msbr+prcs+2);
             x_rem(pos*2+msbr+prcs+1,pos*3+prcs) = x_rem_L(pos*2+msbr+prcs+2, pos*3+prcs) - mulL(pos*2+msbr+prcs+1,pos*3+prcs);





             ap_ufixed<2*msbr+prcs+1,2*msbr+1> mul1 = 0;
             mul1(pos+msbr+prcs+1, 2*pos+2+prcs) = res(msbr+prcs, pos+1+prcs);
             ap_ufixed<2*msbr+prcs+2,2*msbr+2> resq_L = 0;
             resq_L(pos+msbr+prcs+2,2*pos+2+prcs) = resq(pos+msbr+prcs+1,2*pos+2+prcs) + mul1(pos+msbr+prcs+1,2*pos+2+prcs);
             resq(pos+msbr+prcs+1,2*pos+2+prcs) = resq_L(pos+msbr+prcs+1,2*pos+2+prcs);
             resq(2*msbr+prcs+1,pos+msbr+2+prcs) = resq(2*msbr+prcs+1,pos+msbr+2+prcs) + resq_L(pos+msbr+2+prcs,pos+msbr+2+prcs);
             resq[2*pos+prcs] = 1;
             res[pos+prcs] = 1;
         }
# 133 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_cbrt_apfixed.h"
      }





      ap_ufixed<1,-F-1> delta;
      delta[0] = 1;
      ap_ufixed<msbr+F+1,msbr> res_s = res;
      res_s += delta;
      r = res_s;
      if(x[W-1]) return -r;
      else return r;
}

template<int W, int I>
ap_ufixed<W, I> cbrt_fixed(ap_ufixed<W, I> x) {
   ap_fixed<W+1,I+1> xi = x;
   return cbrt_fixed(xi);
}
template<int I>
ap_int<I> cbrt_fixed(ap_int<I> x) {
   ap_fixed<I,I> xi = x;
   return cbrt_fixed(xi);
}
template<int I>
ap_uint<I> cbrt_fixed(ap_uint<I> x) {
   ap_fixed<I+1,I+1> xi = x;
   return cbrt_fixed(xi);
}
}
# 1086 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_math.h" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_hypot_apfixed.h" 1
# 39 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_hypot_apfixed.h"
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/ap_int.h" 1
# 40 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_hypot_apfixed.h" 2

namespace hypot_internal {
template<int W, int I>
ap_fixed<W, I> hypot_fixed(ap_fixed<W, I> x, ap_fixed<W, I> y) {
    const static int F = W - I;
    if(I > 33) return 0;
    else if(F > 32) return 0;
# 55 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_hypot_apfixed.h"
    if(x==0) return fabs_fixed(y);
    if(y==0) return fabs_fixed(x);

    ap_ufixed<2*W, I*2> x_sq = x * x;
    ap_ufixed<2*W, I*2> y_sq = y * y;
    ap_ufixed<2*W, I*2> xy_sq = x_sq + y_sq;
# 69 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_hypot_apfixed.h"
    const static int prcs = (F+1)*2;
    const static int msbr = I > 0? I : 1;
    ap_ufixed<msbr, msbr> res_I = 0;
    ap_ufixed<2*msbr+1,2*msbr+1> x_l_I = 0;
    if(I>0) {
        x_l_I = xy_sq(2*W-1, 2*W-2*I);
        VITIS_LOOP_75_1: for(int pos = msbr - 1; pos >= 0; pos--) {
            ap_ufixed<2*msbr,2*msbr> mul_I = 0;



            mul_I(msbr+pos, 2*pos+1) = res_I(msbr-1, pos);
            mul_I[2*pos] = 1;
            if(x_l_I(msbr+pos+1, 2*pos) >= mul_I(msbr+pos, 2*pos)){



                ap_ufixed<2*msbr+1, 2*msbr+1> x_l_I_ = x_l_I;
                x_l_I(msbr+pos+1, 2*pos) = x_l_I(msbr+pos+1,2*pos) - mul_I(msbr+pos, 2*pos);



                res_I[pos] = 1;
           }
       }
    }
    ap_ufixed<msbr+1, msbr+1> x_l_I_s = x_l_I;
# 104 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_hypot_apfixed.h"
    ap_ufixed<prcs/2,0> res_F = 0;
    ap_ufixed<prcs/2,0> x_l_FH = xy_sq;
    ap_ufixed<prcs/2, -prcs/2> x_l_FL = xy_sq;
    VITIS_LOOP_107_2: for(int pos = -1; pos >= -F-1; pos--) {
        ap_ufixed<msbr+prcs, msbr> mul = 0;



        mul(msbr+pos+prcs, pos+1+prcs) = res_I(msbr-1, 0);
        mul(pos+prcs, 2*pos+1+prcs) = res_F(prcs/2-1,pos+prcs/2);
        mul[2*pos+prcs] = 1;

        ap_ufixed<msbr, msbr> mul_I = 0;
        mul_I = mul;
        ap_ufixed<prcs/2, 0> mul_FH = mul;
        ap_ufixed<prcs/2, -prcs/2> mul_FL = mul;
# 139 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_hypot_apfixed.h"
        if((x_l_I_s > mul_I) || ((x_l_I_s == mul_I) && (x_l_FH > mul_FH)) || ((x_l_I_s == mul_I) && (x_l_FH == mul_FH) && (x_l_FL >= mul_FL))) {







           ap_ufixed<prcs/2+1, -prcs/2+1> x_l_FL_1 = x_l_FL;

           if(x_l_FL < mul_FL) x_l_FL_1[prcs/2] = 1;
           x_l_FL_1 -= mul_FL;



           ap_ufixed<prcs/2+1,1> x_l_FH_1 = x_l_FH;

           if((x_l_FH < mul_FH) || ((x_l_FH == mul_FH) && (x_l_FL < mul_FL))) x_l_FH_1[prcs/2] = 1;
           ap_ufixed<1, -prcs/2+1> delta = 0;
           if(x_l_FL < mul_FL) delta[0] = 1;

           x_l_FH_1 -= delta;
           x_l_FH_1 -= mul_FH;

           if((x_l_FH < mul_FH) || ((x_l_FH == mul_FH) && (x_l_FL < mul_FL))) x_l_I_s--;
           x_l_I_s -= mul_I;
           x_l_FH = x_l_FH_1;
           x_l_FL = x_l_FL_1;







           res_F[pos+prcs/2] = 1;
       }
    }
    ap_ufixed<prcs/2+1, 1> res_F_1 = res_F;

    ap_ufixed<1, -prcs/2+1> delta = 0;
    delta[0] = 1;
    res_F_1 += delta;
    if(res_F_1[prcs/2]) res_I++;
    ap_ufixed<msbr+prcs/2, msbr> res = 0;
    res(msbr+prcs/2-1, prcs/2) = res_I(msbr-1,0);
    res(prcs/2-1, 0) = res_F(prcs/2-1, 0);






    ap_fixed<W,I> r = 0;
    if(res[msbr+prcs/2-1]) {

       VITIS_LOOP_195_3: for(int i = 0; i < W - 1; ++i) {
#pragma HLS unroll
 r[i] = 1;
       }
    } else {
       r = res;
    }





    return r;
}
template<int W, int I>
ap_ufixed<W, I> hypot_fixed(ap_ufixed<W, I> x, ap_fixed<W, I> y) {
   ap_fixed<W+1, I+1> xi = x;
   ap_fixed<W+1, I+1> yi = y;
   return hypot_fixed(xi, yi);
}
template<int I>
ap_int<I> hypot_fixed(ap_int<I> x, ap_int<I> y) {
   ap_fixed<I, I> xi = x;
   ap_fixed<I, I> yi = y;
   return hypot_fixed(xi, yi);
}
template<int I>
ap_uint<I> hypot_fixed(ap_uint<I> x, ap_uint<I> y) {
   ap_fixed<I+1, I+1> xi = x;
   ap_fixed<I+1, I+1> yi = y;
   return hypot_fixed(xi, yi);
}
}
# 1087 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_math.h" 2
# 1 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_ldexp_apfixed.h" 1
# 36 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot/hls_ldexp_apfixed.h"
namespace hls_ldexp {

template<int W, int I>
ap_fixed<W,I> ldexp(ap_fixed<W,I> x, int exp) {
    ap_fixed<W,I> result;
    if(exp >= W || exp <= -W) {
        result = 0;
    } else {
        result = x << exp;
    }
    return result;
}

template<int W, int I>
ap_ufixed<W,I> ldexp(ap_ufixed<W,I> x, int exp) {
    ap_fixed<W+1,I+1> xf = x;
    return ldexp(xf, exp);
}

template<int I>
ap_int<I> ldexp(ap_int<I> x, int exp) {
    ap_fixed<I,I> xf = x;
    return ldexp(xf, exp);
}

template<int I>
ap_uint<I> ldexp(ap_uint<I> x, int exp) {
    ap_fixed<I+1,I+1> xf = x;
    return ldexp(xf, exp);
}

template<int W, int I>
ap_fixed<W,I> scalbn(ap_fixed<W,I> x, int n) {
    ap_fixed<W,I> result;
    if(n >= W || n <= -W) {
        result = 0;
    } else {
        result = x << n;
    }
    return result;
}

template<int W, int I>
ap_ufixed<W,I> scalbn(ap_ufixed<W,I> x, int n) {
    ap_fixed<W+1,I+1> xf = x;
    return scalbn(xf, n);
}

template<int I>
ap_int<I> scalbn(ap_int<I> x, int n) {
    ap_fixed<I,I> xf = x;
    return scalbn(xf, n);
}

template<int I>
ap_uint<I> scalbn(ap_uint<I> x, int n) {
    ap_fixed<I+1,I+1> xf = x;
    return scalbn(xf, n);
}

template<int W, int I>
ap_fixed<W,I> scalbln(ap_fixed<W,I> x, long int n) {
    ap_fixed<W,I> result;
    if(n >= W || n <= -W) {
        result = 0;
    } else {
        result = x << n;
    }
    return result;
}

template<int W, int I>
ap_ufixed<W,I> scalbln(ap_ufixed<W,I> x, long int n) {
    ap_fixed<W+1,I+1> xf = x;
    return scalbln(xf, n);
}

template<int I>
ap_int<I> scalbln(ap_int<I> x, long int n) {
    ap_fixed<I,I> xf = x;
    return scalbln(xf, n);
}

template<int I>
ap_uint<I> scalbln(ap_uint<I> x, long int n) {
    ap_fixed<I+1,I+1> xf = x;
    return scalbln(xf, n);
}

}
# 1088 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_math.h" 2

namespace hls {
# 1112 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_math.h"
  template<int W, int I>
  ap_fixed<W, 2> sinpi(ap_fixed<W,I> x){
    return hotbm_apfixed::sinf_or_cosf<W,I>(x, 0, 1);
  }




  template<int W, int I>
  ap_ufixed<W, 2> sinpi(ap_ufixed<W,I> x){
      ap_fixed<W+1, I+1> xin = x;
      ap_fixed<W+1, 3> xout = hls::sinpi<W+1, I+1>(x);
   ap_ufixed<W, 2> out = 0;
   if(xout[W]==0){
    out = xout;
   }
   return out;
  }

  template<int W, int I>
  ap_fixed<W, 2> cospi(ap_fixed<W,I> x){
    return hotbm_apfixed::sinf_or_cosf<W,I>(x, 1, 1);
  }
  template<int W, int I>
  ap_ufixed<W, 2> cospi(ap_ufixed<W,I> x){
   ap_fixed<W+1, I+1> xin = x;
   ap_fixed<W+1, 3> xout = hls::cospi<W+1, I+1>(x);
   ap_ufixed<W, 2> out = 0;
   if(xout[W]==0){
    out = xout;
   }
   return out;
  }





  template<int I>
  ap_int<I> sinpi(ap_int<I> in){
        (void)(in);
 return ap_int<I>(0);
  }

  template<int I>
  ap_int<I> cospi(ap_int<I> in){
        (void)(in);
 return ap_int<I>(0);
  }

  template<int I>
  ap_uint<I> sinpi(ap_uint<I> in){
        (void)(in);
 return ap_uint<I>(0);
  }

  template<int I>
  ap_uint<I> cospi(ap_uint<I> in){
        (void)(in);
 return ap_uint<I>(0);
  }
  int8_t sinpi(int8_t);
  uint8_t sinpi(uint8_t);
  int16_t sinpi(int16_t);
  uint16_t sinpi(uint16_t);
  int32_t sinpi(int32_t);
  uint32_t sinpi(uint32_t);

  int8_t cospi(int8_t);
  uint8_t cospi(uint8_t);
  int16_t cospi(int16_t);
  uint16_t cospi(uint16_t);
  int32_t cospi(int32_t);
  uint32_t cospi(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> exp(ap_fixed<W,I> x){
    return exp_reduce::exp(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> exp(ap_ufixed<W,I> x){
    return exp_reduce::exp(x);
  }
  template<int I>
  ap_int<I> exp(ap_int<I> x){
    return exp_reduce::exp(x);
  }
  template<int I>
  ap_uint<I> exp(ap_uint<I> x){
    return exp_reduce::exp(x);
  }


  template<int W, int I>
  ap_fixed<W,I> log(ap_fixed<W,I> x){
    return log_apfixed_reduce::log(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> log(ap_ufixed<W,I> x){
    return log_apfixed_reduce::log(x);
  }
  template<int I>
  ap_int<I> log(ap_int<I> x){
    return log_apfixed_reduce::log(x);
  }
  template<int I>
  ap_uint<I> log(ap_uint<I> x){
    return log_apfixed_reduce::log(x);
  }


  template<int W, int I>
  ap_fixed<W,I> log10(ap_fixed<W,I> x){
    return log_apfixed_reduce::log10(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> log10(ap_ufixed<W,I> x){
    return log_apfixed_reduce::log10(x);
  }
  template<int I>
  ap_int<I> log10(ap_int<I> x){
    return log_apfixed_reduce::log10(x);
  }
  template<int I>
  ap_uint<I> log10(ap_uint<I> x){
 return log_apfixed_reduce::log10(x);
  }


  template<int W, int I>
  ap_fixed<W,I> log2(ap_fixed<W,I> x){
    return log_apfixed_reduce::log2(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> log2(ap_ufixed<W,I> x){
    return log_apfixed_reduce::log2(x);
  }
  template<int I>
  ap_int<I> log2(ap_int<I> x){
    return log_apfixed_reduce::log2(x);
  }
  template<int I>
  ap_uint<I> log2(ap_uint<I> x){
 return log_apfixed_reduce::log2(x);
  }


  template<int W, int I>
  ap_fixed<W,I> logb(ap_fixed<W,I> x){
    return log_apfixed_reduce::logb(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> logb(ap_ufixed<W,I> x){
    return log_apfixed_reduce::logb(x);
  }
  template<int I>
  ap_int<I> logb(ap_int<I> x){
    return log_apfixed_reduce::logb(x);
  }
  template<int I>
  ap_uint<I> logb(ap_uint<I> x){
 return log_apfixed_reduce::logb(x);
  }


  template<int W, int I>
  ap_fixed<W,I> sqrt(ap_fixed<W,I> x){
    return sqrt_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> sqrt(ap_ufixed<W,I> x){
    return sqrt_fixed(x);
  }
  template<int I>
  ap_int<I> sqrt(ap_int<I> x){
    return sqrt_fixed(x);
  }
  template<int I>
  ap_uint<I> sqrt(ap_uint<I> x){
    return sqrt_fixed(x);
  }


  template<int W, int I>
  ap_fixed<W,I> rsqrt(ap_fixed<W,I> x){
    return rsqrt_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> rsqrt(ap_ufixed<W,I> x){
    return rsqrt_fixed(x);
  }
  template<int I>
  ap_int<I> rsqrt(ap_int<I> x){
    return rsqrt_fixed(x);
  }
  template<int I>
  ap_uint<I> rsqrt(ap_uint<I> x){
    return rsqrt_fixed(x);
  }


  template<int W, int I>
  ap_fixed<W,I> recip(ap_fixed<W,I> x){
    return recip_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> recip(ap_ufixed<W,I> x){
    return recip_fixed(x);
  }
  template<int I>
  ap_int<I> recip(ap_int<I> x){
    return recip_fixed(x);
  }
  template<int I>
  ap_uint<I> recip(ap_uint<I> x){
    return recip_fixed(x);
  }


  template<int W, int I>
  ap_fixed<W,I> ceil(ap_fixed<W,I> x){
    return ceil_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> ceil(ap_ufixed<W,I> x){
    return ceil_fixed(x);
  }
  template<int I>
  ap_int<I> ceil(ap_int<I> x){
    return ceil_fixed(x);
  }
  template<int I>
  ap_uint<I> ceil(ap_uint<I> x){
    return ceil_fixed(x);
  }


  template<int W, int I>
  ap_fixed<W,I> floor(ap_fixed<W,I> x){
    return floor_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> floor(ap_ufixed<W,I> x){
    return floor_fixed(x);
  }
  template<int I>
  ap_int<I> floor(ap_int<I> x){
    return floor_fixed(x);
  }
  template<int I>
  ap_uint<I> floor(ap_uint<I> x){
    return floor_fixed(x);
  }

  template<int W, int I>
  ap_fixed<W,I> trunc(ap_fixed<W,I> x){
    return trunc_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> trunc(ap_ufixed<W,I> x){
    return trunc_fixed(x);
  }
  template<int I>
  ap_int<I> trunc(ap_int<I> x){
    return trunc_fixed(x);
  }
  template<int I>
  ap_uint<I> trunc(ap_uint<I> x){
    return trunc_fixed(x);
  }


  template<int W, int I>
  ap_fixed<W,I> copysign(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return copysign_fixed(x,y);
  }
  template<int W, int I>
  ap_ufixed<W,I> copysign(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return copysign_fixed(x,y);
  }
  template<int I>
  ap_int<I> copysign(ap_int<I> x, ap_int<I> y){
    return copysign_fixed(x,y);
  }
  template<int I>
  ap_uint<I> copysign(ap_uint<I> x, ap_uint<I> y){
    return copysign_fixed(x,y);
  }


  template<int W, int I>
  ap_fixed<W,I> fabs(ap_fixed<W,I> x){
    return fabs_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> fabs(ap_ufixed<W,I> x){
    return fabs_fixed(x);
  }
  template<int I>
  ap_int<I> fabs(ap_int<I> x){
    return fabs_fixed(x);
  }
  template<int I>
  ap_uint<I> fabs(ap_uint<I> x){
    return fabs_fixed(x);
  }

  template<int W, int I>
  ap_fixed<W,I> abs(ap_fixed<W,I> x){
    return fabs_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> abs(ap_ufixed<W,I> x){
    return fabs_fixed(x);
  }
  template<int I>
  ap_int<I> abs(ap_int<I> x){
    return fabs_fixed(x);
  }
  template<int I>
  ap_uint<I> abs(ap_uint<I> x){
    return fabs_fixed(x);
  }


  template<int W, int I>
  ap_fixed<W,I> fdim(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return fdim_fixed(x,y);
  }
  template<int W, int I>
  ap_ufixed<W,I> fdim(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return fdim_fixed(x,y);
  }
  template<int I>
  ap_int<I> fdim(ap_int<I> x, ap_int<I> y){
    return fdim_fixed(x,y);
  }
  template<int I>
  ap_uint<I> fdim(ap_uint<I> x, ap_uint<I> y){
    return fdim_fixed(x,y);
  }

  template<int W, int I>
  ap_fixed<W,I> fmax(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return fmax_fixed(x,y);
  }
  template<int W, int I>
  ap_ufixed<W,I> fmax(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return fmax_fixed(x,y);
  }
  template<int I>
  ap_int<I> fmax(ap_int<I> x, ap_int<I> y){
    return fmax_fixed(x,y);
  }
  template<int I>
  ap_uint<I> fmax(ap_uint<I> x, ap_uint<I> y){
    return fmax_fixed(x,y);
  }

  template<int W, int I>
  ap_fixed<W,I> fmin(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return fmin_fixed(x,y);
  }
  template<int W, int I>
  ap_ufixed<W,I> fmin(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return fmin_fixed(x,y);
  }
  template<int I>
  ap_int<I> fmin(ap_int<I> x, ap_int<I> y){
    return fmin_fixed(x,y);
  }
  template<int I>
  ap_uint<I> fmin(ap_uint<I> x, ap_uint<I> y){
    return fmin_fixed(x,y);
  }

  template<int W, int I>
  ap_fixed<W,I> maxmag(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return maxmag_fixed(x,y);
  }
  template<int W, int I>
  ap_ufixed<W,I> maxmag(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return maxmag_fixed(x,y);
  }
  template<int I>
  ap_int<I> maxmag(ap_int<I> x, ap_int<I> y){
    return maxmag_fixed(x,y);
  }
  template<int I>
  ap_uint<I> maxmag(ap_uint<I> x, ap_uint<I> y){
    return maxmag_fixed(x,y);
  }

  template<int W, int I>
  ap_fixed<W,I> minmag(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return minmag_fixed(x,y);
  }
  template<int W, int I>
  ap_ufixed<W,I> minmag(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return minmag_fixed(x,y);
  }
  template<int I>
  ap_int<I> minmag(ap_int<I> x, ap_int<I> y){
    return minmag_fixed(x,y);
  }
  template<int I>
  ap_uint<I> minmag(ap_uint<I> x, ap_uint<I> y){
    return minmag_fixed(x,y);
  }



  template<int W, int I>
  ap_fixed<W,I> sinh(ap_fixed<W,I> x){
 return cordic_apfixed::generic_sinh(x);
  }


  template<int W, int I>
  ap_ufixed<W,I> sinh(ap_ufixed<W,I> x){
 return cordic_apfixed::generic_sinh(x);
  }


  template<int I>
  ap_int<I> sinh(ap_int<I> x){
 return cordic_apfixed::generic_sinh(x);
  }


  template<int I>
  ap_uint<I> sinh(ap_uint<I> x){
 return cordic_apfixed::generic_sinh(x);
  }


  template<int W, int I>
  ap_fixed<W,I> cosh(ap_fixed<W,I> x){
 return cordic_apfixed::generic_cosh(x);
  }


  template<int W, int I>
  ap_ufixed<W,I> cosh(ap_ufixed<W,I> x){
 return cordic_apfixed::generic_cosh(x);
  }


  template<int I>
  ap_int<I> cosh(ap_int<I> x){
 return cordic_apfixed::generic_cosh(x);
  }


  template<int I>
  ap_uint<I> cosh(ap_uint<I> x){
 return cordic_apfixed::generic_cosh(x);
  }


  template<int W, int I>
  ap_fixed<W,I> tanh(ap_fixed<W,I> x){
    return cordic_apfixed::generic_tanh(x);
  }


  template<int W, int I>
  ap_ufixed<W,I> tanh(ap_ufixed<W,I> x){
    return cordic_apfixed::generic_tanh(x);
  }


  template<int I>
  ap_int<I> tanh(ap_int<I> x){
    return cordic_apfixed::generic_tanh(x);
  }


  template<int I>
  ap_uint<I> tanh(ap_uint<I> x){
    return cordic_apfixed::generic_tanh(x);
  }


  template<int W, int I>
  ap_fixed<W,I> atanh(ap_fixed<W,I> x){
    ap_fixed<W,I> one_plus_x = 1 + x;
    ap_fixed<W,I> one_minus_x = 1 - x;
    ap_fixed<W,I> input = one_plus_x / one_minus_x ;
    ap_fixed<W,I> result = log_apfixed_reduce::log(input);
    result >>= 1;
    return result;
  }


  template<int W, int I>
  ap_ufixed<W,I> atanh(ap_ufixed<W,I> x){
  ap_fixed<W+1,I+1> input = x;
    ap_fixed<W+1,I+1> result = hls::atanh(input);
    return result;
  }


  template<int I>
  ap_int<I> atanh(ap_int<I> x){
    ap_fixed<I,I> input = x;
    ap_fixed<I,I> result = hls::atanh(input);
    return result;
  }


  template<int I>
  ap_uint<I> atanh(ap_uint<I> x){
    ap_fixed<I+1,I+1> input = x;
    ap_fixed<I+1,I+1> result = hls::atanh(input);
    return result;
  }


  template<int W, int I>
  ap_fixed<W,I> asinh(ap_fixed<W,I> x){
    return cordic_apfixed::generic_asinh(x);
  }


  template<int W, int I>
  ap_ufixed<W,I> asinh(ap_ufixed<W,I> x){
    return cordic_apfixed::generic_asinh(x);
  }


  template<int I>
  ap_int<I> asinh(ap_int<I> x){
    return cordic_apfixed::generic_asinh(x);
  }


  template<int I>
  ap_uint<I> asinh(ap_uint<I> x){
    return cordic_apfixed::generic_asinh(x);
  }


  template<int W, int I>
  ap_fixed<W,I> acosh(ap_fixed<W,I> x){
    return cordic_apfixed::generic_acosh(x);
  }


  template<int W, int I>
  ap_ufixed<W,I> acosh(ap_ufixed<W,I> x){
    return cordic_apfixed::generic_acosh(x);
  }


  template<int I>
  ap_int<I> acosh(ap_int<I> x){
    return cordic_apfixed::generic_acosh(x);
  }


  template<int I>
  ap_uint<I> acosh(ap_uint<I> x){
    return cordic_apfixed::generic_acosh(x);
  }

  int8_t sinh(int8_t);
  uint8_t sinh(uint8_t);
  int16_t sinh(int16_t);
  uint16_t sinh(uint16_t);
  int32_t sinh(int32_t);
  uint32_t sinh(uint32_t);

  int8_t cosh(int8_t);
  uint8_t cosh(uint8_t);
  int16_t cosh(int16_t);
  uint16_t cosh(uint16_t);
  int32_t cosh(int32_t);
  uint32_t cosh(uint32_t);

  int8_t tanh(int8_t);
  uint8_t tanh(uint8_t);
  int16_t tanh(int16_t);
  uint16_t tanh(uint16_t);
  int32_t tanh(int32_t);
  uint32_t tanh(uint32_t);

  int8_t atanh(int8_t);
  uint8_t atanh(uint8_t);
  int16_t atanh(int16_t);
  uint16_t atanh(uint16_t);
  int32_t atanh(int32_t);
  uint32_t atanh(uint32_t);

  int8_t asinh(int8_t);
  uint8_t asinh(uint8_t);
  int16_t asinh(int16_t);
  uint16_t asinh(uint16_t);
  int32_t asinh(int32_t);
  uint32_t asinh(uint32_t);

  int8_t acosh(int8_t);
  uint8_t acosh(uint8_t);
  int16_t acosh(int16_t);
  uint16_t acosh(uint16_t);
  int32_t acosh(int32_t);
  uint32_t acosh(uint32_t);


  template<int W, int I>
  ap_fixed<W-I+3,3> asin(ap_fixed<W,I> x){
 return cordic_apfixed::generic_asin(x);
  }


  template<int W, int I>
  ap_fixed<W-I+3,3> acos(ap_fixed<W,I> x){
 return cordic_apfixed::generic_acos(x);
  }


  template<int W, int I>
  ap_fixed<W,2> atan(ap_fixed<W,I> x){
 return cordic_apfixed::generic_atan(x);
  }


  template<int W, int I>
  ap_ufixed<W,2> atan(ap_ufixed<W,I> x){
 return cordic_apfixed::generic_atan(x);
  }


  template<int I>
  ap_int<2> atan(ap_int<I> x){
   return cordic_apfixed::generic_atan(x);
  }


  template<int I>
  ap_uint<1> atan(ap_uint<I> x){
   return cordic_apfixed::generic_atan(x);
  }

  int8_t asin(int8_t);
  uint8_t asin(uint8_t);
  int16_t asin(int16_t);
  uint16_t asin(uint16_t);
  int32_t asin(int32_t);
  uint32_t asin(uint32_t);

  int8_t acos(int8_t);
  uint8_t acos(uint8_t);
  int16_t acos(int16_t);
  uint16_t acos(uint16_t);
  int32_t acos(int32_t);
  uint32_t acos(uint32_t);

  int8_t atan(int8_t);
  uint8_t atan(uint8_t);
  int16_t atan(int16_t);
  uint16_t atan(uint16_t);
  int32_t atan(int32_t);
  uint32_t atan(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> asinpi(ap_fixed<W,I> x){
      return cordic_apfixed::generic_asinpi(x);
  }

  template<int W, int I>
  ap_ufixed<W,I> asinpi(ap_ufixed<W,I> x){
      return cordic_apfixed::generic_asinpi(x);
  }

  template<int I>
  ap_int<I> asinpi(ap_int<I> x){
     return cordic_apfixed::generic_asinpi(x);
  }

  template<int I>
  ap_uint<I> asinpi(ap_uint<I> x){
     return cordic_apfixed::generic_asinpi(x);
  }


  int8_t asinpi(int8_t);
  uint8_t asinpi(uint8_t);
  int16_t asinpi(int16_t);
  uint16_t asinpi(uint16_t);
  int32_t asinpi(int32_t);
  uint32_t asinpi(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> acospi(ap_fixed<W,I> x){
      return cordic_apfixed::generic_acospi(x);
  }

  template<int W, int I>
  ap_ufixed<W,I> acospi(ap_ufixed<W,I> x){
      return cordic_apfixed::generic_acospi(x);
  }

  template<int I>
  ap_int<I> acospi(ap_int<I> x){
     return cordic_apfixed::generic_acospi(x);
  }

  template<int I>
  ap_uint<I> acospi(ap_uint<I> x){
     return cordic_apfixed::generic_acospi(x);
  }

  int8_t acospi(int8_t);
  uint8_t acospi(uint8_t);
  int16_t acospi(int16_t);
  uint16_t acospi(uint16_t);
  int32_t acospi(int32_t);
  uint32_t acospi(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> atanpi(ap_fixed<W,I> x){
 return cordic_apfixed::generic_atanpi(x);
  }


  template<int W, int I>
  ap_ufixed<W,I> atanpi(ap_ufixed<W,I> x){
 return cordic_apfixed::generic_atanpi(x);
  }


  template<int I>
  ap_int<2> atanpi(ap_int<I> x){
   return cordic_apfixed::generic_atanpi(x);
  }


  template<int I>
  ap_uint<1> atanpi(ap_uint<I> x){
   return cordic_apfixed::generic_atanpi(x);
  }

  int8_t atanpi(int8_t);
  uint8_t atanpi(uint8_t);
  int16_t atanpi(int16_t);
  uint16_t atanpi(uint16_t);
  int32_t atanpi(int32_t);
  uint32_t atanpi(uint32_t);


  template<int W, int I>
  ap_fixed<W,3> atan2(ap_fixed<W,I> x, ap_fixed<W,I> y){
 return cordic_apfixed::generic_atan2(x,y);
  }


  template<int W, int I>
  ap_ufixed<W,3> atan2(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
 return cordic_apfixed::generic_atan2(x,y);
  }


  template<int I>
  ap_int<3> atan2(ap_int<I> x, ap_int<I> y){
   return cordic_apfixed::generic_atan2(x,y);
  }


  template<int I>
  ap_uint<2> atan2(ap_uint<I> x, ap_uint<I> y){
   return cordic_apfixed::generic_atan2(x,y);
  }

  int8_t atan2(int8_t, int8_t);
  uint8_t atan2(uint8_t, uint8_t);
  int16_t atan2(int16_t, int16_t);
  uint16_t atan2(uint16_t, uint16_t);
  int32_t atan2(int32_t, int32_t);
  uint32_t atan2(uint32_t, uint32_t);


  template<int W, int I>
  ap_fixed<W,I> atan2pi(ap_fixed<W,I> x, ap_fixed<W,I> y){
 return cordic_apfixed::generic_atan2pi(x,y);
  }


  template<int W, int I>
  ap_ufixed<W,I> atan2pi(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
 return cordic_apfixed::generic_atan2pi(x,y);
  }


  template<int I>
  ap_int<I> atan2pi(ap_int<I> x, ap_int<I> y){
   return cordic_apfixed::generic_atan2pi(x,y);
  }


  template<int I>
  ap_uint<I> atan2pi(ap_uint<I> x, ap_uint<I> y){
   return cordic_apfixed::generic_atan2pi(x,y);
  }

  int8_t atan2pi(int8_t, int8_t);
  uint8_t atan2pi(uint8_t, uint8_t);
  int16_t atan2pi(int16_t, int16_t);
  uint16_t atan2pi(uint16_t, uint16_t);
  int32_t atan2pi(int32_t, int32_t);
  uint32_t atan2pi(uint32_t, uint32_t);
  template<int W, int I>
  void sincos(ap_fixed<W,I> in,
       ap_fixed<W-I+2,2>* outsin, ap_fixed<W-I+2,2>* outcos){
   cordic_apfixed::generic_sincos(in, *outsin, *outcos);
  }

  template<int W, int I>
  ap_fixed<W-I+2,2> sin(ap_fixed<W,I> x){
        ap_fixed<W-I+2,2> outsin;
        ap_fixed<W-I+2,2> outcos;
        cordic_apfixed::generic_sincos(x, outsin, outcos);
        return outsin;
  }

  template<int W, int I>
  ap_ufixed<W-I+2,2> sin(ap_ufixed<W,I> x){
  ap_fixed<W+1, I+1> xin = x;
  ap_fixed<W-I+3, 3> xout = hls::sin(x);
  ap_fixed<W-I+2, 2> out = 0;
  if(xout[W-I+2]==0){
   out=xout;
  }
  return out;
  }

  template<int W, int I>
  ap_fixed<W-I+2,2> cos(ap_fixed<W,I> x){
        ap_fixed<W-I+2,2> outsin;
        ap_fixed<W-I+2,2> outcos;
        cordic_apfixed::generic_sincos(x, outsin, outcos);
        return outcos;
  }

  template<int W, int I>
  ap_ufixed<W-I+2,2> cos(ap_ufixed<W,I> x){
  ap_fixed<W+1, I+1> xin = x;
  ap_fixed<W-I+3, 3> xout = hls::cos(x);
  ap_fixed<W-I+2, 2> out = 0;
  if(xout[W-I+2]==0){
   out=xout;
  }
  return out;
  }
# 1988 "C:/Xilinx/Vitis_HLS/2020.2/common/technology/autopilot\\hls_math.h"
  template<int I>
  ap_int<I> sin(ap_int<I> in) {
        (void)(in);
 return ap_int<I>(0);
  };
  template<int I>
  ap_int<I> cos(ap_int<I> in) {
        (void)(in);
 return ap_int<I>(0);
  };


  template<int I>
  ap_uint<I> sin(ap_uint<I> in) {
        (void)(in);
 return ap_uint<I>(0);
  };
  template<int I>
  ap_uint<I> cos(ap_uint<I> in) {
        (void)(in);
 return ap_uint<I>(0);
  };

  void sincos(int8_t, int8_t*, int8_t*);
  void sincos(uint8_t, uint8_t*, uint8_t*);
  void sincos(int16_t, int16_t*, int16_t*);
  void sincos(uint16_t, uint16_t*, uint16_t*);
  void sincos(int32_t, int32_t*, int32_t*);
  void sincos(uint32_t, uint32_t*, uint32_t*);

  int8_t sin(int8_t);
  uint8_t sin(uint8_t);
  int16_t sin(int16_t);
  uint16_t sin(uint16_t);
  int32_t sin(int32_t);
  uint32_t sin(uint32_t);

  int8_t cos(int8_t);
  uint8_t cos(uint8_t);
  int16_t cos(int16_t);
  uint16_t cos(uint16_t);
  int32_t cos(int32_t);
  uint32_t cos(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> tan(ap_fixed<W,I> x){
 return cordic_apfixed::generic_tan(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> tan(ap_ufixed<W,I> x){
 return cordic_apfixed::generic_tan(x);
  }
  template<int I>
  ap_int<I> tan(ap_int<I> x){
   return cordic_apfixed::generic_tan(x);
  }
  template<int I>
  ap_uint<I> tan(ap_uint<I> x){
   return cordic_apfixed::generic_tan(x);
  }

  int8_t tan(int8_t);
  uint8_t tan(uint8_t);
  int16_t tan(int16_t);
  uint16_t tan(uint16_t);
  int32_t tan(int32_t);
  uint32_t tan(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> tanpi(ap_fixed<W,I> x){
 return cordic_apfixed::generic_tanpi(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> tanpi(ap_ufixed<W,I> x){
 return cordic_apfixed::generic_tanpi(x);
  }
  template<int I>
  ap_int<I> tanpi(ap_int<I> x){
   return cordic_apfixed::generic_tanpi(x);
  }
  template<int I>
  ap_uint<I> tanpi(ap_uint<I> x){
   return cordic_apfixed::generic_tanpi(x);
  }

  int8_t tanpi(int8_t);
  uint8_t tanpi(uint8_t);
  int16_t tanpi(int16_t);
  uint16_t tanpi(uint16_t);
  int32_t tanpi(int32_t);
  uint32_t tanpi(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> pow(ap_fixed<W,I> x, ap_fixed<W,I> y) {
    return pow_apfixed_reduce::pow(x,y);
  }

  template<int W, int I>
  ap_ufixed<W,I> pow(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return pow_apfixed_reduce::pow(x,y);
  }
  template<int I>
  ap_int<I> pow(ap_int<I> x, ap_int<I> y){
    return pow_apfixed_reduce::pow(x,y);
  }
  template<int I>
  ap_uint<I> pow(ap_uint<I> x,ap_uint<I> y){
    return pow_apfixed_reduce::pow(x,y);
  }

  template<int W, int I>
  ap_fixed<W,I> pown(ap_fixed<W,I> x, int n) {
    return pow_apfixed_reduce::pown(x,n);
  }

  template<int W, int I>
  ap_ufixed<W,I> pown(ap_ufixed<W,I> x, int n){
    return pow_apfixed_reduce::pown(x,n);
  }
  template<int I>
  ap_int<I> pown(ap_int<I> x, int n){
    return pow_apfixed_reduce::pown(x,n);
  }
  template<int I>
  ap_uint<I> pown(ap_uint<I> x, int n){
    return pow_apfixed_reduce::pown(x,n);
  }
  int8_t pown(int8_t, int n);
  uint8_t pown(uint8_t, int n);
  int16_t pown(int16_t, int n);
  uint16_t pown(uint16_t, int n);
  int32_t pown(int32_t, int n);
  uint32_t pown(uint32_t, int n);

  template<int W, int I>
  ap_fixed<W,I> rootn(ap_fixed<W,I> x, int n) {
    return pow_apfixed_reduce::rootn(x,n);
  }

  template<int W, int I>
  ap_ufixed<W,I> rootn(ap_ufixed<W,I> x, int n){
    return pow_apfixed_reduce::rootn(x,n);
  }
  template<int I>
  ap_int<I> rootn(ap_int<I> x, int n){
    return pow_apfixed_reduce::rootn(x,n);
  }
  template<int I>
  ap_uint<I> rootn(ap_uint<I> x, int n){
    return pow_apfixed_reduce::rootn(x,n);
  }
  int8_t rootn(int8_t, int n);
  uint8_t rootn(uint8_t, int n);
  int16_t rootn(int16_t, int n);
  uint16_t rootn(uint16_t, int n);
  int32_t rootn(int32_t, int n);
  uint32_t rootn(uint32_t, int n);

  template<int W, int I>
  ap_fixed<W,I> powr(ap_fixed<W,I> x, ap_fixed<W,I> y) {
    return pow_apfixed_reduce::powr(x,y);
  }

  template<int W, int I>
  ap_ufixed<W,I> powr(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return pow_apfixed_reduce::powr(x,y);
  }
  template<int I>
  ap_int<I> powr(ap_int<I> x, ap_int<I> y){
    return pow_apfixed_reduce::powr(x,y);
  }
  template<int I>
  ap_uint<I> powr(ap_uint<I> x,ap_uint<I> y){
    return pow_apfixed_reduce::powr(x,y);
  }



  template<int W, int I>
  ap_fixed<W,I> round(ap_fixed<W,I> x){
    return round_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> round(ap_ufixed<W,I> x){
    return round_fixed(x);
  }
  template<int I>
  ap_int<I> round(ap_int<I> x){
    return round_fixed(x);
  }
  template<int I>
  ap_uint<I> round(ap_uint<I> x){
    return round_fixed(x);
  }
  int8_t round(int8_t);
  uint8_t round(uint8_t);
  int16_t round(int16_t);
  uint16_t round(uint16_t);
  int32_t round(int32_t);
  uint32_t round(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> rint(ap_fixed<W,I> x){
    return rint_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> rint(ap_ufixed<W,I> x){
    return rint_fixed(x);
  }
  template<int I>
  ap_int<I> rint(ap_int<I> x){
    return rint_fixed(x);
  }
  template<int I>
  ap_uint<I> rint(ap_uint<I> x){
    return rint_fixed(x);
  }
  int8_t rint(int8_t);
  uint8_t rint(uint8_t);
  int16_t rint(int16_t);
  uint16_t rint(uint16_t);
  int32_t rint(int32_t);
  uint32_t rint(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> nearbyint(ap_fixed<W,I> x){
    return nearbyint_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> nearbyint(ap_ufixed<W,I> x){
    return nearbyint_fixed(x);
  }
  template<int I>
  ap_int<I> nearbyint(ap_int<I> x){
    return nearbyint_fixed(x);
  }
  template<int I>
  ap_uint<I> nearbyint(ap_uint<I> x){
    return nearbyint_fixed(x);
  }
  int8_t nearbyint(int8_t);
  uint8_t nearbyint(uint8_t);
  int16_t nearbyint(int16_t);
  uint16_t nearbyint(uint16_t);
  int32_t nearbyint(int32_t);
  uint32_t nearbyint(uint32_t);


  template<int W, int I>
  long long int llround(ap_fixed<W,I> x){
    return llround_fixed(x);
  }
  template<int W, int I>
  long long int llround(ap_ufixed<W,I> x){
    return llround_fixed(x);
  }
  template<int I>
  long long int llround(ap_int<I> x){
    return llround_fixed(x);
  }
  template<int I>
  long long int llround(ap_uint<I> x){
    return llround_fixed(x);
  }


  long long int llround(int8_t);
  long long int llround(uint8_t);
  long long int llround(int16_t);
  long long int llround(uint16_t);
  long long int llround(int32_t);
  long long int llround(uint32_t);


  template<int W, int I>
  long int lround(ap_fixed<W,I> x){
    return lround_fixed(x);
  }
  template<int W, int I>
  long int lround(ap_ufixed<W,I> x){
    return lround_fixed(x);
  }
  template<int I>
  long int lround(ap_int<I> x){
    return lround_fixed(x);
  }
  template<int I>
  long int lround(ap_uint<I> x){
    return lround_fixed(x);
  }


  long int lround(int8_t);
  long int lround(uint8_t);
  long int lround(int16_t);
  long int lround(uint16_t);
  long int lround(int32_t);
  long int lround(uint32_t);


  template<int W, int I>
  long long int llrint(ap_fixed<W,I> x){
    return llrint_fixed(x);
  }
  template<int W, int I>
  long long int llrint(ap_ufixed<W,I> x){
    return llrint_fixed(x);
  }
  template<int I>
  long long int llrint(ap_int<I> x){
    return llrint_fixed(x);
  }
  template<int I>
  long long int llrint(ap_uint<I> x){
    return llrint_fixed(x);
  }


  long long int llrint(int8_t);
  long long int llrint(uint8_t);
  long long int llrint(int16_t);
  long long int llrint(uint16_t);
  long long int llrint(int32_t);
  long long int llrint(uint32_t);


  template<int W, int I>
  long int lrint(ap_fixed<W,I> x){
    return lrint_fixed(x);
  }
  template<int W, int I>
  long int lrint(ap_ufixed<W,I> x){
    return lrint_fixed(x);
  }
  template<int I>
  long int lrint(ap_int<I> x){
    return lrint_fixed(x);
  }
  template<int I>
  long int lrint(ap_uint<I> x){
    return lrint_fixed(x);
  }


  long int lrint(int8_t);
  long int lrint(uint8_t);
  long int lrint(int16_t);
  long int lrint(uint16_t);
  long int lrint(int32_t);
  long int lrint(uint32_t);


  template<int W, int I>
  bool isgreater(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    return isgreater_fixed(x1, x2);
  }
  template<int W, int I>
  bool isgreater(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    return isgreater_fixed(x1, x2);
  }
  template<int I>
  bool isgreater(ap_int<I> x1, ap_int<I> x2){
    return isgreater_fixed(x1, x2);
  }
  template<int I>
  bool isgreater(ap_uint<I> x1, ap_uint<I> x2){
    return isgreater_fixed(x1, x2);
  }
  bool isgreater(int8_t, int8_t);
  bool isgreater(uint8_t, uint8_t);
  bool isgreater(int16_t, int16_t);
  bool isgreater(uint16_t, uint16_t);
  bool isgreater(int32_t, int32_t);
  bool isgreater(uint32_t, uint32_t);


  template<int W, int I>
  bool isgreaterequal(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    return isgreaterequal_fixed(x1, x2);
  }
  template<int W, int I>
  bool isgreaterequal(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    return isgreaterequal_fixed(x1, x2);
  }
  template<int I>
  bool isgreaterequal(ap_int<I> x1, ap_int<I> x2){
    return isgreaterequal_int(x1, x2);
  }
  template<int I>
  bool isgreaterequal(ap_uint<I> x1, ap_uint<I> x2){
    return isgreaterequal_fixed(x1, x2);
  }
  bool isgreaterequal(int8_t, int8_t);
  bool isgreaterequal(uint8_t, uint8_t);
  bool isgreaterequal(int16_t, int16_t);
  bool isgreaterequal(uint16_t, uint16_t);
  bool isgreaterequal(int32_t, int32_t);
  bool isgreaterequal(uint32_t, uint32_t);


  template<int W, int I>
  bool isless(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    return isless_fixed(x1, x2);
  }
  template<int W, int I>
  bool isless(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    return isless_fixed(x1, x2);
  }
  template<int I>
  bool isless(ap_int<I> x1, ap_int<I> x2){
    return isless_fixed(x1, x2);
  }
  template<int I>
  bool isless(ap_uint<I> x1, ap_uint<I> x2){
    return isless_fixed(x1, x2);
  }
  bool isless(int8_t, int8_t);
  bool isless(uint8_t, uint8_t);
  bool isless(int16_t, int16_t);
  bool isless(uint16_t, uint16_t);
  bool isless(int32_t, int32_t);
  bool isless(uint32_t, uint32_t);


  template<int W, int I>
  bool islessequal(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    return islessequal_fixed(x1, x2);
  }
  template<int W, int I>
  bool islessequal(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    return islessequal_fixed(x1, x2);
  }
  template<int I>
  bool islessequal(ap_int<I> x1, ap_int<I> x2){
    return islessequal_fixed(x1, x2);
  }
  template<int I>
  bool islessequal(ap_uint<I> x1, ap_uint<I> x2){
    return islessequal_fixed(x1, x2);
  }
  bool islessequal(int8_t, int8_t);
  bool islessequal(uint8_t, uint8_t);
  bool islessequal(int16_t, int16_t);
  bool islessequal(uint16_t, uint16_t);
  bool islessequal(int32_t, int32_t);
  bool islessequal(uint32_t, uint32_t);


  template<int W, int I>
  bool islessgreater(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    return islessgreater_fixed(x1, x2);
  }
  template<int W, int I>
  bool islessgreater(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    return islessgreater_fixed(x1, x2);
  }
  template<int I>
  bool islessgreater(ap_int<I> x1, ap_int<I> x2){
    return islessgreater_fixed(x1, x2);
  }
  template<int I>
  bool islessgreater(ap_uint<I> x1, ap_uint<I> x2){
    return islessgreater_fixed(x1, x2);
  }

  bool islessgreater(int8_t, int8_t);
  bool islessgreater(uint8_t, uint8_t);
  bool islessgreater(int16_t, int16_t);
  bool islessgreater(uint16_t, uint16_t);
  bool islessgreater(int32_t, int32_t);
  bool islessgreater(uint32_t, uint32_t);

  int8_t frexp(int8_t,int8_t*);
  uint8_t frexp(uint8_t, uint8_t*);
  int16_t frexp(int16_t, int16_t*);
  uint16_t frexp(uint16_t, uint16_t*);
  int32_t frexp(int32_t, int32_t*);
  uint32_t frexp(uint32_t, uint32_t*);

  template<int W, int I>
  ap_fixed<W,I> frexp(ap_fixed<W,I> x, ap_fixed<W,I>* exp) {
    return frexp_internal::frexp(x,exp);
  }

  template<int W, int I>
  ap_ufixed<W,I> frexp(ap_ufixed<W,I> x, ap_ufixed<W,I>* exp){
    return frexp_internal::frexp(x,exp);
  }
  template<int I>
  ap_int<I> frexp(ap_int<I> x, ap_int<I>* exp){
    return frexp_internal::frexp(x,exp);
  }
  template<int I>
  ap_uint<I> frexp(ap_uint<I> x,ap_uint<I>* exp){
    return frexp_internal::frexp(x,exp);
  }

  int8_t modf(int8_t, int8_t*);
  uint8_t modf(uint8_t, uint8_t*);
  int16_t modf(int16_t, int16_t*);
  uint16_t modf(uint16_t, uint16_t*);
  int32_t modf(int32_t, int32_t*);
  uint32_t modf(uint32_t, uint32_t*);

  template<int W, int I>
  ap_fixed<W,I> modf(ap_fixed<W,I> x, ap_fixed<W,I>* intpart) {
    return modf_internal::modf(x,intpart);
  }

  template<int W, int I>
  ap_ufixed<W,I> modf(ap_ufixed<W,I> x, ap_ufixed<W,I>* intpart){
    return modf_internal::modf(x,intpart);
  }
  template<int I>
  ap_int<I> modf(ap_int<I> x, ap_int<I>* intpart){
    return modf_internal::modf(x,intpart);
  }
  template<int I>
  ap_uint<I> modf(ap_uint<I> x,ap_uint<I>* intpart){
    return modf_internal::modf(x,intpart);
  }


  bool isequal(int8_t,int8_t);
  bool isequal(uint8_t,uint8_t);
  bool isequal(int16_t,int16_t);
  bool isequal(uint16_t,uint16_t);
  bool isequal(int32_t,int32_t);
  bool isequal(uint32_t,uint32_t);

  bool isnotequal(int8_t,int8_t);
  bool isnotequal(uint8_t,uint8_t);
  bool isnotequal(int16_t,int16_t);
  bool isnotequal(uint16_t,uint16_t);
  bool isnotequal(int32_t,int32_t);
  bool isnotequal(uint32_t,uint32_t);

  template<int W,int I>
  bool isequal(ap_fixed<W,I> x,ap_fixed<W,I> y){
    return generic_isequal(x,y);
  };
  template<int W,int I>
  bool isequal(ap_ufixed<W,I> x,ap_ufixed<W,I> y){
    return generic_isequal(x,y);
  };
  template<int I>
  bool isequal(ap_int<I> x,ap_int<I> y){
    return generic_isequal(x,y);
  };
  template<int I>
  bool isequal(ap_uint<I> x,ap_uint<I> y){
    return generic_isequal(x,y);
  };

  template<int W,int I>
  bool isnotequal(ap_fixed<W,I> x,ap_fixed<W,I> y){
    return generic_isnotequal(x,y);
  };
  template<int W,int I>
  bool isnotequal(ap_ufixed<W,I> x,ap_ufixed<W,I> y){
    return generic_isnotequal(x,y);
  };
  template<int I>
  bool isnotequal(ap_int<I> x,ap_int<I> y){
    return generic_isnotequal(x,y);
  };
  template<int I>
  bool isnotequal(ap_uint<I> x,ap_uint<I> y){
    return generic_isnotequal(x,y);
  };

  template<int W,int I>
  bool any(ap_fixed<W,I> x){
    return generic_any(x);
  };
  template<int W,int I>
  bool any(ap_ufixed<W,I> x){
    return generic_any(x);
  };
  template<int I>
  bool any(ap_int<I> x){
    return generic_any(x);
  };
  template<int I>
  bool any(ap_uint<I> x){
    return generic_any(x);
  };

  template<int W,int I>
  bool all(ap_fixed<W,I> x){
    return generic_all(x);
  };
  template<int W,int I>
  bool all(ap_ufixed<W,I> x){
    return generic_all(x);
  };
  template<int I>
  bool all(ap_int<I> x){
    return generic_all(x);
  };
  template<int I>
  bool all(ap_uint<I> x){
    return generic_all(x);
  };

  template<int W,int I>
  ap_fixed<W,I> bitselect(ap_fixed<W,I> x,ap_fixed<W,I> y, ap_fixed<W,I> z){
    return generic_bitselect(x,y,z);
  };
  template<int W,int I>
  ap_ufixed<W,I> bitselect(ap_ufixed<W,I> x,ap_ufixed<W,I> y,ap_ufixed<W,I> z){
    return generic_bitselect(x,y,z);
  };
  template<int I>
  ap_int<I> bitselect(ap_int<I> x,ap_int<I> y,ap_int<I> z){
    return generic_bitselect(x,y,z);
  };
  template<int I>
  ap_uint<I> bitselect(ap_uint<I> x,ap_uint<I> y,ap_uint<I> z){
    return generic_bitselect(x,y,z);
  };

  template<int W, int I>
  ap_fixed<W,I> erf(ap_fixed<W,I> x){
    return erf_erfc_fixed::erf(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> erf(ap_ufixed<W,I> x){
    return erf_erfc_fixed::erf(x);
  }
  template<int I>
  ap_int<I> erf(ap_int<I> x){
    return erf_erfc_fixed::erf(x);
  }
  template<int I>
  ap_uint<I> erf(ap_uint<I> x){
    return erf_erfc_fixed::erf(x);
  }

  template<int W, int I>
  ap_fixed<W,I> erfc(ap_fixed<W,I> x){
    return erf_erfc_fixed::erfc(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> erfc(ap_ufixed<W,I> x){
    return erf_erfc_fixed::erfc(x);
  }
  template<int I>
  ap_int<I> erfc(ap_int<I> x){
    return erf_erfc_fixed::erfc(x);
  }
  template<int I>
  ap_uint<I> erfc(ap_uint<I> x){
    return erf_erfc_fixed::erfc(x);
  }

  int8_t divide(int8_t,int8_t);
  int16_t divide(int16_t,int16_t);
  int32_t divide(int32_t,int32_t);
  uint8_t divide(uint8_t,uint8_t);
  uint16_t divide(uint16_t,uint16_t);
  uint32_t divide(uint32_t,uint32_t);

  template<int W, int I>
  ap_fixed<W,I> divide(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return hls_internal::generic_divide(x, y);
  }
  template<int W, int I>
  ap_ufixed<W,I> divide(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return hls_internal::generic_divide(x, y);
  }
  template<int I>
  ap_int<I> divide(ap_int<I> x, ap_int<I> y){
    return hls_internal::generic_divide(x, y);
  }
  template<int I>
  ap_uint<I> divide(ap_uint<I> x, ap_uint<I> y){
    return hls_internal::generic_divide(x, y);
  }

  int8_t fmod(int8_t,int8_t);
  int16_t fmod(int16_t,int16_t);
  int32_t fmod(int32_t,int32_t);
  uint8_t fmod(uint8_t,uint8_t);
  uint16_t fmod(uint16_t,uint16_t);
  uint32_t fmod(uint32_t,uint32_t);

  template<int W, int I>
  ap_fixed<W,I> fmod(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return hls_internal::generic_fmod(x, y);
  }
  template<int W, int I>
  ap_ufixed<W,I> fmod(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return hls_internal::generic_fmod(x, y);
  }
  template<int I>
  ap_int<I> fmod(ap_int<I> x, ap_int<I> y){
    return hls_internal::generic_fmod(x, y);
  }
  template<int I>
  ap_uint<I> fmod(ap_uint<I> x, ap_uint<I> y){
    return hls_internal::generic_fmod(x, y);
  }

  int8_t remainder(int8_t,int8_t);
  int16_t remainder(int16_t,int16_t);
  int32_t remainder(int32_t,int32_t);
  uint8_t remainder(uint8_t,uint8_t);
  uint16_t remainder(uint16_t,uint16_t);
  uint32_t remainder(uint32_t,uint32_t);

  template<int W, int I>
  ap_fixed<W,I> remainder(ap_fixed<W,I> x, ap_fixed<W, I> y){
    return hls_internal::generic_remainder(x, y);
  }
  template<int W, int I>
  ap_ufixed<W,I> remainder(ap_ufixed<W,I> x, ap_ufixed<W, I> y){
    return hls_internal::generic_remainder(x, y);
  }
  template<int I>
  ap_int<I> remainder(ap_int<I> x, ap_int<I> y){
    return hls_internal::generic_remainder(x, y);
  }
  template<int I>
  ap_uint<I> remainder(ap_uint<I> x, ap_uint<I> y){
    return hls_internal::generic_remainder(x, y);
  }

  int8_t remquo(int8_t,int8_t,int*);
  int16_t remquo(int16_t,int16_t,int*);
  int32_t remquo(int32_t,int32_t,int*);
  uint8_t remquo(uint8_t,uint8_t,int*);
  uint16_t remquo(uint16_t,uint16_t,int*);
  uint32_t remquo(uint32_t,uint32_t,int*);

  template<int W, int I>
  ap_fixed<W,I> remquo(ap_fixed<W,I> x, ap_fixed<W,I> y, int* quo){
    return hls_internal::generic_remquo(x, y, quo);
  }
  template<int W, int I>
  ap_ufixed<W,I> remquo(ap_ufixed<W,I> x, ap_ufixed<W, I> y, int* quo){
    return hls_internal::generic_remquo(x, y, quo);
  }
  template<int I>
  ap_int<I> remquo(ap_int<I> x, ap_int<I> y, int* quo){
    return hls_internal::generic_remquo(x, y, quo);
  }
  template<int I>
  ap_uint<I> remquo(ap_uint<I> x, ap_uint<I> y, int* quo){
    return hls_internal::generic_remquo(x, y, quo);
  }

  template<int W, int I>
  bool signbit(ap_fixed<W, I> x) {
    return signbit_fixed(x);
  }
  template<int W, int I>
  bool signbit(ap_ufixed<W, I> x) {
    return signbit_fixed(x);
  }
  template<int I>
  bool signbit(ap_int<I> x) {
    return signbit_fixed(x);
  }
  template<int I>
  bool signbit(ap_uint<I> x) {
    return signbit_fixed(x);
  }
  bool signbit(int8_t);
  bool signbit(uint8_t);
  bool signbit(int16_t);
  bool signbit(uint16_t);
  bool signbit(int32_t);
  bool signbit(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> lgamma_r(ap_fixed<W,I> x, int *signgamp){
    return lgamma_fixed::lgamma_r_generic(x, signgamp);
  }
  template<int W, int I>
  ap_ufixed<W,I> lgamma_r(ap_ufixed<W,I> x, int *signgamp){
    return lgamma_fixed::lgamma_r_generic(x, signgamp);
  }
  template<int I>
  ap_int<I> lgamma_r(ap_int<I> x, int *signgamp){
    return lgamma_fixed::lgamma_r_generic(x, signgamp);
  }
  template<int I>
  ap_uint<I> lgamma_r(ap_uint<I> x, int *signgamp){
    return lgamma_fixed::lgamma_r_generic(x, signgamp);
  }

  template<int W, int I>
  ap_fixed<W,I> lgamma(ap_fixed<W,I> x){
    return lgamma_fixed::lgamma_generic(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> lgamma(ap_ufixed<W,I> x){
    return lgamma_fixed::lgamma_generic(x);
  }
  template<int I>
  ap_int<I> lgamma(ap_int<I> x){
    return lgamma_fixed::lgamma_generic(x);
  }
  template<int I>
  ap_uint<I> lgamma(ap_uint<I> x){
    return lgamma_fixed::lgamma_generic(x);
  }

  int8_t mad(int8_t,int8_t,int8_t);
  int16_t mad(int16_t,int16_t,int16_t);
  int32_t mad(int32_t,int32_t,int32_t);
  uint8_t mad(uint8_t,uint8_t,uint8_t);
  uint16_t mad(uint16_t,uint16_t,uint16_t);
  uint32_t mad(uint32_t,uint32_t,uint32_t);

  template<int W, int I>
  ap_fixed<W,I> mad(ap_fixed<W,I> x,ap_fixed<W,I> y,ap_fixed<W,I> z){
    return hls_mad::generic_mad(x,y,z);
  }
  template<int W, int I>
  ap_ufixed<W,I> mad(ap_ufixed<W,I> x,ap_ufixed<W,I> y,ap_ufixed<W,I> z){
    return hls_mad::generic_mad(x,y,z);
  }
  template<int I>
  ap_int<I> mad(ap_int<I> x,ap_int<I> y,ap_int<I> z){
    return hls_mad::generic_mad(x,y,z);
  }
  template<int I>
  ap_uint<I> mad(ap_uint<I> x,ap_uint<I> y,ap_uint<I> z){
    return hls_mad::generic_mad(x,y,z);
  }

  int8_t fma(int8_t,int8_t,int8_t);
  int16_t fma(int16_t,int16_t,int16_t);
  int32_t fma(int32_t,int32_t,int32_t);
  uint8_t fma(uint8_t,uint8_t,uint8_t);
  uint16_t fma(uint16_t,uint16_t,uint16_t);
  uint32_t fma(uint32_t,uint32_t,uint32_t);

  template<int W, int I>
  ap_fixed<W,I> fma(ap_fixed<W,I> x,ap_fixed<W,I> y,ap_fixed<W,I> z){
    return hls_mad::generic_mad(x,y,z);
  }
  template<int W, int I>
  ap_ufixed<W,I> fma(ap_ufixed<W,I> x,ap_ufixed<W,I> y,ap_ufixed<W,I> z){
    return hls_mad::generic_mad(x,y,z);
  }
  template<int I>
  ap_int<I> fma(ap_int<I> x,ap_int<I> y,ap_int<I> z){
    return hls_mad::generic_mad(x,y,z);
  }
  template<int I>
  ap_uint<I> fma(ap_uint<I> x,ap_uint<I> y,ap_uint<I> z){
    return hls_mad::generic_mad(x,y,z);
  }

  int8_t fract(int8_t);
  int16_t fract(int16_t);
  int32_t fract(int32_t);
  uint8_t fract(uint8_t);
  uint16_t fract(uint16_t);
  uint32_t fract(uint32_t);

  template<int W, int I>
  ap_fixed<W,I> fract(ap_fixed<W,I> x){
    return hls_fract::generic_fract(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> fract(ap_ufixed<W,I> x){
    return hls_fract::generic_fract(x);
  }
  template<int I>
  ap_int<I> fract(ap_int<I> x){
    return hls_fract::generic_fract(x);
  }
  template<int I>
  ap_uint<I> fract(ap_uint<I> x){
    return hls_fract::generic_fract(x);
  }

  template<int W, int I>
  ap_fixed<W,I> cbrt(ap_fixed<W,I> x) {
    return cbrt_internal::cbrt_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> cbrt(ap_ufixed<W,I> x) {
    return cbrt_internal::cbrt_fixed(x);
  }
  template<int I>
  ap_int<I> cbrt(ap_int<I> x) {
    return cbrt_internal::cbrt_fixed(x);
  }
  template<int I>
  ap_uint<I> cbrt(ap_uint<I> x) {
    return cbrt_internal::cbrt_fixed(x);
  }
  int8_t cbrt(int8_t);
  uint8_t cbrt(uint8_t);
  int16_t cbrt(int16_t);
  uint16_t cbrt(uint16_t);
  int32_t cbrt(int32_t);
  uint32_t cbrt(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> tgamma(ap_fixed<W,I> x){
    return tgamma_fixed::tgamma_generic(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> tgamma(ap_ufixed<W,I> x){
    return tgamma_fixed::tgamma_generic(x);
  }
  template<int I>
  ap_int<I> tgamma(ap_int<I> x){
    return tgamma_fixed::tgamma_generic(x);
  }
  template<int I>
  ap_uint<I> tgamma(ap_uint<I> x){
    return tgamma_fixed::tgamma_generic(x);
  }


  template<int W, int I>
  ap_fixed<W,I> nextafter(ap_fixed<W, I> x, ap_fixed<W, I> y) {
    return fp_internal::nextafter(x, y);
  }
  template<int W, int I>
  ap_ufixed<W,I> nextafter(ap_ufixed<W, I> x, ap_ufixed<W, I> y) {
    return fp_internal::nextafter(x, y);
  }
  template<int I>
  ap_int<I> nextafter(ap_int<I> x, ap_int<I> y) {
    return fp_internal::nextafter(x, y);
  }
  template<int I>
  ap_uint<I> nextafter(ap_uint<I> x, ap_uint<I> y) {
    return fp_internal::nextafter(x, y);
  }
  int8_t nextafter(int8_t, int8_t);
  uint8_t nextafter(uint8_t, uint8_t);
  int16_t nextafter(int16_t, int16_t);
  uint16_t nextafter(uint16_t, uint16_t);
  int32_t nextafter(int32_t, int32_t);
  uint32_t nextafter(uint32_t, uint32_t);


  template<int W, int I>
  ap_fixed<W,I> nexttoward(ap_fixed<W, I> x, ap_fixed<W, I> y) {
    return fp_internal::nexttoward(x, y);
  }
  template<int W, int I>
  ap_ufixed<W,I> nexttoward(ap_ufixed<W, I> x, ap_ufixed<W, I> y) {
    return fp_internal::nexttoward(x, y);
  }
  template<int I>
  ap_int<I> nexttoward(ap_int<I> x, ap_int<I> y) {
    return fp_internal::nexttoward(x, y);
  }
  template<int I>
  ap_uint<I> nexttoward(ap_uint<I> x, ap_uint<I> y) {
    return fp_internal::nexttoward(x, y);
  }
  int8_t nexttoward(int8_t, int8_t);
  uint8_t nexttoward(uint8_t, uint8_t);
  int16_t nexttoward(int16_t, int16_t);
  uint16_t nexttoward(uint16_t, uint16_t);
  int32_t nexttoward(int32_t, int32_t);
  uint32_t nexttoward(uint32_t, uint32_t);


  template<int W, int I>
  ap_fixed<W,I> hypot(ap_fixed<W,I> x, ap_fixed<W,I> y) {
    return hypot_internal::hypot_fixed(x,y);
  }
  template<int W, int I>
  ap_ufixed<W,I> hypot(ap_ufixed<W,I> x, ap_ufixed<W,I> y) {
    return hypot_internal::hypot_fixed(x,y);
  }
  template<int I>
  ap_int<I> hypot(ap_int<I> x, ap_int<I> y) {
    return hypot_internal::hypot_fixed(x,y);
  }
  template<int I>
  ap_uint<I> hypot(ap_uint<I> x, ap_uint<I> y) {
    return hypot_internal::hypot_fixed(x,y);
  }
  int8_t hypot(int8_t, int8_t);
  uint8_t hypot(uint8_t, uint8_t);
  int16_t hypot(int16_t, int16_t);
  uint16_t hypot(uint16_t, uint16_t);
  int32_t hypot(int32_t, int32_t);
  uint32_t hypot(uint32_t, uint32_t);

  template<int W, int I>
  ap_fixed<W,I> exp2(ap_fixed<W,I> x) {
    return exp_reduce::exp2(x);
  }

  template<int W, int I>
  ap_ufixed<W,I> exp2(ap_ufixed<W,I> x) {
    return exp_reduce::exp2(x);
  }

  template<int I>
  ap_int<I> exp2(ap_int<I> x) {
    return exp_reduce::exp2(x);
  }

  template<int I>
  ap_uint<I> exp2(ap_uint<I> x) {
    return exp_reduce::exp2(x);
  }

  template<int W, int I>
  ap_fixed<W,I> exp10(ap_fixed<W,I> x) {
    return exp_reduce::exp10(x);
  }

  template<int W, int I>
  ap_ufixed<W,I> exp10(ap_ufixed<W,I> x) {
    return exp_reduce::exp10(x);
  }

  template<int I>
  ap_int<I> exp10(ap_int<I> x) {
    return exp_reduce::exp10(x);
  }

  template<int I>
  ap_uint<I> exp10(ap_uint<I> x) {
    return exp_reduce::exp10(x);
  }

  template<int W, int I>
  ap_fixed<W,I> expm1(ap_fixed<W,I> x) {
    return exp_reduce::expm1(x);
  }

  template<int W, int I>
  ap_ufixed<W,I> expm1(ap_ufixed<W,I> x) {
    return exp_reduce::expm1(x);
  }

  template<int I>
  ap_int<I> expm1(ap_int<I> x) {
    return exp_reduce::expm1(x);
  }

  template<int I>
  ap_uint<I> expm1(ap_uint<I> x) {
    return exp_reduce::expm1(x);
  }

  template<int W, int I>
  ap_fixed<W,I> log1p(ap_fixed<W,I> x) {
    return log_apfixed_reduce::log1p(x);
  }

  template<int W, int I>
  ap_ufixed<W,I> log1p(ap_ufixed<W,I> x) {
    return log_apfixed_reduce::log1p(x);
  }

  template<int I>
  ap_int<I> log1p(ap_int<I> x) {
    return log_apfixed_reduce::log1p(x);
  }

  template<int I>
  ap_uint<I> log1p(ap_uint<I> x) {
    return log_apfixed_reduce::log1p(x);
  }

  template<int W, int I>
  ap_fixed<W,I> ilogb(ap_fixed<W,I> x) {
    return log_apfixed_reduce::ilogb(x);
  }

  template<int W, int I>
  ap_ufixed<W,I> ilogb(ap_ufixed<W,I> x) {
    return log_apfixed_reduce::ilogb(x);
  }

  template<int I>
  ap_int<I> ilogb(ap_int<I> x) {
    return log_apfixed_reduce::ilogb(x);
  }

  template<int I>
  ap_uint<I> ilogb(ap_uint<I> x) {
    return log_apfixed_reduce::ilogb(x);
  }

  template<int W, int I>
  ap_fixed<W,I> ldexp(ap_fixed<W,I> x, int exp) {
    return hls_ldexp::ldexp(x, exp);
  }

  template<int W, int I>
  ap_ufixed<W,I> ldexp(ap_ufixed<W,I> x, int exp) {
    return hls_ldexp::ldexp(x, exp);
  }

  template<int I>
  ap_int<I> ldexp(ap_int<I> x, int exp) {
    return hls_ldexp::ldexp(x, exp);
  }

  template<int I>
  ap_uint<I> ldexp(ap_uint<I> x, int exp) {
    return hls_ldexp::ldexp(x, exp);
  }

  template<int W, int I>
  ap_fixed<W,I> scalbn(ap_fixed<W,I> x, int n) {
    return hls_ldexp::scalbn(x, n);
  }

  template<int W, int I>
  ap_ufixed<W,I> scalbn(ap_ufixed<W,I> x, int n) {
    return hls_ldexp::scalbn(x, n);
  }

  template<int I>
  ap_int<I> scalbn(ap_int<I> x, int n) {
    return hls_ldexp::scalbn(x, n);
  }

  template<int I>
  ap_uint<I> scalbn(ap_uint<I> x, int n) {
    return hls_ldexp::scalbn(x, n);
  }

  template<int W, int I>
  ap_fixed<W,I> scalbln(ap_fixed<W,I> x, long int n) {
    return hls_ldexp::scalbln(x, n);
  }

  template<int W, int I>
  ap_ufixed<W,I> scalbln(ap_ufixed<W,I> x, long int n) {
    return hls_ldexp::scalbln(x, n);
  }

  template<int I>
  ap_int<I> scalbln(ap_int<I> x, long int n) {
    return hls_ldexp::scalbln(x, n);
  }

  template<int I>
  ap_uint<I> scalbln(ap_uint<I> x, long int n) {
    return hls_ldexp::scalbln(x, n);
  }

    int8_t ldexp(int8_t x, int exp);
    int16_t ldexp(int16_t x, int exp);
    int32_t ldexp(int32_t x, int exp);
    uint8_t ldexp(uint8_t x, int exp);
    uint16_t ldexp(uint16_t x, int exp);
    uint32_t ldexp(uint32_t x, int exp);

    int8_t scalbn(int8_t x, int n);
    int16_t scalbn(int16_t x, int n);
    int32_t scalbn(int32_t x, int n);
    uint8_t scalbn(uint8_t x, int n);
    uint16_t scalbn(uint16_t x, int n);
    uint32_t scalbn(uint32_t x, int n);

    int8_t scalbln(int8_t x, int n);
    int16_t scalbln(int16_t x, int n);
    int32_t scalbln(int32_t x, int n);
    uint8_t scalbln(uint8_t x, int n);
    uint16_t scalbln(uint16_t x, int n);
    uint32_t scalbln(uint32_t x, int n);

    int8_t exp2(int8_t x);
    int16_t exp2(int16_t x);
    int32_t exp2(int32_t x);
    uint8_t exp2(uint8_t x);
    uint16_t exp2(uint16_t x);
    uint32_t exp2(uint32_t x);

    int8_t exp10(int8_t x);
    int16_t exp10(int16_t x);
    int32_t exp10(int32_t x);
    uint8_t exp10(uint8_t x);
    uint16_t exp10(uint16_t x);
    uint32_t exp10(uint32_t x);

    int8_t expm1(int8_t x);
    int16_t expm1(int16_t x);
    int32_t expm1(int32_t x);
    uint8_t expm1(uint8_t x);
    uint16_t expm1(uint16_t x);
    uint32_t expm1(uint32_t x);

    int8_t ilogb(int8_t x);
    int16_t ilogb(int16_t x);
    int32_t ilogb(int32_t x);
    uint8_t ilogb(uint8_t x);
    uint16_t ilogb(uint16_t x);
    uint32_t ilogb(uint32_t x);

    int8_t log1p(int8_t x);
    int16_t log1p(int16_t x);
    int32_t log1p(int32_t x);
    uint8_t log1p(uint8_t x);
    uint16_t log1p(uint16_t x);
    uint32_t log1p(uint32_t x);

    int8_t log2(int8_t);
    uint8_t log2(uint8_t);
    int16_t log2(int16_t);
    uint16_t log2(uint16_t);
    int32_t log2(int32_t);
    uint32_t log2(uint32_t);

    int8_t logb(int8_t);
    uint8_t logb(uint8_t);
    int16_t logb(int16_t);
    uint16_t logb(uint16_t);
    int32_t logb(int32_t);
    uint32_t logb(uint32_t);

};
# 50 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src\\hls_video.h" 2





# 1 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_types.h" 1
# 177 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_types.h"
template<int T> struct Type { typedef ap_int<T-12> name; static const int bitdepth = T-12; };
template<> struct Type<0> { typedef unsigned char name; static const int bitdepth = 8; };
template<> struct Type<1> { typedef char name; static const int bitdepth = 8; };
template<> struct Type<8> { typedef ap_uint<10> name; static const int bitdepth = 10; };
template<> struct Type<9> { typedef ap_int<10> name; static const int bitdepth = 10; };
template<> struct Type<10> { typedef ap_uint<12> name; static const int bitdepth = 12; };
template<> struct Type<11> { typedef ap_int<12> name; static const int bitdepth = 12; };
template<> struct Type<2> { typedef unsigned short name; static const int bitdepth = 16; };
template<> struct Type<3> { typedef short name; static const int bitdepth = 16; };
template<> struct Type<4> { typedef int name; static const int bitdepth = 32; };
template<> struct Type<5> { typedef float name; static const int bitdepth = 32; };
template<> struct Type<6> { typedef double name; static const int bitdepth = 64; };

template<typename PIXEL_T> struct pixel_op_type { typedef PIXEL_T T; };
template<> struct pixel_op_type<unsigned char> { typedef ap_uint<8> T; };
template<> struct pixel_op_type<char> { typedef ap_int<8> T; };
template<> struct pixel_op_type<unsigned short> { typedef ap_uint<16> T; };
template<> struct pixel_op_type<short> { typedef ap_int<16> T; };
template<> struct pixel_op_type<unsigned int> { typedef ap_uint<32> T; };
template<> struct pixel_op_type<int> { typedef ap_int<32> T; };
template<int W> struct pixel_op_type<ap_int<W> > { typedef ap_int<W> T; };
template<int W> struct pixel_op_type<ap_uint<W> > { typedef ap_uint<W> T; };
# 225 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_types.h"
template<typename T> struct Name
{ static const int _min = -2147483647; static const int _max = 2147483647; };
template<> struct Name<unsigned char>
{ static const int _min = 0; static const int _max = 255; };
template<> struct Name<char>
{ static const int _min = -127; static const int _max = 127; };
template<> struct Name<unsigned short>
{ static const int _min = 0; static const int _max = 65535; };
template<> struct Name<short>
{ static const int _min = -32767; static const int _max = 32767; };
template<> struct Name<int>
{ static const int _min = -2147483647; static const int _max = 2147483647; };

template<typename T>
unsigned char Convert2uchar(T v)
{
    unsigned char result=0;
    if(v>=255)
    {
        result=255;
    }
    else if(v>=0&&v<255)
    {
        ap_fixed<9,9,AP_RND> temp=v;
        result=temp;
    }
    return result;
}
template<typename T>
char Convert2char(T v)
{
    char result=-127;
    if(v>=127)
    {
        result=127;
    }
    else if(v>=-127&&v<127)
    {
        ap_fixed<9,9,AP_RND> temp=v;
        result=temp;
    }
    return result;
}
template<typename T>
unsigned short Convert2ushort(T v)
{
    unsigned short result=0;
    if(v>=65535)
    {
        result=65535;
    }
    else if(v>=0&&v<65535)
    {
        ap_fixed<17,17,AP_RND> temp=v;
        result=temp;
    }
    return result;
}
template<typename T>
short Convert2short(T v)
{
    short result=-32767;
    if(v>=32767)
    {
        result=32767;
    }
    else if(v>=-32767&&v<32767)
    {
        ap_fixed<17,17,AP_RND> temp=v;
        result=temp;
    }
    return result;
}
template<typename T>
int Convert2int(T v)
{
    int result=-2147483647;
    if(v>=2147483647)
    {
        result=2147483647;
    }
    else if(v>=-2147483647&&v<2147483647)
    {
        ap_fixed<32,32,AP_RND> temp=v;
        result=temp;
    }
    return result;
}

typedef ap_uint<32> HLS_SIZE_T;
typedef ap_uint<5> HLS_CHANNEL_T;

namespace hls {



template<typename T2> class sr_cast_class { };

template<> class sr_cast_class<float> {
public:
    template<typename T1>
    inline float operator()(T1 v) { return v; }
    inline float operator()(double v) { return ((float)(v)); }
};

template<> class sr_cast_class<double> {
public:
    template<typename T1>
    inline double operator()(T1 v) { return v; }
    inline double operator()(float v) { return ((double)(v)); }
};

template<int N2> class sr_cast_class<ap_int<N2> > {
public:
    template<int N1>
    inline ap_int<N2> operator()(ap_int<N1> v) {
        return ap_fixed<N2,N2,AP_TRN,AP_SAT>(v);
    }
    template<int N1>
    inline ap_int<N2> operator()(ap_uint<N1> v) {
        return ap_fixed<N2,N2,AP_TRN,AP_SAT>(v);
    }
    template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O>
    inline ap_int<N2> operator()(ap_fixed<W,I, _AP_Q, _AP_O> v) {
        return ap_fixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O>
    inline ap_int<N2> operator()(ap_ufixed<W,I, _AP_Q, _AP_O> v) {
        return ap_fixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int N>
    inline ap_int<N2> operator()(ap_fixed_base<W,I, true, _AP_Q, _AP_O, N> v) {
        return ap_fixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int N>
    inline ap_int<N2> operator()(ap_fixed_base<W,I, false,_AP_Q, _AP_O, N> v) {
        return ap_fixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    inline ap_int<N2> operator()(float v) {
        if(::hls::__isnan(v)) return 0;
        else return ap_fixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    inline ap_int<N2> operator()(double v) {
        if(::hls::__isnan(v)) return 0;
        else return ap_fixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    inline ap_int<N2> operator()(unsigned char v) {
        return operator()(ap_uint<8>(v));
    }
    inline ap_int<N2> operator()(char v) {
        return operator()(ap_int<8>(v));
    }
    inline ap_int<N2> operator()(unsigned short v) {
        return operator()(ap_uint<16>(v));
    }
    inline ap_int<N2> operator()(short v) {
        return operator()(ap_int<16>(v));
    }
    inline ap_int<N2> operator()(unsigned int v) {
        return operator()(ap_uint<32>(v));
    }
    inline ap_int<N2> operator()(int v) {
        return operator()(ap_int<32>(v));
    }
    inline ap_int<N2> operator()(unsigned long long v) {
        return operator()(ap_uint<64>(v));
    }
    inline ap_int<N2> operator()(long long v) {
        return operator()(ap_int<64>(v));
    }
};

template<int N2> class sr_cast_class<ap_uint<N2> > {
public:
    template<int N1>
    inline ap_uint<N2> operator()(ap_int<N1> v) {
        return ap_ufixed<N2,N2,AP_TRN,AP_SAT>(v);
    }
    template<int N1>
    inline ap_uint<N2> operator()(ap_uint<N1> v) {
        return ap_ufixed<N2,N2,AP_TRN,AP_SAT>(v);
    }
    template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O>
    inline ap_uint<N2> operator()(ap_fixed<W,I, _AP_Q, _AP_O> v) {
        return ap_ufixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O>
    inline ap_uint<N2> operator()(ap_ufixed<W,I, _AP_Q, _AP_O> v) {
        return ap_ufixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int N>
    inline ap_uint<N2> operator()(ap_fixed_base<W,I, true, _AP_Q, _AP_O, N> v) {
        return ap_ufixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    template <int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int N>
    inline ap_uint<N2> operator()(ap_fixed_base<W,I, false,_AP_Q, _AP_O, N> v) {
        return ap_ufixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    inline ap_uint<N2> operator()(float v) {
        if(::hls::__isnan(v)) return 0;
        else return ap_ufixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    inline ap_uint<N2> operator()(double v) {
        if(::hls::__isnan(v)) return 0;
        else return ap_ufixed<N2,N2,AP_RND,AP_SAT>(v);
    }
    inline ap_uint<N2> operator()(unsigned char v) {
        return operator()(ap_uint<8>(v));
    }
    inline ap_uint<N2> operator()(char v) {
        return operator()(ap_int<8>(v));
    }
    inline ap_uint<N2> operator()(unsigned short v) {
        return operator()(ap_uint<16>(v));
    }
    inline ap_uint<N2> operator()(short v) {
        return operator()(ap_int<16>(v));
    }
    inline ap_uint<N2> operator()(unsigned int v) {
        return operator()(ap_uint<32>(v));
    }
    inline ap_uint<N2> operator()(int v) {
        return operator()(ap_int<32>(v));
    }
    inline ap_uint<N2> operator()(unsigned long long v) {
        return operator()(ap_uint<64>(v));
    }
    inline ap_uint<N2> operator()(long long v) {
        return operator()(ap_int<64>(v));
    }
};

template<> class sr_cast_class<unsigned char> : public sr_cast_class<ap_uint<8> > {
public:
    using sr_cast_class<ap_uint<8> >::operator();
};

template<> class sr_cast_class<char> : public sr_cast_class<ap_int<8> > {
public:
    using sr_cast_class<ap_int<8> >::operator();
};

template<> class sr_cast_class<unsigned short> : public sr_cast_class<ap_uint<16> > {
public:
    using sr_cast_class<ap_uint<16> >::operator();
};

template<> class sr_cast_class<short> : public sr_cast_class<ap_int<16> > {
public:
    using sr_cast_class<ap_int<16> >::operator();
};

template<> class sr_cast_class<unsigned int> : public sr_cast_class<ap_uint<32> > {
public:
    using sr_cast_class<ap_uint<32> >::operator();
};

template<> class sr_cast_class<int> : public sr_cast_class<ap_int<32> > {
public:
    using sr_cast_class<ap_int<32> >::operator();
};

template<> class sr_cast_class<unsigned long long> : public sr_cast_class<ap_uint<64> > {
public:
    using sr_cast_class<ap_uint<64> >::operator();
};

template<> class sr_cast_class<long long> : public sr_cast_class<ap_int<64> > {
public:
    using sr_cast_class<ap_int<64> >::operator();
};

template<typename T2, typename T1> inline T2 sr_cast(T1 v)
{
    ::hls::sr_cast_class<T2> V;
    return V(v);
}


typedef struct{
  unsigned char Y;
  char UV;
}yuv422_8;

typedef struct{
  unsigned char Y;
  char U;
  char V;
}yuv444_8;

typedef struct{
  unsigned char R;
  unsigned char G;
  unsigned char B;
}rgb_8;

typedef yuv422_8 yuv420_8;

typedef struct{
  char A;
  unsigned char Y;
  char UV;
}yuva422_8;

typedef struct{
  char A;
  unsigned char Y;
  char U;
  char V;
}yuva444_8;

typedef struct{
  char A;
  unsigned char R;
  unsigned char G;
  unsigned char B;
}rgba_8;

typedef struct{
  char AUV;
  unsigned char Y;
}yuva420_8;

typedef struct{
  unsigned char D;
  unsigned char Y;
  char UV;
}yuvd422_8;

typedef struct{
  unsigned char D;
  unsigned char Y;
  char U;
  char V;
}yuvd444_8;

typedef struct{
  unsigned char D;
  unsigned char R;
  unsigned char G;
  unsigned char B;
}rgbd_8;

typedef yuvd422_8 yuvd420_8;

typedef struct{
  unsigned char CMY;
}bayer_8;

typedef struct{
  unsigned char Y;
}luma_8;

}
# 56 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src\\hls_video.h" 2
# 1 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h" 1
# 45 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h"
namespace hls {


template<int ROWS, int COLS, typename T>
class Window {
public:
    Window() {
#pragma HLS ARRAY_PARTITION variable=val dim=1 complete
#pragma HLS ARRAY_PARTITION variable=val dim=2 complete
 };


    void shift_pixels_left();
    void shift_pixels_right();
    void shift_pixels_up();
    void shift_pixels_down();
    void insert_pixel(T value, int row, int col);
    void insert_row(T value[COLS], int row);
    void insert_top_row(T value[COLS]);
    void insert_bottom_row(T value[COLS]);
    void insert_col(T value[ROWS], int col);
    void insert_left_col(T value[ROWS]);
    void insert_right_col(T value[ROWS]);
    T& getval(int row, int col);
    T& operator ()(int row, int col);


    void shift_left();
    void shift_right();
    void shift_up();
    void shift_down();
    void insert(T value, int row, int col);
    void insert_top(T value[COLS]);
    void insert_bottom(T value[COLS]);
    void insert_left(T value[ROWS]);
    void insert_right(T value[ROWS]);



    T val[ROWS][COLS];





};
# 113 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h"
template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::shift_pixels_left() {
#pragma HLS inline







 HLS_SIZE_T i, j;
    VITIS_LOOP_123_1: for(i = 0; i < ROWS; i++) {
#pragma HLS unroll
 VITIS_LOOP_125_2: for(j = 0; j < COLS-1; j++) {
#pragma HLS unroll
 val[i][j] = val[i][j+1];
        }
    }
# 145 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h"
}





template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::shift_pixels_right() {
#pragma HLS inline







 HLS_SIZE_T i, j;
    VITIS_LOOP_161_1: for(i = 0; i < ROWS; i++) {
#pragma HLS unroll
 VITIS_LOOP_163_2: for(j = COLS-1; j > 0; j--) {
#pragma HLS unroll
 val[i][j] = val[i][j-1];
        }
    }
# 183 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h"
}





template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::shift_pixels_up() {
#pragma HLS inline







 HLS_SIZE_T i, j;
    VITIS_LOOP_199_1: for(i = 0; i < ROWS-1; i++) {
#pragma HLS unroll
 VITIS_LOOP_201_2: for(j = 0; j < COLS; j++) {
#pragma HLS unroll
 val[i][j] = val[i+1][j];
        }
    }
# 221 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h"
}





template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::shift_pixels_down() {
#pragma HLS inline







 HLS_SIZE_T i, j;
    VITIS_LOOP_237_1: for(i = ROWS-1; i > 0; i--) {
#pragma HLS unroll
 VITIS_LOOP_239_2: for(j = 0; j < COLS; j++) {
#pragma HLS unroll
 val[i][j] = val[i-1][j];
        }
    }
# 259 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h"
}




template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_pixel(T value, int row, int col) {
#pragma HLS inline
 (void) ((!!(row >= 0 && row < ROWS && col >= 0 && col < COLS)) || (_assert("row >= 0 && row < ROWS && col >= 0 && col < COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h",266),0));







    val[row][col] = value;
# 291 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h"
}




template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_row(T value[COLS], int row) {
#pragma HLS inline







 HLS_SIZE_T j;
    VITIS_LOOP_306_1: for(j = 0; j < COLS; j++) {
#pragma HLS unroll
 val[row][j] = value[j];
    }
# 326 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h"
}




template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_top_row(T value[COLS]) {
#pragma HLS inline







 insert_row(value, 0);
# 357 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h"
}




template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_bottom_row(T value[COLS]) {
#pragma HLS inline







 insert_row(value, ROWS-1);
# 388 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h"
}




template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_col(T value[ROWS], int col) {
#pragma HLS inline







 HLS_SIZE_T i;
    VITIS_LOOP_403_1: for(i = 0; i < ROWS; i++) {
#pragma HLS unroll
 val[i][col] = value[i];
    }
# 423 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h"
}




template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_left_col(T value[ROWS]) {
#pragma HLS inline







 insert_col(value, 0);
# 454 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h"
}




template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_right_col(T value[ROWS]) {
#pragma HLS inline







 insert_col(value, COLS-1);
# 485 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h"
}




template<int ROWS, int COLS, typename T> T& Window<ROWS, COLS, T>::getval(int row, int col) {
#pragma HLS inline
 (void) ((!!(row >= 0 && row < ROWS && col >= 0 && col < COLS)) || (_assert("row >= 0 && row < ROWS && col >= 0 && col < COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h",492),0));
    return val[row][col];
}




template<int ROWS, int COLS, typename T> T& Window<ROWS, COLS, T>::operator ()(int row, int col) {
#pragma HLS inline
 return getval(row, col);
}
# 531 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h"
template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::shift_left() {
#pragma HLS inline
 shift_pixels_left();
}






template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::shift_right() {
#pragma HLS inline
 shift_pixels_right();
}






template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::shift_up() {
#pragma HLS inline
 shift_pixels_up();
}






template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::shift_down() {
#pragma HLS inline
 shift_pixels_down();
}






template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert(T value, int row, int col) {
#pragma HLS inline
 insert_pixel(value, row, col);
}






template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_top(T value[COLS]) {
#pragma HLS inline
 insert_bottom_row(value);
}






template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_bottom(T value[COLS]) {
#pragma HLS inline
 insert_top_row(value);
}






template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_left(T value[ROWS]) {
#pragma HLS inline
 insert_right_col(value);
}






template<int ROWS, int COLS, typename T> void Window<ROWS, COLS, T>::insert_right(T value[ROWS]) {
#pragma HLS inline
 insert_left_col(value);
}


template<int ROWS, int COLS, typename T, int RESHAPE=0>
class LineBuffer;

template<int ROWS, int COLS, typename T>
class LineBuffer<ROWS, COLS, T, 0> {
public:
    LineBuffer() {
#pragma HLS inline
#pragma HLS array_partition variable=val dim=1 complete
#pragma HLS dependence variable=val inter false
#pragma HLS dependence variable=val intra false
 };

    void shift_pixels_up(int col);
    void shift_pixels_down(int col);
    void insert_bottom_row(T value, int col);
    void insert_top_row(T value, int col);
    void get_col(T value[ROWS], int col);
    T& getval(int row, int col);
    T& operator ()(int row, int col);


    void shift_up(int col);
    void shift_down(int col);
    void insert_bottom(T value, int col);
    void insert_top(T value, int col);



    T val[ROWS][COLS];





};
# 677 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h"
template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::shift_pixels_down(int col) {
#pragma HLS inline
 (void) ((!!(col >= 0 && col < COLS)) || (_assert("col >= 0 && col < COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h",679),0));







    HLS_SIZE_T i;
    VITIS_LOOP_688_1: for(i = ROWS-1; i > 0; i--) {
#pragma HLS unroll
 val[i][col] = val[i-1][col];
    }
# 711 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h"
}





template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::shift_pixels_up(int col) {
#pragma HLS inline
 (void) ((!!(col >= 0 && col < COLS)) || (_assert("col >= 0 && col < COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h",719),0));







    HLS_SIZE_T i;
    VITIS_LOOP_728_1: for(i = 0; i < ROWS-1; i++) {
#pragma HLS unroll
 val[i][col] = val[i+1][col];
    }
# 751 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h"
}




template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::insert_bottom_row(T value, int col) {
#pragma HLS inline
 (void) ((!!(col >= 0 && col < COLS)) || (_assert("col >= 0 && col < COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h",758),0));







    val[ROWS-1][col] = value;
# 783 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h"
}




template <int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::insert_top_row(T value, int col) {
#pragma HLS inline
 (void) ((!!(col >= 0 && col < COLS)) || (_assert("col >= 0 && col < COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h",790),0));







    val[0][col] = value;
# 815 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h"
}




template <int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::get_col(T value[ROWS], int col) {
#pragma HLS inline
 (void) ((!!(col >= 0 && col < COLS)) || (_assert("col >= 0 && col < COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h",822),0));
    HLS_SIZE_T i;
    VITIS_LOOP_824_1: for(i = 0; i < ROWS; i++) {
#pragma HLS unroll
 value[i] = val[i][col];
    }
}




template <int ROWS, int COLS, typename T> T& LineBuffer<ROWS, COLS, T>::getval(int row, int col) {
#pragma HLS inline
 (void) ((!!(row >= 0 && row < ROWS && col >= 0 && col < COLS)) || (_assert("row >= 0 && row < ROWS && col >= 0 && col < COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h",835),0));
    return val[row][col];
}




template<int ROWS, int COLS, typename T> T& LineBuffer<ROWS, COLS, T>::operator ()(int row, int col) {
#pragma HLS inline
 return getval(row, col);
}






template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::shift_down(int col) {
#pragma HLS inline
 shift_pixels_down(col);
}






template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::shift_up(int col) {
#pragma HLS inline
 shift_pixels_up(col);
}






template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::insert_bottom(T value, int col) {
#pragma HLS inline
 insert_top_row(value, col);
}






template <int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T>::insert_top(T value, int col) {
#pragma HLS inline
 insert_bottom_row(value, col);
}
# 908 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h"
template<int ROWS, int COLS, typename T>
class LineBuffer<ROWS, COLS, T, 1> {
public:
    LineBuffer() {
#pragma HLS array_reshape variable=val dim=1
#pragma HLS dependence variable=val inter false
#pragma HLS dependence variable=val intra false
 };

    void shift_pixels_up(int col);
    void shift_pixels_down(int col);
    void insert_bottom_row(T value, int col);
    void insert_top_row(T value, int col);
    void get_col(T value[ROWS], int col);
    T& getval(int row, int col);
    T& operator ()(int row, int col);


    void shift_up(int col);
    void shift_down(int col);
    void insert_bottom(T value, int col);
    void insert_top(T value, int col);



    T val[ROWS][COLS];





};
# 965 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h"
template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::shift_pixels_down(int col) {
#pragma HLS inline
 (void) ((!!(col >= 0 && col < COLS)) || (_assert("col >= 0 && col < COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h",967),0));







    HLS_SIZE_T i;
    VITIS_LOOP_976_1: for(i = ROWS-1; i > 0; i--) {
#pragma HLS unroll
 val[i][col] = val[i-1][col];
    }
# 999 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h"
}





template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::shift_pixels_up(int col) {
#pragma HLS inline
 (void) ((!!(col >= 0 && col < COLS)) || (_assert("col >= 0 && col < COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h",1007),0));







    HLS_SIZE_T i;
    VITIS_LOOP_1016_1: for(i = 0; i < ROWS-1; i++) {
#pragma HLS unroll
 val[i][col] = val[i+1][col];
    }
# 1039 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h"
}




template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::insert_bottom_row(T value, int col) {
#pragma HLS inline
 (void) ((!!(col >= 0 && col < COLS)) || (_assert("col >= 0 && col < COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h",1046),0));







    val[ROWS-1][col] = value;
# 1071 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h"
}




template <int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::insert_top_row(T value, int col) {
#pragma HLS inline
 (void) ((!!(col >= 0 && col < COLS)) || (_assert("col >= 0 && col < COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h",1078),0));







    val[0][col] = value;
# 1103 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h"
}




template <int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::get_col(T value[ROWS], int col) {
#pragma HLS inline
 (void) ((!!(col >= 0 && col < COLS)) || (_assert("col >= 0 && col < COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h",1110),0));
    HLS_SIZE_T i;
    VITIS_LOOP_1112_1: for(i = 0; i < ROWS; i++) {
#pragma HLS unroll
 value[i] = val[i][col];
    }
}




template <int ROWS, int COLS, typename T> T& LineBuffer<ROWS, COLS, T, 1>::getval(int row, int col) {
#pragma HLS inline
 (void) ((!!(row >= 0 && row < ROWS && col >= 0 && col < COLS)) || (_assert("row >= 0 && row < ROWS && col >= 0 && col < COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h",1123),0));
    return val[row][col];
}




template<int ROWS, int COLS, typename T> T& LineBuffer<ROWS, COLS, T, 1>::operator ()(int row, int col) {
#pragma HLS inline
 return getval(row, col);
}






template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::shift_down(int col) {
#pragma HLS inline
 shift_pixels_down(col);
}






template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::shift_up(int col) {
#pragma HLS inline
 shift_pixels_up(col);
}






template<int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::insert_bottom(T value, int col) {
#pragma HLS inline
 insert_top_row(value, col);
}






template <int ROWS, int COLS, typename T> void LineBuffer<ROWS, COLS, T, 1>::insert_top(T value, int col) {
#pragma HLS inline
 insert_bottom_row(value, col);
}
# 1195 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_mem.h"
}
# 57 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src\\hls_video.h" 2
# 1 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_core.h" 1
# 84 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_core.h"
namespace hls {


template<typename T>
class Point_ {
public:
    Point_();
    Point_(T _x, T _y);
    Point_(const Point_& pt);
    ~Point_();

    T x, y;
};


template<typename T> inline Point_<T>::Point_() {}
template<typename T> inline Point_<T>::Point_(T _x, T _y) : x(_x), y(_y) {}
template<typename T> inline Point_<T>::Point_(const Point_<T>& pt) : x(pt.x), y(pt.y) {}
template<typename T> inline Point_<T>::~Point_() {}

typedef Point_<int> Point;



template<typename T>
class Size_ {
public:
    Size_();
    Size_(T _width, T _height);
    Size_(const Size_<T>& sz);
    Size_(const Point_<T>& pt);
    T area();
    ~Size_();

    T width, height;
};


template<typename T> inline Size_<T>::Size_() {}
template<typename T> inline Size_<T>::Size_(T _width, T _height) : width(_width), height(_height) {}
template<typename T> inline Size_<T>::Size_(const Size_<T>& sz) : width(sz.width), height(sz.height) {}
template<typename T> inline Size_<T>::Size_(const Point_<T>& pt) : width(pt.x), height(pt.y) {}
template<typename T> inline T Size_<T>::area() { return width*height; }
template<typename T> inline Size_<T>::~Size_() {}

typedef Size_<int> Size;



template<typename T>
class Rect_ {
public:
    Rect_();
    Rect_(T _x, T _y, T _width, T _height);
    Rect_(const Rect_& rect);
    Rect_(const Point_<T>& pt, const Size_<T>& sz);
    T area();
    Size_<T> size();
    Point_<T> tl();
    Point_<T> tr();
    Point_<T> bl();
    Point_<T> br();
    bool bContains(const Point_<T>& pt);
    ~Rect_();

    T x, y, width, height;
};


template<typename T> inline Rect_<T>::Rect_() {}
template<typename T> inline Rect_<T>::Rect_(T _x, T _y, T _width, T _height) : x(_x), y(_y), width(_width), height(_height) {}
template<typename T> inline Rect_<T>::Rect_(const Rect_<T>& rect) : x(rect.x), y(rect.y), width(rect.width), height(rect.height) {}
template<typename T> inline Rect_<T>::Rect_(const Point_<T>& pt, const Size_<T>& sz) : x(pt.x), y(pt.y), width(sz.width), height(sz.height) {}
template<typename T> inline T Rect_<T>::area() { return width*height; }
template<typename T> inline Size_<T> Rect_<T>::size() { return Size_<T>(width, height); }
template<typename T> inline Point_<T> Rect_<T>::tl() { return Point_<T>(x, y); }
template<typename T> inline Point_<T> Rect_<T>::tr() { return Point_<T>(x+width, y); }
template<typename T> inline Point_<T> Rect_<T>::bl() { return Point_<T>(x, y+height); }
template<typename T> inline Point_<T> Rect_<T>::br() { return Point_<T>(x+width, y+height); }
template<typename T> inline bool Rect_<T>::bContains(const Point_<T>& pt) { return (pt.x >= x && pt.x < x+width && pt.y >= y && pt.y < y+height); }
template<typename T> inline Rect_<T>::~Rect_() {}

typedef Rect_<int> Rect;


template<bool c>
struct eqb {};

template<>
struct eqb <true> { typedef void type; };

template<typename T1, typename T2>
struct eqwt { typedef typename eqb<Type_BitWidth<T1>::Value == Type_BitWidth<T2>::Value>::type type; };


template<int N, typename T>
class Scalar {
public:
    Scalar() {
#pragma HLS INLINE
#pragma HLS ARRAY_PARTITION variable=val dim=1 complete
 (void) ((!!(N > 0)) || (_assert("N > 0","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_core.h",185),0));
    }
    Scalar(T v0) {
#pragma HLS INLINE
#pragma HLS ARRAY_PARTITION variable=val dim=1 complete
 (void) ((!!(N >= 1 && "Scalar must have enough channels for constructor.")) || (_assert("N >= 1 && \"Scalar must have enough channels for constructor.\"","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_core.h",190),0));
        val[0] = v0;
    }
    Scalar(T v0, T v1) {
#pragma HLS INLINE
#pragma HLS ARRAY_PARTITION variable=val dim=1 complete
 (void) ((!!(N >= 2 && "Scalar must have enough channels for constructor.")) || (_assert("N >= 2 && \"Scalar must have enough channels for constructor.\"","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_core.h",196),0));
        val[0] = v0; val[1] = v1;
    }
    Scalar(T v0, T v1, T v2) {
#pragma HLS INLINE
#pragma HLS ARRAY_PARTITION variable=val dim=1 complete
 (void) ((!!(N >= 3 && "Scalar must have enough channels for constructor.")) || (_assert("N >= 3 && \"Scalar must have enough channels for constructor.\"","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_core.h",202),0));
        val[0] = v0; val[1] = v1; val[2] = v2;
    }
    Scalar(T v0, T v1, T v2, T v3) {
#pragma HLS INLINE
#pragma HLS ARRAY_PARTITION variable=val dim=1 complete
 (void) ((!!(N >= 4 && "Scalar must have enough channels for constructor.")) || (_assert("N >= 4 && \"Scalar must have enough channels for constructor.\"","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_core.h",208),0));
        val[0] = v0; val[1] = v1; val[2] = v2; val[3] = v3;
    }

    void operator = (T value);


    template<typename T2>
    typename eqwt<T,T2>::type operator = (const Scalar<N, T2> &value) {
#pragma HLS inline
 VITIS_LOOP_218_1: for (int k = 0; k < N; k++) {
#pragma HLS unroll
 val[k] = (T)value.val[k];
        }
    }

    Scalar<N, T> operator + (T value);
    Scalar<N, T> operator + (Scalar<N, T> s);
    Scalar<N, T> operator - (T value);
    Scalar<N, T> operator - (Scalar<N, T> s);
    Scalar<N, T> operator * (T value);
    Scalar<N, T> operator * (Scalar<N, T> s);
    Scalar<N, T> operator / (T value);
    Scalar<N, T> operator / (Scalar<N, T> s);

    T val[N];
};

template<int N, typename T>
void Scalar<N, T>::operator = (T value) {
#pragma HLS inline
 VITIS_LOOP_239_1: for (int k = 0; k < N; k++) {
#pragma HLS unroll
 val[k] = value;
    }
}

template<int N, typename T>
Scalar<N, T> Scalar<N, T>::operator + (T value) {
#pragma HLS inline
 Scalar<N, T> res;
    VITIS_LOOP_249_1: for (int k = 0; k < N; k++) {
#pragma HLS unroll
 res.val[k] = val[k] + value;
    }
    return res;
}

template<int N, typename T>
Scalar<N, T> Scalar<N, T>::operator + (Scalar<N, T> s) {
#pragma HLS inline
 Scalar<N, T> res;
    VITIS_LOOP_260_1: for (int k = 0; k < N; k++) {
#pragma HLS unroll
 res.val[k] = val[k] + s.val[k];
    }
    return res;
}

template<int N, typename T>
Scalar<N, T> Scalar<N, T>::operator - (T value) {
#pragma HLS inline
 Scalar<N, T> res;
    VITIS_LOOP_271_1: for (int k = 0; k < N; k++) {
#pragma HLS unroll
 res.val[k] = val[k] - value;
    }
    return res;
}

template<int N, typename T>
Scalar<N, T> Scalar<N, T>::operator - (Scalar<N, T> s) {
#pragma HLS inline
 Scalar<N, T> res;
    VITIS_LOOP_282_1: for (int k = 0; k < N; k++) {
#pragma HLS unroll
 res.val[k] = val[k] - s.val[k];
    }
    return res;
}


template<int N, typename T>
Scalar<N, T> Scalar<N, T>::operator * (T value) {
#pragma HLS inline
 Scalar<N, T> res;
    VITIS_LOOP_294_1: for (int k = 0; k < N; k++) {
#pragma HLS unroll
 res.val[k] = val[k] * value;
    }
    return res;
}

template<int N, typename T>
Scalar<N, T> Scalar<N, T>::operator * (Scalar<N, T> s) {
#pragma HLS inline
 Scalar<N, T> res;
    VITIS_LOOP_305_1: for (int k = 0; k < N; k++) {
#pragma HLS unroll
 res.val[k] = val[k] * s.val[k];
    }
    return res;
}


template<int N, typename T>
Scalar<N, T> Scalar<N, T>::operator / (T value) {
#pragma HLS inline
 Scalar<N, T> res;
    VITIS_LOOP_317_1: for (int k = 0; k < N; k++) {
#pragma HLS unroll
 res.val[k] = val[k] / value;
    }
    return res;
}

template<int N, typename T>
Scalar<N, T> Scalar<N, T>::operator / (Scalar<N, T> s) {
#pragma HLS inline
 Scalar<N, T> res;
    VITIS_LOOP_328_1: for (int k = 0; k < N; k++) {
#pragma HLS unroll
 res.val[k] = val[k] / s.val[k];
    }
    return res;
}





template<typename T>
yuv422_8 Scalar_to_yuv422_8(Scalar<2, T> scl) {
#pragma HLS inline
 yuv422_8 pix;
    pix.Y = (unsigned char)scl.val[0];
    pix.UV = (char)scl.val[1];
    return pix;
}
template<typename T>
Scalar<2, T> yuv422_8_to_Scalar(yuv422_8 pix) {
#pragma HLS inline
 Scalar<2, T> scl;
    scl.val[0] = (T)pix.Y;
    scl.val[1] = (T)pix.UV;
    return scl;
}


template<typename T>
yuv444_8 Scalar_to_yuv444_8(Scalar<3, T> scl) {
#pragma HLS inline
 yuv444_8 pix;
    pix.Y = (unsigned char)scl.val[0];
    pix.U = (char)scl.val[1];
    pix.V = (char)scl.val[2];
    return pix;
}
template<typename T>
Scalar<3, T> yuv444_8_to_Scalar(yuv444_8 pix) {
#pragma HLS inline
 Scalar<3, T> scl;
    scl.val[0] = (T)pix.Y;
    scl.val[1] = (T)pix.U;
    scl.val[2] = (T)pix.V;
    return scl;
}


template<typename T>
rgb_8 Scalar_to_rgb_8(Scalar<3, T> scl) {
#pragma HLS inline
 rgb_8 pix;
    pix.R = (unsigned char)scl.val[0];
    pix.G = (unsigned char)scl.val[1];
    pix.B = (unsigned char)scl.val[2];
    return pix;
}
template<typename T>
Scalar<3, T> rgb_8_to_Scalar(rgb_8 pix) {
#pragma HLS inline
 Scalar<3, T> scl;
    scl.val[0] = (T)pix.R;
    scl.val[1] = (T)pix.G;
    scl.val[2] = (T)pix.B;
    return scl;
}


template<typename T>
yuva422_8 Scalar_to_yuva422_8(Scalar<3, T> scl) {
#pragma HLS inline
 yuva422_8 pix;
    pix.A = (char)scl.val[0];
    pix.Y = (unsigned char)scl.val[1];
    pix.UV = (char)scl.val[2];
    return pix;
}
template<typename T>
Scalar<3, T> yuva422_8_to_Scalar(yuva422_8 pix) {
#pragma HLS inline
 Scalar<3, T> scl;
    scl.val[0] = (T)pix.A;
    scl.val[1] = (T)pix.Y;
    scl.val[2] = (T)pix.UV;
    return scl;
}


template<typename T>
yuva444_8 Scalar_to_yuva444_8(Scalar<4, T> scl) {
#pragma HLS inline
 yuva444_8 pix;
    pix.A = (char)scl.val[0];
    pix.Y = (unsigned char)scl.val[1];
    pix.U = (char)scl.val[2];
    pix.V = (char)scl.val[3];
    return pix;
}
template<typename T>
Scalar<4, T> yuva444_8_to_Scalar(yuva444_8 pix) {
#pragma HLS inline
 Scalar<4, T> scl;
    scl.val[0] = (T)pix.A;
    scl.val[1] = (T)pix.Y;
    scl.val[2] = (T)pix.U;
    scl.val[3] = (T)pix.V;
    return scl;
}


template<typename T>
rgba_8 Scalar_to_rgba_8(Scalar<4, T> scl) {
#pragma HLS inline
 rgba_8 pix;
    pix.A = (char)scl.val[0];
    pix.R = (unsigned char)scl.val[1];
    pix.G = (unsigned char)scl.val[2];
    pix.B = (unsigned char)scl.val[3];
    return pix;
}
template<typename T>
Scalar<4, T> rgba_8_to_Scalar(rgba_8 pix) {
#pragma HLS inline
 Scalar<4, T> scl;
    scl.val[0] = (T)pix.A;
    scl.val[1] = (T)pix.R;
    scl.val[2] = (T)pix.G;
    scl.val[3] = (T)pix.B;
    return scl;
}


template<typename T>
yuva420_8 Scalar_to_yuva420_8(Scalar<2, T> scl) {
#pragma HLS inline
 yuva420_8 pix;
    pix.AUV = (char)scl.val[0];
    pix.Y = (unsigned char)scl.val[1];
    return pix;
}
template<typename T>
Scalar<2, T> yuva420_8_to_Scalar(yuva420_8 pix) {
#pragma HLS inline
 Scalar<2, T> scl;
    scl.val[0] = (T)pix.AUV;
    scl.val[1] = (T)pix.Y;
    return scl;
}


template<typename T>
yuvd422_8 Scalar_to_yuvd422_8(Scalar<3, T> scl) {
#pragma HLS inline
 yuvd422_8 pix;
    pix.D = (unsigned char)scl.val[0];
    pix.Y = (unsigned char)scl.val[1];
    pix.UV = (char)scl.val[2];
    return pix;
}
template<typename T>
Scalar<3, T> yuvd422_8_to_Scalar(yuvd422_8 pix) {
#pragma HLS inline
 Scalar<3, T> scl;
    scl.val[0] = (T)pix.D;
    scl.val[1] = (T)pix.Y;
    scl.val[2] = (T)pix.UV;
    return scl;
}


template<typename T>
yuvd444_8 Scalar_to_yuvd444_8(Scalar<4, T> scl) {
#pragma HLS inline
 yuvd444_8 pix;
    pix.D = (unsigned char)scl.val[0];
    pix.Y = (unsigned char)scl.val[1];
    pix.U = (char)scl.val[2];
    pix.V = (char)scl.val[3];
    return pix;
}
template<typename T>
Scalar<4, T> yuvd444_8_to_Scalar(yuvd444_8 pix) {
#pragma HLS inline
 Scalar<4, T> scl;
    scl.val[0] = (T)pix.D;
    scl.val[1] = (T)pix.Y;
    scl.val[2] = (T)pix.U;
    scl.val[3] = (T)pix.V;
    return scl;
}


template<typename T>
rgbd_8 Scalar_to_rgbd_8(Scalar<4, T> scl) {
#pragma HLS inline
 rgbd_8 pix;
    pix.D = (unsigned char)scl.val[0];
    pix.R = (unsigned char)scl.val[1];
    pix.G = (unsigned char)scl.val[2];
    pix.B = (unsigned char)scl.val[3];
    return pix;
}
template<typename T>
Scalar<4, T> rgbd_8_to_Scalar(rgbd_8 pix) {
#pragma HLS inline
 Scalar<4, T> scl;
    scl.val[0] = (T)pix.D;
    scl.val[1] = (T)pix.R;
    scl.val[2] = (T)pix.G;
    scl.val[3] = (T)pix.B;
    return scl;
}


template<typename T>
bayer_8 Scalar_to_bayer_8(Scalar<1, T> scl) {
#pragma HLS inline
 bayer_8 pix;
    pix.CMY = (unsigned char)scl.val[0];
    return pix;
}
template<typename T>
Scalar<1, T> bayer_8_to_Scalar(bayer_8 pix) {
#pragma HLS inline
 Scalar<1, T> scl;
    scl.val[0] = (T)pix.CMY;
    return scl;
}


template<typename T>
luma_8 Scalar_to_luma_8(Scalar<1, T> scl) {
#pragma HLS inline
 luma_8 pix;
    pix.Y = (unsigned char)scl.val[0];
    return pix;
}
template<typename T>
Scalar<1, T> luma_8_to_Scalar(luma_8 pix) {
#pragma HLS inline
 Scalar<1, T> scl;
    scl.val[0] = (T)pix.Y;
    return scl;
}


template<int ROWS, int COLS, int T>
class Mat {
public:
    Mat();
    Mat(int _rows, int _cols);
    Mat(Size _sz);

    void init(int _rows, int _cols);
    void assignto(Mat<ROWS, COLS, T>& mat);

    Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> read();

    void read(Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name>& s);
    template <typename T2>
    typename eqwt<typename Type<((T) & ((1 << 11) - 1))>::name,T2>::type read(Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), T2>& s){
#pragma HLS inline
 s = read();
    }

    void write(Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> s);
    template<typename T2>
    typename eqwt<typename Type<((T) & ((1 << 11) - 1))>::name,T2>::type write(Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), T2> s) {
#pragma HLS inline
#pragma HLS data_pack variable=data_stream
 HLS_CHANNEL_T i;
        {



#pragma HLS protocol floating
 VITIS_LOOP_605_1: for (i = 0; i < ((((T) & ((512 - 1) << 11)) >> 11) + 1); i++) {
#pragma HLS unroll
 data_stream[i] << s.val[i];
            }
        }
    }

   void operator >> (Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name>& s);
    template <typename T2>
    typename eqwt<typename Type<((T) & ((1 << 11) - 1))>::name,T2>::type operator >> (Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), T2>& s) {
#pragma HLS inline
 s = read();
    }

    void operator << (Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> s);
    template<typename T2>
    typename eqwt<typename Type<((T) & ((1 << 11) - 1))>::name,T2>::type operator << (Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), T2> s) {
#pragma HLS inline
 write(s);
    }

    bool empty();

    const int type() const;
    const int depth() const;
    const int channels() const;

    HLS_SIZE_T rows, cols;

    hls::stream<typename Type<((T) & ((1 << 11) - 1))>::name> data_stream[((((T) & ((512 - 1) << 11)) >> 11) + 1)];
};


template<int ROWS, int COLS, int T>
inline Mat<ROWS, COLS, T>::Mat() {
#pragma HLS inline
 init(ROWS, COLS);
}

template<int ROWS, int COLS, int T>
inline Mat<ROWS, COLS, T>::Mat(int _rows, int _cols) {
#pragma HLS inline
 init(_rows, _cols);
}

template<int ROWS, int COLS, int T>
inline Mat<ROWS, COLS, T>::Mat(Size _sz) {
#pragma HLS inline
 init(_sz.height, _sz.width);
}

template<int ROWS, int COLS, int T>
inline void Mat<ROWS, COLS, T>::init(int _rows, int _cols) {
#pragma HLS inline
 (void) ((!!((_rows > 0) && (_rows <= ROWS) && (_cols > 0) && (_cols <= COLS) && "The number of rows and columns must be less than the template arguments.")) || (_assert("(_rows > 0) && (_rows <= ROWS) && (_cols > 0) && (_cols <= COLS) && \"The number of rows and columns must be less than the template arguments.\"","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_core.h",660),0));

    rows = _rows;
    cols = _cols;
}

template<int ROWS, int COLS, int T>
void Mat<ROWS, COLS, T>::assignto(Mat<ROWS, COLS, T>& mat) {
#pragma HLS inline
 mat.rows = rows;
    mat.cols = cols;
}

template<int ROWS, int COLS, int T>
Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> Mat<ROWS, COLS, T>::read() {
#pragma HLS inline
 Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> scl;
    HLS_CHANNEL_T i;
    {



#pragma HLS protocol floating
 VITIS_LOOP_682_1: for (i = 0; i < ((((T) & ((512 - 1) << 11)) >> 11) + 1); i++) {
#pragma HLS unroll
 data_stream[i] >> scl.val[i];
        }
    }
    return scl;
}

template<int ROWS, int COLS, int T>
void Mat<ROWS, COLS, T>::read(Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name>& s) {
#pragma HLS inline
 s = read();
}

template<int ROWS, int COLS, int T>
void Mat<ROWS, COLS, T>::write(Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> s) {
#pragma HLS inline
#pragma HLS data_pack variable=data_stream
 HLS_CHANNEL_T i;
    {



#pragma HLS protocol floating
 VITIS_LOOP_706_1: for (i = 0; i < ((((T) & ((512 - 1) << 11)) >> 11) + 1); i++) {
#pragma HLS unroll
 data_stream[i] << s.val[i];
        }
    }
}

template<int ROWS, int COLS, int T>
void Mat<ROWS, COLS, T>::operator >> (Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name>& s) {
#pragma HLS inline
 s = read();
}

template<int ROWS, int COLS, int T>
void Mat<ROWS, COLS, T>::operator << (Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> s) {
#pragma HLS inline
 write(s);
}

template<int ROWS, int COLS, int T>
bool Mat<ROWS, COLS, T>::empty() {
#pragma HLS inline
 unsigned char flag = 0;
    VITIS_LOOP_729_1: for (HLS_CHANNEL_T i = 0; i < ((((T) & ((512 - 1) << 11)) >> 11) + 1); i++) {
#pragma HLS unroll
 flag += (data_stream[i].empty()) ? 1 : 0;
    }




    return ((flag == ((((T) & ((512 - 1) << 11)) >> 11) + 1)) ? true : false);
}

template<int ROWS, int COLS, int T>
const int Mat<ROWS, COLS, T>::type() const {
#pragma HLS inline
 return ((T) & ((1 << 11)*512 - 1));
}

template<int ROWS, int COLS, int T>
const int Mat<ROWS, COLS, T>::depth() const {
#pragma HLS inline
 return ((T) & ((1 << 11) - 1));
}
template<int ROWS, int COLS, int T>
const int Mat<ROWS, COLS, T>::channels() const {
#pragma HLS inline
 return ((((T) & ((512 - 1) << 11)) >> 11) + 1);
}

}
# 58 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src\\hls_video.h" 2
# 1 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgbase.h" 1
# 86 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgbase.h"
namespace hls {

enum {MORPH_RECT,MORPH_CROSS,MORPH_ELLIPSE};

class border_mode {
public:
    enum values {BORDER_CONSTANT,BORDER_REPLICATE,BORDER_REFLECT,BORDER_WRAP,BORDER_REFLECT_101};
    typedef void isBorderMode;
};

class BORDER_CONSTANT : public border_mode { public: static const values value = border_mode::BORDER_CONSTANT; };
class BORDER_REPLICATE : public border_mode { public: static const values value = border_mode::BORDER_REPLICATE; };
class BORDER_REFLECT : public border_mode { public: static const values value = border_mode::BORDER_REFLECT; };
class BORDER_WRAP : public border_mode { public: static const values value = border_mode::BORDER_WRAP; };
class BORDER_REFLECT_101 : public border_mode { public: static const values value = border_mode::BORDER_REFLECT_101; };
class BORDER_DEFAULT : public border_mode { public: static const values value = border_mode::BORDER_REFLECT_101; };
# 113 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgbase.h"
static int borderInterpolate( int p, int len, int borderType )
{
#pragma HLS INLINE
 (void) ((!!(borderType != BORDER_WRAP::value && "BORDER_WRAP is not supported.")) || (_assert("borderType != BORDER_WRAP::value && \"BORDER_WRAP is not supported.\"","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgbase.h",116),0));

    if( p >= 0 && p < len )
        return p;
    else if( borderType == BORDER_REPLICATE::value )
        p = p < 0 ? 0 : len - 1;
    else if( borderType == BORDER_REFLECT::value)
    {
        if( len == 1 )
            return 0;
        if(p<0)
        {
            p=-p-1;
        }
        if( p >= len )
        {
            p=2*len-p-1;
        }
    }
    else if(borderType == BORDER_REFLECT_101::value )
    {
        if( len == 1 )
            return 0;
        if(p<0)
        {

            p=-p;
        }
        if( p >= len )
        {

            p=2*len-p-2;
        }
    }

    else if( borderType == BORDER_CONSTANT::value )
        p = -1;
    return p;
}

template <typename anchor_T,typename kernel_T>
inline void normalizeAnchor(
        hls::Point_<anchor_T> &anchor,
        hls::Size_<kernel_T> kernel_size)
{
#pragma HLS INLINE
 if(anchor.x==-1)
        anchor.x=kernel_size.width/2;
    if(anchor.y==-1)
        anchor.y=kernel_size.height/2;

    (void) ((!!(anchor.x>=0)) || (_assert("anchor.x>=0","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgbase.h",167),0));
    (void) ((!!(anchor.x<=kernel_size.width-1)) || (_assert("anchor.x<=kernel_size.width-1","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgbase.h",168),0));
    (void) ((!!(anchor.y>=0)) || (_assert("anchor.y>=0","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgbase.h",169),0));
    (void) ((!!(anchor.y<=kernel_size.height-1)) || (_assert("anchor.y<=kernel_size.height-1","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgbase.h",170),0));
}
template<int SRC_T,int ROWS,int COLS>
void DuplicateImageN(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, SRC_T> _dst[],
  int num
                )
{
    int cols=_src.cols;
    int rows=_src.rows;
 loop_size: for(int k=0;k<num;k++) {
        _dst[k].rows=rows;
        _dst[k].cols=cols;
    }
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
 loop_height: for(int i= 0;i<rows;i++)
 {
#pragma HLS LOOP_TRIPCOUNT min=20 max=2000
 loop_width: for (int j= 0;j<cols;j++)
#pragma HLS LOOP_TRIPCOUNT min=20 max=2000
 {
#pragma HLS PIPELINE
 _src >> s;
                        VITIS_LOOP_194_1: for(int k=0;k<num;k++)
                        _dst[k] << s;
                }
        }
}
}
# 59 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src\\hls_video.h" 2
# 1 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_io.h" 1
# 41 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_io.h"
namespace hls {
# 50 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_io.h"
template<int W, int ROWS, int COLS, int T>
int AXIvideo2Mat(stream<ap_axiu<W,1,1,1> >& AXI_video_strm,
                 Mat<ROWS, COLS, T>& img)
{
    int res = 0;
    ap_axiu<W,1,1,1> axi;
    Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> pix;
    int depth = Type<((T) & ((1 << 11) - 1))>::bitdepth;

    (void) ((!!(W >= depth*((((T) & ((512 - 1) << 11)) >> 11) + 1) && "Bit-Width of AXI stream must be greater than the total number of bits in a pixel")) || (_assert("W >= depth*HLS_MAT_CN(T) && \"Bit-Width of AXI stream must be greater than the total number of bits in a pixel\"","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_io.h",59),0));
    HLS_SIZE_T rows = img.rows;
    HLS_SIZE_T cols = img.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_io.h",62),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_io.h",63),0));
    bool sof = 0;
 loop_wait_for_start: while (!sof) {
#pragma HLS pipeline II=1
#pragma HLS loop_tripcount avg=0 max=0
 AXI_video_strm >> axi;
        sof = axi.user.to_int();
    }
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
        bool eol = 0;
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
 if (sof || eol) {
                sof = 0;
                eol = axi.last.to_int();
            } else {

                AXI_video_strm >> axi;
                eol = axi.last.to_int();
                bool user = axi.user.to_int();
                if(user) {
                    res |= (1 << 0);
                }
            }
            if (eol && (j != cols-1)) {
                res |= (1 << 0);
            }
        loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                AXIGetBitFields(axi, k*depth, depth, pix.val[k]);
            }
            img << pix;
        }
    loop_wait_for_eol: while (!eol) {
#pragma HLS pipeline II=1
#pragma HLS loop_tripcount avg=0 max=0

 AXI_video_strm >> axi;
            eol = axi.last.to_int();
            res |= (1 << 1);
        }
    }
    return res;
}



template<int W, int ROWS, int COLS, int T>
int Mat2AXIvideo(Mat<ROWS, COLS, T>& img,
                 stream<ap_axiu<W,1,1,1> >& AXI_video_strm)
{
    int res = 0;
    Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> pix;
    ap_axiu<W,1,1,1> axi;
    int depth = Type<((T) & ((1 << 11) - 1))>::bitdepth;

    (void) ((!!(W >= depth*((((T) & ((512 - 1) << 11)) >> 11) + 1) && "Bit-Width of AXI stream must be greater than the total number of bits in a pixel")) || (_assert("W >= depth*HLS_MAT_CN(T) && \"Bit-Width of AXI stream must be greater than the total number of bits in a pixel\"","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_io.h",119),0));
    HLS_SIZE_T rows = img.rows;
    HLS_SIZE_T cols = img.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_io.h",122),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_io.h",123),0));
    bool sof = 1;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
 if (sof) {
                axi.user = 1;
                sof = 0;
            } else {
                axi.user = 0;
            }
            if (j == (cols-1)) {
                axi.last = 1;
            } else {
                axi.last = 0;
            }
            img >> pix;
            axi.data = -1;
        loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                AXISetBitFields(axi, k*depth, depth, pix.val[k]);
            }
            axi.keep = -1;
            AXI_video_strm << axi;
        }
    }
    return res;
}




template <int FB_COLS, typename FB_T, int ROWS, int COLS, int T>
int Array2Mat(FB_T fb[ROWS*FB_COLS], int rowStride,
             Mat<ROWS, COLS, T>& img)
{
    int res = 0;
    HLS_SIZE_T rows = img.rows;
    HLS_SIZE_T cols = img.cols;
    (void) ((!!(cols <= rowStride)) || (_assert("cols <= rowStride","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_io.h",162),0));
    (void) ((!!(rowStride <= FB_COLS)) || (_assert("rowStride <= FB_COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_io.h",163),0));
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_io.h",164),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_io.h",165),0));
    (void) ((!!(COLS <= FB_COLS)) || (_assert("COLS <= FB_COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_io.h",166),0));
    int fb_BitWidth = Type_BitWidth<FB_T>::Value;
    int depth = Type<((T) & ((1 << 11) - 1))>::bitdepth;
    int ch = ((((T) & ((512 - 1) << 11)) >> 11) + 1);
    (void) ((!!(fb_BitWidth >= ch*depth && "Bit-Width of frame buffer must be greater than the total number of bits in a pixel")) || (_assert("fb_BitWidth >= ch*depth && \"Bit-Width of frame buffer must be greater than the total number of bits in a pixel\"","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_io.h",170),0));
    HLS_SIZE_T col = 0;
    Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> pix;
loop_pixel:
    for (HLS_SIZE_T row = 0; row < rows; row++) {
        VITIS_LOOP_175_1: for (HLS_SIZE_T col = 0; col < cols; col++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
 FB_T fb_pix = fb[row*rowStride+col];
            ap_uint<((((T) & ((512 - 1) << 11)) >> 11) + 1)*Type<((T) & ((1 << 11) - 1))>::bitdepth> pix_value;
            AXISetBitFields(pix_value, 0, ((((T) & ((512 - 1) << 11)) >> 11) + 1)*Type<((T) & ((1 << 11) - 1))>::bitdepth, fb_pix);
loop_channels:
            for (HLS_CHANNEL_T k = 0; k < ((((T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
#pragma HLS unroll
 AXIGetBitFields(pix_value, k*depth, depth, pix.val[k]);
            }
            img << pix;
        }
    }
    return res;
}

template <int FB_COLS, typename FB_T, int ROWS, int COLS, int T>
int Array2Mat(FB_T fb[ROWS*FB_COLS],
              Mat<ROWS, COLS, T>& img)
{
    int res = 0;
    res=Array2Mat<FB_COLS>(fb, FB_COLS, img);
    return res;
}

template <int FB_COLS, typename FB_T, int ROWS, int COLS, int T>
int AXIM2Mat(FB_T fb[ROWS*FB_COLS],
             Mat<ROWS, COLS, T>& img)
{
    int res = 0;
    res=Array2Mat<FB_COLS>(fb, FB_COLS, img);
    return res;
}

template <int FB_COLS, typename FB_T, int ROWS, int COLS, int T>
int AXIM2Mat(FB_T fb[ROWS*FB_COLS], int rowStride,
             Mat<ROWS, COLS, T>& img)
{
    int res = 0;
    res=Array2Mat<FB_COLS>(fb, rowStride, img);
    return res;
}



template <int FB_COLS, typename FB_T, int ROWS, int COLS, int T>
int Mat2Array(Mat<ROWS, COLS, T>& img,
             FB_T fb[ROWS*FB_COLS], int rowStride)
{
    int res = 0;
    HLS_SIZE_T rows = img.rows;
    HLS_SIZE_T cols = img.cols;
    (void) ((!!(cols <= rowStride)) || (_assert("cols <= rowStride","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_io.h",228),0));
    (void) ((!!(rowStride <= FB_COLS)) || (_assert("rowStride <= FB_COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_io.h",229),0));
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_io.h",230),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_io.h",231),0));
    (void) ((!!(COLS <= FB_COLS)) || (_assert("COLS <= FB_COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_io.h",232),0));
    int fb_BitWidth = Type_BitWidth<FB_T>::Value;
    int depth = Type<((T) & ((1 << 11) - 1))>::bitdepth;
    int ch = ((((T) & ((512 - 1) << 11)) >> 11) + 1);
    (void) ((!!(fb_BitWidth >= ch*depth && "Bit-Width of frame buffer must be greater than the total number of bits in a pixel")) || (_assert("fb_BitWidth >= ch*depth && \"Bit-Width of frame buffer must be greater than the total number of bits in a pixel\"","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_io.h",236),0));
    HLS_SIZE_T col = 0;
    Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> pix;
loop_pixel:
    for (HLS_SIZE_T row = 0; row < rows; row++) {
        VITIS_LOOP_241_1: for (HLS_SIZE_T col = 0; col < cols; col++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
 ap_uint<((((T) & ((512 - 1) << 11)) >> 11) + 1)*Type<((T) & ((1 << 11) - 1))>::bitdepth> pix_value;
            img >> pix;
loop_channels:
            for (HLS_CHANNEL_T k = 0; k < ((((T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
#pragma HLS unroll
 AXISetBitFields(pix_value, k*depth, depth, pix.val[k]);
            }
            FB_T fb_pix;
            AXIGetBitFields(pix_value, 0, ((((T) & ((512 - 1) << 11)) >> 11) + 1)*Type<((T) & ((1 << 11) - 1))>::bitdepth, fb_pix);
            fb[row*rowStride+col] = fb_pix;
        }
    }
    return res;
}

template <int FB_COLS, typename FB_T, int ROWS, int COLS, int T>
int Mat2Array(Mat<ROWS, COLS, T>& img,
              FB_T fb[ROWS*FB_COLS])
{
    int res = 0;
    res=Mat2Array<FB_COLS>(img, fb, FB_COLS);
    return res;
}

template <int FB_COLS, typename FB_T, int ROWS, int COLS, int T>
int Mat2AXIM(Mat<ROWS, COLS, T>& img,
             FB_T fb[ROWS*FB_COLS])
{
    int res = 0;
    res=Mat2Array<FB_COLS>(img, fb, FB_COLS);
    return res;
}

template <int FB_COLS, typename FB_T, int ROWS, int COLS, int T>
int Mat2AXIM(Mat<ROWS, COLS, T>& img,
             FB_T fb[ROWS*FB_COLS], int rowStride)
{
    int res = 0;
    res=Mat2Array<FB_COLS>(img, fb, rowStride);
    return res;
}

}
# 60 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src\\hls_video.h" 2

# 1 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h" 1
# 88 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h"
namespace hls {
# 110 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h"
typedef ap_fixed<64,32,AP_RND> _AP_T;
typedef unsigned long long _SUM_T;

class kernel_min {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
#pragma HLS inline

 if(src1<src2) {
            dst=sr_cast<DST_T>(src1);
        } else {
            dst=sr_cast<DST_T>(src2);
        }
    }
};

class kernel_max {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
#pragma HLS inline

 if(src1>src2) {
            dst=sr_cast<DST_T>(src1);
        } else {
            dst=sr_cast<DST_T>(src2);
        }
    }
};

class kernel_absdiff {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
#pragma HLS inline
 typename pixel_op_type<SRC1_T>::T src1_cast = src1;
        typename pixel_op_type<SRC2_T>::T src2_cast = src2;
        typedef typename x_traits<typename pixel_op_type<SRC1_T>::T, typename pixel_op_type<SRC2_T>::T >::ADD_T TEMP_TYPE;
        TEMP_TYPE diff = src1_cast-src2_cast;
        TEMP_TYPE mdiff = src2_cast-src1_cast;
        dst = sr_cast<DST_T>((src1_cast > src2_cast) ? diff : mdiff);
    }
};

template<typename P_T, typename SRC1_T, typename SRC2_T, typename DST_T>
void kernel_and_apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst) {
#pragma HLS inline
 dst = (sr_cast<DST_T>(src1)) & (sr_cast<DST_T>(src2));
}

template<typename P_T>
void kernel_and_apply(float& src1, float& src2, float& dst) {
#pragma HLS inline
 fp_struct<float> src1_fp(src1);
    fp_struct<float> src2_fp(src2);
    unsigned int dst_tmp = src1_fp.to_int() & src2_fp.to_int();
    fp_struct<float> dst_fp(dst_tmp);
    dst = dst_fp.to_float();
}

class kernel_and {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
#pragma HLS inline
 kernel_and_apply<P_T>(src1, src2, dst);
    }
};

class kernel_not {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src, SRC2_T& val, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
#pragma HLS inline
 dst = ~(sr_cast<DST_T>(src));
    }
};

class kernel_set {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src, SRC2_T& val, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
#pragma HLS inline
 dst = sr_cast<DST_T>(val);
    }
};

class kernel_scale {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src, SRC2_T& val, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
#pragma HLS inline
 typedef typename x_traits<typename pixel_op_type<SRC1_T>::T, typename pixel_op_type<P_T>::T>::MULT_T MULT_T;
        typedef typename x_traits<typename pixel_op_type<P_T>::T, MULT_T>::ADD_T ADD_T;
        MULT_T mult_t=(typename pixel_op_type<SRC1_T>::T)src * (typename pixel_op_type<P_T>::T)p0;
        ADD_T sum_t=mult_t + (typename pixel_op_type<P_T>::T)p1;

        dst = sr_cast<DST_T>(sum_t);
    }
};

class kernel_add {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
#pragma HLS inline
 typename x_traits<typename pixel_op_type<SRC1_T>::T, typename pixel_op_type<SRC2_T>::T>::ADD_T t =
            (typename pixel_op_type<SRC1_T>::T)src1 + (typename pixel_op_type<SRC2_T>::T)src2;
        dst = sr_cast<DST_T>(t);
    }
};

class kernel_sub {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
#pragma HLS inline
 typename x_traits<typename pixel_op_type<SRC1_T>::T, typename pixel_op_type<SRC2_T>::T>::SUB_T t =
            (typename pixel_op_type<SRC1_T>::T)src1 - (typename pixel_op_type<SRC2_T>::T)src2;
        dst = sr_cast<DST_T>(t);
    }
};

class kernel_subR {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
#pragma HLS inline
 typename x_traits<typename pixel_op_type<SRC1_T>::T, typename pixel_op_type<SRC2_T>::T>::SUB_T t =
            (typename pixel_op_type<SRC2_T>::T)src2 - (typename pixel_op_type<SRC1_T>::T)src1;
        dst = sr_cast<DST_T>(t);
    }
};

class kernel_mul {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T, typename P2_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P2_T p1=0, P2_T p2=0) {
#pragma HLS inline
 typedef typename x_traits<typename pixel_op_type<SRC1_T>::T, typename pixel_op_type<SRC2_T>::T>::MULT_T MULT_T;
        MULT_T t1 = (typename pixel_op_type<SRC1_T>::T)src1 * (typename pixel_op_type<SRC2_T>::T)src2;
        typename x_traits<MULT_T, typename pixel_op_type<P_T>::T>::MULT_T t2 = t1 * (typename pixel_op_type<P_T>::T)p0;

        dst = sr_cast<DST_T>(t2);
    }
};

class kernel_mul2 {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
#pragma HLS inline
 typename x_traits<typename pixel_op_type<SRC1_T>::T, typename pixel_op_type<SRC2_T>::T>::MULT_T t =
            (typename pixel_op_type<SRC1_T>::T)src1 * (typename pixel_op_type<SRC2_T>::T)src2;

        dst = sr_cast<DST_T>(t);
    }
};

class kernel_addWeighted {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
#pragma HLS inline
 typedef typename x_traits<typename pixel_op_type<SRC1_T>::T, typename pixel_op_type<P_T>::T>::MULT_T MULT_T1;
        MULT_T1 t1 = (typename pixel_op_type<SRC1_T>::T)src1 * (typename pixel_op_type<P_T>::T)p0;
        typedef typename x_traits<typename pixel_op_type<SRC2_T>::T, typename pixel_op_type<P_T>::T>::MULT_T MULT_T2;
        MULT_T2 t2 = (typename pixel_op_type<SRC2_T>::T)src2 * (typename pixel_op_type<P_T>::T)p1;
        typedef typename x_traits<MULT_T1, MULT_T2>::ADD_T ADD_T;
        ADD_T sum = t1 + t2 + p2;

        dst = sr_cast<DST_T>(sum);
    }
};

class kernel_cmp {
public:
    template<typename SRC1_T, typename SRC2_T, typename DST_T, typename P_T>
    static void apply(SRC1_T& src1, SRC2_T& src2, DST_T& dst, P_T p0=0, P_T p1=0, P_T p2=0) {
#pragma HLS inline
 switch (p0) {
            case 0:
            dst = (src1==src2 ? 255 : 0);
            break;
            case 1:
            dst = (src1 >src2 ? 255 : 0);
            break;
            case 2:
            dst = (src1>=src2 ? 255 : 0);
            break;
            case 3:
            dst = (src1 <src2 ? 255 : 0);
            break;
            case 4:
            dst = (src1<=src2 ? 255 : 0);
            break;
            case 5:
            dst = (src1!=src2 ? 255 : 0);
            break;
            default:
            break;
        }
    }
};

class kernel_sum {
public:
    template<typename SRC_T>
    static void apply(SRC_T& s, _SUM_T& sum, _SUM_T& sqsum) {
#pragma HLS inline
 sum = sum+(_SUM_T)s;
    }
};

class kernel_avgsdv {
public:
    template<typename SRC_T>
    static void apply(SRC_T& s, _SUM_T& sum, _SUM_T& sqsum) {
#pragma HLS inline
 sum=sum+ (_SUM_T)s;
        sqsum=sqsum+ ((_SUM_T)s*(_SUM_T)s);
    }
};



template<typename KERNEL, int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T, typename P0_T, typename P1_T, typename P2_T>
void arithm_pro(
            Mat<ROWS, COLS, SRC1_T>& src1,
            Mat<ROWS, COLS, SRC2_T>& src2,
            Mat<ROWS, COLS, DST_T>& dst,
            P0_T p0=0,
            P1_T p1=0,
            P2_T p2=0)
{
    KERNEL opr;
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",349),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",350),0));
    Scalar<((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC1_T) & ((1 << 11) - 1))>::name> s1;
    Scalar<((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC2_T) & ((1 << 11) - 1))>::name> s2;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name > d;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
 src1 >> s1;
            src2 >> s2;
        loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                opr.template apply(s1.val[k], s2.val[k], d.val[k], p0, p1, p2);
            }
            dst << d;
        }
    }
}


template<typename KERNEL, int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
void arithm_pro(
            Mat<ROWS, COLS, SRC1_T>& src1,
            Mat<ROWS, COLS, SRC2_T>& src2,
            Mat<ROWS, COLS, DST_T>& dst,
            Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask,
            Mat<ROWS, COLS, DST_T>& dst_ref)
{
    KERNEL opr;
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",380),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",381),0));
    Scalar<((((SRC1_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC1_T) & ((1 << 11) - 1))>::name> s1;
    Scalar<((((SRC2_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC2_T) & ((1 << 11) - 1))>::name> s2;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d_ref, d;
    Scalar<1, unsigned char> m;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
 src1 >> s1;
            src2 >> s2;
            mask >> m;
            dst_ref >> d_ref;
        loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                if (m.val[0] == 0) {
                    d.val[k] = d_ref.val[k];
                } else {
                    opr.template apply(s1.val[k], s2.val[k], d.val[k]);
                }
            }
            dst << d;
        }
    }
}



template<typename KERNEL, int ROWS, int COLS, int SRC_T, typename _T, int DST_T, typename P0_T, typename P1_T, typename P2_T>
void arithm_pro(
            Mat<ROWS, COLS, SRC_T>& src,
            Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
            Mat<ROWS, COLS, DST_T>& dst,
            P0_T p0=0,
            P1_T p1=0,
            P2_T p2=0)
{
    KERNEL opr;
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",420),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",421),0));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> _s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    _s = scl;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
 src >> s;
        loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {

                opr.template apply(s.val[k], _s.val[k], d.val[k], p0, p1, p2);

            }
            dst << d;
        }
    }
}


template<typename KERNEL, int ROWS, int COLS, typename _T, int DST_T, typename P0_T, typename P1_T, typename P2_T>
void arithm_pro(
            Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
            Mat<ROWS, COLS, DST_T>& dst,
            P0_T p0=0,
            P1_T p1=0,
            P2_T p2=0)
{
    KERNEL opr;
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",453),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",454),0));
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), _T> _s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    _s = scl;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
 _T s = 0;
        loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                opr.template apply(s, _s.val[k], d.val[k], p0, p1, p2);
            }
            dst << d;
        }
    }
}


template<typename KERNEL, int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void arithm_pro(
            Mat<ROWS, COLS, SRC_T>& src,
            Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
            Mat<ROWS, COLS, DST_T>& dst,
            Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask,
            Mat<ROWS, COLS, DST_T>& dst_ref)
{
    KERNEL opr;
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",483),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",484),0));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> _s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d_ref, d;
    Scalar<1, unsigned char> m;
    _s = scl;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
 src >> s;
            mask >> m;
            dst_ref >> d_ref;
        loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                if (m.val[0] == 0) {
                    d.val[k] = d_ref.val[k];
                } else {

                    opr.template apply(s.val[k], _s.val[k], d.val[k]);

                }
            }
            dst << d;
        }
    }
}


template<typename KERNEL, int ROWS, int COLS, int SRC_T>
void arithm_pro(
            Mat<ROWS, COLS, SRC_T>& src,
            Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T>& sum,
            Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T>& sqsum)
{
    KERNEL opr;
    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",521),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",522),0));
 loop_init: for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
#pragma HLS unroll
 sum.val[k] = 0;
        sqsum.val[k] = 0;
    }
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
 src >> s;
        loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                opr.template apply(s.val[k], sum.val[k], sqsum.val[k]);
            }
        }
    }
}


template<typename KERNEL, int ROWS, int COLS, int SRC_T>
void arithm_pro(
            Mat<ROWS, COLS, SRC_T>& src,
            Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T>& sum,
            Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T>& sqsum,
            int& ncount,
            Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask)
{
    KERNEL opr;
    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",553),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",554),0));
 loop_init: for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
#pragma HLS unroll
 sum.val[k] = 0;
        sqsum.val[k] = 0;
    }
    ncount = 0;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<1, unsigned char> m;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
 src >> s;
            mask >> m;
            if (m.val[0]) {
            loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                    opr.template apply(s.val[k], sum.val[k], sqsum.val[k]);
                }
                ncount++;
            }
        }
    }
}


template<typename INTER_SUM_T, int ROWS, int COLS, int SRC_T, int DST_ROWS, int DST_COLS, int DST_T>
void reduce_opr(
        Mat<ROWS, COLS, SRC_T> &src,
        Mat<DST_ROWS, DST_COLS, DST_T> &dst,
        int dim,
        int op=1)
{
    LineBuffer<1,DST_COLS,INTER_SUM_T> dst_buffer[((((DST_T) & ((512 - 1) << 11)) >> 11) + 1)];
#pragma HLS ARRAY_PARTITION variable=dst_buffer complete dim=1
#pragma HLS ARRAY_PARTITION variable=dst_buffer complete dim=2
 HLS_SIZE_T rows=src.rows;
    HLS_SIZE_T cols=src.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",592),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",593),0));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),INTER_SUM_T> internal;
 loop_init: for(HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
#pragma HLS unroll
 internal.val[k]=0;
    }
 loop_height: for(HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
 loop_channels: for(HLS_CHANNEL_T k= 0;k< ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);k++) {
                typename Type<((SRC_T) & ((1 << 11) - 1))>::name src_val;
                src.data_stream[k]>>src_val;
                if(dim==0) {
                    if(i!=0) {
                        internal.val[k]=(INTER_SUM_T)dst_buffer[k].val[i][0];
                    } else {
                        if(op==1||op==2)
                            internal.val[k]=0;
                        else if(op==3||op==4)
                            internal.val[k]=src_val;
                    }
                }
                switch (op) {
                    case 1:
                    internal.val[k]=internal.val[k]+src_val;
                    break;
                    case 2:
                    internal.val[k]=internal.val[k]+src_val;
                    break;
                    case 3:
                    internal.val[k]=(internal.val[k]>(INTER_SUM_T)src_val?internal.val[k]:src_val);
                    break;
                    case 4:
                    internal.val[k]=(internal.val[k]<(INTER_SUM_T)src_val?internal.val[k]:src_val);
                    break;
  }
                if(dim==0) {
                    if(i==rows-1) {
                        if(op==2)
                            dst.data_stream[k] << ((typename Type<((DST_T) & ((1 << 11) - 1))>::name)internal.val[k])/rows;
                        else
                            dst.data_stream[k]<< (typename Type<((DST_T) & ((1 << 11) - 1))>::name)internal.val[k];
                    } else {
                        dst_buffer[k].val[i][0]=internal.val[k];
                    }
                }
            }
            if(dim==1&&j==cols-1) {
            loop_output: for(HLS_CHANNEL_T k=0;k<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);k++) {
                    if(op==2) {
                        dst.data_stream[k] << ((typename Type<((DST_T) & ((1 << 11) - 1))>::name)internal.val[k])/cols;
                    } else {
                        dst.data_stream[k] << (typename Type<((DST_T) & ((1 << 11) - 1))>::name)internal.val[k];
                    }
                    internal.val[k]=0;
                }
            }
        }
    }
}



template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
void Min(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst)
{
# 671 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h"
    arithm_pro<kernel_min>(src1, src2, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
void Max(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst)
{
# 688 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h"
    arithm_pro<kernel_max>(src1, src2, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void MinS(
        Mat<ROWS, COLS, SRC_T>& src,
        _T value,
        Mat<ROWS, COLS, DST_T>& dst)
{






    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl;
 loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
#pragma HLS unroll
 scl.val[k] = (value);
    }
    arithm_pro<kernel_min>(src, scl, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void MaxS(
        Mat<ROWS, COLS, SRC_T>& src,
        _T value,
        Mat<ROWS, COLS, DST_T>& dst)
{






    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl;
 loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
#pragma HLS unroll
 scl.val[k] = (value);
    }
    arithm_pro<kernel_max>(src, scl, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void AddS(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
        Mat<ROWS, COLS, DST_T>& dst)
{






    arithm_pro<kernel_add>(src, scl, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void AddS(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
        Mat<ROWS, COLS, DST_T>& dst,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask,
        Mat<ROWS, COLS, DST_T>& dst_ref)
{






    arithm_pro<kernel_add>(src, scl, dst, mask, dst_ref);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void SubS(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
        Mat<ROWS, COLS, DST_T>& dst)
{






    arithm_pro<kernel_sub>(src, scl, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void SubS(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
        Mat<ROWS, COLS, DST_T>& dst,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask,
        Mat<ROWS, COLS, DST_T>& dst_ref)
{






    arithm_pro<kernel_sub>(src, scl, dst, mask, dst_ref);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void SubRS(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
        Mat<ROWS, COLS, DST_T>& dst)
{






    arithm_pro<kernel_subR>(src, scl, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void SubRS(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
        Mat<ROWS, COLS, DST_T>& dst,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask,
        Mat<ROWS, COLS, DST_T>& dst_ref)
{






    arithm_pro<kernel_subR>(src, scl, dst, mask, dst_ref);
}

template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T, typename P_T>
void Mul(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst,
        P_T scale)
{
# 842 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h"
    arithm_pro<kernel_mul>(src1, src2, dst, scale, (typename Type<((DST_T) & ((1 << 11) - 1))>::name)0, (typename Type<((DST_T) & ((1 << 11) - 1))>::name)0);
}

template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
void Mul(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst)
{
# 859 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h"
    arithm_pro<kernel_mul2>(src1, src2, dst, (typename Type<((DST_T) & ((1 << 11) - 1))>::name)0, (typename Type<((DST_T) & ((1 << 11) - 1))>::name)0, (typename Type<((DST_T) & ((1 << 11) - 1))>::name)0);
}

template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T, typename P_T>
void AddWeighted(
        Mat<ROWS, COLS, SRC1_T>& src1,
        P_T alpha,
        Mat<ROWS, COLS, SRC2_T>& src2,
        P_T beta,
        P_T gamma,
        Mat<ROWS, COLS, DST_T>& dst)
{
# 879 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h"
    arithm_pro<kernel_addWeighted>(src1, src2, dst, alpha, beta, gamma);
}

template<int ROWS, int COLS, int SRC_T, int DST_T, typename P_T>
void Scale(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst,
        P_T scale=1.0,
        P_T shift=0.0)
{






    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> scl;
    arithm_pro<kernel_scale>(src, scl, dst, scale, shift, (P_T)0);
}

template<int ROWS, int COLS, int SRC_T, typename _T, int DST_T>
void Set(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
        Mat<ROWS, COLS, DST_T>& dst)
{






    arithm_pro<kernel_set>(src, scl, dst, 0, 0, 0);
}

template<int ROWS, int COLS, typename _T, int DST_T>
void Set(
        Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), _T> scl,
        Mat<ROWS, COLS, DST_T>& dst)
{
    arithm_pro<kernel_set>(scl, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Zero(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst)
{
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s0;
 loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
#pragma HLS unroll
 s0.val[k] = 0;
    }
    arithm_pro<kernel_set>(src, s0, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int DST_T>
void Zero(
        Mat<ROWS, COLS, DST_T>& dst)
{
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> s0;
 loop_channels: for (HLS_CHANNEL_T k = 0; k < ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
#pragma HLS unroll
 s0.val[k] = 0;
    }
    arithm_pro<kernel_set>(s0, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
void AbsDiff(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst)
{
# 961 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h"
    arithm_pro<kernel_absdiff>(src1, src2, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Not(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst)
{






    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> scl;
    arithm_pro<kernel_not>(src, scl, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
void Cmp(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst,
        int cmp_op)
{
# 994 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h"
    arithm_pro<kernel_cmp>(src1, src2, dst, cmp_op, 0, 0);
}

template<int ROWS, int COLS, int SRC_T, typename P_T, int DST_T>
void CmpS(
        Mat<ROWS, COLS, SRC_T>& src,
        P_T value,
        Mat<ROWS, COLS, DST_T>& dst,
        int cmp_op)
{






    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), P_T> scl;
    VITIS_LOOP_1011_1: for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
#pragma HLS unroll
 scl.val[k] = (value);
    }
    arithm_pro<kernel_cmp>(src, scl, dst, cmp_op, 0, 0);
}

template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
void And(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst)
{
# 1032 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h"
    arithm_pro<kernel_and>(src1, src2, dst, 0, 0, 0);
}

template<int ROWS, int COLS, int SRC1_T, int SRC2_T, int DST_T>
void And(
        Mat<ROWS, COLS, SRC1_T>& src1,
        Mat<ROWS, COLS, SRC2_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask,
        Mat<ROWS, COLS, DST_T>& dst_ref)
{
# 1051 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h"
    arithm_pro<kernel_and>(src1, src2, dst, mask, dst_ref);
}

template<typename INTER_SUM_T, int ROWS, int COLS, int SRC_T, int DST_ROWS, int DST_COLS, int DST_T>
void Reduce(
         Mat<ROWS, COLS, SRC_T> &src,
         Mat<DST_ROWS, DST_COLS, DST_T> &dst,
         int dim,
         int op=1)
{
    reduce_opr<INTER_SUM_T>(src, dst, dim, op);
}

template<int ROWS, int COLS, int SRC_T, int DST_T, typename P_T>
void Range(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst,
        P_T start,
        P_T end)
{
# 1079 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h"
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",1081),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",1082),0));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    _AP_T _dis = end-start;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
 src >> s;
            VITIS_LOOP_1091_1: for (HLS_CHANNEL_T k = 0; k < ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                d.val[k] = _dis*(i*cols+j)/(rows*cols);
            }
            dst << d;
        }
    }
}

template<typename DST_T, int ROWS, int COLS, int SRC_T>
Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), DST_T> Sum(
        Mat<ROWS, COLS, SRC_T>& src)
{
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T> sum, sqsum;
    int ncount = src.rows * src.cols;
    arithm_pro<kernel_sum>(src, sum, sqsum);
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), DST_T> res;
    VITIS_LOOP_1107_1: for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
#pragma HLS unroll
 res.val[k] = sr_cast<DST_T>(sum.val[k]);
    }
    return res;
}

template<typename DST_T, int ROWS, int COLS, int SRC_T>
Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), DST_T> Avg(
        Mat<ROWS, COLS, SRC_T>& src)
{
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T> sum, sqsum;
    int ncount = src.rows * src.cols;
    _AP_T _sum = 0;
    arithm_pro<kernel_sum>(src, sum, sqsum);
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), DST_T> avg;
    VITIS_LOOP_1123_1: for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
#pragma HLS unroll
 _sum = sum.val[k];
        avg.val[k] = _sum/ncount;
    }
    return avg;
}

template<typename DST_T, int ROWS, int COLS, int SRC_T>
Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), DST_T> Avg(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask)
{
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T> sum, sqsum;
    int ncount = 0;
    _AP_T _sum = 0;
    arithm_pro<kernel_sum>(src, sum, sqsum, ncount, mask);
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), DST_T> avg;
    VITIS_LOOP_1141_1: for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
#pragma HLS unroll
 _sum = sum.val[k];
        avg.val[k] = _sum/ncount;
    }
    return avg;
}

template<typename DST_T, int ROWS, int COLS, int SRC_T>
DST_T Mean(
        Mat<ROWS, COLS, SRC_T>& src)
{
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), DST_T> avg;
    avg = Avg<DST_T>(src);
    return avg.val[0];
}

template<typename DST_T, int ROWS, int COLS, int SRC_T>
DST_T Mean(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask)
{
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), DST_T> avg;
    avg = Avg<DST_T>(src, mask);
    return avg.val[0];
}

template<int ROWS, int COLS, int SRC_T, typename _T>
void AvgSdv(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T>& avg,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T>& sdv)
{
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T> sum, sqsum;
    int ncount = src.rows * src.cols;
    _AP_T _sum = 0;
    ap_fixed<64,40,AP_RND> _sqsum = 0;
    arithm_pro<kernel_avgsdv>(src, sum, sqsum);
    VITIS_LOOP_1179_1: for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
        _sum = sum.val[k];
        _sqsum = sqsum.val[k];
        avg.val[k] = _sum/ncount;
        sdv.val[k] = sqrt((double)((_sqsum*ncount)-((_sum)*(_sum))))/ncount;
    }
}

template<int ROWS, int COLS, int SRC_T, typename _T>
void AvgSdv(
        Mat<ROWS, COLS, SRC_T>& src,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T>& avg,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _T>& sdv,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask)
{
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), _SUM_T> sum, sqsum;
    int ncount = 0;
    _AP_T _sum = 0;
    ap_fixed<64,40,AP_RND> _sqsum = 0;
    arithm_pro<kernel_avgsdv>(src, sum, sqsum, ncount, mask);
    VITIS_LOOP_1199_1: for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
        _sum = sum.val[k];
        _sqsum = sqsum.val[k];
        avg.val[k] = _sum/ncount;
        sdv.val[k] = sqrt((double)((_sqsum*ncount)-((_sum)*(_sum))))/ncount;
    }
}

template<typename S_T>
class MinMaxLoc_opr
{
public:
template<int ROWS, int COLS, int SRC_T, typename P_T>
static void get_max_min(
        Mat<ROWS, COLS, SRC_T>& src,
        P_T* min_val,
        P_T* max_val,
        Point& min_loc,
        Point& max_loc)
{
#pragma HLS inline




 HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",1226),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",1227),0));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Name<typename Type<((SRC_T) & ((1 << 11) - 1))>::name> type_val;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _min_val = (typename Type<((SRC_T) & ((1 << 11) - 1))>::name) type_val._max;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _max_val = (typename Type<((SRC_T) & ((1 << 11) - 1))>::name) type_val._min;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
 src >> s;
            if (s.val[0] < _min_val) {
                _min_val = s.val[0];
                min_loc.x = j;
                min_loc.y = i;
            }
            if (s.val[0] > _max_val) {
                _max_val = s.val[0];
                max_loc.x = j;
                max_loc.y = i;
            }
        }
    }
    *min_val = sr_cast<P_T>(_min_val);
    *max_val = sr_cast<P_T>(_max_val);
}

template<int ROWS, int COLS, int SRC_T, typename P_T>
static void get_max_min(
        Mat<ROWS, COLS, SRC_T>& src,
        P_T* min_val,
        P_T* max_val,
        Point& min_loc,
        Point& max_loc,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask)
{
#pragma HLS inline




 HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",1269),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",1270),0));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<1, unsigned char> m;
    Name<typename Type<((SRC_T) & ((1 << 11) - 1))>::name> type_val;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _min_val = (typename Type<((SRC_T) & ((1 << 11) - 1))>::name)type_val._max;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _max_val = (typename Type<((SRC_T) & ((1 << 11) - 1))>::name)type_val._min;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
 src >> s;
            mask >> m;
            if (m.val[0]) {
                if (s.val[0] < (_min_val)) {
                    _min_val = s.val[0];
                    min_loc.x = j;
                    min_loc.y = i;
                }
                if (s.val[0] > (_max_val)) {
                    _max_val = s.val[0];
                    max_loc.x = j;
                    max_loc.y = i;
                }
            }
        }
    }
    *min_val = sr_cast<P_T>(_min_val);
    *max_val = sr_cast<P_T>(_max_val);
}

};

template< >
class MinMaxLoc_opr<float>
{
public:
template<int ROWS, int COLS, int SRC_T, typename P_T>
static void get_max_min(
        Mat<ROWS, COLS, SRC_T>& src,
        P_T* min_val,
        P_T* max_val,
        Point& min_loc,
        Point& max_loc)
{
#pragma HLS inline




 HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",1321),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",1322),0));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Name<typename Type<((SRC_T) & ((1 << 11) - 1))>::name> type_val;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _min_val = (typename Type<((SRC_T) & ((1 << 11) - 1))>::name) type_val._max;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _max_val = (typename Type<((SRC_T) & ((1 << 11) - 1))>::name) type_val._min;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
 src >> s;
            fp_struct<float> min_fp(_min_val);
         fp_struct<float> max_fp(_max_val);
         fp_struct<float> s_fp(s.val[0]);
            if (min_fp.sign==1 && s_fp.sign==1) {
                if(s_fp.to_int() > min_fp.to_int()) {
                    _min_val = s.val[0];
                    min_loc.x = j;
                    min_loc.y = i;
                }
            }
            else {
                if(s_fp.to_int() < min_fp.to_int()) {
                    _min_val = s.val[0];
                    min_loc.x = j;
                    min_loc.y = i;
                }
            }

            if (max_fp.sign==1 && s_fp.sign==1) {
                if(s_fp.to_int() < max_fp.to_int()) {
                    _max_val = s.val[0];
                    max_loc.x = j;
                    max_loc.y = i;
                }
            }
            else {
                if(s_fp.to_int() > max_fp.to_int()) {
                    _max_val = s.val[0];
                    max_loc.x = j;
                    max_loc.y = i;
                }
            }
        }
    }
    *min_val = sr_cast<P_T>(_min_val);
    *max_val = sr_cast<P_T>(_max_val);
}

template<int ROWS, int COLS, int SRC_T, typename P_T>
static void get_max_min(
        Mat<ROWS, COLS, SRC_T>& src,
        P_T* min_val,
        P_T* max_val,
        Point& min_loc,
        Point& max_loc,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask)
{
#pragma HLS inline




 HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",1386),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",1387),0));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<1, unsigned char> m;
    Name<typename Type<((SRC_T) & ((1 << 11) - 1))>::name> type_val;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _min_val = (typename Type<((SRC_T) & ((1 << 11) - 1))>::name)type_val._max;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _max_val = (typename Type<((SRC_T) & ((1 << 11) - 1))>::name)type_val._min;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
 src >> s;
            mask >> m;
            fp_struct<float> min_fp(_min_val);
         fp_struct<float> max_fp(_max_val);
         fp_struct<float> s_fp(s.val[0]);
            if (m.val[0]) {
                if (min_fp.sign==1 && s_fp.sign==1) {
                    if(s_fp.to_int() > min_fp.to_int()) {
                        _min_val = s.val[0];
                        min_loc.x = j;
                        min_loc.y = i;
                    }
                }
                else {
                    if(s_fp.to_int() < min_fp.to_int()) {
                        _min_val = s.val[0];
                        min_loc.x = j;
                        min_loc.y = i;
                    }
                }

                if (max_fp.sign==1 && s_fp.sign==1) {
                    if(s_fp.to_int() < max_fp.to_int()) {
                        _max_val = s.val[0];
                        max_loc.x = j;
                        max_loc.y = i;
                    }
                }
                else {
                    if(s_fp.to_int() > max_fp.to_int()) {
                        _max_val = s.val[0];
                        max_loc.x = j;
                        max_loc.y = i;
                    }
                }
            }
        }
    }
    *min_val = sr_cast<P_T>(_min_val);
    *max_val = sr_cast<P_T>(_max_val);
}

};

template<int ROWS, int COLS, int SRC_T, typename P_T>
void MinMaxLoc(
        Mat<ROWS, COLS, SRC_T>& src,
        P_T* min_val,
        P_T* max_val,
        Point& min_loc,
        Point& max_loc)
{
    MinMaxLoc_opr< typename Type<((SRC_T) & ((1 << 11) - 1))>::name >::get_max_min(src, min_val, max_val, min_loc, max_loc);
}

template<int ROWS, int COLS, int SRC_T, typename P_T>
void MinMaxLoc(
        Mat<ROWS, COLS, SRC_T>& src,
        P_T* min_val,
        P_T* max_val,
        Point& min_loc,
        Point& max_loc,
        Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))>& mask)
{
    MinMaxLoc_opr< typename Type<((SRC_T) & ((1 << 11) - 1))>::name >::get_max_min(src, min_val, max_val, min_loc, max_loc, mask);
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Threshold(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst,
        typename Type<((SRC_T) & ((1 << 11) - 1))>::name thresh,
        typename Type<((DST_T) & ((1 << 11) - 1))>::name maxval,
        int thresh_type)
{
# 1480 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h"
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",1482),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",1483),0));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name _thresh = sr_cast<typename Type<((SRC_T) & ((1 << 11) - 1))>::name>(thresh);
    typename Type<((DST_T) & ((1 << 11) - 1))>::name _maxval = sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(maxval);
    typename Type<((DST_T) & ((1 << 11) - 1))>::name _zero = 0;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
 src >> s;
            VITIS_LOOP_1494_1: for (HLS_CHANNEL_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                switch (thresh_type) {
                    case 0:
                    d.val[k] = (s.val[k] > _thresh) ? (_maxval) : _zero;
                    break;
                    case 1:
                    d.val[k] = (s.val[k] > _thresh) ? _zero : (_maxval);
                    break;
                    case 2:
                    d.val[k] = (s.val[k] > _thresh) ? (_thresh) : s.val[k];
                    break;
                    case 3:
                    d.val[k] = (s.val[k] > _thresh) ? (s.val[k]) : _zero;
                    break;
                    case 4:
                    d.val[k] = (s.val[k] > _thresh) ? _zero : (s.val[k]);
                    break;
                    default:
                    d.val[k] = s.val[k];
                    break;
                }
            }
            dst << d;
        }
    }
}

template<int ROWS, int COLS, int SRC_T>
void Consume(
        Mat<ROWS, COLS, SRC_T>& src)
{
    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",1527),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",1528),0));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
 src >> s;
        }
    }
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Duplicate(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst1,
        Mat<ROWS, COLS, DST_T>& dst2)
{







    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",1554),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",1555),0));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
 src >> s;
            dst1 << s;
            dst2 << s;
        }
    }
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Split(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst0,
        Mat<ROWS, COLS, DST_T>& dst1)
{
# 1582 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h"
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",1586),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",1587),0));
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
 src >> s;
            d.val[0] = s.val[0]; dst0 << d;
            d.val[0] = s.val[1]; dst1 << d;
        }
    }
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Split(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst0,
        Mat<ROWS, COLS, DST_T>& dst1,
        Mat<ROWS, COLS, DST_T>& dst2)
{
# 1615 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h"
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",1619),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",1620),0));
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
 src >> s;
            d.val[0] = s.val[0]; dst0 << d;
            d.val[0] = s.val[1]; dst1 << d;
            d.val[0] = s.val[2]; dst2 << d;
        }
    }
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Split(
        Mat<ROWS, COLS, SRC_T>& src,
        Mat<ROWS, COLS, DST_T>& dst0,
        Mat<ROWS, COLS, DST_T>& dst1,
        Mat<ROWS, COLS, DST_T>& dst2,
        Mat<ROWS, COLS, DST_T>& dst3)
{
# 1651 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h"
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",1655),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",1656),0));
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
 src >> s;
            d.val[0] = s.val[0]; dst0 << d;
            d.val[0] = s.val[1]; dst1 << d;
            d.val[0] = s.val[2]; dst2 << d;
            d.val[0] = s.val[3]; dst3 << d;
        }
    }
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Merge(
        Mat<ROWS, COLS, SRC_T>& src0,
        Mat<ROWS, COLS, SRC_T>& src1,
        Mat<ROWS, COLS, DST_T>& dst)
{
# 1684 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h"
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",1688),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",1689),0));
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
 src0 >> s; d.val[0] = s.val[0];
            src1 >> s; d.val[1] = s.val[0];
            dst << d;
        }
    }
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Merge(
        Mat<ROWS, COLS, SRC_T>& src0,
        Mat<ROWS, COLS, SRC_T>& src1,
        Mat<ROWS, COLS, SRC_T>& src2,
        Mat<ROWS, COLS, DST_T>& dst)
{
# 1717 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h"
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",1721),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",1722),0));
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
 src0 >> s; d.val[0] = s.val[0];
            src1 >> s; d.val[1] = s.val[0];
            src2 >> s; d.val[2] = s.val[0];
            dst << d;
        }
    }
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Merge(
        Mat<ROWS, COLS, SRC_T>& src0,
        Mat<ROWS, COLS, SRC_T>& src1,
        Mat<ROWS, COLS, SRC_T>& src2,
        Mat<ROWS, COLS, SRC_T>& src3,
        Mat<ROWS, COLS, DST_T>& dst)
{
# 1753 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h"
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    HLS_SIZE_T rows = dst.rows;
    HLS_SIZE_T cols = dst.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",1757),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_arithm.h",1758),0));
 loop_height: for (HLS_SIZE_T i = 0; i < rows; i++) {
    loop_width: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
 src0 >> s; d.val[0] = s.val[0];
            src1 >> s; d.val[1] = s.val[0];
            src2 >> s; d.val[2] = s.val[0];
            src3 >> s; d.val[3] = s.val[0];
            dst << d;
        }
    }
}

}
# 62 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src\\hls_video.h" 2
# 1 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h" 1
# 91 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h"
namespace hls {
# 144 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h"
class erode_kernel
{
    public:
    template<typename SRC_T,typename DST_T,typename FILTER_T, int F_HEIGHT, int F_WIDTH>
    void apply(Window<F_HEIGHT,F_WIDTH,FILTER_T> &_kernel_filter,
            Window<F_HEIGHT,F_WIDTH,SRC_T> &_kernel_pixel,
            DST_T &out)
    {
#pragma HLS INLINE
 out = hls::numeric_limits<DST_T>::max();
    loop_height: for( int m=0;m< F_HEIGHT;m++)
        {
        loop_width: for( int n=0;n<F_WIDTH;n++)
            {
                DST_T temp;
                if(_kernel_filter.val[F_HEIGHT-m-1][F_WIDTH-1-n]>0)
                {
                    temp=_kernel_pixel.val[F_HEIGHT-m-1][(F_WIDTH-1-n)];
                    if (temp<out)
                        out=temp;
                }
            }
        }
    }
};

class dilate_kernel
{
    public:
    template<typename SRC_T,typename DST_T,typename FILTER_T, int F_HEIGHT, int F_WIDTH>
    void apply(Window<F_HEIGHT,F_WIDTH,FILTER_T> &_kernel_filter,
            Window<F_HEIGHT,F_WIDTH,SRC_T> &_kernel_pixel,
            DST_T &out)
    {
#pragma HLS INLINE
 out = hls::numeric_limits<DST_T>::min();
    loop_height: for( int m=0;m< F_HEIGHT;m++)
        {
        loop_width: for( int n=0;n<F_WIDTH;n++)
            {
                DST_T temp;
                if(_kernel_filter.val[F_HEIGHT-m-1][F_WIDTH-1-n]>0)
                {
                    temp=_kernel_pixel.val[F_HEIGHT-m-1][(F_WIDTH-1-n)];
                    if (temp>out)
                        out=temp;
                }
            }
        }
    }
};


template <typename SRC_T, typename FILTER_T, int SIZE=0>
struct filter2d_traits {
    typedef typename fixed_type<SRC_T>::T SRC_CAST_T;
    typedef typename fixed_type<FILTER_T>::T FILTER_CAST_T;
    typedef typename x_traits<SRC_CAST_T, FILTER_CAST_T >::MULT_T MULT_T;
    typedef typename x_traits_d<MULT_T, SIZE>::ACCUM_T ACCUM_T;
    typedef typename x_traits<ACCUM_T, ap_fixed<1,1> >::MULT_T TEMP_T;
};

template <int SIZE , int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O>
struct filter2d_traits<float, ap_fixed<W, I, _AP_Q, _AP_O>, SIZE> {
    typedef float SRC_CAST_T;
    typedef float FILTER_CAST_T;
    typedef ap_fixed<64,32,AP_RND> MULT_T;
    typedef ap_fixed<64,32,AP_RND> ACCUM_T;
    typedef ap_fixed<64,32,AP_RND> TEMP_T;
};
template <int SIZE, int W>
struct filter2d_traits<float, ap_int<W>, SIZE> {
    typedef float SRC_CAST_T;
    typedef ap_int<W> FILTER_CAST_T;
    typedef float MULT_T;
    typedef float ACCUM_T;
    typedef float TEMP_T;
};
template <int SIZE>
struct filter2d_traits<unsigned char,float, SIZE> {
    typedef unsigned char SRC_CAST_T;
    typedef float FILTER_CAST_T;
    typedef ap_fixed<64,32,AP_RND> MULT_T;
    typedef ap_fixed<64,32,AP_RND> ACCUM_T;
    typedef ap_fixed<64,32,AP_RND> TEMP_T;
};
template <int SIZE>
struct filter2d_traits<float, unsigned char, SIZE> {
    typedef float SRC_CAST_T;
    typedef unsigned char FILTER_CAST_T;
    typedef ap_fixed<64,32,AP_RND> MULT_T;
    typedef ap_fixed<64,32,AP_RND> ACCUM_T;
    typedef ap_fixed<64,32,AP_RND> TEMP_T;
};
template <int SIZE>
struct filter2d_traits<float, float, SIZE> {
    typedef float SRC_CAST_T;
    typedef float FILTER_CAST_T;
    typedef ap_fixed<64,32,AP_RND> MULT_T;
    typedef ap_fixed<64,32,AP_RND> ACCUM_T;
    typedef ap_fixed<64,32,AP_RND> TEMP_T;
};
template <int SIZE>
struct filter2d_traits<double, double, SIZE> {
    typedef double SRC_CAST_T;
    typedef double FILTER_CAST_T;
    typedef ap_fixed<64,32,AP_RND> MULT_T;
    typedef ap_fixed<64,32,AP_RND> ACCUM_T;
    typedef ap_fixed<64,32,AP_RND> TEMP_T;
};
template <int SIZE>
struct filter2d_traits<float, double, SIZE> {
    typedef float SRC_CAST_T;
    typedef double FILTER_CAST_T;
    typedef ap_fixed<64,32,AP_RND> MULT_T;
    typedef ap_fixed<64,32,AP_RND> ACCUM_T;
    typedef ap_fixed<64,32,AP_RND> TEMP_T;
};
template <int SIZE>
struct filter2d_traits<double, float, SIZE> {
    typedef double SRC_CAST_T;
    typedef float FILTER_CAST_T;
    typedef ap_fixed<64,32,AP_RND> MULT_T;
    typedef ap_fixed<64,32,AP_RND> ACCUM_T;
    typedef ap_fixed<64,32,AP_RND> TEMP_T;
};

class filter2d_kernel
{
    public:
    template<typename SRC_T,typename DST_T,typename FILTER_T, int F_HEIGHT, int F_WIDTH>
    void apply(Window<F_HEIGHT,F_WIDTH,FILTER_T> &_kernel_filter,
               Window<F_HEIGHT,F_WIDTH,SRC_T> &_kernel_pixel,
               DST_T &out,
               const bool cast)
    {
#pragma HLS INLINE
 typename filter2d_traits<SRC_T, FILTER_T>::SRC_CAST_T src_v;
     typename filter2d_traits<SRC_T, FILTER_T>::FILTER_CAST_T filter_v;
        typename filter2d_traits<SRC_T, FILTER_T, F_HEIGHT*F_WIDTH-1>::ACCUM_T sum=0;
        typename filter2d_traits<SRC_T, FILTER_T>::MULT_T temp=0;
        loop_height: for(int m = 0; m < F_HEIGHT; m++) {
            loop_width: for(int n = 0; n < F_WIDTH; n++) {
                src_v = _kernel_pixel.val[F_HEIGHT-m-1][F_WIDTH-1-n];
                filter_v = _kernel_filter.val[m][n];
                temp = src_v * filter_v;
                sum = sum + temp;
            }
        }
        out=sum;
    }

    template<typename SRC_T,typename DST_T,typename FILTER_T, int F_HEIGHT, int F_WIDTH>
    void apply(Window<F_HEIGHT,F_WIDTH,FILTER_T> &_kernel_filter,
               Window<F_HEIGHT,F_WIDTH,SRC_T> &_kernel_pixel,
               DST_T &out)
    {
#pragma HLS INLINE
 typename filter2d_traits<SRC_T, FILTER_T, F_HEIGHT*F_WIDTH-1>::ACCUM_T sum=0;
     apply(_kernel_filter,_kernel_pixel,sum,true);
     out=sr_cast<DST_T>(sum);
    }
};

template <typename SRC_T,typename SIZE_T,typename POINT_T,int HEIGHT,int WIDTH>
void getStructuringElement(
        int shape,
        Size_<SIZE_T> ksize,
        Point_<POINT_T> anchor,
        Window<HEIGHT,WIDTH,SRC_T> &result)
{
#pragma HLS inline
 int i, j;
    int r = 0, c = 0;
    ap_fixed<31,11,AP_RND> inv_r2 = 0;

    if( ksize.width==1&&ksize.height == 1 )
        shape = MORPH_RECT;

    if( shape == MORPH_ELLIPSE )
    {
        r = ksize.height/2;
        c = ksize.width/2;
        if(r!=0)
        {
            inv_r2 =(ap_fixed<31,11,AP_RND>) 1/(r*r) ;
        }
        else
            inv_r2=0;
    }
 loop_height: for( i = 0; i < ksize.height; i++ )
    {
        int j1 = 0, j2 = 0;
        if( shape == MORPH_RECT || (shape ==MORPH_CROSS && i == anchor.y) )
            j2 = ksize.width;
        else if( shape == MORPH_CROSS ) {
            j1 = anchor.x;
            j2 = j1 + 1;
        } else
        {
            int dy = i - r;
            if( abs(dy) <= r )
            {
     ap_fixed<12,12,AP_RND> dxx = (c*::hls::sqrt(double(((r-dy)*(r+dy))*inv_r2)));
                int dx=dxx;
                j1 = (c - dx)> 0?( c - dx):0;
                j2 = (c + dx + 1)< ksize.width?(c + dx + 1):ksize.width;
            }
        }
    loop_width: for( j = 0; j < ksize.width; j++ ) {
            if(shape == MORPH_RECT || (j >= j1 && j < j2)) {
                result.val[i][j] = 1;
            } else {
                result.val[i][j] = 0;
            }
        }
    }
}


template<typename P_T,typename W_T,int W_HEIGHT, int W_WIDTH,typename BUF_T,int BUF_HEIGHT,int BUF_WIDTH >
void fill_pixelkernel(
        LineBuffer<BUF_HEIGHT,BUF_WIDTH,BUF_T> &col_buf,
        Window<W_HEIGHT,W_WIDTH,W_T> &kernel,
        Point_<P_T> curp,
        int borderType, int ref,
        int imgheight,int constval=0, bool forceconst = false)
{
#pragma HLS INLINE
 loop_fill: for(int buf_row= 0;buf_row<W_HEIGHT;buf_row++)
    {
        int locy;
        int t = borderInterpolate(curp.y,imgheight,borderType);
        locy = ref - t;
        curp.y--;
        kernel.val[buf_row][0] = (t < 0 || forceconst) ? constval : col_buf.val[locy][0];
    }
}

template<typename OPR_KERNEL, typename BORDERMODE>
class filter_opr {
public:
template<int SRC_T, int DST_T, typename KN_T, typename POINT_T,
         int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
static void filter(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &kernel,
        Point_<POINT_T> _anchor,
        int rows,int cols)
    {
#pragma HLS inline
 OPR_KERNEL fk_opr;

    Window<K_HEIGHT,K_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> src_kernel_win[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

    LineBuffer<2*K_HEIGHT,IMG_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> k_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];


    Window<K_HEIGHT,K_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> right_border_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

    Window<K_HEIGHT,1,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> col_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

    (void) ((!!(rows >= 8)) || (_assert("rows >= 8","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",407),0));
    (void) ((!!(cols >= 8)) || (_assert("cols >= 8","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",408),0));
    (void) ((!!(rows <= IMG_HEIGHT)) || (_assert("rows <= IMG_HEIGHT","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",409),0));
    (void) ((!!(cols <= IMG_WIDTH)) || (_assert("cols <= IMG_WIDTH","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",410),0));

#pragma HLS ARRAY_PARTITION variable=col_buf complete dim=0
#pragma HLS ARRAY_PARTITION variable=&kernel complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_kernel_win complete dim=0
#pragma HLS ARRAY_PARTITION variable=k_buf complete dim=1
#pragma HLS ARRAY_PARTITION variable=right_border_buf complete dim=0

 Point_<POINT_T> anchor;
    anchor.x=_anchor.x;
    anchor.y=_anchor.y;
    Size_<int> kernel_size;
    kernel_size.width=K_WIDTH;
    kernel_size.height=K_HEIGHT;
    normalizeAnchor(anchor,kernel_size);
    (void) ((!!(anchor.x >= 0)) || (_assert("anchor.x >= 0","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",425),0));
    (void) ((!!(anchor.x <= K_WIDTH-1)) || (_assert("anchor.x <= K_WIDTH-1","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",426),0));
    (void) ((!!(anchor.y >= 0)) || (_assert("anchor.y >= 0","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",427),0));
    (void) ((!!(anchor.y <= K_HEIGHT-1)) || (_assert("anchor.y <= K_HEIGHT-1","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",428),0));

    int start_row;
    int row_index;
    int col_index;
    int stop_row;
    get_parameters<K_HEIGHT, K_WIDTH>(rows, anchor, start_row, stop_row, row_index, col_index);
    (void) ((!!(start_row >= 0)) || (_assert("start_row >= 0","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",435),0));
    (void) ((!!(start_row <= K_HEIGHT-1)) || (_assert("start_row <= K_HEIGHT-1","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",436),0));

    int heightloop= rows+start_row+1;
    int widthloop = cols+K_WIDTH-1;
    Point_<int> ImagLoc;
    int channels=((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);

 loop_height: for(HLS_SIZE_T i= 0;i< heightloop;i++) {
    loop_width: for (HLS_SIZE_T j= 0;j< widthloop;j++) {

#pragma HLS DEPENDENCE array inter false
#pragma HLS LOOP_FLATTEN OFF
#pragma HLS PIPELINE
channelloop: for(HLS_CHANNEL_T k= 0; k < channels; k++)
                {
                    ImagLoc.x=j-anchor.x;
                    int x = borderInterpolate(ImagLoc.x, cols, BORDERMODE::value);
                    (void) ((!!(x < cols)) || (_assert("x < cols","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",453),0));


                    VITIS_LOOP_456_1: for(int buf_row=0; buf_row<K_HEIGHT; buf_row++) {
                        if((i<stop_row) && (ImagLoc.x>=cols)) {
                            col_buf[k](buf_row,0)=right_border_buf[k](buf_row,cols-1-x);
                        } else {
                            col_buf[k](buf_row,0)=k_buf[k](K_HEIGHT+buf_row,x);
                        }
                    }


                    if(ImagLoc.x >= 0 && ImagLoc.x < cols) {
                        if(i<=start_row) {
                            typename Type<((SRC_T) & ((1 << 11) - 1))>::name src_temp;
                            _src.data_stream[k] >> src_temp;
                            VITIS_LOOP_469_2: for(int buf_row=2*K_HEIGHT-1; buf_row>=0; buf_row--) {
                                int y = borderInterpolate(2*K_HEIGHT-1-anchor.y-buf_row, rows, BORDERMODE::value);
                                if(y==i) {
                                    k_buf[k](buf_row,x)=src_temp;
                                }
                            }
                        } else if(i<stop_row) {


                            VITIS_LOOP_478_3: for(int buf_row=0; buf_row<K_HEIGHT; buf_row++) {
                                VITIS_LOOP_479_4: for(int buf_col=K_WIDTH-1; buf_col>0; buf_col--) {
                                    if(buf_col <= col_index) {
                                         right_border_buf[k](buf_row,buf_col)=right_border_buf[k](buf_row,buf_col-1);
                                    }
                                }
                                right_border_buf[k](buf_row,0)=col_buf[k](buf_row,0);
                            }

                            VITIS_LOOP_487_5: for(int buf_row=2*K_HEIGHT-1; buf_row>0; buf_row--) {
                                if(buf_row>row_index) {
                                    k_buf[k](buf_row,x)=k_buf[k](buf_row-1,x);
                                }
                            }
                            if(i<rows) {
                                _src.data_stream[k] >> k_buf[k](row_index,x);
                            }
                        }
                    }


              src_kernel_win[k].shift_right();

                    VITIS_LOOP_501_6: for(int buf_row=0; buf_row<K_HEIGHT; buf_row++){
                        if(i<=stop_row) {
                            src_kernel_win[k](buf_row,0)=col_buf[k](buf_row,0);
                        }
                        else {
                            int y = borderInterpolate((i-(stop_row-rows+1)-buf_row), rows, BORDERMODE::value);
                            src_kernel_win[k](buf_row,0)=col_buf[k](rows-1-y,0);
                        }
                    }


                    if(i > start_row && j >= K_WIDTH-1) {
                  typename Type<((DST_T) & ((1 << 11) - 1))>::name temp;
                        fk_opr.apply(kernel,src_kernel_win[k],temp);
                        _dst.data_stream[k]<<temp;
                    }
                }
            }
        }
    }

private:
template<int K_HEIGHT, int K_WIDTH, typename POINT_T>
static void get_parameters(int rows, Point_<POINT_T> anchor, int &start_row, int &stop_row, int &row_index, int &col_index)
    {
#pragma HLS inline
 switch(BORDERMODE::value) {
            case BORDER_REPLICATE::value:
                start_row=K_HEIGHT-1-anchor.y;
                row_index=K_HEIGHT;
                col_index=0;
                stop_row=rows;
                break;
            case BORDER_REFLECT::value:
                col_index=K_WIDTH-1-anchor.x-1;
                if(anchor.y<=K_HEIGHT/2) {
                    start_row=K_HEIGHT-1-anchor.y;
                    row_index=K_HEIGHT;
                    stop_row=rows;
                } else {
                    start_row=anchor.y-1;
                    row_index=2*K_HEIGHT-2*anchor.y;
                    stop_row=rows+K_HEIGHT-row_index;
                }
                break;
            case BORDER_REFLECT_101::value:
                col_index=K_WIDTH-1-anchor.x;
                if(anchor.y<=K_HEIGHT/2) {
                    start_row=K_HEIGHT-1-anchor.y;
                    row_index=K_HEIGHT;
                    stop_row=rows;
                } else {
                    start_row=anchor.y;
                    row_index=2*K_HEIGHT-2*anchor.y-1;
                    stop_row=rows+K_HEIGHT-row_index;
                }
                break;
            default:
                col_index=K_WIDTH-1-anchor.x;
                if(anchor.y<=K_HEIGHT/2) {
                    start_row=K_HEIGHT-1-anchor.y;
                    row_index=K_HEIGHT;
                    stop_row=rows;
                } else {
                    start_row=anchor.y;
                    row_index=2*K_HEIGHT-2*anchor.y-1;
                    stop_row=rows+K_HEIGHT-row_index;
                }
                break;
        }
    }

};

template<typename OPR_KERNEL>
class filter_opr<OPR_KERNEL, BORDER_CONSTANT> {
public:
template<int SRC_T, int DST_T, typename KN_T, typename POINT_T,
         int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
    static void filter(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &kernel,
        Point_<POINT_T> _anchor,
        int rows,int cols)
{
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name fillvalue = 0;
#pragma HLS inline
 OPR_KERNEL fk_opr;

    Window<K_HEIGHT,K_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> src_kernel_win[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

    LineBuffer<K_HEIGHT,IMG_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> k_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

    Window<1,K_HEIGHT,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> col_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

#pragma HLS ARRAY_PARTITION variable=&kernel complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_kernel_win complete dim=0
#pragma HLS ARRAY_PARTITION variable=k_buf complete dim=1
#pragma HLS ARRAY_PARTITION variable=col_buf complete dim=0

 (void) ((!!(rows <= IMG_HEIGHT)) || (_assert("rows <= IMG_HEIGHT","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",602),0));
    (void) ((!!(cols <= IMG_WIDTH)) || (_assert("cols <= IMG_WIDTH","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",603),0));


    Point_<POINT_T> anchor;
    anchor.x=_anchor.x;
    anchor.y=_anchor.y;
    Size_<int> kernel_size;
    kernel_size.width=K_WIDTH;
    kernel_size.height=K_HEIGHT;
    normalizeAnchor(anchor,kernel_size);
    (void) ((!!(anchor.x >= 0)) || (_assert("anchor.x >= 0","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",613),0));
    (void) ((!!(anchor.x <= K_WIDTH-1)) || (_assert("anchor.x <= K_WIDTH-1","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",614),0));
    (void) ((!!(anchor.y >= 0)) || (_assert("anchor.y >= 0","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",615),0));
    (void) ((!!(anchor.y <= K_HEIGHT-1)) || (_assert("anchor.y <= K_HEIGHT-1","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",616),0));

    int start_row=K_HEIGHT-1-anchor.y;
    int start_col=K_WIDTH-1-anchor.x;
    int heightloop= rows+start_row;
    int widthloop = cols+start_col;
    Point_<int> ImagLoc;
    int channels=((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);

 loop_height: for(HLS_SIZE_T i= 0;i< heightloop;i++) {
    loop_width: for (HLS_SIZE_T j= 0;j< widthloop;j++) {
#pragma HLS LOOP_FLATTEN OFF
#pragma HLS PIPELINE
channelloop: for(HLS_CHANNEL_T k= 0; k < channels; k++)
                {
                    typename Type<((SRC_T) & ((1 << 11) - 1))>::name src_temp;
                    if((j<cols) && (i<rows)) {
                        _src.data_stream[k] >> src_temp;
                    }

                    if(j<cols) {
                        VITIS_LOOP_637_1: for(int buf_row=K_HEIGHT-1; buf_row>0; buf_row--) {
                            col_buf[k](0,buf_row)=k_buf[k](buf_row-1,j);
                        }
                    } else {
                        VITIS_LOOP_641_2: for(int buf_row=K_HEIGHT-1; buf_row>=0; buf_row--) {
                            col_buf[k](0,buf_row)=fillvalue;
                        }
                    }

                    if(j<cols) {
                        if(i==0) {
                            VITIS_LOOP_648_3: for(int buf_row=K_HEIGHT-1; buf_row>0; buf_row--) {
                                k_buf[k](buf_row,j)=fillvalue;
                                col_buf[k](0,buf_row)=fillvalue;
                            }
                            k_buf[k](0,j)=src_temp;
                            col_buf[k](0,0)=src_temp;
                        } else {
                            if(i>=rows) {
                                src_temp=fillvalue;
                            }
                            k_buf[k].shift_down(j);
                            k_buf[k](0,j)=src_temp;
                            col_buf[k](0,0)=src_temp;
                        }
                    }

                    if(j==0) {
                        VITIS_LOOP_665_4: for(int buf_row=K_HEIGHT-1; buf_row>=0; buf_row--) {
                            VITIS_LOOP_666_5: for(int buf_col=K_WIDTH-1; buf_col>0; buf_col--) {
                                src_kernel_win[k](buf_row,buf_col)=fillvalue;
                            }
                        }
                    } else {
                  src_kernel_win[k].shift_right();
                    }
              src_kernel_win[k].insert_right(col_buf[k].val[0]);


                    if(i >= start_row && j >= start_col) {
                  typename Type<((DST_T) & ((1 << 11) - 1))>::name temp;
                        fk_opr.apply(kernel,src_kernel_win[k],temp);
                        _dst.data_stream[k]<<temp;
                    }
                }
            }
        }
    }
};

template<typename OPR_KERNEL, typename BORDERMODE>
class sepfilter_opr {
private:

template<int CH, int IMG_HEIGHT, int IMG_WIDTH, int SRC_T, typename DST_T,
         typename KNY_T, typename POINT_T, int K_HEIGHT>
static void column_filter(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        stream<DST_T> (&_dst)[CH],
        Window<K_HEIGHT,1,KNY_T> &kernelY,
        Point_<POINT_T> _anchor,
        int rows,
        int cols)
{
    OPR_KERNEL fk_opr;

    Window<K_HEIGHT,1,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> src_kernel_winY[CH];

    Window<K_HEIGHT,1,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> col_buf[CH];


    LineBuffer<2*K_HEIGHT,IMG_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> k_buf[CH];

    (void) ((!!(rows >= 8)) || (_assert("rows >= 8","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",710),0));
    (void) ((!!(cols >= 8)) || (_assert("cols >= 8","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",711),0));
    (void) ((!!(rows <= IMG_HEIGHT)) || (_assert("rows <= IMG_HEIGHT","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",712),0));
    (void) ((!!(cols <= IMG_WIDTH)) || (_assert("cols <= IMG_WIDTH","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",713),0));

#pragma HLS ARRAY_PARTITION variable=col_buf complete dim=0
#pragma HLS ARRAY_PARTITION variable=&kernelY complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_kernel_winY complete dim=0
#pragma HLS ARRAY_PARTITION variable=k_buf complete dim=1

 Point_<POINT_T> anchor;
    anchor.x=_anchor.x;
    anchor.y=_anchor.y;
    Size_<int> kernel_size;
    kernel_size.width=1;
    kernel_size.height=K_HEIGHT;
    normalizeAnchor(anchor,kernel_size);

    int start_row;
    int row_index;
    int stop_row;

    switch(BORDERMODE::value) {
        case BORDER_REPLICATE::value:
            start_row=K_HEIGHT-1-anchor.y;
            row_index=K_HEIGHT;
            stop_row=rows;
            break;
        case BORDER_REFLECT::value:
            start_row = (anchor.y<=K_HEIGHT/2) ? K_HEIGHT-1-anchor.y : anchor.y-1;
            row_index = (anchor.y<=K_HEIGHT/2) ? K_HEIGHT : 2*K_HEIGHT-2*anchor.y;
            stop_row = (anchor.y<=K_HEIGHT/2) ? rows : rows+K_HEIGHT-row_index;
            break;
        case BORDER_REFLECT_101::value:
            start_row = (anchor.y<=K_HEIGHT/2) ? K_HEIGHT-1-anchor.y : anchor.y;
            row_index = (anchor.y<=K_HEIGHT/2) ? K_HEIGHT : 2*K_HEIGHT-2*anchor.y-1;
            stop_row = (anchor.y<=K_HEIGHT/2) ? rows : rows+K_HEIGHT-row_index;
            break;
        default:
            start_row = (anchor.y<=K_HEIGHT/2) ? K_HEIGHT-1-anchor.y : anchor.y;
            row_index = (anchor.y<=K_HEIGHT/2) ? K_HEIGHT : 2*K_HEIGHT-2*anchor.y-1;
            stop_row = (anchor.y<=K_HEIGHT/2) ? rows : rows+K_HEIGHT-row_index;
            break;
    }

    int heightloop = rows+start_row+1;
    int widthloop = cols;

    loop_height: for(HLS_SIZE_T i= 0;i< heightloop;i++) {
        loop_width: for (HLS_SIZE_T j= 0;j< widthloop;j++) {

#pragma HLS DEPENDENCE array inter false
#pragma HLS LOOP_FLATTEN OFF
#pragma HLS PIPELINE
 channelloop: for(HLS_CHANNEL_T k= 0; k < CH; k++)
            {


                VITIS_LOOP_768_1: for(int buf_row=0; buf_row<K_HEIGHT; buf_row++) {
                    col_buf[k](buf_row,0)=k_buf[k](2*K_HEIGHT-1-buf_row,j);
                }

                typename Type<((SRC_T) & ((1 << 11) - 1))>::name src_temp;
                if (i<rows) {
                    _src.data_stream[k] >> src_temp;
                }

                if(i<=start_row) {
                    VITIS_LOOP_778_2: for(int buf_row=2*K_HEIGHT-1; buf_row>=0; buf_row--) {
                        int y = borderInterpolate(2*K_HEIGHT-1-anchor.y-buf_row, rows, BORDERMODE::value);
                        if(y==i) {
                            k_buf[k](buf_row,j)=src_temp;
                        }
                    }
                } else if(i<stop_row) {
                    VITIS_LOOP_785_3: for(int buf_row=2*K_HEIGHT-1; buf_row>0; buf_row--) {
                        if(buf_row>row_index) {
                            k_buf[k](buf_row,j)=k_buf[k](buf_row-1,j);
                        }
                    }
                    if(i<rows) {
                        k_buf[k](row_index,j) = src_temp;
                    }
                }

                VITIS_LOOP_795_4: for(int buf_row=0; buf_row<K_HEIGHT; buf_row++){
                    if(i<=stop_row) {
                        src_kernel_winY[k](buf_row,0)=col_buf[k](K_HEIGHT-1-buf_row,0);
                    }
                    else {
                        int y = borderInterpolate(i-(stop_row-rows+1)-buf_row, rows, BORDERMODE::value);


                        int index = (rows-K_HEIGHT>0) ? rows-K_HEIGHT : 0;
                        src_kernel_winY[k](buf_row,0)=col_buf[k](y-index,0);
                    }
                }

                if(i > start_row) {
                    DST_T tempY;
                    fk_opr.apply(kernelY,src_kernel_winY[k],tempY,false);
                    _dst[k]<<tempY;
                }
            }
        }
    }
}

template<int CH, int IMG_HEIGHT, int IMG_WIDTH, typename SRC_T, int DST_T,
         typename KNX_T, typename POINT_T, int K_WIDTH, typename SCALE_T>
static void row_filter(
        stream<SRC_T> (&_src)[CH],
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<1,K_WIDTH,KNX_T> &kernelX,
        Point_<POINT_T> _anchor,
        int rows,
        int cols,
        SCALE_T scale)
{
    OPR_KERNEL fk_opr;

    Window<1,K_WIDTH,SRC_T> src_kernel_winX[CH];

    SRC_T src_kernel_winX_temp[CH][K_WIDTH];


    Window<1,2*K_WIDTH,SRC_T> row_buf[CH];




    LineBuffer<1,K_WIDTH,SRC_T> l_border_buf[CH];
    LineBuffer<1,K_WIDTH,SRC_T> r_border_buf[CH];

    (void) ((!!(rows >= 8)) || (_assert("rows >= 8","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",844),0));
    (void) ((!!(cols >= 8)) || (_assert("cols >= 8","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",845),0));
    (void) ((!!(rows <= IMG_HEIGHT)) || (_assert("rows <= IMG_HEIGHT","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",846),0));
    (void) ((!!(cols <= IMG_WIDTH)) || (_assert("cols <= IMG_WIDTH","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",847),0));

#pragma HLS ARRAY_PARTITION variable=&kernelX complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_kernel_winX complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_kernel_winX_temp complete dim=0
#pragma HLS ARRAY_PARTITION variable=row_buf complete dim=0
#pragma HLS ARRAY_PARTITION variable=l_border_buf complete dim=1
#pragma HLS ARRAY_PARTITION variable=r_border_buf complete dim=1

 Point_<POINT_T> anchor;
    anchor.x=_anchor.x;
    anchor.y=_anchor.y;
    Size_<int> kernel_size;
    kernel_size.width=K_WIDTH;
    kernel_size.height=1;
    normalizeAnchor(anchor,kernel_size);



    int left_border;

    int right_border;

    int index;

    int start;

    int stop;

    switch(BORDERMODE::value) {
        case BORDER_REPLICATE::value:
            left_border = 0;
            right_border = cols-1;
            index = anchor.x;
            break;
        case BORDER_REFLECT::value:
            left_border = (anchor.x-1>0) ? anchor.x-1: 0;
            right_border = cols-(K_WIDTH-anchor.x)+1;
            index = (2*anchor.x-1>0) ? 2*anchor.x-1: 0;
            break;
        case BORDER_REFLECT_101::value:
            left_border = anchor.x;
            right_border = cols-(K_WIDTH-anchor.x);
            index = 2*anchor.x;
            break;
        default:
            left_border = anchor.x;
            right_border = cols-(K_WIDTH-anchor.x);
            index = 2*anchor.x;
            break;
    }


    right_border = right_border<0 ? 0 : right_border;
    start = K_WIDTH+left_border;
    stop = cols+index;
    int heightloop= rows;
    int widthloop = cols+start;
    SRC_T src_temp;

    loop_height: for(HLS_SIZE_T i= 0;i< heightloop;i++) {
        loop_width: for (HLS_SIZE_T j= 0;j< widthloop;j++) {

#pragma HLS DEPENDENCE array inter false
#pragma HLS LOOP_FLATTEN OFF
#pragma HLS PIPELINE
 channelloop: for(HLS_CHANNEL_T k=0; k<CH; k++)
            {
                int x = borderInterpolate(j-index-1, cols, BORDERMODE::value);

                if (j<cols)
                    _src[k] >> src_temp;


                VITIS_LOOP_921_1: for (int buf_col=K_WIDTH-1; buf_col>0; buf_col--) {
                    src_kernel_winX_temp[k][buf_col] = src_kernel_winX_temp[k][buf_col-1];
                }

                if (j<=left_border) {
                    l_border_buf[k](0,j) = src_temp;
                }
                if ((j>=right_border) && (j<cols)) {
                    r_border_buf[k](0,cols-1-j) = src_temp;
                }

                if ((j>left_border) && (j<=index)) {

                    src_kernel_winX_temp[k][0] = l_border_buf[k](0,x);
                } else if (j<=stop) {

                    src_kernel_winX_temp[k][0] = row_buf[k](0,0);
                } else {

                    src_kernel_winX_temp[k][0] = r_border_buf[k](0,cols-1-x);
                }

                VITIS_LOOP_943_2: for (int buf_col=0; buf_col<2*K_WIDTH; buf_col++) {
                    if (buf_col<index)
                        row_buf[k](0,buf_col) = row_buf[k](0,buf_col+1);
                }
                row_buf[k](0,index) = src_temp;

                VITIS_LOOP_949_3: for (int buf_col=0; buf_col<K_WIDTH; buf_col++) {
                    src_kernel_winX[k](0,buf_col) = src_kernel_winX_temp[k][buf_col];
                }

                if(j >= start) {
                    typedef typename filter2d_traits<SRC_T, KNX_T, K_WIDTH*1-1>::TEMP_T tempX_T;
                    tempX_T tempX;
                    fk_opr.apply(kernelX,src_kernel_winX[k],tempX,false);
                    _dst.data_stream[k]<<sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(tempX*scale);
                }
            }
        }
    }
}

public:
template<int SRC_T, int DST_T, typename KNX_T, typename KNY_T, typename POINT_T,
         int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH, typename SCALE_T>
static void filter(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<1,K_WIDTH,KNX_T> &kernelX,
        Window<K_HEIGHT,1,KNY_T> &kernelY,
        Point_<POINT_T> _anchor,
        int rows,
     int cols,
     SCALE_T scale)

{
#pragma HLS inline
#pragma HLS DATAFLOW

 typedef typename filter2d_traits<typename Type<((SRC_T) & ((1 << 11) - 1))>::name, KNY_T, K_HEIGHT*1-1>::TEMP_T tempY_T;
    stream<tempY_T> tempY_stream[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

    column_filter<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)>(_src, tempY_stream, kernelY, Point_<POINT_T>(0,_anchor.y), rows, cols);

    row_filter<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)>(tempY_stream, _dst, kernelX, Point_<POINT_T>(_anchor.x,0), rows, cols, scale);
}

template<int SRC_T, int DST_T, typename KNX_T, typename KNY_T, typename POINT_T,
         int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
static void filter(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<1,K_WIDTH,KNX_T> &kernelX,
        Window<K_HEIGHT,1,KNY_T> &kernelY,
        Point_<POINT_T> _anchor,
        int rows,
     int cols)

{
#pragma HLS inline
 filter(_src, _dst, kernelX, kernelY, _anchor, rows, cols, 1);
}

};

template<typename OPR_KERNEL>
class sepfilter_opr<OPR_KERNEL, BORDER_CONSTANT> {
public:
template<int SRC_T, int DST_T, typename KNX_T, typename KNY_T, typename POINT_T,
         int IMG_HEIGHT, int IMG_WIDTH, int K_HEIGHT, int K_WIDTH, typename SCALE_T>
    static void filter(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<1,K_WIDTH,KNX_T> &kernelX,
        Window<K_HEIGHT,1,KNY_T> &kernelY,
        Point_<POINT_T> _anchor,
        int rows,
     int cols,
     SCALE_T scale)
{
#pragma HLS inline
 typename Type<((SRC_T) & ((1 << 11) - 1))>::name fillvalue = 0;
    OPR_KERNEL fk_opr;
    typedef typename filter2d_traits<typename Type<((SRC_T) & ((1 << 11) - 1))>::name, KNY_T, K_HEIGHT*1-1>::TEMP_T tempY_T;

    Window<K_HEIGHT,1,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> src_kernel_winY[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];
    Window<1,K_WIDTH,tempY_T> src_kernel_winX[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];
    tempY_T src_kernel_winX_temp[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)][K_WIDTH];

    LineBuffer<K_HEIGHT,IMG_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> k_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

#pragma HLS ARRAY_PARTITION variable=&kernelX complete dim=0
#pragma HLS ARRAY_PARTITION variable=&kernelY complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_kernel_winX complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_kernel_winX_temp complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_kernel_winY complete dim=0
#pragma HLS ARRAY_PARTITION variable=k_buf complete dim=1

 (void) ((!!(rows <= IMG_HEIGHT)) || (_assert("rows <= IMG_HEIGHT","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",1040),0));
    (void) ((!!(cols <= IMG_WIDTH)) || (_assert("cols <= IMG_WIDTH","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",1041),0));


    Point_<POINT_T> anchor;
    anchor.x=_anchor.x;
    anchor.y=_anchor.y;
    Size_<int> kernel_size;
    kernel_size.width=K_WIDTH;
    kernel_size.height=K_HEIGHT;
    normalizeAnchor(anchor,kernel_size);

    int heightloop= rows+K_HEIGHT-1;
    int widthloop = cols+K_WIDTH-1;
    Point_<int> ImagLoc;
    int channels=((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);

    loop_height: for(HLS_SIZE_T i= 0;i< heightloop;i++) {
        loop_width: for (HLS_SIZE_T j= 0;j< widthloop;j++) {
#pragma HLS LOOP_FLATTEN OFF
#pragma HLS PIPELINE
 channelloop: for(HLS_CHANNEL_T k= 0; k < channels; k++) {


                ImagLoc.x=j-anchor.x;
                ImagLoc.y=i-anchor.y;



                VITIS_LOOP_1069_1: for(int buf_col=K_WIDTH-1; buf_col>=1; buf_col--) {
                    src_kernel_winX_temp[k][buf_col] = src_kernel_winX_temp[k][buf_col-1];
                }

                if(ImagLoc.x >= 0 && ImagLoc.x < cols) {
                    VITIS_LOOP_1074_2: for(int buf_row= K_HEIGHT-1;buf_row >= 1;buf_row--) {
                        src_kernel_winY[k](buf_row,0)=k_buf[k](buf_row-1,ImagLoc.x);
                        k_buf[k](buf_row,ImagLoc.x)=k_buf[k](buf_row-1,ImagLoc.x);
                    }

                    typename Type<((SRC_T) & ((1 << 11) - 1))>::name temp=fillvalue;
                    if(ImagLoc.y >= 0 && ImagLoc.y < rows) {
                        _src.data_stream[k] >> temp;
                    }
                    src_kernel_winY[k](0,0)=temp;
                    k_buf[k](0,ImagLoc.x)=temp;
                }





                if(ImagLoc.x < 0 || ImagLoc.x >= cols) {

                    src_kernel_winX_temp[k][0] = fillvalue;
                } else if(i >= (K_HEIGHT-1)) {
                    tempY_T tempY;
                    fk_opr.apply(kernelY,src_kernel_winY[k],tempY,false);

                    src_kernel_winX_temp[k][0] = tempY;
                }

                VITIS_LOOP_1101_3: for (int buf_col=0; buf_col<K_WIDTH; buf_col++) {
                    src_kernel_winX[k](0,buf_col) = src_kernel_winX_temp[k][buf_col];
                }



                if(i >= (K_HEIGHT-1) && j >= (K_WIDTH-1)) {
                    typename filter2d_traits<tempY_T, KNX_T, 1*K_WIDTH>::ACCUM_T tempX;
                    fk_opr.apply(kernelX,src_kernel_winX[k],tempX,false);
                    _dst.data_stream[k]<<sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(tempX*scale);
                }
            }
        }
    }
}

template<int SRC_T, int DST_T, typename KNX_T, typename KNY_T, typename POINT_T,
         int IMG_HEIGHT, int IMG_WIDTH, int K_HEIGHT, int K_WIDTH>
    static void filter(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<1,K_WIDTH,KNX_T> &kernelX,
        Window<K_HEIGHT,1,KNY_T> &kernelY,
        Point_<POINT_T> _anchor,
        int rows,
     int cols)
{
#pragma HLS inline
 filter(_src, _dst, kernelX, kernelY, _anchor, rows, cols, 1);
}

};

template<typename OPR_KERNEL, typename BORDERMODE, int SRC_T, int DST_T, typename KN_T, typename POINT_T,
int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
void filter_opr_flow_more(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &_kernel,
        Point_<POINT_T> &anchor,
        int rows, int cols
        )
{
    filter_opr<OPR_KERNEL, BORDERMODE>::filter(_src,_dst,_kernel,anchor,rows,cols);
}
template<typename OPR_KERNEL, typename BORDERMODE, int ITERATIONS,int SRC_T, int DST_T, typename KN_T, typename POINT_T,
int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
void filter_opr_iter(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &_kernel,
        Point_<POINT_T> &anchor,
        int rows,int cols )
{
#pragma HLS DATAFLOW
 Mat<IMG_HEIGHT,IMG_WIDTH,DST_T> internal[ITERATIONS-1];
#pragma HLS array partition variable=internal dim=1
 filter_opr_flow_more<OPR_KERNEL,BORDERMODE,SRC_T,DST_T,KN_T,POINT_T>(_src,internal[0],_kernel,anchor,rows,cols);
loop_iterations: for(int iter=0;iter<ITERATIONS-2;iter++)
    {
#pragma HLS UNROLL
 filter_opr_flow_more<OPR_KERNEL,BORDERMODE,SRC_T,DST_T,KN_T,POINT_T>(internal[iter],internal[iter+1],_kernel,anchor,rows, cols);
    }
    filter_opr_flow_more<OPR_KERNEL,BORDERMODE,SRC_T,DST_T,KN_T,POINT_T>(internal[ITERATIONS-2],_dst,_kernel,anchor,rows,cols);
}
template<typename OPR_KERNEL, typename BORDERMODE, int SRC_T, int DST_T,
    int IMG_HEIGHT,int IMG_WIDTH>
void morp_opr(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst)
{
#pragma HLS inline
 int rows=_src.rows;
    int cols=_src.cols;
    Size_<int> size;
    Point_<int> anchor;
    anchor.x=1;
    anchor.y=1;
    size.width=2*1+1;
    size.height=2*1+1;
    Window<2*1+1,2*1+1,unsigned char> temp_kernel;
    getStructuringElement<unsigned char,int,int,2*1+1,2*1+1>(MORPH_RECT, size, anchor,temp_kernel);

    filter_opr<OPR_KERNEL, BORDERMODE>::filter(_src,_dst,temp_kernel,anchor,rows,cols);
}
template<typename OPR_KERNEL, typename BORDERMODE, int Shape_type, int ITERATIONS, int SRC_T, int DST_T, typename KN_T, typename POINT_T,
int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
void morp_opr(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &_kernel,
        Point_<POINT_T> anchor)
{
#pragma HLS INLINE
 int rows=_src.rows;
    int cols=_src.cols;
    if((Shape_type==MORPH_RECT)&&ITERATIONS>1)
    {
        Size_<int> size;
        anchor.x=ITERATIONS*(anchor.x);
        anchor.y=ITERATIONS*(anchor.y);
        size.width=K_WIDTH+ITERATIONS*(K_WIDTH-1);
        size.height=K_HEIGHT+ITERATIONS*(K_HEIGHT-1);
        Window<K_WIDTH+ITERATIONS*(K_WIDTH-1),K_HEIGHT+ITERATIONS*(K_HEIGHT-1),KN_T> temp_kernel;
        getStructuringElement<KN_T,int,int,K_WIDTH+ITERATIONS*(K_WIDTH-1),K_HEIGHT+ITERATIONS*(K_HEIGHT-1)>(MORPH_RECT, size, anchor,temp_kernel);

        filter_opr<OPR_KERNEL, BORDERMODE>::filter(_src,_dst,temp_kernel,anchor,rows,cols);
    }
    else if(ITERATIONS==1)
    {
        filter_opr<OPR_KERNEL, BORDERMODE>::filter(_src,_dst,_kernel,anchor,rows,cols);
    }
    else if(ITERATIONS>=2)
    {
        filter_opr_iter<OPR_KERNEL, BORDERMODE, ITERATIONS,SRC_T,DST_T,KN_T,POINT_T>(_src,_dst,_kernel,anchor,rows,cols);
    }
}





template<int SRC_T, int DST_T, int IMG_HEIGHT,int IMG_WIDTH>
void Erode(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst)
{



    morp_opr<erode_kernel,BORDER_REPLICATE>(_src,_dst);
}
template<int Shape_type,int ITERATIONS,int SRC_T, int DST_T, typename KN_T,int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
void Erode(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &_kernel)
{
#pragma HLS INLINE



 Point_<int> anchor(K_WIDTH/2,K_HEIGHT/2);
    morp_opr<erode_kernel,BORDER_REPLICATE,Shape_type,ITERATIONS>(_src,_dst,_kernel,anchor);
}




template<int SRC_T, int DST_T, int IMG_HEIGHT,int IMG_WIDTH>
void Dilate(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst)
{



    morp_opr<dilate_kernel,BORDER_REPLICATE>(_src,_dst);
}
template<int Shape_type,int ITERATIONS,int SRC_T, int DST_T, typename KN_T,int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
void Dilate(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &_kernel)
{
#pragma HLS INLINE



 Point_<int> anchor(K_WIDTH/2,K_HEIGHT/2);
    morp_opr<dilate_kernel,BORDER_REPLICATE,Shape_type,ITERATIONS>(_src,_dst,_kernel,anchor);
}



template<typename BORDERMODE, int SRC_T, int DST_T, typename KN_T, typename POINT_T,
int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
void Filter2D(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &_kernel,
        Point_<POINT_T> anchor)
{



    int rows=_src.rows;
    int cols=_src.cols;
    filter_opr<filter2d_kernel, BORDERMODE>::filter(_src,_dst,_kernel,anchor,rows,cols);
}

template<int SRC_T, int DST_T, typename KN_T, typename POINT_T,
int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
void Filter2D(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<K_HEIGHT,K_WIDTH,KN_T> &_kernel,
        Point_<POINT_T> anchor)
{



    int rows=_src.rows;
    int cols=_src.cols;
    filter_opr<filter2d_kernel, BORDER_DEFAULT>::filter(_src,_dst,_kernel,anchor,rows,cols);
}

template<typename BORDERMODE, int SRC_T, int DST_T, typename KNX_T, typename KNY_T,
typename POINT_T, int IMG_HEIGHT, int IMG_WIDTH, int K_HEIGHT, int K_WIDTH, typename SCALE_T>
void SepFilter2D(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<1,K_WIDTH,KNX_T> &_kernelX,
        Window<K_HEIGHT,1,KNY_T> &_kernelY,
        Point_<POINT_T> anchor,
        SCALE_T scale)
{



    int rows=_src.rows;
    int cols=_src.cols;
    sepfilter_opr<filter2d_kernel, BORDERMODE>::filter(_src,_dst,_kernelX,_kernelY,anchor,rows,cols,scale);
}

template<typename BORDERMODE, int SRC_T, int DST_T, typename KNX_T, typename KNY_T,
typename POINT_T, int IMG_HEIGHT, int IMG_WIDTH, int K_HEIGHT, int K_WIDTH>
void SepFilter2D(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<1,K_WIDTH,KNX_T> &_kernelX,
        Window<K_HEIGHT,1,KNY_T> &_kernelY,
        Point_<POINT_T> anchor)
{



    int rows=_src.rows;
    int cols=_src.cols;
    sepfilter_opr<filter2d_kernel, BORDERMODE>::filter(_src,_dst,_kernelX,_kernelY,anchor,rows,cols);
}

template<int SRC_T, int DST_T, typename KNX_T, typename KNY_T, typename POINT_T,
int IMG_HEIGHT,int IMG_WIDTH,int K_HEIGHT,int K_WIDTH>
void SepFilter2D(
        Mat<IMG_HEIGHT, IMG_WIDTH, SRC_T> &_src,
        Mat<IMG_HEIGHT, IMG_WIDTH, DST_T> &_dst,
        Window<1,K_WIDTH,KNX_T> &_kernelX,
        Window<K_HEIGHT,1,KNY_T> &_kernelY,
        Point_<POINT_T> anchor)
{



    int rows=_src.rows;
    int cols=_src.cols;
    sepfilter_opr<filter2d_kernel, BORDER_DEFAULT>::filter(_src,_dst,_kernelX,_kernelY,anchor,rows,cols);
}



class CvtColor_mode {
public:
    enum values {RGB2GRAY,BGR2GRAY,GRAY2RGB,GRAY2BGR,
                 BGR2XYZ, RGB2XYZ, XYZ2BGR, XYZ2RGB,
                 BGR2YCrCb, RGB2YCrCb, YCrCb2BGR, YCrCb2RGB,
                 BGR2HSV, RGB2HSV, HSV2BGR, HSV2RGB,
                 BGR2HLS, RGB2HLS, HLS2BGR, HLS2RGB};
    typedef void isCvtColorMode;
};

}

class HLS_RGB2GRAY : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::RGB2GRAY; };
class HLS_BGR2GRAY : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::BGR2GRAY; };
class HLS_GRAY2RGB : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::GRAY2RGB; };
class HLS_GRAY2BGR : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::GRAY2BGR; };

class HLS_RGB2XYZ : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::RGB2XYZ; };
class HLS_BGR2XYZ : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::BGR2XYZ; };
class HLS_XYZ2RGB : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::XYZ2RGB; };
class HLS_XYZ2BGR : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::XYZ2BGR; };

class HLS_RGB2YCrCb : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::RGB2YCrCb; };
class HLS_BGR2YCrCb : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::BGR2YCrCb; };
class HLS_YCrCb2RGB : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::YCrCb2RGB; };
class HLS_YCrCb2BGR : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::YCrCb2BGR; };

class HLS_RGB2HSV : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::RGB2HSV; };
class HLS_BGR2HSV : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::BGR2HSV; };
class HLS_HSV2RGB : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::HSV2RGB; };
class HLS_HSV2BGR : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::HSV2BGR; };

class HLS_RGB2HLS : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::RGB2HLS; };
class HLS_BGR2HLS : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::BGR2HLS; };
class HLS_HLS2RGB : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::HLS2RGB; };
class HLS_HLS2BGR : public hls::CvtColor_mode { public: static const values value = hls::CvtColor_mode::HLS2BGR; };

namespace hls {

    template <typename T> class CvtColor_traits {

    };

    template <> class CvtColor_traits<unsigned char> {
    public:
        typedef unsigned char T;
        typedef ap_fixed<25,3> COEFF_T;
     typedef ap_ufixed<20,1,AP_RND> INV_T;

        const int delta;
        const unsigned int hrange;
        const unsigned int scale;
        const INV_T inv_scale;
        const INV_T inv_hrange;
        typedef typename x_traits<COEFF_T, typename fixed_type<T>::T >::MULT_T MULT_T;
        typedef typename x_traits_d<MULT_T, 3>::ACCUM_T ACCUM_T;
        typedef typename x_traits<typename fixed_type<T>::T, typename fixed_type<T>::T>::SUB_T SUB_T;
        typedef typename x_traits<typename fixed_type<T>::T, typename fixed_type<T>::T>::ADD_T ADD_T;
        typedef typename x_traits<ap_fixed<17,17>, INV_T>::MULT_T H_MULT_T;
        typedef typename x_traits<typename fixed_type<T>::T, INV_T>::MULT_T S_MULT_T;
        CvtColor_traits() : delta(128), hrange(180), scale(255),
       inv_scale(0.0039215686274509804), inv_hrange(0.0333333333333333333) {};
    };
    template <int N> class CvtColor_traits< ap_uint<N> > {
    public:
        typedef ap_uint<N> T;
        typedef ap_fixed<25,3> COEFF_T;
     typedef ap_ufixed<20,1,AP_RND> INV_T;

        const int delta;
        const unsigned int hrange;
        const unsigned int scale;
        const INV_T inv_scale;
        const INV_T inv_hrange;
        typedef typename x_traits<COEFF_T, typename fixed_type<T>::T >::MULT_T MULT_T;
        typedef typename x_traits_d<MULT_T, 3>::ACCUM_T ACCUM_T;
        typedef typename x_traits<typename fixed_type<T>::T, typename fixed_type<T>::T>::SUB_T SUB_T;
        typedef typename x_traits<typename fixed_type<T>::T, typename fixed_type<T>::T>::ADD_T ADD_T;
        typedef typename x_traits<ap_fixed<17,17>, INV_T>::MULT_T H_MULT_T;
        typedef typename x_traits<typename fixed_type<T>::T, INV_T>::MULT_T S_MULT_T;
        CvtColor_traits() : delta(1 << (N-1)), hrange(180),
                            scale(::hls::numeric_limits<T>::max()),
                            inv_scale(1.0/::hls::numeric_limits<T>::max()),
                            inv_hrange(0.0333333333333333333) {};
    };
    template <> class CvtColor_traits<float> {
    public:
        typedef float T;
        typedef float COEFF_T;
        typedef float INV_T;
        const float delta;
        const float hrange;
        const float scale;
        const INV_T inv_scale;
        const INV_T inv_hrange;
        typedef float MULT_T;
        typedef float ACCUM_T;
        typedef float SUB_T;
        typedef float ADD_T;
        typedef float H_MULT_T;
        typedef float S_MULT_T;
        CvtColor_traits() : delta(0.5f), hrange(360), scale(1), inv_scale(1),
       inv_hrange(0.0166666666666666667) {};
    };
    template <> class CvtColor_traits<double> {
    public:
        typedef double T;
        typedef double COEFF_T;
        typedef double INV_T;
        const double delta;
        const double hrange;
        const double scale;
        const INV_T inv_scale;
        const INV_T inv_hrange;
        typedef double MULT_T;
        typedef double ACCUM_T;
        typedef double SUB_T;
        typedef double ADD_T;
        typedef double H_MULT_T;
        typedef double S_MULT_T;
        CvtColor_traits() : delta(0.5f), hrange(360), scale(1), inv_scale(1),
       inv_hrange(0.0166666666666666667) {};
};

template <typename SRC_T, typename DST_T>
class ColorConverter {
public:
    template <int CN1>
    static void convert(Scalar<CN1,SRC_T>& _src, DST_T& result, Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > par) {
#pragma HLS inline
 typename CvtColor_traits<SRC_T>::MULT_T b,g,r;
        r=par.val[0]*_src.val[0];
        b=par.val[1]*_src.val[1];
        g=par.val[2]*_src.val[2];
        typename CvtColor_traits<SRC_T>::ACCUM_T c;
        c=r+g+b;
        result=sr_cast<DST_T> (c);
    }
};

template <typename SRC_T, typename DST_T>
class MaxMin{
public:
    template <int CN1>
    static void max(Scalar<CN1,SRC_T>& _src, DST_T& result) {
#pragma HLS inline

 VITIS_LOOP_1509_1: for(int i=0; i<CN1; i++) {
   result=(_src.val[i]>result) ? _src.val[i] : result;
 }
    }

    template <int CN1>
    static void min(Scalar<CN1,SRC_T>& _src, DST_T& result) {
#pragma HLS inline

 VITIS_LOOP_1518_1: for(int i=0; i<CN1; i++) {
   result=(_src.val[i]<result) ? _src.val[i] : result;
 }
    }
};

template <typename CONVERSION, typename SRC_T, typename DST_T>
class kernel_CvtColor {};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_BGR2GRAY, SRC_T, DST_T> {
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > par;
public:
    kernel_CvtColor() : par(0.114,0.587,0.299) {};
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        ColorConverter<SRC_T,DST_T>::convert(_src, _dst.val[0], par);
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_RGB2GRAY, SRC_T, DST_T> {
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > par;
public:
    kernel_CvtColor() : par(0.299,0.587,0.114) {};
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        ColorConverter<SRC_T,DST_T>::convert(_src, _dst.val[0], par);
    }
};
template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_GRAY2RGB, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
#pragma HLS inline
 _dst.val[0] = sr_cast<DST_T> (_src.val[0]);
        _dst.val[1] = sr_cast<DST_T> (_src.val[0]);
        _dst.val[2] = sr_cast<DST_T> (_src.val[0]);
    }
};
template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_GRAY2BGR, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
#pragma HLS inline
 _dst.val[0] = sr_cast<DST_T> (_src.val[0]);
        _dst.val[1] = sr_cast<DST_T> (_src.val[0]);
        _dst.val[2] = sr_cast<DST_T> (_src.val[0]);
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_RGB2XYZ, SRC_T, DST_T> {
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > parX;
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > parY;
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > parZ;
public:
    kernel_CvtColor() : parX(0.412453, 0.357580, 0.180423),
                        parY(0.212671, 0.715160, 0.072169),
                        parZ(0.019334, 0.119193, 0.950227) {};
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        ColorConverter<SRC_T,DST_T>::convert(_src, _dst.val[0], parX);
        ColorConverter<SRC_T,DST_T>::convert(_src, _dst.val[1], parY);
        ColorConverter<SRC_T,DST_T>::convert(_src, _dst.val[2], parZ);
    }
};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_BGR2XYZ, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        Scalar<CN1,SRC_T> src2;
        src2.val[0] = _src.val[2];
        src2.val[1] = _src.val[1];
        src2.val[2] = _src.val[0];
        kernel_CvtColor<HLS_RGB2XYZ,SRC_T,DST_T> kernel_opr;
        kernel_opr.apply(src2, _dst);
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_XYZ2RGB, SRC_T, DST_T> {
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > parR;
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > parG;
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > parB;
public:
    kernel_CvtColor() : parR( 3.240479, -1.53715, -0.498535),
                        parG(-0.969256, 1.875991, 0.041556),
                        parB( 0.055648, -0.204043, 1.057311) {};
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        ColorConverter<SRC_T,DST_T>::convert(_src, _dst.val[0], parR);
        ColorConverter<SRC_T,DST_T>::convert(_src, _dst.val[1], parG);
        ColorConverter<SRC_T,DST_T>::convert(_src, _dst.val[2], parB);
    }
};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_XYZ2BGR, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        Scalar<CN1,SRC_T> dst2;
        kernel_CvtColor<HLS_XYZ2RGB,SRC_T,DST_T> kernel_opr;
        kernel_opr.apply(_src, dst2);
        _dst.val[0] = dst2.val[2];
        _dst.val[1] = dst2.val[1];
        _dst.val[2] = dst2.val[0];
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_RGB2YCrCb, SRC_T, DST_T> {
    Scalar<3, typename CvtColor_traits<SRC_T>::COEFF_T > par;
    typename CvtColor_traits<SRC_T>::COEFF_T Cr;
    typename CvtColor_traits<SRC_T>::COEFF_T Cb;
public:
    kernel_CvtColor() : par(0.299,0.587,0.114),Cr(.713),Cb(.564) {};
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        SRC_T R = _src.val[0];
        SRC_T G = _src.val[1];
        SRC_T B = _src.val[2];
        DST_T Y;
        ColorConverter<SRC_T,DST_T>::convert(_src, Y, par);
        _dst.val[0] = Y;
        _dst.val[1] = sr_cast<DST_T>((R-Y)*Cr+ CvtColor_traits<SRC_T>().delta);
        _dst.val[2] = sr_cast<DST_T>((B-Y)*Cb+ CvtColor_traits<SRC_T>().delta);
    }
};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_BGR2YCrCb, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        Scalar<CN1,SRC_T> src2;
        src2.val[0] = _src.val[2];
        src2.val[1] = _src.val[1];
        src2.val[2] = _src.val[0];
        kernel_CvtColor<HLS_RGB2YCrCb,SRC_T,DST_T> kernel_opr;
        kernel_opr.apply(src2, _dst);
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_YCrCb2RGB, SRC_T, DST_T> {
    typename CvtColor_traits<SRC_T>::COEFF_T parGr;
    typename CvtColor_traits<SRC_T>::COEFF_T parGb;
    typename CvtColor_traits<SRC_T>::COEFF_T parCr;
    typename CvtColor_traits<SRC_T>::COEFF_T parCb;
public:
    kernel_CvtColor() : parGr(-0.714), parGb(-0.344), parCr(1.403), parCb(1.773) {};
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        SRC_T Y = _src.val[0];
        SRC_T Cr = _src.val[1];
        SRC_T Cb = _src.val[2];
        _dst.val[0] = sr_cast<DST_T> (Y + parCr * (Cr-CvtColor_traits<SRC_T>().delta));
        _dst.val[1] = sr_cast<DST_T> (Y + parGr * (Cr-CvtColor_traits<SRC_T>().delta) + parGb * (Cb-CvtColor_traits<SRC_T>().delta));
        _dst.val[2] = sr_cast<DST_T> (Y + parCb * (Cb-CvtColor_traits<SRC_T>().delta));
    }
};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_YCrCb2BGR, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        Scalar<CN1,SRC_T> dst2;
        kernel_CvtColor<HLS_YCrCb2RGB,SRC_T,DST_T> kernel_opr;
        kernel_opr.apply(_src, dst2);
        _dst.val[0] = dst2.val[2];
        _dst.val[1] = dst2.val[1];
        _dst.val[2] = dst2.val[0];
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_RGB2HSV, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
#pragma HLS inline
 SRC_T R = _src.val[0];
        SRC_T G = _src.val[1];
        SRC_T B = _src.val[2];
 typename CvtColor_traits<DST_T>::H_MULT_T H;
 typename CvtColor_traits<DST_T>::S_MULT_T S;
 typename CvtColor_traits<DST_T>::SUB_T sub;
 typename CvtColor_traits<DST_T>::INV_T inv_max = 0;
 typename CvtColor_traits<DST_T>::INV_T inv_diff = 0;
 DST_T max = B;
 DST_T min = B;
 DST_T diff;

 MaxMin<SRC_T,DST_T>::max(_src, max);
 MaxMin<SRC_T,DST_T>::min(_src, min);
 diff=max-min;

 if(max!=0)
   inv_max = (typename CvtColor_traits<DST_T>::INV_T) 1/max;
 else
   inv_max = 0;

 S=inv_max*diff;

 if(diff!=0)
   inv_diff = (typename CvtColor_traits<DST_T>::INV_T) 1/diff;
 else
   inv_diff = 0;

 sub=(max==R) ? (G-B) : (max==G) ? (B-R) : (R-G);
 H=(max==R) ? 0 : (max==G) ? 120 : 240;
 H+=60*sub*inv_diff;

 if(180==CvtColor_traits<SRC_T>().hrange) {
   H=H/2;
   H+=((H+(typename CvtColor_traits<DST_T>::H_MULT_T)0.5)<0) ? 180 : 0;
 }
 else
   H+=(H<0) ? 360 :0;

        _dst.val[0] = sr_cast<DST_T>(H);
        _dst.val[1] = (180==CvtColor_traits<SRC_T>().hrange) ? sr_cast<DST_T>(255*S) : sr_cast<DST_T>(S);
        _dst.val[2] = max;
    }
};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_BGR2HSV, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        Scalar<CN1,SRC_T> src2;
        src2.val[0] = _src.val[2];
        src2.val[1] = _src.val[1];
        src2.val[2] = _src.val[0];
        kernel_CvtColor<HLS_RGB2HSV,SRC_T,DST_T> kernel_opr;
        kernel_opr.apply(src2, _dst);
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_HSV2RGB, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
#pragma HLS inline
 SRC_T H = _src.val[0];
        SRC_T S = _src.val[1];
        SRC_T V = _src.val[2];
 typename CvtColor_traits<DST_T>::S_MULT_T tab[4];
 typename CvtColor_traits<DST_T>::S_MULT_T f;
 static const int sector_data[][3]=
  {{0,3,1}, {2,0,1}, {1,0,3}, {1,2,0}, {3,1,0},{0,1,2}};
 typename CvtColor_traits<DST_T>::S_MULT_T S_scale;
 unsigned char h_i;

#pragma HLS array_partition variable=tab dim=0 complete

 h_i = (unsigned char)(H*(CvtColor_traits<SRC_T>().inv_hrange));
 f = H*(CvtColor_traits<SRC_T>().inv_hrange) - h_i;
 if(h_i >= 6)
   h_i -= 6;

 S_scale=S*(CvtColor_traits<SRC_T>().inv_scale);

 tab[0] = V;
 tab[1] = V*(1-S_scale);
 tab[2] = V*(1-f*S_scale);
 tab[3] = V*(1-S_scale+f*S_scale);

        _dst.val[0] = sr_cast<DST_T>(tab[sector_data[h_i][0]]);
        _dst.val[1] = sr_cast<DST_T>(tab[sector_data[h_i][1]]);
        _dst.val[2] = sr_cast<DST_T>(tab[sector_data[h_i][2]]);
    }
};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_HSV2BGR, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        Scalar<CN1,SRC_T> dst2;
        kernel_CvtColor<HLS_HSV2RGB,SRC_T,DST_T> kernel_opr;
        kernel_opr.apply(_src, dst2);
        _dst.val[0] = dst2.val[2];
        _dst.val[1] = dst2.val[1];
        _dst.val[2] = dst2.val[0];
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_RGB2HLS, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
#pragma HLS inline
 SRC_T R = _src.val[0];
        SRC_T G = _src.val[1];
        SRC_T B = _src.val[2];
 typename CvtColor_traits<DST_T>::H_MULT_T H;
 typename CvtColor_traits<DST_T>::S_MULT_T S;
 DST_T L;
 typename CvtColor_traits<DST_T>::SUB_T sub;
 typename CvtColor_traits<DST_T>::ADD_T add;
 typename CvtColor_traits<DST_T>::INV_T inv_add = 0;
 typename CvtColor_traits<DST_T>::INV_T inv_add_comp= 0;
 typename CvtColor_traits<DST_T>::INV_T inv_diff = 0;
 DST_T max = B;
 DST_T min = B;
 DST_T diff;

 MaxMin<SRC_T,DST_T>::max(_src, max);
 MaxMin<SRC_T,DST_T>::min(_src, min);
 diff=max-min;
 add=max+min;
 L=sr_cast<DST_T>((max+min)/2);

 if(add!=0)
   inv_add = (typename CvtColor_traits<DST_T>::INV_T) 1/add;
 else
   inv_add = 0;



 if((2*(CvtColor_traits<SRC_T>().scale)-add)!=0)
   inv_add_comp = (typename CvtColor_traits<DST_T>::INV_T) 1/(2*(CvtColor_traits<SRC_T>().scale)-add);
 else
   inv_add_comp = 0;

 if(L<=CvtColor_traits<SRC_T>().delta)
   S=inv_add*diff;
 else
   S=inv_add_comp*diff;

 if(diff!=0)
   inv_diff = (typename CvtColor_traits<DST_T>::INV_T) 1/diff;
 else
   inv_diff = 0;

 sub=(max==R) ? (G-B) : (max==G) ? (B-R) : (R-G);
 H=(max==R) ? 0 : (max==G) ? 120 : 240;
 H+=60*sub*inv_diff;

 if(180==CvtColor_traits<SRC_T>().hrange) {
   H=H/2;
   H+=((H+(typename CvtColor_traits<DST_T>::H_MULT_T)0.5)<0) ? 180 : 0;
 }
 else
   H+=(H<0) ? 360 :0;

        _dst.val[0] = sr_cast<DST_T>(H);
        _dst.val[1] = L;
        _dst.val[2] = (180==CvtColor_traits<SRC_T>().hrange) ?
            sr_cast<DST_T>(CvtColor_traits<SRC_T>().scale*S) :
            sr_cast<DST_T>(S);

    }
};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_BGR2HLS, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        Scalar<CN1,SRC_T> src2;
        src2.val[0] = _src.val[2];
        src2.val[1] = _src.val[1];
        src2.val[2] = _src.val[0];
        kernel_CvtColor<HLS_RGB2HLS,SRC_T,DST_T> kernel_opr;
        kernel_opr.apply(src2, _dst);
    }
};

template<typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_HLS2RGB, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
#pragma HLS inline
 SRC_T H = _src.val[0];
        SRC_T L = _src.val[1];
        SRC_T S = _src.val[2];
 typename CvtColor_traits<DST_T>::S_MULT_T tab[4];
 typename CvtColor_traits<DST_T>::S_MULT_T f;
 static const int sector_data[][3]=
  {{0,3,1}, {2,0,1}, {1,0,3}, {1,2,0}, {3,1,0},{0,1,2}};
 typename CvtColor_traits<DST_T>::S_MULT_T S_scale;
 unsigned char h_i;

#pragma HLS array_partition variable=tab dim=0 complete

 h_i = (unsigned char)(H*(CvtColor_traits<SRC_T>().inv_hrange));
 f = H*(CvtColor_traits<SRC_T>().inv_hrange) - h_i;
 if(h_i >= 6)
   h_i -= 6;

 S_scale=S*(CvtColor_traits<SRC_T>().inv_scale);

 if(L<=0.5*CvtColor_traits<SRC_T>().scale)
   tab[0] = L+L*S_scale;

 else
    tab[0] = L+S-L*S_scale;

 tab[1] = 2*L-tab[0];
 tab[2] = tab[0]-(tab[0]-tab[1])*f;
 tab[3] = tab[1]+(tab[0]-tab[1])*f;

        _dst.val[0] = sr_cast<DST_T>(tab[sector_data[h_i][0]]);
        _dst.val[1] = sr_cast<DST_T>(tab[sector_data[h_i][1]]);
        _dst.val[2] = sr_cast<DST_T>(tab[sector_data[h_i][2]]);
    }
};

template <typename SRC_T, typename DST_T>
class kernel_CvtColor<HLS_HLS2BGR, SRC_T, DST_T> {
public:
    template<int CN1,int CN2>
    void apply(Scalar<CN1,SRC_T>& _src, Scalar<CN2,DST_T>& _dst) {
        Scalar<CN1,SRC_T> dst2;
        kernel_CvtColor<HLS_HLS2RGB,SRC_T,DST_T> kernel_opr;
        kernel_opr.apply(_src, dst2);
        _dst.val[0] = dst2.val[2];
        _dst.val[1] = dst2.val[1];
        _dst.val[2] = dst2.val[0];
    }
};

template<typename CONVERSION,int SRC_T, int DST_T,
    int ROWS,int COLS>
void CvtColor(
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<ROWS, COLS, DST_T> &_dst
        )
{
    kernel_CvtColor<CONVERSION,typename Type<((SRC_T) & ((1 << 11) - 1))>::name,typename Type<((DST_T) & ((1 << 11) - 1))>::name> kernel_opr;
    int cols=_src.cols;
    int rows=_src.rows;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",1963),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",1964),0));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> _s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> _d;
 loop_height: for(int i= 0; i < rows; i++) {
    loop_width: for (int j= 0; j < cols; j++) {
#pragma HLS LOOP_FLATTEN OFF
#pragma HLS PIPELINE
 _src >> _s;
            kernel_opr.apply(_s,_d);
            _dst << _d;
        }
    }
}

template<int SRC_T, int DST_T,
int ROWS,int COLS>
void Integral(
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<ROWS+1, COLS+1, DST_T> &_sum
        )
{
    LineBuffer<1,COLS+1,typename Type<((DST_T) & ((1 << 11) - 1))>::name> k_buf;
    int cols=_src.cols;
    int rows=_src.rows;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",1988),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",1989),0));
    Scalar<1,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> _s;
    Scalar<1,typename Type<((DST_T) & ((1 << 11) - 1))>::name> _d;
    int sqsum, sum=0;

 loop_height: for(int i= 0;i<rows+1;i++) {
    loop_width: for (int j= 0;j<cols+1;j++) {
#pragma HLS LOOP_FLATTEN OFF
#pragma HLS PIPELINE
 if(i==0||(j==0&&i!=0))
            {
                k_buf.val[0][j]=0;
                _d.val[0]=0;
                sum=0;
            }
            else
            {
                _src>>_s;
                sum=sum+_s.val[0];
                _d.val[0]=sum+k_buf.val[0][j];
                k_buf.val[0][j]=_d.val[0];
            }
            _sum<<_d;
        }
    }
}
template<int SRC_T, int DST_T,int DSTSQ_T,
    int ROWS,int COLS>
void Integral(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS+1, COLS+1, DST_T> &_sum,
  Mat<ROWS+1, COLS+1, DSTSQ_T> &_sqsum
                )
{
    LineBuffer<1,COLS+1,typename Type<((DST_T) & ((1 << 11) - 1))>::name> k_buf;
    LineBuffer<1,COLS+1,typename Type<((DSTSQ_T) & ((1 << 11) - 1))>::name> k_sqbuf;
    int cols=_src.cols;
    int rows=_src.rows;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",2027),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",2028),0));
    Scalar<1,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> _s;
    Scalar<1,typename Type<((DST_T) & ((1 << 11) - 1))>::name> _d;
    Scalar<1,typename Type<((DSTSQ_T) & ((1 << 11) - 1))>::name> _sqd;
    int sqsum, sum=0;

 loop_height: for(int i= 0;i<rows+1;i++) {
    loop_width: for (int j= 0;j<cols+1;j++) {
#pragma HLS LOOP_FLATTEN OFF
#pragma HLS PIPELINE
 if(i==0||(j==0&&i!=0))
            {
                k_buf.val[0][j]=0;
                k_sqbuf.val[0][j]=0;
                _d.val[0]=0;
                _sqd.val[0]=0;
                sum=0;
                sqsum=0;
            }
            else
            {
                _src>>_s;
                sum=sum+_s.val[0];
                sqsum=sqsum+_s.val[0]*_s.val[0];

                _d.val[0]=sum+k_buf.val[0][j];
                _sqd.val[0]=sqsum+k_sqbuf.val[0][j];
                k_buf.val[0][j]=_d.val[0];
                k_sqbuf.val[0][j]=_sqd.val[0];
            }
            _sum<<_d;
            _sqsum<<_sqd;
        }
    }
}







template <int NTAPS, int NPHASES, int COEFF_BITS,typename HT, typename VT>
void init_scale_coefficients(HT *Hcoefs, VT *Vcoefs) {

#pragma HLS inline off
 static const float A = -0.5;
    double t;
    double coeff[NPHASES][NTAPS];
    int i,j;

    VITIS_LOOP_2079_1: for (i=0; i<NPHASES; i++) {
        t=((double) i)/NPHASES;
        coeff[i][0] = A*(t*((2-t)*t-1));
        coeff[i][1] = A*(t*t*(3*t-5)+2);
        coeff[i][2] = A*(t*((4-3*t)*t+1));
        coeff[i][3] = A*((t-1)*t*t);
    }
    VITIS_LOOP_2086_2: for (i = 0; i < NPHASES; i++) {
        VITIS_LOOP_2087_3: for (j = 0; j < NTAPS; j++) {
            Hcoefs[(NTAPS*i)+j] = (HT)coeff[i][j];
            Vcoefs[(NTAPS*i)+j] = (VT)coeff[i][j];
        }
    }
}

template<int NTAPS, int COEFF_BITS, int T,typename FILTER_T>
hls::Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> scale_operator(hls::Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> *samples, FILTER_T *coeffs) {

    typedef typename filter2d_traits<typename Type<((T) & ((1 << 11) - 1))>::name, FILTER_T, NTAPS>::SRC_CAST_T SRCT;
    int i,j,ch;
    hls::Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> pix_out;
CHAN_LOOP : for (ch =0; ch<((((T) & ((512 - 1) << 11)) >> 11) + 1); ch++) {
        typename filter2d_traits<typename Type<((T) & ((1 << 11) - 1))>::name, FILTER_T, NTAPS>::ACCUM_T t=0;
        typename filter2d_traits<typename Type<((T) & ((1 << 11) - 1))>::name, FILTER_T, NTAPS>::MULT_T temp;
    TAPS_LOOP : for (i = 0,t=0.5; i < NTAPS; i++) {
#pragma HLS inline
 typename Type<((T) & ((1 << 11) - 1))>::name sample = samples[i].val[ch];
            temp = ((SRCT)sample)*coeffs[NTAPS-1-i];
            t = t - temp ;
        }
        pix_out.val[ch] = sr_cast<typename Type<((T) & ((1 << 11) - 1))>::name> (t);
    }
    return pix_out;
}


template <int COLS, int ROWS,int DCOLS, int DROWS, int T>
void Resize_opr_bicubic(hls::Mat<ROWS, COLS, T>& _src, hls::Mat<DROWS, DCOLS, T>& _dst) {
    typedef ap_fixed<32, 16, AP_RND> FT;
    typedef short N16;
    const int NTAPS = 4;
    const int NPHASES = 16;
    const int COEFF_BITS = 16;
    const short ES = 2;
    typename filter2d_traits<typename Type<((T) & ((1 << 11) - 1))>::name, ap_fixed<25, 5, AP_RND>, NTAPS>::FILTER_CAST_T hcoeffs[NPHASES][NTAPS];
    typename filter2d_traits<typename Type<((T) & ((1 << 11) - 1))>::name, ap_fixed<25, 5, AP_RND>, NTAPS>::FILTER_CAST_T vcoeffs[NPHASES][NTAPS];
    N16 row, col;
    N16 rows, cols;
    ap_uint<32> v_phase_acc;
    ap_uint<32> h_phase_acc;

    hls::LineBuffer<NTAPS, (COLS>DCOLS?COLS:DCOLS) + 3, hls::Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> > linebuf;
    hls::Window<1, NTAPS, hls::Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> > h_shreg;
    hls::Scalar<((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name> pix_in, h_fir_out, pix_out, h_fir[NTAPS], v_fir[NTAPS];
    hls::Scalar < ((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name > temp_in[NTAPS];
    hls::Scalar < ((((T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((T) & ((1 << 11) - 1))>::name > temp_out[NTAPS];
    typename Type<((T) & ((1 << 11) - 1))>::name pix_in_ch, pix_out_ch;

    N16 rows_rw = -1, cols_rw = -1;
    bool col_rd_en;
    bool row_rd_en;
    bool col_wr_en;
    bool row_wr_en;
    ap_uint<4> v_phase;
    ap_uint<4> h_phase;
#pragma HLS array_partition variable= temp_in dim=0 complete
#pragma HLS array_partition variable= temp_out dim=0 complete
#pragma HLS array_partition variable= h_fir dim=0 complete
#pragma HLS array_partition variable= v_fir dim=0 complete
#pragma HLS array_partition variable=hcoeffs dim=2 complete
#pragma HLS array_partition variable=vcoeffs dim=2 complete


 init_scale_coefficients<NTAPS, NPHASES, COEFF_BITS>(hcoeffs[0], vcoeffs[0]);

    N16 rows_in = _src.rows;
    N16 cols_in = _src.cols;
    N16 rows_out = _dst.rows;
    N16 cols_out = _dst.cols;
    FT row_ratio = (FT(rows_out)) / (FT)rows_in;
    FT col_ratio = (FT(cols_out)) / (FT)cols_in;

    int row_rate = (ap_fixed<4, 2, AP_RND>(0.5) + row_ratio * 65536);
    int col_rate = (ap_fixed<4, 2, AP_RND>(0.5) + col_ratio * 65536);
    rows = (rows_in > rows_out) ? rows_in : rows_out;
    cols = (cols_in > cols_out) ? cols_in : cols_out;
    (void) ((!!(rows<=ROWS || rows<=DROWS)) || (_assert("rows<=ROWS || rows<=DROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",2165),0));
    (void) ((!!(cols<=COLS || cols<=DCOLS)) || (_assert("cols<=COLS || cols<=DCOLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",2166),0));
    v_phase_acc = 0;

 ROW_LOOP: for (row = 0; row < rows + 3; row++) {
    COL_LOOP: for (col = 0; col < cols + 3; col++) {
#pragma HLS PIPELINE
#pragma HLS loop_flatten off
#pragma HLS DEPENDENCE array inter false
 if (col == 0) {
                  v_phase = (v_phase_acc >> 12) & 15;
                  if (row_rate < 65536) {
                      row_rd_en = true;
                      N16 drow = row * row_ratio;
                      if (rows_rw != drow) {
                          row_wr_en = true;
                          rows_rw = drow;
                      } else
                          row_wr_en = false;
                  } else {
                      row_wr_en = true;
                      N16 drow = row / row_ratio;
                      if (rows_rw != drow) {
                          row_rd_en = true;
                          rows_rw = drow;
                      } else
                          row_rd_en = false;
                  }
                  if (row_rate < 65536 || row_rd_en)
                      v_phase_acc = v_phase_acc + row_rate;
              }

              h_phase = (h_phase_acc >> 12) & 15;
              if (col_rate < 65536) {
                  col_rd_en = true;
                  N16 dcol = col * col_ratio;
                  if (col == 0 || (col > 0 && cols_rw != dcol)) {
                      col_wr_en = true;
                      cols_rw = dcol;
                  } else
                      col_wr_en = false;
              } else {
                  col_wr_en = true;
                  N16 dcol = col / col_ratio;
                  if (col == 0 || (col > 0 && cols_rw != dcol)) {
                      col_rd_en = true;
                      cols_rw = dcol;
                  } else
                      col_rd_en = false;
              }

              if (col > 0 && (col_rate < 65536 || col_rd_en))
                  h_phase_acc = h_phase_acc + col_rate;
              else
                  h_phase_acc = col_rate;

              if (col_rd_en) {
                  h_shreg.shift_left();
                  if (row_rd_en) {
                      if (row < rows && col < cols) {
                          pix_in = _src.read();
                          h_shreg.insert(pix_in, 0, NTAPS - 1);
                      } else if (col >= cols && row < rows) {
                          h_shreg.insert(pix_in, 0, NTAPS - 1);
                      } else if (row >= rows) {
                          VITIS_LOOP_2230_1: for (int m = 0; m < ((((T) & ((512 - 1) << 11)) >> 11) + 1); m++)
                              pix_in.val[0] = 0;
                          h_shreg.insert(pix_in, 0, NTAPS - 1);
                      }
                  }
              }

              VITIS_LOOP_2237_2: for (int i = 0; i < NTAPS; i++) {
                  temp_in[i] = linebuf.val[i][col];
              }

              if (col_wr_en) {
                  if ((row_rd_en) || (row < ES) || (row >= rows - ES)) {
                      VITIS_LOOP_2243_3: for (int i = NTAPS - 1; i > 0; i--) {
                          temp_out[i] = temp_in[i - 1];
                      }
H_LOOP: for (int i = 0; i < NTAPS; i++) {
            h_fir[i] =
                (col > i) ?
                h_shreg.getval(0, i) :
                h_shreg.getval(0, NTAPS - 1 - col);
        }
        h_fir_out = scale_operator<NTAPS, COEFF_BITS, T>(h_fir,
                hcoeffs[h_phase]);
        temp_out[0] = h_fir_out;
        v_fir[NTAPS - 1] = h_fir_out;
                  } else {
                      VITIS_LOOP_2257_4: for (int i = NTAPS - 1; i >= 0; i--) {
                          temp_out[i] = temp_in[i];
                      }
                      v_fir[NTAPS - 1] = temp_in[0];
                  }
V_LOOP: for (int i = 0; i < NTAPS - 1; i++) {
            v_fir[i] =
                (row > 0) ? temp_out[NTAPS - 1 - i] : temp_out[0];
        }
              }

              VITIS_LOOP_2268_5: for (int i = 0; i < NTAPS; i++) {
                  linebuf.val[i][col] = (row > 0) ? temp_out[i] : temp_out[0];
              }

              if (row >= 3 && col >= 3 && row_wr_en && col_wr_en) {
                  pix_out = scale_operator<NTAPS, COEFF_BITS, T>(v_fir, vcoeffs[v_phase]);
                  _dst.write(pix_out);
              }
          }
          }
}

template<int SRC_T, int ROWS,int COLS,int DROWS,int DCOLS>
void Resize_opr_linear (
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<DROWS, DCOLS, SRC_T> &_dst )
{
    LineBuffer<2,(COLS>DCOLS?COLS:DCOLS)+1,Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> > k_buf;
    Window<2,2,Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> > win;
    short dcols=_dst.cols;
    short drows=_dst.rows;
    short srows=_src.rows;
    short scols=_src.cols;
    ap_fixed<32,16,AP_RND> row_rate=((ap_fixed<32,16,AP_RND> )srows)/(ap_fixed<32,16,AP_RND>)drows;
    ap_fixed<32,16,AP_RND> col_rate=((ap_fixed<32,16,AP_RND> )scols)/(ap_fixed<32,16,AP_RND>)dcols;
    typename filter2d_traits<typename Type<((SRC_T) & ((1 << 11) - 1))>::name, ap_fixed<20,2,AP_RND> ,4>::FILTER_CAST_T u,v, u1,v1;

    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s, temp, d;
    ap_fixed<4,2,AP_RND> par=0.5;
    ap_fixed<20,10,AP_RND> offset_row=row_rate/2-par;
    ap_fixed<20,10,AP_RND> offset_col=col_rate/2-par;
    ap_fixed<32,16,AP_RND> fx=0;
    ap_fixed<32,16,AP_RND> fy=0;

    short rows=srows > drows ? srows : (drows+1);
    short cols=scols > dcols ? scols : (dcols+1);
    (void) ((!!(rows<=ROWS || rows<=DROWS+1)) || (_assert("rows<=ROWS || rows<=DROWS+1","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",2304),0));
    (void) ((!!(cols<=COLS || cols<=DCOLS+1)) || (_assert("cols<=COLS || cols<=DCOLS+1","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",2305),0));

    short x=0;
    short pre_fy=-10;
    short pre_fx=-10;
    bool row_rd=false;
    bool row_wr=false;

    VITIS_LOOP_2313_1: for(short i= 0;i<rows;i++) {
        VITIS_LOOP_2314_2: for(short j= 0;j<cols;j++) {
#pragma HLS LOOP_FLATTEN OFF
#pragma HLS DEPENDENCE array inter false
#pragma HLS PIPELINE

 bool col_rd=false;
            bool col_wr=false;

            short dy = row_rate>1 ? (short)(i/row_rate):(i-1);
            short dx = col_rate>1 ? (short)(j/col_rate):(j-1);

            fy =(dy)*row_rate+offset_row;
            fx =(dx)*col_rate+offset_col;

            short sx=(short)fx;
            short sy=(short)fy;
            if(fx-sx>0)
                u=fx-sx;
            else
                u=0;
            if(fy-sy>0)
                v=fy-sy;
            else
                v=0;
            u1=1-u;
            v1=1-v;
            if(sx>scols-1)
            {
                sx=scols-1;
                u=0;
            }
            if(sy>srows-1)
            {
                sy=srows-1;
                v=0;
            }
            if(j==0)
            {
                x=0;
                pre_fx=-10;
                if(row_rate>1)
                {
                    row_rd=true;
                    row_wr= (sy==(i-1)) ? true : false;
                }
                else
                {
                    if(i==0){
                        row_rd=true;
                    }
                    else if(sy!=pre_fy)
                    {
                        row_rd=true;
                        pre_fy=sy;
                    }
                    else {
                        row_rd=false;
                    }
                    row_wr= i>0? true: false;
                }
            }
            if(col_rate>1)
            {
                col_rd=true;
                col_wr= (sx==(j-1)) ? true : false;
            }else{
                if(j==0){
                    col_rd=true;
                }
                else if(sx!=pre_fx)
                {
                    col_rd=true;
                    pre_fx=sx;
                }
                else
                    col_rd=false;
                col_wr= j>0? true: false;
            }
            if(col_rd)
            {
                VITIS_LOOP_2394_3: for(int r= 0;r<2;r++)
                {
                    win.val[r][1]=win.val[r][0];
                }
                if(row_rd)
                {

                    k_buf.val[1][x]=k_buf.val[0][x];
                    win.val[1][0]=k_buf.val[0][x];
                    if(sy<srows-1&&sx<scols-1)
                    {
                        _src >> s;
                        k_buf.val[0][x]=s;
                        win.val[0][0]=k_buf.val[0][x];
                    }
                    else if(sx>=scols-1&&sy<srows-1){
                        k_buf.val[0][x]=s;
                    }
                    else if(sy>=srows-1){
                        win.val[0][0]=k_buf.val[0][x];
                    }
                }
                else
                {
                    VITIS_LOOP_2418_4: for(int r= 0;r<2;r++)
                    {
                        win.val[r][0]=k_buf.val[r][x];
                    }
                }

                x++;
            }
            if(row_wr && col_wr)
            {
                VITIS_LOOP_2428_5: for(int k=0;k<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);k++)
                {
                    typename filter2d_traits<typename Type<((SRC_T) & ((1 << 11) - 1))>::name, ap_fixed<15,1,AP_RND> ,4>::ACCUM_T t=0;
                    typedef typename fixed_type<typename Type<((SRC_T) & ((1 << 11) - 1))>::name>::T SRCT;

                    t=((SRCT)win.val[1][1].val[k])*u1*v1+
                        ((SRCT)win.val[1][0].val[k])*v1*u+
                        ((SRCT)win.val[0][1].val[k])*u1*v+
                        ((SRCT)win.val[0][0].val[k])*u*v;
                    d.val[k]=sr_cast<typename Type<((SRC_T) & ((1 << 11) - 1))>::name>(t);
                }
                _dst << d;
            }
        }
    }
}







template<int SRC_T, int ROWS,int COLS,int DROWS,int DCOLS>
void Resize (
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<DROWS, DCOLS, SRC_T> &_dst,
        int interpolation=1 )
{
    switch(interpolation) {
    case 0:



        break;
    case 2:



        break;
    case 4:



        break;
    case 3:
        Resize_opr_bicubic(_src,_dst);
        break;
    case 1:
        Resize_opr_linear(_src,_dst);
        break;
    }
}

template<int SRC_T, int DST_T,
    int ROWS,int COLS>
void ConvertScale (
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<ROWS, COLS, DST_T> &_dst,
        double alpha=1,
        double beta=0
        )
{
    int cols=_src.cols;
    int rows=_src.rows;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",2493),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",2494),0));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> _s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> _d;
loop_height: for(int i= 0;i<rows;i++) {
    loop_width: for (int j= 0;j<cols;j++) {
#pragma HLS LOOP_FLATTEN OFF
#pragma HLS PIPELINE
 _src>>_s;
        loop_channels: for(int k=0;k<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);k++)
            {
                _d.val[k]=sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(_s.val[k]*alpha+beta);
            }
            _dst<<_d;
        }
    }
}

template<int SRC_T, int DST_T,
    int ROWS,int COLS>
void ConvertScaleAbs (
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<ROWS, COLS, DST_T> &_dst,
        double alpha=1,
        double beta=0
        )
{
    int cols=_src.cols;
    int rows=_src.rows;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",2522),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",2523),0));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> _s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> _d;
loop_height: for(int i= 0;i<rows;i++) {
    loop_width: for (int j= 0;j<cols;j++) {
#pragma HLS LOOP_FLATTEN OFF
#pragma HLS PIPELINE
 _src>>_s;
        loop_channels: for(int k=0;k<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);k++)
            {
                _d.val[k]=sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(abs(_s.val[k]*alpha+beta));
            }
            _dst<<_d;
        }
    }
}
template<int XORDER, int YORDER, int SIZE, typename T>
void Sobel_kernel(Window<SIZE,SIZE,T > &kernel)
{
    int kerI[SIZE+1];
    Window<1,SIZE,T> kernelX;
    Window<SIZE,1,T> kernelY;

    VITIS_LOOP_2546_1: for(int k=0; k<2; k++)
    {
        int order = k == 0 ? XORDER : YORDER;

        if( SIZE==3 )
        {
            if(order==0 )
                kerI[0]=1, kerI[1]=2, kerI[2]=1;
            else if( order == 1 )
                kerI[0]=-1, kerI[1]=0, kerI[2]=1;
            else
                kerI[0]=1, kerI[1]=-2, kerI[2]=1;
        }
        else
        {
            int oldval, newval;
            kerI[0] = 1;
            VITIS_LOOP_2563_2: for(int i=0; i<SIZE; i++)
                kerI[i+1] = 0;

            VITIS_LOOP_2566_3: for(int i=0; i<SIZE-order-1; i++)
            {
                oldval = kerI[0];
                VITIS_LOOP_2569_4: for(int j = 1; j <= SIZE; j++ )
                {
                    newval = kerI[j]+kerI[j-1];
                    kerI[j-1] = oldval;
                    oldval = newval;
                }
            }

            VITIS_LOOP_2577_5: for(int i = 0; i < order; i++ )
            {
                oldval = -kerI[0];
                VITIS_LOOP_2580_6: for(int j = 1; j <= SIZE; j++ )
                {
                    newval = kerI[j-1] - kerI[j];
                    kerI[j-1] = oldval;
                    oldval = newval;
                }
            }
        }

        VITIS_LOOP_2589_7: for(int i=0; i<SIZE; i++) {
         if(k==0)
             kernelX(0,i)=kerI[i];
         else
             kernelY(i,0)=kerI[i];
     }
    }

    VITIS_LOOP_2597_8: for(int i=0; i<SIZE; i++) {
        VITIS_LOOP_2598_9: for(int j=0; j<SIZE; j++) {
            kernel(i,j)=kernelY(i,0)*kernelX(0,j);
     }
    }

}

template<int XORDER, int YORDER, int SIZE, typename BORDERMODE, int SRC_T, int DST_T, int ROWS,int COLS,int DROWS,int DCOLS>
void Sobel (
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<DROWS, DCOLS, DST_T> &_dst)
{




    Window<SIZE,SIZE,ap_int<8> > kernel;
    Sobel_kernel<XORDER, YORDER >(kernel);
    Point_<int> c_point;
    c_point.x=-1;
    c_point.y=-1;
    Filter2D<BORDERMODE>(_src,_dst,kernel, c_point);
}

template<int XORDER, int YORDER, int SIZE, int SRC_T, int DST_T, int ROWS,int COLS,int DROWS,int DCOLS>
void Sobel (
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<DROWS, DCOLS, DST_T> &_dst)
{
    Sobel<XORDER,YORDER,SIZE,BORDER_DEFAULT>(_src, _dst);
}

template<int KH,int KW,typename K_T,typename XT, typename YT>
void getGaussianKernel(
        Window<KH,KW,K_T> &kernel,
        XT sigmaX=0,
        YT sigmaY=0
        )
{
#pragma HLS INLINE off
 float kval[KH][KW];
     float sum=0;
     if(sigmaX <= 0)
     {
         sigmaX=0.3*((KW-1)*0.5-1)+0.8;
     }
     if(sigmaY <= 0)
     {
         sigmaY=0.3*((KH-1)*0.5-1)+0.8;
     }
     VITIS_LOOP_2648_1: for (int i = 0; i < KH; i++) {
            VITIS_LOOP_2649_2: for (int j = 0; j < KW; j++) {
                float index1=powf( (i-(KH-1)/2),2)*1.0/(2*sigmaY*sigmaY);
                float index2=powf( (j-(KW-1)/2),2)*1.0/(2*sigmaX*sigmaX);
                float index= -index1-index2;
                kval[i][j] = expf(index);
                sum+=kval[i][j];
            }
        }
     VITIS_LOOP_2657_3: for (int i = 0; i < KH; i++) {
         VITIS_LOOP_2658_4: for (int j = 0; j < KW; j++) {
             kval[i][j]=kval[i][j]/sum;
             kernel.val[i][j]=kval[i][j];
         }
     }

}

template<int KH,int KW,typename BORDERMODE,int SRC_T,int DST_T,int ROWS,int COLS>
void GaussianBlur(
  Mat<ROWS, COLS, SRC_T> &_src,
                Mat<ROWS, COLS, DST_T> &_dst,
                double sigmaX=0,
                double sigmaY=0)
{
    Point_<int> anchor;
    anchor.x = -1;
    anchor.y = -1;
    Window<KW, KH, ap_fixed<16,2,AP_RND> > kernel;
    getGaussianKernel(kernel,sigmaX,sigmaY);
    Filter2D<BORDERMODE>(_src, _dst, kernel, anchor);
}

template<int KH,int KW,int SRC_T,int DST_T,int ROWS,int COLS>
void GaussianBlur(
  Mat<ROWS, COLS, SRC_T> &_src,
                Mat<ROWS, COLS, DST_T> &_dst,
                double sigmaX=0,
                double sigmaY=0)
{
    GaussianBlur<KH,KW,BORDER_DEFAULT>(_src, _dst, sigmaX, sigmaY);
}


template <int KH,int KW>
void Box_kernel_1d(
        Window<1, KW, ap_ufixed<1,1> >& kernelX,
        Window<KH, 1, ap_ufixed<1,1> >& kernelY
        )
{
    float kval[KW];

    VITIS_LOOP_2700_1: for (int i = 0; i < KW; i++) {
        kernelX.val[0][i] = 1;
    }

    VITIS_LOOP_2704_2: for (int i = 0; i < KH; i++) {
        kernelY.val[i][0] = 1;
    }
}

template<int KH,int KW, bool NORMALIZE,typename BORDERMODE,
  int SRC_T,int DST_T,int ROWS,int COLS>
void BoxFilter(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, DST_T> &_dst,
        Point_<int> anchor=Point_<int>(-1,-1))
{
    Window<1, KW, ap_ufixed<1,1> > kernelX;
    Window<KH, 1, ap_ufixed<1,1> > kernelY;
    Box_kernel_1d(kernelX,kernelY);

    if( NORMALIZE)
    {
        const int BW = BitWidth<KH*KW>::Value+Type<((SRC_T) & ((1 << 11) - 1))>::bitdepth;
        const ap_ufixed<BW+1,1> scale = 1.0/(KH*KW);
        SepFilter2D<BORDERMODE>(_src, _dst, kernelX, kernelY, anchor, scale);
    }
    else
    {
        SepFilter2D<BORDERMODE>(_src, _dst, kernelX, kernelY, anchor);
    }
}

template<int KH,int KW, typename BORDERMODE, int SRC_T,int DST_T,int ROWS,int COLS>
void BoxFilter(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, DST_T> &_dst,
        Point_<int> anchor=Point_<int>(-1,-1))
{
    BoxFilter<KH,KW,true,BORDERMODE>(_src, _dst, anchor);
}

template<int KH,int KW, int SRC_T,int DST_T,int ROWS,int COLS>
void BoxFilter(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, DST_T> &_dst,
        Point_<int> anchor=Point_<int>(-1,-1))
{
    BoxFilter<KH,KW,true,BORDER_DEFAULT>(_src, _dst, anchor);
}


template <typename T,typename FT, int KH,int KW>
void Pyr_kernel(
        Window<KH, KW, T>& kernel,
        FT factor
        )
{
    int k[25]={1, 4, 6, 4, 1, 4, 16, 24, 16, 4, 6, 24, 36, 24, 6, 4, 16, 24, 16, 4, 1, 4, 6, 4, 1};
    VITIS_LOOP_2758_1: for(int i=0; i<5; i++)
        VITIS_LOOP_2759_2: for(int j=0; j<5; j++)
            kernel.val[i][j]=k[i*5+j]*(1.0/256)*factor;
}
template<int K_HEIGHT,int K_WIDTH,int SRC_T, int DST_T, typename KN_T,
         int ROWS,int COLS,int DROWS, int DCOLS>
void PyrUp_opr(
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<DROWS, DCOLS, DST_T> &_dst,
        Window<5,5,KN_T> &kernel
        )
{
    HLS_SIZE_T rows=_src.rows;
    HLS_SIZE_T cols=_src.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",2772),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",2773),0));
#pragma HLS inline

 Window<K_HEIGHT,K_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> src_kernel_win[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

    LineBuffer<K_HEIGHT,COLS,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> k_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];


    Window<K_HEIGHT,K_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> right_border_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

    Window<K_HEIGHT,1,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> col_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

#pragma HLS ARRAY_PARTITION variable=col_buf complete dim=0
#pragma HLS ARRAY_PARTITION variable=&kernel complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_kernel_win complete dim=0
#pragma HLS ARRAY_PARTITION variable=k_buf complete dim=1
#pragma HLS ARRAY_PARTITION variable=right_border_buf complete dim=0

 Point_< ap_int<14> > anchor;
    anchor.x=K_HEIGHT/2;
    anchor.y=K_WIDTH/2;
    ap_int<14> heightloop= 2*(rows+K_HEIGHT-1+K_HEIGHT);
    ap_int<14> widthloop = 2*(cols+K_WIDTH-1);
    Point_<ap_int<14> > ImagLoc;

    int channels=((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);
 loop_height: for(HLS_SIZE_T i= 0;i< heightloop;i++) {
    loop_width: for (HLS_SIZE_T j= 0;j< widthloop;j++) {
#pragma HLS LOOP_FLATTEN OFF
#pragma HLS DEPENDENCE array inter false
#pragma HLS PIPELINE
 bool oddrow=(i+1)&1;
                bool oddcol=(j+1)&1;
                ImagLoc.x=j/2-anchor.x;
                ImagLoc.y=i/2-K_HEIGHT-anchor.y;
                int x= ImagLoc.x;
                if(ImagLoc.x<0)
                    x= -ImagLoc.x;
                else if( ImagLoc.x >= cols )
                    x=2*cols- ImagLoc.x-1;
channelloop: for(HLS_CHANNEL_T k= 0; k < channels; k++)
                {
                    if(oddcol)
                    {

                        VITIS_LOOP_2818_1: for(int row= 0;row<K_HEIGHT;row++)
                            VITIS_LOOP_2819_2: for(int col= K_WIDTH-1;col>=1;col--)
                                src_kernel_win[k](row,col) = src_kernel_win[k](row,col-1);

                        VITIS_LOOP_2822_3: for(int buf_row = 0; buf_row < K_HEIGHT; buf_row++)
                        {

                            col_buf[k](buf_row,0) = k_buf[k](buf_row,x);
                        }

                        if((ImagLoc.y < (-anchor.y)) ||
                                (ImagLoc.y >= K_HEIGHT-1 && ImagLoc.y < rows-1 )) {

                            if(ImagLoc.x >= 0 && ImagLoc.x < cols) {
                                typename Type<((SRC_T) & ((1 << 11) - 1))>::name Toppixel = col_buf[k](K_HEIGHT-1,0);
                                src_kernel_win[k](K_HEIGHT-1,0) = Toppixel;
                                VITIS_LOOP_2834_4: for(int buf_row= K_HEIGHT-1;buf_row >= 1;buf_row--)
                                {
                                    typename Type<((SRC_T) & ((1 << 11) - 1))>::name temp = col_buf[k](buf_row-1,0);
                                    src_kernel_win[k](buf_row-1,0)=temp;
                                }
                                if(oddrow)
                                {
                                    if(ImagLoc.x >= cols - K_WIDTH)
                                    {
                                        right_border_buf[k](0,ImagLoc.x-(cols-K_WIDTH)) = Toppixel;
                                    }
                                    VITIS_LOOP_2845_5: for(int buf_row= K_HEIGHT-1;buf_row >= 1;buf_row--)
                                    {
                                        typename Type<((SRC_T) & ((1 << 11) - 1))>::name temp = col_buf[k](buf_row-1,0);
                                        k_buf[k](buf_row,x)=temp;
                                        if(ImagLoc.x >= cols - K_WIDTH)
                                        {
                                            right_border_buf[k](K_HEIGHT-buf_row,ImagLoc.x-(cols-K_WIDTH)) = temp;
                                        }
                                    }
                                    typename Type<((SRC_T) & ((1 << 11) - 1))>::name temp=0;
                                    _src.data_stream[k] >> temp;
                                    k_buf[k](0,x)=temp;
                                }
                            }
                            else if(ImagLoc.x < 0)
                            {
                                VITIS_LOOP_2861_6: for(int buf_row = 0;buf_row < K_HEIGHT; buf_row++)
                                {
                                    src_kernel_win[k](buf_row,0) = col_buf[k](buf_row,0);
                                }
                            }
                            else if (ImagLoc.x >= cols) {
                                VITIS_LOOP_2867_7: for(int buf_row= 0;buf_row < K_HEIGHT; buf_row++)
                                {
                                    src_kernel_win[k](buf_row,0) = right_border_buf[k](K_HEIGHT-1-buf_row,x-(cols-K_WIDTH));
                                }
                                if(!oddrow)
                                {
                                   VITIS_LOOP_2873_8: for(int buf_row= K_HEIGHT-1;buf_row>0;buf_row--)
                                     src_kernel_win[k](buf_row,0)= src_kernel_win[k](buf_row-1,0);
                                }

                            }
                        }
                        else if(ImagLoc.y > 0 )
                        {
                            ap_int<14> ref = K_HEIGHT-1;
                            if(ImagLoc.y >= rows-1)
                                ref = rows-1;
                            ap_int<14> y = ImagLoc.y;
                            VITIS_LOOP_2885_9: for(int buf_row= 0;buf_row<K_HEIGHT;buf_row++)
                            {
                                ap_int<14> t=y;
                                if(y<0)
                                    t=-y;
                                else if( y >= rows )
                                    t=2*rows-y-1;

                                ap_int<14> locy = ref - t;
                                src_kernel_win[k](buf_row,0) = col_buf[k](locy,0);
                                y--;
                            }
                           if(ImagLoc.y >= rows-1&&!oddrow)
                            {
                                VITIS_LOOP_2899_10: for(int buf_row= K_HEIGHT-1;buf_row>0;buf_row--)
                                   src_kernel_win[k](buf_row,0)= src_kernel_win[k](buf_row-1,0);
                            }
                        }

                    }

                    if(i >= 2*(K_HEIGHT + K_HEIGHT - 1) && j >= 2*(K_WIDTH-1))
                    {
                        typename filter2d_traits<typename Type<((SRC_T) & ((1 << 11) - 1))>::name, KN_T, K_HEIGHT*K_WIDTH>::ACCUM_T result=0;
                        if(oddrow)
                        {
                            if(oddcol)
                            {
                                VITIS_LOOP_2913_11: for(int m=0; m<K_HEIGHT; m++)
                                    VITIS_LOOP_2914_12: for(int n=0; n<K_WIDTH; n++)
                                        result= result + src_kernel_win[k](K_HEIGHT-1-m, K_WIDTH-1-n)* kernel.val[2*m][2*n];
                            }
                            else
                            {
                                VITIS_LOOP_2919_13: for(int m=0; m<K_HEIGHT; m++)
                                    VITIS_LOOP_2920_14: for(int n=1; n<K_WIDTH; n++)
                                        result= result + src_kernel_win[k](K_HEIGHT-1-m, K_WIDTH-1-n)* kernel.val[2*m][2*n-1];
                            }
                        }else
                        {
                            if(oddcol)
                            {
                                VITIS_LOOP_2927_15: for(int m=0; m<K_HEIGHT-1; m++)
                                    VITIS_LOOP_2928_16: for(int n=0; n<K_WIDTH; n++)
                                        result= result + src_kernel_win[k](K_HEIGHT-1-m, K_WIDTH-1-n)* kernel.val[2*m+1][2*n];
                            }
                            else
                            {

                                VITIS_LOOP_2934_17: for(int m=0; m<K_HEIGHT-1; m++)
                                    VITIS_LOOP_2935_18: for(int n=1; n<K_WIDTH; n++)
                                        result= result + src_kernel_win[k](K_HEIGHT-1-m, K_WIDTH-1-n)* kernel.val[2*m+1][2*n-1];
                            }
                        }
                        _dst.data_stream[k]<< sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(result);
                    }
                }
            }
             }
}
template<int SRC_T,int DST_T,int ROWS,int COLS, int DROWS, int DCOLS>
void PyrUp(
  Mat<ROWS, COLS, SRC_T> &_src,
                Mat<DROWS, DCOLS, DST_T> &_dst
                )
{



    Window<5, 5, ap_fixed<16,2,AP_RND> > kernel;
    Pyr_kernel(kernel, 4);
    PyrUp_opr<3,3>(_src, _dst, kernel);
}

template<int K_HEIGHT,int K_WIDTH,int SRC_T, int DST_T, typename KN_T,
         int ROWS,int COLS,int DROWS, int DCOLS>
void PyrDown_opr(
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<DROWS, DCOLS, DST_T> &_dst,
        Window<5,5,KN_T> &kernel
        )
{



#pragma HLS inline

 Window<K_HEIGHT,K_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> src_kernel_win[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

    LineBuffer<K_HEIGHT,COLS,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> k_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];


    LineBuffer<K_HEIGHT,K_WIDTH,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> right_border_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

    LineBuffer<K_HEIGHT,1,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> col_buf[((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1)];

#pragma HLS ARRAY_PARTITION variable=col_buf complete dim=0
#pragma HLS ARRAY_PARTITION variable=&kernel complete dim=0
#pragma HLS ARRAY_PARTITION variable=src_kernel_win complete dim=0
#pragma HLS ARRAY_PARTITION variable=k_buf complete dim=1
#pragma HLS ARRAY_PARTITION variable=right_border_buf complete dim=0

 Point_< ap_int<4> > anchor;
    anchor.x=K_WIDTH/2;
    anchor.y=K_HEIGHT/2;

    HLS_SIZE_T rows=_src.rows;
    HLS_SIZE_T cols=_src.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",2993),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",2994),0));
    HLS_SIZE_T heightloop= rows+K_HEIGHT-1+K_HEIGHT;
    HLS_SIZE_T widthloop = cols+K_WIDTH-1;
    Point_< ap_int<14> > ImagLoc;

    int channels=((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);
 loop_height: for(HLS_SIZE_T i= 0;i< heightloop;i++) {
    loop_width: for (HLS_SIZE_T j= 0;j< widthloop;j++) {
#pragma HLS LOOP_FLATTEN OFF
#pragma HLS DEPENDENCE array inter false
#pragma HLS PIPELINE
 bool oddrow=(i+1)&1;
                bool oddcol=(j+1)&1;

                ImagLoc.x=j-anchor.x;
                ImagLoc.y=i-K_HEIGHT-anchor.y;
                int x=ImagLoc.x ;
                if(ImagLoc.x<0)
                    x=-ImagLoc.x;
                else if( ImagLoc.x >= cols )
                    x=2*cols-ImagLoc.x-2;
channelloop: for(HLS_CHANNEL_T k= 0; k < channels; k++)
                {

                    VITIS_LOOP_3018_1: for(int row= 0;row<K_HEIGHT;row++)
                        VITIS_LOOP_3019_2: for(int col= K_WIDTH-1;col>=1;col--)
                            src_kernel_win[k](row,col) = src_kernel_win[k](row,col-1);

                    VITIS_LOOP_3022_3: for(int buf_row = 0; buf_row < K_HEIGHT; buf_row++)
                    {

                        col_buf[k](buf_row,0) = k_buf[k](buf_row,x);
                    }
                    if((ImagLoc.y < (-anchor.y)) ||
                            (ImagLoc.y >= K_HEIGHT-1 && ImagLoc.y < rows-1 ))
                    {

                        if(ImagLoc.x >= 0 && ImagLoc.x < cols)
                        {
                            typename Type<((SRC_T) & ((1 << 11) - 1))>::name Toppixel = col_buf[k](K_HEIGHT-1,0);
                            src_kernel_win[k](K_HEIGHT-1,0) = Toppixel;
                            if(ImagLoc.x >= cols - K_WIDTH)
                            {
                                right_border_buf[k](0,ImagLoc.x-(cols-K_WIDTH)) = Toppixel;
                            }
                            VITIS_LOOP_3039_4: for(int buf_row= K_HEIGHT-1;buf_row >= 1;buf_row--)
                            {
                                typename Type<((SRC_T) & ((1 << 11) - 1))>::name temp = col_buf[k](buf_row-1,0);
                                src_kernel_win[k](buf_row-1,0)=temp;
                                k_buf[k](buf_row,x)=temp;
                                if(ImagLoc.x >= cols - K_WIDTH)
                                {
                                    right_border_buf[k](K_HEIGHT-buf_row,ImagLoc.x-(cols-K_WIDTH)) = temp;
                                }
                            }
                            typename Type<((SRC_T) & ((1 << 11) - 1))>::name temp=0;
                            _src.data_stream[k] >> temp;
                            k_buf[k](0,x)=temp;
                        }
                        else if(ImagLoc.x < 0)
                        {
                            VITIS_LOOP_3055_5: for(int buf_row = 0;buf_row < K_HEIGHT; buf_row++)
                            {
                                src_kernel_win[k](buf_row,0) = col_buf[k](buf_row,0);
                            }
                        }
                        else if (ImagLoc.x >= cols)
                        {
                            VITIS_LOOP_3062_6: for(int buf_row= 0;buf_row < K_HEIGHT; buf_row++)
                            {
                                src_kernel_win[k](buf_row,0) = right_border_buf[k](K_HEIGHT-1-buf_row,x-(cols-K_WIDTH));
                            }
                        }
                    }
                    else if(ImagLoc.y >= 0) {

                        ap_int<14> ref = K_HEIGHT-1;
                        if(ImagLoc.y >= rows-1)
                            ref = rows-1;
                        ap_int<14> y = ImagLoc.y;
                        VITIS_LOOP_3074_7: for(int buf_row= 0;buf_row<K_HEIGHT;buf_row++)
                        {
                            ap_int<14> t = y;
                            if(y<0)
                                t=-y;
                            else if( y>= rows )
                                t=2*rows-y-2;
                            ap_int<14> locy = ref - t;
                            (void) ((!!(t < 0 || (locy >= 0 && locy < K_HEIGHT))) || (_assert("t < 0 || (locy >= 0 && locy < K_HEIGHT)","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_imgproc.h",3082),0));
                            src_kernel_win[k](buf_row,0) = col_buf[k](locy,0);
                            y--;
                        }
                    }

                    if(i >= (K_HEIGHT + K_HEIGHT - 1) && j >= (K_WIDTH-1))
                    {
                        typename filter2d_traits<typename Type<((SRC_T) & ((1 << 11) - 1))>::name, KN_T, 5*5>::ACCUM_T result=0;
                        if(!oddrow&&oddcol)
                        {
                            VITIS_LOOP_3093_8: for(int m=0; m<K_HEIGHT; m++)
                                VITIS_LOOP_3094_9: for(int n=0; n<K_WIDTH; n++)
                                    result= result + src_kernel_win[k](K_HEIGHT-1-m, K_WIDTH-1-n)* kernel.val[m][n];
                            _dst.data_stream[k]<< sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(result);
                        }
                    }
                }
            }
             }
}
template<int SRC_T,int DST_T,int ROWS,int COLS, int DROWS, int DCOLS>
void PyrDown(
  Mat<ROWS, COLS, SRC_T> &_src,
                Mat<DROWS, DCOLS, DST_T> &_dst
                )
{
    Window<5, 5, ap_fixed<16,2,AP_RND> > kernel;
    Pyr_kernel(kernel, 1);
    PyrDown_opr<5,5>(_src, _dst, kernel);
}

}
# 63 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src\\hls_video.h" 2
# 1 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_histogram.h" 1
# 39 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_histogram.h"
namespace hls {

template<int SRC_T, int DST_T,int ROW, int COL, int N>
void Equalize(
 Mat<ROW, COL, SRC_T> &_src,
 Mat<ROW, COL, DST_T> &_dst,
    ap_uint<8> (&map)[N]
                      )
{

    const int NUM_STATES=4;
    Window<1,NUM_STATES,ap_uint<8> > addr_win;

    ap_uint<BitWidth<ROW*COL>::Value> hist_out[N];
    Window<1,NUM_STATES,ap_uint<BitWidth<ROW*COL>::Value> > hist_win;
    ap_uint<BitWidth<ROW*COL>::Value> hist;
    ap_uint<8> addr;
    ap_uint<8> addr_last;
    ap_uint<BitWidth<ROW*COL>::Value> hist_last;
    ap_uint<8> addr_flag;
    ap_uint<BitWidth<ROW*COL>::Value> hist_flag;
    ap_uint<8> addr_w;
    ap_uint<BitWidth<ROW*COL>::Value> hist_w;

    VITIS_LOOP_63_1: for(int i=0;i<NUM_STATES;i++) {
#pragma HLS UNROLL
 addr_win(0,i)=i;
        hist_win(0,i)=0;
    }

    VITIS_LOOP_69_2: for(int i=0;i<N;i++)
        hist_out[i]=0;

    int cols=_src.cols;
    int rows=_src.rows;
    (void) ((!!(rows<=ROW)) || (_assert("rows<=ROW","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_histogram.h",74),0));
    (void) ((!!(cols<=COL)) || (_assert("cols<=COL","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_histogram.h",75),0));
 loop_height: for(int i=0;i<rows;i++)
    {
    loop_width: for(int j=0;j<cols;j++)
        {
#pragma HLS PIPELINE
#pragma HLS LOOP_FLATTEN OFF
#pragma HLS DEPENDENCE array inter false
 ap_uint<4> flag=NUM_STATES;
            typename Type<((SRC_T) & ((1 << 11) - 1))>::name tempsrc=0;
            typename Type<((DST_T) & ((1 << 11) - 1))>::name tempdst=0;
            _src.data_stream[0].read(tempsrc);
            tempdst=map[tempsrc];
            _dst.data_stream[0]<<tempdst;

            VITIS_LOOP_90_3: for (int m=0; m<NUM_STATES; m++) {
                if (tempsrc==addr_win(0,m)) {
                    flag = m;
                    break;
                }
            }

            latency_region:{
#pragma HLS latency min=0 max=1
 addr_last = addr_win(0,NUM_STATES-1);
            hist_last = hist_win(0,NUM_STATES-1)+1;

            VITIS_LOOP_102_4: for (int m=NUM_STATES-1; m>0; m--) {
                addr = addr_win(0,m-1);
                hist = hist_win(0,m-1);
                if (m==NUM_STATES/2) {
                    addr_w = addr;
                    if (m==flag+1) {
                        hist_w = hist+1;
                    } else {
                        hist_w = hist;
                    }
                }
                if (m==flag+1) {
                    addr_flag = addr;
                    hist_flag = hist+1;
                    addr_win(0,m) = addr_flag;
                    hist_win(0,m) = hist_flag;
                } else {
                    addr_win(0,m) = addr;
                    hist_win(0,m) = hist;
                }
            }

            if (flag==NUM_STATES) {
                hist_win(0,0) = hist_out[tempsrc]+1;
                addr_win(0,0) = tempsrc;
            } else if (flag==NUM_STATES-1) {
                addr_win(0,0) = addr_last;
                hist_win(0,0) = hist_last;
            } else if (flag>=NUM_STATES/2) {
                addr_win(0,0) = addr_flag;
                hist_win(0,0) = hist_flag;
            } else {
                addr_win(0,0) = addr_w;
                hist_win(0,0) = hist_w;
            }

            hist_out[addr_w] = hist_w;
            }
        }
    }
    VITIS_LOOP_142_5: for (int m=0; m<NUM_STATES/2; m++) {
#pragma HLS PIPELINE
 hist_out[addr_win(0,m)]=hist_win(0,m);
    }



    float scale = 1.f;
    ap_uint<BitWidth<ROW*COL>::Value> sum=0;
    bool flag = false;
 loop_normalize: for(int i=0;i<N;i++)
    {
#pragma HLS PIPELINE

 if (!flag) {
            if (hist_out[i] != 0) {
                flag = true;
                scale = 255.0f/(cols*rows - hist_out[i]);
                map[i] = 0;
                continue;
            }
        }

        sum+=hist_out[i];
        ap_uint<8> val=sr_cast< ap_uint<8> > (sum*scale);
        map[i]=val;
    }
    map[0]=0;
}

static ap_uint<8> lut[256];
template<int SRC_T, int DST_T,int ROW, int COL>
void EqualizeHist(
  Mat<ROW, COL, SRC_T> &_src,
  Mat<ROW, COL, DST_T> &_dst)
{
#pragma HLS INLINE
 Equalize(_src, _dst, lut);
}
}
# 64 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src\\hls_video.h" 2
# 1 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_fast.h" 1
# 39 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_fast.h"
namespace hls {

    template<int PSize,int KERNEL_SIZE,int NUM,typename SRC_T, typename DIFF_T>
int fast_pixel_diff(
        Window<KERNEL_SIZE,KERNEL_SIZE,SRC_T> &win,
        SRC_T _threshold,
        ap_uint<2> (&flag_val)[NUM],
        DIFF_T (&flag_d)[NUM],
        int (&flag)[PSize][2])
{
#pragma HLS INLINE
 DIFF_T d1,d2;
    int vt1,vt2;
    int x1,x2,y1,y2;
    int result=3;
    int K=PSize/2;
    VITIS_LOOP_55_1: for(int index=0;index<K;index++) {
        int kernel_half=KERNEL_SIZE/2;
        x1=flag[index][0];
        y1=flag[index][1];
        x2=flag[index+K][0];
        y2=flag[index+K][1];
        d1=win.val[kernel_half][kernel_half]-win.val[ y1 ][ x1 ];
        d2=win.val[kernel_half][kernel_half]-win.val[ y2 ][ x2 ];
        flag_d[index]=d1;
        flag_d[index+K]=d2;
        flag_d[index+PSize]=d1;
        if (d1 > _threshold)
            vt1=1;
        else if(d1 < -_threshold)
            vt1=2;
        else
            vt1=0;
        if (d2 > _threshold)
            vt2=1;
        else if(d2 < -_threshold)
            vt2=2;
        else
            vt2=0;
        result &= vt1 | vt2;
        flag_val[index] = vt1;
        flag_val[index+K] = vt2;
        flag_val[index+PSize] = vt1;
    }
    flag_val[PSize/2+PSize] = flag_val[PSize/2];
    flag_d[PSize/2+PSize] = flag_d[PSize/2];
    return result;
}

    template<int PSize,int NUM, typename DIFF_T, typename SRC_T>
int coreScore(DIFF_T (&flag_d)[NUM], SRC_T _threshold)
{
#pragma HLS INLINE

 DIFF_T flag_d_min2[NUM-1];
    DIFF_T flag_d_max2[NUM-1];
    DIFF_T flag_d_min4[NUM-3];
    DIFF_T flag_d_max4[NUM-3];
    DIFF_T flag_d_min8[NUM-7];
    DIFF_T flag_d_max8[NUM-7];
#pragma HLS ARRAY_PARTITION variable=flag_d_min2 dim=0
#pragma HLS ARRAY_PARTITION variable=flag_d_max2 dim=0
#pragma HLS ARRAY_PARTITION variable=flag_d_min4 dim=0
#pragma HLS ARRAY_PARTITION variable=flag_d_max4 dim=0
 if(PSize == 16) {
        VITIS_LOOP_104_1: for(int i=0;i<NUM-1;i++) {
            flag_d_min2[i] = reg(hls::min<int>(flag_d[i],flag_d[i+1]));
            flag_d_max2[i] = reg(hls::max<int>(flag_d[i],flag_d[i+1]));
        }
        VITIS_LOOP_108_2: for(int i=0;i<NUM-3;i++) {
            flag_d_min4[i] = reg(hls::min<int>(flag_d_min2[i],flag_d_min2[i+2]));
            flag_d_max4[i] = reg(hls::max<int>(flag_d_max2[i],flag_d_max2[i+2]));
        }

        VITIS_LOOP_113_3: for(int i=0;i<NUM-7;i++) {
            flag_d_min8[i] = reg(hls::min<int>(flag_d_min4[i],flag_d_min4[i+4]));
            flag_d_max8[i] = reg(hls::max<int>(flag_d_max4[i],flag_d_max4[i+4]));
        }
    } else {



    }

    DIFF_T a0 = _threshold;
    VITIS_LOOP_124_4: for(int i=0;i<PSize;i+=2) {
        DIFF_T a = hls::numeric_limits<DIFF_T>::max();
        if(PSize == 16) {
            a = flag_d_min8[i+1];
        } else {
            VITIS_LOOP_129_5: for(int j=1;j<PSize/2+1;j++) {
                a=hls::min<int>(a,flag_d[i+j]);
            }
        }
        a0 = hls::max<int>(a0,hls::min<int>(a,flag_d[i]));
        a0 = hls::max<int>(a0,hls::min<int>(a,flag_d[i+PSize/2+1]));
    }
    DIFF_T b0 = -_threshold;
    VITIS_LOOP_137_6: for(int i=0;i<PSize;i+=2) {
        DIFF_T b = hls::numeric_limits<DIFF_T>::min();
        if(PSize == 16) {
            b = flag_d_max8[i+1];
        } else {
            VITIS_LOOP_142_7: for(int j=1;j<PSize/2+1;j++) {
                b=hls::max<int>(b,flag_d[i+j]);
            }
        }
        b0 = hls::min<int>(b0,hls::max<int>(b,flag_d[i]));
        b0 = hls::min<int>(b0,hls::max<int>(b,flag_d[i+PSize/2+1]));
    }
    return hls::max<int>(a0,(DIFF_T)-b0)-1;
}

template<int PSize,int KERNEL_SIZE,typename SRC_T, typename DIFF_T>
bool fast_judge(Window<KERNEL_SIZE,KERNEL_SIZE,SRC_T> & win,
                SRC_T _threshold,
                ap_uint<2> (&flag_val)[PSize+PSize/2+1],
                DIFF_T (&flag_d)[PSize+PSize/2+1],
                int (&flag)[PSize][2],
                int &core,
                bool _nonmax_supression) {
#pragma HLS ARRAY_PARTITION variable=flag_val dim=0
#pragma HLS ARRAY_PARTITION variable=flag_d dim=0

#pragma HLS INLINE
 bool iscorner=false;
    int kernel_half=KERNEL_SIZE/2;
    int result=fast_pixel_diff<PSize>(win,_threshold,flag_val,flag_d,flag);
    int count=1;
    VITIS_LOOP_168_1: for(int c=1;c<PSize+PSize/2+1;c++)
    {
        if(flag_val[c-1]==flag_val[c] && flag_val[c]>0)
        {
            count++;
            if(count>PSize/2)
            {
                iscorner=true;
            }
        }
        else
        {
            count=1;
        }
    }
    if(_nonmax_supression && iscorner) {
        core=coreScore<PSize>(flag_d,_threshold);
    }
    return iscorner;
}
template<int KERNEL_SIZE,typename SRC_T>
bool fast_nonmax(
        Window<KERNEL_SIZE,KERNEL_SIZE,SRC_T> & core_win
        )
{
#pragma HLS INLINE
 bool iscorner=true;
    VITIS_LOOP_195_1: for(int k=0;k<3;k++) {
        if(core_win.val[1][1]>core_win.val[0][k])
            iscorner=iscorner && true;
        else
            iscorner=iscorner && false;
    }
    VITIS_LOOP_201_2: for(int k=0;k<3;k++) {
        if(core_win.val[1][1]>core_win.val[2][k])
            iscorner=iscorner && true;
        else
            iscorner=iscorner && false;
    }
    if(core_win.val[1][1]>core_win.val[1][0]&&core_win.val[1][1]>core_win.val[1][2])
        iscorner=iscorner && true;
    else
        iscorner=iscorner && false;
    return iscorner;
}

template<int PSize,int KERNEL_SIZE,int SRC_T,int ROWS,int COLS>
void FAST_t_opr(
        Mat<ROWS,COLS,SRC_T> &_src,
        Mat<ROWS,COLS,(((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> &_mask,
        typename Type<((SRC_T) & ((1 << 11) - 1))>::name _threshold,
        bool _nonmax_supression,
        int (&flag)[PSize][2]) {
    typedef typename pixel_op_type<typename Type<((SRC_T) & ((1 << 11) - 1))>::name>::T INPUT_T;
    LineBuffer<KERNEL_SIZE-1,COLS,INPUT_T> k_buf;
    LineBuffer<2,COLS+KERNEL_SIZE,ap_int<16> > core_buf;
    Window<3,3,ap_int<16> > core_win;
    Window<KERNEL_SIZE,KERNEL_SIZE,INPUT_T> win;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<(((((((0) & ((1 << 11) - 1)) + (((1)-1) << 11))) & ((512 - 1) << 11)) >> 11) + 1),typename Type<(((((0) & ((1 << 11) - 1)) + (((1)-1) << 11))) & ((1 << 11) - 1))>::name> d;
    int rows= _src.rows;
    int cols= _src.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_fast.h",230),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_fast.h",231),0));
    int kernel_half=KERNEL_SIZE/2;
    ap_uint<2> flag_val[PSize+PSize/2+1];
    int flag_d[PSize+PSize/2+1];
#pragma HLS ARRAY_PARTITION variable=flag_val dim=0
#pragma HLS ARRAY_PARTITION variable=flag_d dim=0

 int index=0;
    int offset=KERNEL_SIZE/2;
    if(_nonmax_supression)
    {
        offset=offset+1;
    }
 loop_height: for(HLS_SIZE_T i=0;i<rows+offset;i++) {
    loop_width: for(HLS_SIZE_T j=0;j<cols+offset;j++) {
#pragma HLS LOOP_FLATTEN off
#pragma HLS PIPELINE II=1
 d.val[0]=0;
            if((i<rows&&j<cols)) {
                VITIS_LOOP_250_1: for(int r= 0;r<KERNEL_SIZE;r++) {
                    VITIS_LOOP_251_2: for(int c=0;c<KERNEL_SIZE-1;c++) {
                        win.val[r][c]=win.val[r][c+1];
                    }
                }
                win.val[0][KERNEL_SIZE-1]=k_buf.val[0][j];
                VITIS_LOOP_256_3: for(int buf_row= 1;buf_row< KERNEL_SIZE-1;buf_row++) {
                    win.val[buf_row][KERNEL_SIZE-1]=k_buf.val[buf_row][j];
                    k_buf.val[buf_row-1][j]=k_buf.val[buf_row][j];
                }

                _src>>s;
                win.val[KERNEL_SIZE-1][KERNEL_SIZE-1]=s.val[0];
                k_buf.val[KERNEL_SIZE-2][j]=s.val[0];
            }

            VITIS_LOOP_266_4: for(int r= 0;r<3;r++)
            {
                VITIS_LOOP_268_5: for(int c=0;c<3-1;c++)
                {
                    core_win.val[r][c]=core_win.val[r][c+1];
                }
            }
            core_win.val[0][3-1]=core_buf.val[0][j];
            VITIS_LOOP_274_6: for(int buf_row= 1;buf_row< 3-1;buf_row++)
            {
                core_win.val[buf_row][3-1]=core_buf.val[buf_row][j];
                core_buf.val[buf_row-1][j]=core_buf.val[buf_row][j];
            }
            int core=0;


            if(i>=KERNEL_SIZE-1 && i<rows && j>=KERNEL_SIZE-1 & j<cols)
            {

                bool iscorner=fast_judge<PSize>(win,(INPUT_T)_threshold,flag_val,flag_d,flag,core,_nonmax_supression);
                if(iscorner&&!_nonmax_supression)
                {
                    d.val[0]=255;
                }
            }
            if(i>=rows||j>=cols)
            {
                core=0;
            }
            if(_nonmax_supression)
            {
                core_win.val[3-1][3-1]=core;
                core_buf.val[3-2][j]=core;
                if(core_win.val[1][1]!=0&&i>=KERNEL_SIZE&&j>=KERNEL_SIZE)
                {
                    bool iscorner=fast_nonmax(core_win);
                    if(iscorner)
                    {
                        d.val[0]=255;
                    }
                }
            }

            if(i>=offset&&j>=offset)
            {
                _mask<<d;
            }
        }
    }
}
template<int SRC_T,int ROWS,int COLS>
void FASTX(
        Mat<ROWS,COLS,SRC_T> &_src,
        Mat<ROWS,COLS,(((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> &_mask,
        typename Type<((SRC_T) & ((1 << 11) - 1))>::name _threshold,
        bool _nomax_supression
        )
{
#pragma HLS INLINE
 int flag[16][2]={{3,0},{4,0},{5,1},{6,2},{6,3},{6,4},{5,5},{4,6},
        {3,6},{2,6},{1,5},{0,4},{0,3},{0,2},{1,1},{2,0}};
    FAST_t_opr<16,7>(_src,_mask,_threshold,_nomax_supression,flag);
}

template<int PSize,int KERNEL_SIZE,typename T, int N, int SRC_T,int ROWS,int COLS>
void FAST_t_opr(
        Mat<ROWS,COLS,SRC_T> &_src,
        Point_<T> (&_keypoints)[N],
        typename Type<((SRC_T) & ((1 << 11) - 1))>::name _threshold,
        bool _nonmax_supression,
        int (&flag)[PSize][2]
        )
{
    typedef typename pixel_op_type<typename Type<((SRC_T) & ((1 << 11) - 1))>::name>::T INPUT_T;
    LineBuffer<KERNEL_SIZE-1,COLS,INPUT_T> k_buf;
    LineBuffer<2,COLS+KERNEL_SIZE,ap_int<16> > core_buf;
    Window<3,3,ap_int<16> > core_win;
    Window<KERNEL_SIZE,KERNEL_SIZE,INPUT_T> win;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    int rows= _src.rows;
    int cols= _src.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_fast.h",347),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_fast.h",348),0));
    int kernel_half=KERNEL_SIZE/2;
    ap_uint<2> flag_val[PSize+PSize/2+1];
    int flag_d[PSize+PSize/2+1];
#pragma HLS ARRAY_PARTITION variable=flag_val dim=0
#pragma HLS ARRAY_PARTITION variable=flag_d dim=0
 int index=0;
    int offset=KERNEL_SIZE/2;

    if(_nonmax_supression)
    {
        offset=offset+1;
    }
 loop_height: for(HLS_SIZE_T i=0;i<rows+offset;i++) {
    loop_width: for(HLS_SIZE_T j=0;j<cols+offset;j++) {
#pragma HLS LOOP_FLATTEN off
#pragma HLS PIPELINE II=1
 if(i<rows&&j<cols) {
                VITIS_LOOP_366_1: for(int r= 0;r<KERNEL_SIZE;r++) {
                    VITIS_LOOP_367_2: for(int c=0;c<KERNEL_SIZE-1;c++) {
                        win.val[r][c]=win.val[r][c+1];
                    }
                }
                win.val[0][KERNEL_SIZE-1]=k_buf.val[0][j];
                VITIS_LOOP_372_3: for(int buf_row= 1;buf_row< KERNEL_SIZE-1;buf_row++) {
                    win.val[buf_row][KERNEL_SIZE-1]=k_buf.val[buf_row][j];
                    k_buf.val[buf_row-1][j]=k_buf.val[buf_row][j];
                }

                _src>>s;
                win.val[KERNEL_SIZE-1][KERNEL_SIZE-1]=s.val[0];
                k_buf.val[KERNEL_SIZE-2][j]=s.val[0];
            }

            VITIS_LOOP_382_4: for(int r= 0;r<3;r++)
            {
                VITIS_LOOP_384_5: for(int c=0;c<3-1;c++)
                {
                    core_win.val[r][c]=core_win.val[r][c+1];
                }
            }
            core_win.val[0][3-1]=core_buf.val[0][j];
            VITIS_LOOP_390_6: for(int buf_row= 1;buf_row< 3-1;buf_row++)
            {
                core_win.val[buf_row][3-1]=core_buf.val[buf_row][j];
                core_buf.val[buf_row-1][j]=core_buf.val[buf_row][j];
            }
            int core=0;


            if(i>=KERNEL_SIZE-1 && i<rows && j>=KERNEL_SIZE-1 & j<cols)
            {

                bool iscorner=fast_judge<PSize>(win,(INPUT_T)_threshold,flag_val,flag_d,flag,core,_nonmax_supression);
                if(iscorner&&!_nonmax_supression)
                {
                    if(index<N)
                    {
                    _keypoints[index].x=j-offset;
                    _keypoints[index].y=i-offset;
                    index++;
                    }
                }
            }
            if(i>=rows||j>=cols)
            {
                core=0;
            }
            if(_nonmax_supression)
            {
                core_win.val[3-1][3-1]=core;
                core_buf.val[3-2][j]=core;
                if(i>=KERNEL_SIZE&&j>=KERNEL_SIZE&&core_win.val[1][1]!=0)
                {
                    bool iscorner=fast_nonmax(core_win);
                    if(iscorner)
                    {
                    if(index<N)
                    {
                        _keypoints[index].x=j-offset;
                        _keypoints[index].y=i-offset;
                        index++;
                    }
                    }
                }
            }

        }
    }
}
template<typename T, int N, int SRC_T,int ROWS,int COLS>
void FASTX(
        Mat<ROWS,COLS,SRC_T> &_src,
        Point_<T> (&_keypoints)[N],
        typename Type<((SRC_T) & ((1 << 11) - 1))>::name _threshold,
        bool _nomax_supression
        )
{
#pragma HLS INLINE
 int flag[16][2]={{3,0},{4,0},{5,1},{6,2},{6,3},{6,4},{5,5},{4,6},
        {3,6},{2,6},{1,5},{0,4},{0,3},{0,2},{1,1},{2,0}};
    FAST_t_opr<16,7>(_src,_keypoints,_threshold,_nomax_supression,flag);
}
template<int SRC_T,int MASK_T,int ROWS,int COLS>
void PaintMask(
        Mat<ROWS,COLS,SRC_T> &_src,
        Mat<ROWS,COLS,MASK_T> &_mask,
        Mat<ROWS,COLS,SRC_T> &_dst,
        Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> _color
        )
{






    int rows= _src.rows;
    int cols= _src.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_fast.h",467),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_fast.h",468),0));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> d;
    Scalar<((((MASK_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((MASK_T) & ((1 << 11) - 1))>::name> m;
 loop_height: for(HLS_SIZE_T i=0;i<rows;i++) {
    loop_width: for(HLS_SIZE_T j=0;j<cols;j++) {
#pragma HLS LOOP_FLATTEN off
#pragma HLS PIPELINE II=1
 _src >> s;
            _mask >> m;
            if(m.val[0]!=0)
            {
                d = _color;
            }
            else
            {
                d = s;
            }
            _dst << d;
        }
    }
}
}
# 65 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src\\hls_video.h" 2
# 1 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_undistort.h" 1
# 83 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_undistort.h"
namespace hls {

template <int N, typename T,typename PT>
void LU( T A[N][N], PT pos[N])
{
    int imax = 0;
    T lu[N] ;
    VITIS_LOOP_90_1: for (int i = 0; i < N; i++)
    {
        lu[i]=0;
    }
    VITIS_LOOP_94_2: for (int i = 0; i < N; i++) {
        T big = 0.0;
        VITIS_LOOP_96_3: for (int j = 0; j < N; j++) {
            T temp = ::hls::abs((double)A[i][j]);
            if (temp > big) big = temp;
        }
        lu[i] = ((T)1.0)/big;
    }
    VITIS_LOOP_102_4: for (int j = 0; j < N; j++) {
        VITIS_LOOP_103_5: for (int i = 0; i < j; i++) {
            T sum = A[i][j];
            VITIS_LOOP_105_6: for (int k = 0; k < i; k++) sum -= A[i][k] * A[k][j];
            A[i][j] = sum;
        }
        T big = 0.0;
        VITIS_LOOP_109_7: for (int i = j; i < N; i++) {
            T sum = A[i][j];
            VITIS_LOOP_111_8: for (int k = 0; k < j; k++) sum -= A[i][k] * A[k][j];
            A[i][j] = sum;
            T dum = lu[i] *((T) ::hls::abs((double)sum));
            if (dum >= big) {
                big = dum;
                imax = i;
            }
        }
        if (j != imax&&imax<N&&imax>=0) {
            VITIS_LOOP_120_9: for (int i = 0; i < N; i++) {
                T mid = A[imax][i];
                A[imax][i] = A[j][i];
                A[j][i] = mid;
            }
            T mid = lu[j];
            lu[j] = lu[imax];
            lu[imax] = mid;
        }
        pos[j] = imax;
        if (j != N - 1) {
            T dum = ((T)1.0)/(A[j][j]);
            VITIS_LOOP_132_10: for (int i = j + 1; i < N; i++) A[i][j] *= dum;
        }
    }
}
template <int N, typename T, typename PT,typename BT>
void LUex(T A[N][N], PT pos[N],BT b[N])
{
    int ii = 0;
    VITIS_LOOP_140_1: for (int i = 0; i < N; i++) {
        int ip = pos[i];
        T sum=0;
        if(ip<N&& ip>=0)
        {
            sum = b[ip];
            b[ip] = b[i];
        }
        if (ii != 0)
            VITIS_LOOP_149_2: for (int j = ii - 1; j < i; j++) sum -= A[i][j] * b[j];
        else
            ii = i + 1;
        b[i] = sum;
    }
    VITIS_LOOP_154_3: for (int i = N - 1; i >= 0; i--) {
        T sum = b[i];
        VITIS_LOOP_156_4: for (int j = i + 1; j < N; j++) sum -= A[i][j]*b[j];
        b[i] = (sum)*((T) 1.0/A[i][i]);
    }
}


template <int N,typename T>
void Invert(T A[N][N],T Ar[N][N], int flags=0)
{
    T b[N];
    int pos[N];
    VITIS_LOOP_167_1: for (int i = 0; i < N; i++) {
        b[i]=0;
        pos[i]=0;
    }
    LU<N>(A,pos);
    VITIS_LOOP_172_2: for (int i = 0; i < N; i++) {
        VITIS_LOOP_173_3: for (int j = 0; j < N; j++) b[j] = 0;
        b[i] = 1.0;
        LUex<N>(A,pos,b);
        VITIS_LOOP_176_4: for (int j = 0; j < N; j++) Ar[j][i] = b[j];
    }
}
template<int AROW, int ACOL, int BCOL, typename AT, typename BT, typename CT>
void mul(
               AT A [AROW][ ACOL],
               BT B [ACOL][ BCOL],
               CT C [AROW][ BCOL]
)
{
 loop_i: for(int i=0; i<AROW; i++)
    {
    loop_j: for(int j=0; j<BCOL; j++)
        {
            CT sum=0;
        loop_k: for(int k=0; k<ACOL; k++)
                {
                sum=sum+A[i][k]*B[k][j];

            }
            C[i][j]=sum;
        }
    }
}





template <int WIN_ROW, int ROWS, int COLS, int SRC_T, int DST_T, int MAP1_T, int MAP2_T>
void Remap_nearest(
           Mat<ROWS, COLS, SRC_T> &src,
           Mat<ROWS, COLS, DST_T> &dst,
           Mat<ROWS, COLS, MAP1_T> &map1,
           Mat<ROWS, COLS, MAP2_T> &map2


        )
{
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> buf[WIN_ROW][COLS];
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    Scalar<((((MAP1_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((MAP1_T) & ((1 << 11) - 1))>::name> m1;
    Scalar<((((MAP2_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((MAP2_T) & ((1 << 11) - 1))>::name> m2;
    int rows=src.rows;
    int cols=src.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_undistort.h",222),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_undistort.h",223),0));
    int ishift=WIN_ROW/2;
    int r[WIN_ROW] = {};

 loop_height: for( int i=0; i< rows+ishift; i++)
    {
#pragma HLS LOOP_FLATTEN OFF
 loop_width: for( int j=0; j< cols; j++)
        {
#pragma HLS PIPELINE II=1
#pragma HLS dependence array inter false
 if(i<rows&& j<cols)
            {
                src >> s;
            }
            buf[i % WIN_ROW][j] = s;
            r[i % WIN_ROW] = i;

            if(i>=ishift)
            {
                map1 >> m1;
                map2 >> m2;
                int x=m1.val[0]+1;
                int y=m1.val[1]+1;

                bool in_range = (y>=0 && y<rows && r[y%WIN_ROW] == y && x>=0 && x<cols);
                if(in_range) {
                    d = buf[y%WIN_ROW][x];
                } else {
                    VITIS_LOOP_252_1: for(int k=0;k<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1);k++) {
                        d.val[k]=0;
                    }
                }
                dst<< d;
            }
        }
    }
}

template <int WIN_ROW, int ROWS, int COLS, int SRC_T, int DST_T, int MAP1_T, int MAP2_T>
void Remap_linear(
           Mat<ROWS, COLS, SRC_T> &src,
           Mat<ROWS, COLS, DST_T> &dst,
           Mat<ROWS, COLS, MAP1_T> &map1,
           Mat<ROWS, COLS, MAP2_T> &map2


        )
{

    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> buf[WIN_ROW/2+1][2][COLS/2+1][2];
#pragma HLS array_partition complete variable=buf dim=2
#pragma HLS array_partition complete variable=buf dim=4
 Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((MAP1_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((MAP1_T) & ((1 << 11) - 1))>::name> m1;
    Scalar<((((MAP2_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((MAP2_T) & ((1 << 11) - 1))>::name> m2;
    int rows=src.rows;
    int cols=src.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_undistort.h",281),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_undistort.h",282),0));
    int ishift=WIN_ROW/2;
    int r1[WIN_ROW] = {};
    int r2[WIN_ROW] = {};

 loop_height: for( int i=0; i< rows+ishift; i++)
    {
#pragma HLS LOOP_FLATTEN OFF
 loop_width: for( int j=0; j< cols; j++)
        {
#pragma HLS PIPELINE II=1
#pragma HLS dependence array inter false
 if(i<rows&& j<cols)
            {
                src >> s;
            }
            if((i % WIN_ROW) % 2) {
                buf[(i % WIN_ROW)/2][(i % WIN_ROW) % 2][j/2][j%2] = s;
            } else {
                buf[(i % WIN_ROW)/2][(i % WIN_ROW) % 2][j/2][j%2] = s;
            }
            r1[i % WIN_ROW] = i;
            r2[i % WIN_ROW] = i;

            if(i>=ishift)
            {
                map1 >> m1;
                map2 >> m2;
                int x=m1.val[0];
                int y=m1.val[1];

                int ynext = y+1;

                ap_ufixed<5, 0> iu, iv;
                iu(5 -1, 0) = m2.val[0] & (32 -1);
                iv(5 -1, 0) = (m2.val[0] >> 5) & (32 -1);



                bool in_range = (y>=0 && y<rows && r1[y%WIN_ROW] == y && r2[ynext%WIN_ROW] == ynext && x>=0 && x<cols);

                int xa0, xa1, ya0, ya1;
# 337 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_undistort.h"
                (void) ((!!(((WIN_ROW & (WIN_ROW-1)) == 0) && "WIN_ROW must be a power of two")) || (_assert("((WIN_ROW & (WIN_ROW-1)) == 0) && \"WIN_ROW must be a power of two\"","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_undistort.h",337),0));
                xa0 = x/2 + x%2;
                xa1 = x/2;
                ya0 = (y/2 + y%2)%(WIN_ROW/2);
                ya1 = (y/2)%(WIN_ROW/2);

                Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> d00,d01,d10,d11;
                d00=buf[ya0][0][xa0][0];
                d01=buf[ya0][0][xa1][1];
                d10=buf[ya1][1][xa0][0];
                d11=buf[ya1][1][xa1][1];

                Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> d_t00,d_t01,d_t10,d_t11;
                if(x%2) {
                    d_t00 = d00;
                    d_t01 = d01;
                    d00 = d_t01;
                    d01 = d_t00;

                    d_t10 = d10;
                    d_t11 = d11;
                    d10 = d_t11;
                    d11 = d_t10;


                }
                if(y%2) {
                    d_t00 = d00;
                    d_t10 = d10;
                    d00 = d_t10;
                    d10 = d_t00;

                    d_t01 = d01;
                    d_t11 = d11;
                    d01 = d_t11;
                    d11 = d_t01;


                }
                ap_ufixed<2*5 + 1, 1> k01 = (1-iv)*( iu);
                ap_ufixed<2*5 + 1, 1> k10 = ( iv)*(1-iu);
                ap_ufixed<2*5 + 1, 1> k11 = ( iv)*( iu);
                ap_ufixed<2*5 + 1, 1> k00 = 1-iv-k01;
                (void) ((!!(k00 + k01 + k10 + k11 == 1)) || (_assert("k00 + k01 + k10 + k11 == 1","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_undistort.h",380),0));

                Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;

                VITIS_LOOP_384_1: for(int k = 0; k < ((((DST_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                    if(in_range) {
                        d.val[k] =
                            d00.val[k] * k00 +
                            d01.val[k] * k01 +
                            d10.val[k] * k10 +
                            d11.val[k] * k11;
                    } else {
                        d.val[k] = 0;
                    }
                }
                dst<< d;
            }
        }
    }
}

template <int WIN_ROW, int ROWS, int COLS, int SRC_T, int DST_T, int MAP1_T, int MAP2_T>
void Remap(
           Mat<ROWS, COLS, SRC_T> &src,
           Mat<ROWS, COLS, DST_T> &dst,
           Mat<ROWS, COLS, MAP1_T> &map1,
           Mat<ROWS, COLS, MAP2_T> &map2,
           int interpolation=0


        )
{
    if(interpolation==0) {
        Remap_nearest<WIN_ROW>(src, dst, map1, map2);
    } else if(interpolation==1) {
        Remap_linear<WIN_ROW>(src, dst, map1, map2);
    }
}



template <typename T>
class RangeAnalyzer {
public:
# 435 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_undistort.h"
    void operator ()(T x) {};



};
# 458 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_undistort.h"
template<typename T>
T one_over_x_approx(T x) {
    return T(1.0)/x;
}


template <int W, int I, ap_q_mode Q, ap_o_mode O>
ap_fixed<W,I,Q,O> one_over_x_approx(ap_fixed<W,I,Q,O> x) {
    return 2-x;
}

template <int W, int I, ap_q_mode Q, ap_o_mode O>
ap_ufixed<W,I,Q,O> one_over_x_approx(ap_ufixed<W,I,Q,O> x) {
    return 2-x;
}



template<typename T>
T one_over_one_plus_x_approx(T x) {
    return T(1.0)/(T(1.0)+x);
}


template <int W, int I, ap_q_mode Q, ap_o_mode O>
ap_fixed<W,I,Q,O> one_over_one_plus_x_approx(ap_fixed<W,I,Q,O> x) {
    return 1-x;
}

template <int W, int I, ap_q_mode Q, ap_o_mode O>
ap_ufixed<W,I,Q,O> one_over_one_plus_x_approx(ap_ufixed<W,I,Q,O> x) {
    return 1-x;
}

template <typename FRAMET, typename FRAME2T, typename ROWT, typename COLT, typename ROWOUTT, typename COLOUTT, typename CMT, typename DT, typename ICMT, int N>
void computeUndistortCoordinates(Window<3,3, CMT> cameraMatrix,
                                 DT (&distCoeffs)[N],
                                 Window<3,3, ICMT> ir,
                                 int noRotation,
                                 ROWT i, COLT j,
                                 ROWOUTT &u, COLOUTT &v) {

    DT zo=0;
    DT k1=distCoeffs[0];
    DT k2=distCoeffs[1];
    DT p1=distCoeffs[2];
    DT p2=distCoeffs[3];
    DT k3= N>=5? distCoeffs[4] : zo;
    DT k4= N>=8? distCoeffs[5] : zo;
    DT k5= N>=8? distCoeffs[6] : zo;
    DT k6= N>=8? distCoeffs[7] : zo;
    CMT u0= cameraMatrix.val[0][2];
    CMT v0= cameraMatrix.val[1][2];
    CMT fx= cameraMatrix.val[0][0];
    CMT fy= cameraMatrix.val[1][1];
# 524 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_undistort.h"
    FRAMET _x, _y, x, y;
    _x=i*ir.val[0][1] + j * ir.val[0][0] + ir.val[0][2];
    _y=i*ir.val[1][1] + j * ir.val[1][0] + ir.val[1][2];

    float x_gold = ((float)i*(float)ir.val[0][1] + (float)j*(float)ir.val[0][0] + (float)ir.val[0][2]);
    if(noRotation) {

        x=_x;
        y=_y;
    } else {
        FRAMET w=i*ir.val[2][1] + j * ir.val[2][0] + ir.val[2][2];
        FRAMET winv = one_over_x_approx(w);
        float winv_gold = 1.0f/((float)i*(float)ir.val[2][1] + (float)j*(float)ir.val[2][0] + (float)ir.val[2][2]);





        x = (FRAMET)(_x*winv);
        y = (FRAMET)(_y*winv);
        x_gold = x_gold*winv_gold;
    }

    typename x_traits<FRAMET,FRAMET>::MULT_T x2t = x*x, y2t = y*y;
    FRAME2T _2xy = 2*x*y;
    FRAME2T r2 = x2t + y2t;
    FRAME2T x2 = x2t, y2 = y2t;

    FRAMET kr = (1 + FRAMET(FRAMET(k3*r2 + k2)*r2 + k1)*r2);
    FRAME2T krd = FRAMET(FRAMET(k6*r2 + k5)*r2 + k4)*r2;

    if(N >5) kr = kr*one_over_one_plus_x_approx(krd);

    float kr_gold = (1 + (((float)k3*(float)r2 + (float)k2)*(float)r2 + (float)k1)*(float)r2)/
                    (1 + (((float)k6*(float)r2 + (float)k5)*(float)r2 + (float)k4)*(float)r2);

    u = fx*(FRAMET(x*kr) + FRAMET(p1*_2xy) + FRAMET(p2*(2*x2 + r2))) + u0;
    v = fy*(FRAMET(y*kr) + FRAMET(p1*(r2 + 2*y2)) + FRAMET(p2*_2xy)) + v0;
# 575 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_undistort.h"
}

template <typename ROWT, typename COLT, typename ROWOUTT, typename COLOUTT, int N>
void computeUndistortCoordinatesRef(Window<3,3, float> cameraMatrix,
                                 float (&distCoeffs)[N],
                                 Window<3,3, float> ir,
                                 int noRotation,
                                 ROWT i, COLT j,
                                 ROWOUTT &u, COLOUTT &v) {
    typedef float DT;
    typedef float CMT;
    typedef float FRAMET;
    typedef float FRAME2T;

    DT zo=0;
    DT k1=distCoeffs[0];
    DT k2=distCoeffs[1];
    DT p1=distCoeffs[2];
    DT p2=distCoeffs[3];
    DT k3= N>=5? distCoeffs[4] : zo;
    DT k4= N>=8? distCoeffs[5] : zo;
    DT k5= N>=8? distCoeffs[6] : zo;
    DT k6= N>=8? distCoeffs[7] : zo;
    CMT u0= cameraMatrix.val[0][2];
    CMT v0= cameraMatrix.val[1][2];
    CMT fx= cameraMatrix.val[0][0];
    CMT fy= cameraMatrix.val[1][1];


    FRAMET _x, _y, x, y;
    _x=i*ir.val[0][1] + j * ir.val[0][0] + ir.val[0][2];
    _y=i*ir.val[1][1] + j * ir.val[1][0] + ir.val[1][2];

    if(noRotation) {

        (void) ((!!(ir.val[2][0] == 0)) || (_assert("ir.val[2][0] == 0","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_undistort.h",610),0));
        (void) ((!!(ir.val[2][1] == 0)) || (_assert("ir.val[2][1] == 0","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_undistort.h",611),0));
        (void) ((!!(ir.val[2][1] == 1)) || (_assert("ir.val[2][1] == 1","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_undistort.h",612),0));
        x=_x;
        y=_y;
    } else {
        FRAMET w=i*ir.val[2][1] + j * ir.val[2][0] + ir.val[2][2];
        float winv = 1.0f/w;




        x = (FRAMET)(_x*winv);
        y = (FRAMET)(_y*winv);
    }

    typename x_traits<FRAMET,FRAMET>::MULT_T x2t = x*x, y2t = y*y;

    FRAME2T _2xy = 2*x*y;
    FRAME2T r2 = x2t + y2t;
    FRAME2T x2 = x2t, y2 = y2t;

    FRAMET kr = (1 + FRAMET(FRAMET(k3*r2 + k2)*r2 + k1)*r2);
    if(N >5) kr = kr/
        (1 + FRAMET(FRAMET(k6*r2 + k5)*r2 + k4)*r2);

    u = fx*(FRAMET(x*kr) + FRAMET(p1*_2xy) + FRAMET(p2*(2*x2 + r2))) + u0;
    v = fy*(FRAMET(y*kr) + FRAMET(p1*(r2 + 2*y2)) + FRAMET(p2*_2xy)) + v0;
# 651 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_undistort.h"
}

template<typename T>
struct InitUndistortRectifyMap_traits {
    typedef T FRAMET;
    typedef T FRAME2T;
};

template<int W, int I>
struct InitUndistortRectifyMap_traits<ap_fixed<W,I> > {
    typedef ap_fixed<18,2> FRAMET;
    typedef ap_fixed<23,4,AP_RND,AP_SAT> FRAME2T;
};
template<typename CMT, typename DT, typename ICMT, int ROWS, int COLS, int MAP1_T, int MAP2_T, int N>
void InitUndistortRectifyMapInverse (
                            Window<3,3, CMT> cameraMatrix,
                            DT (&distCoeffs)[N],
                            Window<3,3, ICMT> ir,
                            Mat<ROWS, COLS, MAP1_T> &map1,
                            Mat<ROWS, COLS, MAP2_T> &map2,
                            int noRotation=false)
{
#pragma HLS array_partition variable=distCoeffs complete
 int rows= map1.rows;
    int cols= map1.cols;
    Scalar<((((MAP1_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((MAP1_T) & ((1 << 11) - 1))>::name> m1;
    Scalar<((((MAP2_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((MAP2_T) & ((1 << 11) - 1))>::name> m2;

    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_undistort.h",679),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_undistort.h",680),0));

    static RangeAnalyzer<float> rau, rav;
    static RangeAnalyzer<float> rauerr, raverr;

 loop_height: for(int i=0; i< rows; i++) {
    loop_width: for(int j=0; j< cols; j++) {
#pragma HLS PIPELINE II=1
 typedef ap_uint<BitWidth<ROWS>::Value> ROWT;
            typedef ap_uint<BitWidth<COLS>::Value> COLT;
            ROWT ifixed = i;
            COLT jfixed = j;

            ap_fixed<1+BitWidth<COLS>::Value+5, 1+BitWidth<COLS>::Value, AP_RND, AP_SAT> u;
            ap_fixed<1+BitWidth<ROWS>::Value+5, 1+BitWidth<ROWS>::Value, AP_RND, AP_SAT> v;
            computeUndistortCoordinates
                <typename InitUndistortRectifyMap_traits<CMT>::FRAMET, typename InitUndistortRectifyMap_traits<CMT>::FRAME2T>
                (cameraMatrix, distCoeffs, ir, noRotation,ifixed,jfixed,u,v);
# 719 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_undistort.h"
            (void) ((!!(MAP1_T==(((3) & ((1 << 11) - 1)) + (((2)-1) << 11)))) || (_assert("MAP1_T==HLS_16SC2","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_undistort.h",719),0));
            {
                int iu = sr_cast<int>(u*32);
                int iv = sr_cast<int>(v*32);
                m1.val[0]=(iu >> 5);
                m1.val[1]=(iv >> 5);
                m2.val[0]=(unsigned short)((iv &(32 -1))*32 + (iu & (32 -1)));
            }






            map1<< m1;
            map2<< m2;
        }
    }







}
template< typename CMT, typename RT, typename DT, int ROWS, int COL, int MAP1_T, int MAP2_T, int N>
void InitUndistortRectifyMap(
                            Window<3,3, CMT> cameraMatrix,
                            DT (&distCoeffs)[N],
                            Window<3,3, RT> R,
                            Window<3,3, CMT> newcameraMatrix,
                            Mat<ROWS, COL, MAP1_T> &map1,
                            Mat<ROWS, COL, MAP2_T> &map2
                            )
{
    Window<3,3, RT> iR;
    Window<3,3, RT> ir;
    mul<3, 3, 3>(newcameraMatrix.val, R.val, iR.val);
    Invert<3>(iR.val, ir.val);
    InitUndistortRectifyMapInverse(cameraMatrix, distCoeffs,ir,map1,map2);
}
}
# 66 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src\\hls_video.h" 2
# 1 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_hough.h" 1
# 83 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_hough.h"
namespace hls {

typedef ap_fixed<19,2,AP_RND> angleAccuracy_T;

template<typename AT,typename RT>
struct Polar_
{
 AT angle;
 RT rho;
};

template<unsigned int theta,unsigned int rho,typename ACCUMT,int SRC_T, int ROW,int COL, typename S_T>
void HoughPolar(
        Mat<ROW,COL,SRC_T> &_src,
        ACCUMT accum[][(2*(COL+ROW)+1)/rho+2],
        S_T (&sinval)[180/theta],
        S_T (&cosval)[180/theta]
        )
{
    ACCUMT addr[180/theta];
    ACCUMT accbuf[2][180/theta];
#pragma HLS ARRAY_PARTITION variable=addr complete dim=0
#pragma HLS ARRAY_PARTITION variable=accbuf complete dim=0
 int rows=_src.rows;
    int cols=_src.cols;
    unsigned int rhoN =(2*(COL+ROW)+1)/ rho;
    unsigned int Half_rhoN=(rhoN-1)/2;
    unsigned int AngleN= 180/theta;
#pragma HLS ARRAY_PARTITION variable=sinval complete dim=0
#pragma HLS ARRAY_PARTITION variable=cosval complete dim=0
 loop_init_r: for(int r=0;r<rhoN+2;r++)
    {
    loop_init_n: for(int n=0;n<AngleN+2;n++)
        {
#pragma HLS PIPELINE
 accum[n][r]=0;
        }
    }

 loop_init: for(int n = 0; n < AngleN; n++ )
    {
        addr[n]=0;
        accbuf[0][n]=accum[n+1][Half_rhoN+1];
        sinval[n]=sinval[n]/rho;
        cosval[n]=cosval[n]/rho;
    }


 loop_height: for( int i = 0; i < rows; i++ )
    {
    loop_width: for( int j = 0; j < cols; j++ )
        {
#pragma HLS PIPELINE
#pragma HLS DEPENDENCE array inter false
 typename Type<((SRC_T) & ((1 << 11) - 1))>::name temp;
            _src.data_stream[0]>>temp;
            if(temp!=0&&!(i==0&&j==0))
            {
            loop_angle: for(int n = 0; n < AngleN; n++ )
                {
                    accbuf[1][n]=accbuf[0][n];
                    ACCUMT r=j*cosval[n]+i*sinval[n];
                    r+=Half_rhoN;
                    accbuf[0][n]=accum[n+1][r+1];
                    if(r==addr[n])
                        accbuf[0][n]=accbuf[0][n]+1;

                    accum[n+1][addr[n]+1]=accbuf[1][n]+1;
                    addr[n]=r;
                }
            }

        }
    }
 loop_exit: for(int n = 0; n < AngleN; n++ )
    {
        accum[n+1][addr[n]+1]=accbuf[0][n]+1;
    }
}
template<int rho,int ROW,int COL,typename ACCUMT, typename AT, typename RT,int linesMax>
void Sort_insert(
        ACCUMT accum[][(2*(COL+ROW)+1)/rho+2],
        Polar_<AT,RT> (&lines)[linesMax],
        unsigned int threshold,
        unsigned int theta,
        unsigned int& storenum)
{
    LineBuffer<2,((2*(COL+ROW)+1)/rho+2),ACCUMT> accum_buf;
    Window<3,3,ACCUMT> accum_win;
    ACCUMT lines_val[linesMax+1];
    ap_uint<1> lines_flag[linesMax+1];
    unsigned int rhoN =(2*(COL+ROW)+1)/ rho;
    unsigned int AngleN= 180/theta;
    unsigned int Half_rhoN=(rhoN-1)/2;

#pragma HLS ARRAY_PARTITION variable=&accum_buf complete dim=1
#pragma HLS ARRAY_PARTITION variable=lines_val complete dim=1
#pragma HLS ARRAY_PARTITION variable=lines complete dim=0
#pragma HLS ARRAY_PARTITION variable=&accum_win complete dim=0
#pragma HLS ARRAY_PARTITION variable=lines_flag complete dim=0

 loop_init: for(int i=0;i<linesMax;i++)
    {
        lines[i].angle=0;
        lines[i].rho=0;
        lines_val[i]=0;
        lines_flag[i]=0;
    }
        lines_val[linesMax]=0;
        lines_flag[linesMax]=0;

 loop_n: for(int n=0;n<AngleN+2;n++)
    {
    loop_r: for(int r=0;r<rhoN+2;r++)
        {
#pragma HLS DEPENDENCE array intra false
#pragma HLS DEPENDENCE array inter false
#pragma HLS PIPELINE
 VITIS_LOOP_201_1: for(int row=2;row>=0;row--)
            {
                VITIS_LOOP_203_2: for(int col=2;col>=1;col--)
                {
                    accum_win.val[row][col]=accum_win.val[row][col-1];
                }
            }

            ACCUMT temp=accum[n][r];

            ACCUMT accum_buf0=accum_buf.val[0][r];

            accum_win.val[2][0]=accum_buf.val[1][r];
            accum_win.val[1][0]=accum_buf0;
            accum_win.val[0][0]=temp;

            accum_buf.val[1][r]=accum_buf0;

            accum_buf.val[0][r]=temp;

            if(r>=2&&r!=Half_rhoN+2&&r<rhoN+2&&n>=2&&n<AngleN+2)
            {
                if((accum_win.val[1][1]>threshold)&&(accum_win.val[1][1]>accum_win.val[1][2])&&(accum_win.val[1][1]>=accum_win.val[1][0])&&(accum_win.val[1][1]>accum_win.val[2][1])&&(accum_win.val[1][1]>=accum_win.val[0][1] ))
                {

                loop_lines: for(int i=linesMax-2;i>=0;i--)
                    {
                        ACCUMT max=lines_val[i];
                        if(accum_win.val[1][1]>max)
                        {
                            lines[i+1].rho=lines[i].rho;
                            lines[i+1].angle=lines[i].angle;
                            lines_val[i+1]=max;
                            lines_flag[i]=0;
                        }
                        else
                        {
                            lines_flag[i]=1;
                        }
                    }
                    int sum=0;
                loop_sum: for(int i=0;i<linesMax;i++)
                        sum+=lines_flag[i];

                    lines[sum].rho=r-1;
                    lines[sum].angle=n-1;
                    lines_val[sum]=accum_win.val[1][1];
                    storenum++;
                }
            }
        }
    }
}
template<typename _AT, typename _RT,typename AT, typename RT,int linesMax>
void inline GetTopLines(
        Polar_<_AT,_RT> (&_lines)[linesMax],
        Polar_<AT,RT> (&lines)[linesMax+1],
        unsigned int storenum,
        unsigned int theta,
        unsigned int rho,
        unsigned int Half_rhoN)
{
    angleAccuracy_T Angle_accuracy=3.1415926*theta/180;
loop_lines: for(int i=0;i<linesMax;i++)
    {
        if(i<storenum)
        {
            RT r=lines[i].rho-1;
            AT n=lines[i].angle-1;
            _RT _rho = (r - Half_rhoN) * rho;
            _AT _angle = n * Angle_accuracy;
            _lines[i].rho=_rho;
            _lines[i].angle=_angle;
        }
        else
        {
                _lines[i].rho=0;
                _lines[i].angle=0;
        }
    }
}



template<unsigned int theta,unsigned int rho,typename AT,typename RT,typename ACCUMT,int SRC_T,int ROW,int COL,unsigned int linesMax, typename S_T>
void HoughLinesStandard(
        Mat<ROW,COL,SRC_T> &_src,
        Polar_<AT,RT> (&_lines)[linesMax],
        ACCUMT _accum[][(2*(COL+ROW)+1)/rho+2],
        unsigned int _threshold,
        S_T (&sinval)[180/theta],
        S_T (&cosval)[180/theta]
        )
{
    unsigned int storenum=0;
    Polar_<ap_uint<10>,ACCUMT > lines[linesMax+1];
    unsigned int rhoN =(2*(COL+ROW)+1)/ rho;
    unsigned int Half_rhoN=(rhoN-1)/2;

    HoughPolar<theta,rho>(_src,_accum, sinval, cosval);
    Sort_insert<rho,ROW,COL>(_accum,lines, _threshold,theta,storenum);
    GetTopLines(_lines,lines,storenum,theta,rho,Half_rhoN);
}
# 312 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_hough.h"
template<unsigned int theta,unsigned int rho,typename AT,typename RT,int SRC_T,int ROW,int COL,unsigned int linesMax>
void HoughLines2(
        Mat<ROW,COL,SRC_T> & _src,
 Polar_<AT,RT> (&_lines)[linesMax],
 unsigned int threshold
        )
{
 static ap_uint<12> _accum[180/theta+2][(2*(COL+ROW)+1)/rho+2];
#pragma HLS ARRAY_PARTITION variable=_accum complete dim=1
 ap_fixed<19,2,AP_RND> sinval[180/theta];
        ap_fixed<19,2,AP_RND> cosval[180/theta];
        angleAccuracy_T Angle_accuracy=3.1415926*theta/180;
 loop_init: for(int i=0;i<180/theta;i++)
        {
            sinval[i]=::hls::sinf((i*Angle_accuracy));
            cosval[i]=::hls::cosf(i*Angle_accuracy);
        }
 HoughLinesStandard<theta,rho>(_src,_lines,_accum,threshold, sinval,cosval);
}

}
# 67 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src\\hls_video.h" 2
# 1 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_harris.h" 1
# 83 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_harris.h"
namespace hls {

template<int KH,int KW, typename SRC_T>
bool IsMax(Window<KH,KW,SRC_T> & core_win)
{
#pragma HLS INLINE
 bool isMax=true;
    VITIS_LOOP_90_1: for(int i=0;i<KH;i++) {
        VITIS_LOOP_91_2: for(int j=0;j<KW;j++) {
            if(((i!=KH/2)||(j!=KW/2))&&core_win.val[i][j]>core_win.val[KH/2][KW/2])
                isMax=false;
        }
    }
    return isMax;
}
template<int KH, int KW, int SRC_T,int DST_T,int ROWS,int COLS>
void FindMax(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, DST_T> &_dst,
        typename Type<((SRC_T) & ((1 << 11) - 1))>::name threshold
                )
{
    LineBuffer<KH-1,COLS,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> k_buf;
    Window<KH,KW,typename Type<((SRC_T) & ((1 << 11) - 1))>::name> win;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    int rows= _src.rows;
    int cols= _src.cols;
    int ioffset=KH/2+1;
    int joffset=KH/2+1;
    VITIS_LOOP_113_1: for(HLS_SIZE_T i=0;i<rows+ioffset;i++)
    {
#pragma HLS LOOP_TRIPCOUNT MAX=ROWS
 VITIS_LOOP_116_2: for(HLS_SIZE_T j=0;j<cols+joffset;j++)
        {
#pragma HLS DEPENDENCE ARRAY INTER FALSE
#pragma HLS LOOP_TRIPCOUNT MAX=COLS
#pragma HLS LOOP_FLATTEN off
#pragma HLS PIPELINE II=1
 d.val[0]=0;
            VITIS_LOOP_123_3: for(int r= 0;r<KH;r++)
            {
                VITIS_LOOP_125_4: for(int c=0;c<KW-1;c++)
                {
                    win.val[r][c]=win.val[r][c+1];
                }
            }
            if(i<rows&&j<cols)
            {
                win.val[0][KW-1]=k_buf.val[0][j];
                VITIS_LOOP_133_5: for(int buf_row= 1;buf_row< KH-1;buf_row++)
                {
                    win.val[buf_row][KW-1]=k_buf.val[buf_row][j];
                    k_buf.val[buf_row-1][j]=k_buf.val[buf_row][j];
                }

                _src>>s;
                win.val[KH-1][KW-1]=s.val[0];
                k_buf.val[KH-2][j]=s.val[0];
            }
            else if(j>=cols)
            {

                VITIS_LOOP_146_6: for(int i= 1;i< KW;i++)
                    win.val[i][KW-1]=0;
            }
            if(win.val[1][1]>=threshold&&i>=KH&&j>=KW)
            {
                bool _ismax=IsMax(win);
                if(_ismax)
                {

                    d.val[0]=255;
                }
            }

            if(i>=ioffset&&j>=joffset)
            {
                _dst<<d;
            }
        }
    }
}
template<typename KT, typename ST, int X2_T,int Y2_T,int XY_T,int DST_T,int ROWS,int COLS>
void CalCim(
  Mat<ROWS, COLS, X2_T> &_gradx,
  Mat<ROWS, COLS, Y2_T> &_grady,
  Mat<ROWS, COLS, XY_T> &_gradxy,
  Mat<ROWS, COLS, DST_T> &_dst,
        KT k,
        ST scale
        )
{
    Scalar<((((X2_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((X2_T) & ((1 << 11) - 1))>::name> gx;
    Scalar<((((Y2_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((Y2_T) & ((1 << 11) - 1))>::name> gy;
    Scalar<((((XY_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((XY_T) & ((1 << 11) - 1))>::name> gxy;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    int rows= _grady.rows;
    int cols= _grady.cols;
    VITIS_LOOP_182_1: for(HLS_SIZE_T i=0;i<rows;i++)
    {
#pragma HLS LOOP_TRIPCOUNT MAX=ROWS
 VITIS_LOOP_185_2: for(HLS_SIZE_T j=0;j<cols;j++)
        {
#pragma HLS DEPENDENCE ARRAY INTER FALSE
#pragma HLS LOOP_TRIPCOUNT MAX=COLS
#pragma HLS LOOP_FLATTEN off
#pragma HLS PIPELINE II=1
 d.val[0]=0;
            _gradx>> gx;
            _grady>> gy;
            _gradxy>> gxy;
            typename Type<((DST_T) & ((1 << 11) - 1))>::name lgx = sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(gx.val[0])*typename Type<((DST_T) & ((1 << 11) - 1))>::name(scale*scale);
            typename Type<((DST_T) & ((1 << 11) - 1))>::name lgy = sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(gy.val[0])*typename Type<((DST_T) & ((1 << 11) - 1))>::name(scale*scale);
            typename Type<((DST_T) & ((1 << 11) - 1))>::name lgxy= sr_cast<typename Type<((DST_T) & ((1 << 11) - 1))>::name>(gxy.val[0])*typename Type<((DST_T) & ((1 << 11) - 1))>::name(scale*scale);
            typename Type<((DST_T) & ((1 << 11) - 1))>::name det = lgx*lgy - lgxy*lgxy;
            typename Type<((DST_T) & ((1 << 11) - 1))>::name trac= lgx + lgy;

            typename Type<((DST_T) & ((1 << 11) - 1))>::name cim = det - k*(trac)*(trac);
            d.val[0] = cim;
            _dst<<d;
        }
    }
}
template<int blockSize,int Ksize, bool NORMALIZE, class BORDERMODEL, int GT, int G2T, typename ST, typename KT,int SRC_T,int DST_T,int ROWS,int COLS>
void Harris_opr(
        Mat<ROWS, COLS, SRC_T> &_src,
        Mat<ROWS, COLS, DST_T> &_dst,
        KT k,
        ST scale)
{
#pragma HLS INLINE
#pragma HLS dataflow



 int rows = _src.rows;
    int cols = _src.cols;
    Mat<ROWS,COLS,SRC_T> gray1(rows,cols);
    Mat<ROWS,COLS,SRC_T> gray2(rows,cols);

    Mat<ROWS,COLS,GT> grad_x(rows,cols);
    Mat<ROWS,COLS,GT> grad_x1(rows,cols);
    Mat<ROWS,COLS,GT> grad_x2(rows,cols);
    Mat<ROWS,COLS,GT> grad_x3(rows,cols);
    Mat<ROWS,COLS,GT> grad_x4(rows,cols);

    Mat<ROWS,COLS,GT> grad_y(rows,cols);
    Mat<ROWS,COLS,GT> grad_y1(rows,cols);
    Mat<ROWS,COLS,GT> grad_y2(rows,cols);
    Mat<ROWS,COLS,GT> grad_y3(rows,cols);
    Mat<ROWS,COLS,GT> grad_y4(rows,cols);

    Mat<ROWS,COLS,G2T> grad_xx(rows,cols);
    Mat<ROWS,COLS,G2T> grad_yy(rows,cols);
    Mat<ROWS,COLS,G2T> grad_xy(rows,cols);

    Mat<ROWS,COLS,G2T> grad_gx(rows,cols);
    Mat<ROWS,COLS,G2T> grad_gy(rows,cols);
    Mat<ROWS,COLS,G2T> grad_gxy(rows,cols);

    Duplicate(_src,gray1,gray2);

    Sobel<1,0,Ksize,BORDERMODEL>(gray1,grad_x);
    Duplicate(grad_x,grad_x1,grad_x2);
    Duplicate(grad_x1,grad_x3,grad_x4);
    Sobel<0,1,Ksize,BORDERMODEL>(gray2,grad_y);
    Duplicate(grad_y,grad_y1,grad_y2);
    Duplicate(grad_y1,grad_y3,grad_y4);

    Mul(grad_x3,grad_x4,grad_xx);
    Mul(grad_y3,grad_y4,grad_yy);
    Mul(grad_x2,grad_y2,grad_xy);

    BoxFilter<blockSize,blockSize,NORMALIZE,BORDERMODEL>(grad_xx,grad_gx);
    BoxFilter<blockSize,blockSize,NORMALIZE,BORDERMODEL>(grad_yy,grad_gy);
    BoxFilter<blockSize,blockSize,NORMALIZE,BORDERMODEL>(grad_xy,grad_gxy);

    CalCim(grad_gx,grad_gy,grad_gxy, _dst,k, scale);
}

template<int blockSize,int Ksize,typename KT,int SRC_T,int DST_T,int ROWS,int COLS>
void CornerHarris(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, DST_T> &_dst,
        KT k)
{
#pragma HLS INLINE
 ap_uint<9> sc=(1 << ((Ksize>0 ? Ksize:3)-1))*blockSize;



    if(SRC_T==(((0) & ((1 << 11) - 1)) + (((1)-1) << 11))||SRC_T==(((8) & ((1 << 11) - 1)) + (((1)-1) << 11)))
    {
        ap_fixed<25,-7-Ksize> scale = (ap_fixed<25,2>(1.0f)/255) / sc;
        switch(Ksize) {
            case 3:
                Harris_opr<blockSize, Ksize,false,BORDER_REPLICATE, (((10+1 +12) & ((1 << 11) - 1)) + (((1)-1) << 11)),
                        (((20+1+BitWidth<blockSize*blockSize>::Value+12) & ((1 << 11) - 1)) + (((1)-1) << 11))>(_src, _dst, k,scale);
                break;
            case 5:
                Harris_opr<blockSize, Ksize,false,BORDER_REPLICATE, (((14+1 +12) & ((1 << 11) - 1)) + (((1)-1) << 11)),
                        (((28+1+BitWidth<blockSize*blockSize>::Value+12) & ((1 << 11) - 1)) + (((1)-1) << 11))>(_src, _dst, k,scale);
                break;
            case 7:
                Harris_opr<blockSize, Ksize,false,BORDER_REPLICATE, (((18+1 +12) & ((1 << 11) - 1)) + (((1)-1) << 11)),
                        (((36+1+BitWidth<blockSize*blockSize>::Value+12) & ((1 << 11) - 1)) + (((1)-1) << 11))>(_src, _dst, k,scale);
                break;
            default:
                Harris_opr<blockSize, Ksize,false,BORDER_REPLICATE, (((10+1 +12) & ((1 << 11) - 1)) + (((1)-1) << 11)),
                        (((20+1+BitWidth<blockSize*blockSize>::Value+12) & ((1 << 11) - 1)) + (((1)-1) << 11))>(_src, _dst, k,scale);
        }

    }
    else
    {
        float scale = 1.0f / sc;
        Harris_opr<blockSize, Ksize,false,BORDER_REPLICATE, (((5) & ((1 << 11) - 1)) + (((1)-1) << 11)), (((5) & ((1 << 11) - 1)) + (((1)-1) << 11))>(_src, _dst, k,scale);
    }
}

template<int blockSize,int Ksize,typename KT,int SRC_T,int DST_T,int ROWS,int COLS>
void Harris(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, DST_T> &_dst,
        KT k,
        int threshold)
{
#pragma HLS INLINE
 Mat<ROWS,COLS,(((5) & ((1 << 11) - 1)) + (((1)-1) << 11))> res(_src.rows,_src.cols);
    CornerHarris<blockSize,Ksize>(_src, res, k);
    FindMax<3,3>(res,_dst,threshold);
}

}
# 68 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src\\hls_video.h" 2
# 1 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_haar.h" 1
# 41 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_haar.h"
namespace hls {

typedef ap_fixed<12,6,AP_RND> VAR_T;
typedef ap_uint<3> WEIGHT_T;
typedef unsigned int STHRESHOLD_T;
typedef short CTHRESHOLD_T;
typedef unsigned short ALPHA_T;

struct HaarRect
{
    Rect_< ap_uint<6> > r;
    WEIGHT_T weight;
};
struct HaarFeature
{
    public:
    HaarFeature()
    {
#pragma HLS ARRAY_PARTITION variable=rect complete dim=1
 };
    HaarRect rect[3];

};
template <int FEATURE_MAX>
struct HaarClassifier
{
    public:
    HaarClassifier()
    {
#pragma HLS ARRAY_PARTITION variable=haar_feature complete dim=1
 };
        unsigned short count;
        HaarFeature haar_feature[FEATURE_MAX];
        CTHRESHOLD_T threshold[FEATURE_MAX];
        ap_int<5> left[FEATURE_MAX];
        ap_int<5> right[FEATURE_MAX];
        ALPHA_T alpha[FEATURE_MAX+1];
        };
template <int STAGE,int CLASSIFIER_ALL,int FEATURE_MAX>
struct HaarStageClassifier
{
    public:
    HaarStageClassifier()
    {
#pragma HLS ARRAY_PARTITION variable=classifier complete dim=1
 };
        unsigned char count[STAGE];
        STHRESHOLD_T threshold[STAGE];
        HaarClassifier<FEATURE_MAX> classifier[CLASSIFIER_ALL];




        };
template <int STAGE,int CLASSIFIER_ALL,int FEATURE_MAX>
struct HaarClassifierCascade
{
    public:
        HaarClassifierCascade()
        {
        };
        unsigned short count;
        Size_<unsigned char> real_window_size;
        HaarStageClassifier<STAGE,CLASSIFIER_ALL,FEATURE_MAX> stage_classifier;
};

class HaarLoadData
{
        public:
template <int STAGE,int CLASSIFIER_ALL,int FEATURE_MAX>
HaarLoadData(HaarClassifierCascade<STAGE,CLASSIFIER_ALL,FEATURE_MAX> &cascade,

        const int ca_count,

        const Size_<unsigned char> ca_real_window_size,
        const int s_count[],
        const float s_threshold[],
        const int c_left[][FEATURE_MAX],
        const int c_right[][FEATURE_MAX],
        const float c_threshold[][FEATURE_MAX],
        const float c_alpha[][FEATURE_MAX+1],
        const unsigned int haar_feature[][FEATURE_MAX][4*3],
        const float haar_feature_weight[][FEATURE_MAX][3]




        )
{

        cascade.count=ca_count;

        cascade.real_window_size=ca_real_window_size;
        VITIS_LOOP_134_1: for(int i=0;i<STAGE;i++)
        {
                cascade.stage_classifier.count[i]=s_count[i];
                cascade.stage_classifier.threshold[i]=s_threshold[i];



        }
        VITIS_LOOP_142_2: for(int i=0;i<CLASSIFIER_ALL;i++)
        {

               VITIS_LOOP_145_3: for(int j=0;j<FEATURE_MAX;j++)
               {
                      cascade.stage_classifier.classifier[i].left[j]=c_left[i][j];
                      cascade.stage_classifier.classifier[i].right[j]=c_right[i][j];
                      cascade.stage_classifier.classifier[i].threshold[j]=c_threshold[i][j];
                      cascade.stage_classifier.classifier[i].alpha[j]=c_alpha[i][j];
                      cascade.stage_classifier.classifier[i].alpha[FEATURE_MAX]=c_alpha[i][FEATURE_MAX];

                      VITIS_LOOP_153_4: for(int n=0;n<3;n++)
                      {
                            cascade.stage_classifier.classifier[i].haar_feature[j].rect[n].r.x=haar_feature[i][j][n*4+0];
                            cascade.stage_classifier.classifier[i].haar_feature[j].rect[n].r.y=haar_feature[i][j][n*4+1];
                            cascade.stage_classifier.classifier[i].haar_feature[j].rect[n].r.width=haar_feature[i][j][n*4+2];
                            cascade.stage_classifier.classifier[i].haar_feature[j].rect[n].r.height=haar_feature[i][j][n*4+3];
                       }
                            cascade.stage_classifier.classifier[i].haar_feature[j].rect[0].weight=-1;
                            cascade.stage_classifier.classifier[i].haar_feature[j].rect[1].weight=haar_feature_weight[i][j][1];
                            cascade.stage_classifier.classifier[i].haar_feature[j].rect[2].weight=haar_feature_weight[i][j][2];
                 }
        }
}
};

template<typename SUMT, typename VART,int ROWS,int COLS>
void intergral_win(
        Window<ROWS,COLS,VART> &win_var,
        SUMT &var
        )
{
#pragma HLS INLINE
 var=0;
    VITIS_LOOP_176_1: for(int j=0;j<COLS;j++)
    {
        SUMT t = 0;
        VITIS_LOOP_179_2: for(int i=0;i<ROWS;i++)
        {
            var=var+win_var.val[i][j];
            t += win_var.val[i][j];
        }

    }
}

template< typename SRC_T,int ROWS,int COLS,int FEATURE_MAX>
ALPHA_T icvEvalHidHaarClassifier(HaarClassifier<FEATURE_MAX> & classifier,Window<ROWS,COLS,SRC_T>& win,VAR_T &variance )
{
#pragma HLS inline off
#pragma HLS function_instantiate variable=&classifier


 int m=0,i=0;
    VITIS_LOOP_196_1: for(m=0;m<FEATURE_MAX;m++)
    {
        Rect_<ap_uint<6> > rr=classifier.haar_feature[i].rect[0].r;
        if(i>0||(i==0&&m==0))
        {

            CTHRESHOLD_T sum=-(win.val[rr.height][rr.width]-win.val[rr.height][rr.x]-win.val[rr.y][rr.width]+win.val[rr.y][rr.x]);
            VITIS_LOOP_203_2: for(int j=1;j<3;j++)
            {
                WEIGHT_T weight=classifier.haar_feature[i].rect[j].weight;
                Rect_< ap_uint<6> > rj=classifier.haar_feature[i].rect[j].r;
                sum+=(win.val[rj.height][rj.width]-win.val[rj.height][rj.x]-win.val[rj.y][rj.width]+win.val[rj.y][rj.x])*weight;
            }
            if(sum<classifier.threshold[i]*variance)
            {
                i=classifier.left[i];
            }
            else
            {
                i=classifier.right[i];
            }
        }


    }
    return classifier.alpha[-i] ;
}

template< typename SRC_T,int ROWS,int COLS,int STAGE,int CLASSIFIER_ALL,int FEATURE_MAX>
bool RunHaarClassifierCascade(HaarClassifierCascade<STAGE,CLASSIFIER_ALL,FEATURE_MAX> &cascade,Window<ROWS,COLS,SRC_T>&win,VAR_T &variance )
{
#pragma HLS inline
 ALPHA_T sum=0;
    bool result=true;
    unsigned char stage_index=0;
    unsigned char stage_count=0;
    VITIS_LOOP_232_1: for (int i=0;i<CLASSIFIER_ALL;i++)
    {
        sum+=icvEvalHidHaarClassifier(cascade.stage_classifier.classifier[i],win,variance);
        stage_count++;
        if(cascade.stage_classifier.count[stage_index]==stage_count)
        {
            if(sum < cascade.stage_classifier.threshold[stage_index])
            {
                result =false;
            }
            sum=0;
            stage_count=0;
            stage_index++;
        }
    }
    return result;
}
template < typename T>
T TaylorExp(T &t)
{
   return (1+((T)0.5)*(t)-((T)0.125)*(t)*(t));
}

template< int K_H,int K_W,int S_T,int ROWS,int COLS,int STAGE,int CLASSIFIER_ALL,int FEATURE_MAX, int DST_T>
void HaarClassifierObject_opr(
                HaarClassifierCascade<STAGE,CLASSIFIER_ALL,FEATURE_MAX> &cascade,
  Mat<ROWS, COLS, S_T> &_src,
  Mat<ROWS, COLS, DST_T> &_mask
  )
{
    int storage_count=0;






    Window<1,K_W+1,ap_uint<16+16> > sqwin;
    Window<K_H+1,K_W+1,ap_uint<8+16> > swin;
    LineBuffer<K_H,COLS,typename Type<((S_T) & ((1 << 11) - 1))>::name> sbuf;

    int rows=_src.rows;
    int cols=_src.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_haar.h",275),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_haar.h",276),0));
    Scalar<1,typename Type<((DST_T) & ((1 << 11) - 1))>::name> m;
    Scalar<((((S_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((S_T) & ((1 << 11) - 1))>::name> ss;

    VITIS_LOOP_280_1: for(int i=0;i<rows;i++)
    {
        VITIS_LOOP_282_2: for(int j=0;j<cols;j++)
        {
#pragma HLS loop_flatten off
#pragma HLS PIPELINE
#pragma HLS DEPENDENCE array inter false

 {
#pragma HLS expression_balance off
 sqwin.shift_left();
            swin.shift_left();
            swin.val[0][K_W]=(j == 0 ? ap_uint<24>(0) :swin.val[0][K_W-1])+sbuf.val[0][j];
            ap_uint<16> col_sum=sbuf.val[0][j];
            ap_uint<32> col_sum_sq=0;
            VITIS_LOOP_295_3: for(int buf_row= 1;buf_row<K_H;buf_row++)
            {
                ss.val[0]=sbuf.val[buf_row][j];
                sbuf.val[buf_row-1][j]=ss.val[0];
                col_sum += ss.val[0];
                col_sum_sq += ss.val[0] * ss.val[0];
                swin.val[buf_row][K_W] = (j == 0 ? ap_uint<24>(0) :swin.val[buf_row][K_W-1]) + col_sum;
            }
            _src >> ss;
            sbuf.val[K_H-1][j]=ss.val[0];
            col_sum += ss.val[0];
            col_sum_sq += ss.val[0] * ss.val[0];
            swin.val[K_H][K_W] = (j == 0 ? ap_uint<24>(0) : swin.val[K_H][K_W-1]) + col_sum;
            sqwin.val[0][K_W] = (j == 0 ? ap_uint<32>(0) : sqwin.val[0][K_W-1]) + col_sum_sq;
# 322 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_haar.h"
            }

            m.val[0]=0;
            if(i>=K_H && j>=K_W &&( (j & 1)==0 ))
            {
                int b=K_H,s=0;

                float inv_window_area=1.0/(K_H*K_W);
                ap_uint<26> varsum=sqwin.val[0][K_W] - sqwin.val[0][0];






                ap_uint<17> meansum=swin.val[b][b]-swin.val[b][s]-swin.val[s][b]+swin.val[s][s];
                ap_fixed<32,18,AP_RND> mean=(meansum)*inv_window_area;
                ap_fixed<32,18,AP_RND> meansq=mean*mean;
                ap_fixed<32,18,AP_RND> var_a=varsum*inv_window_area;
                ap_fixed<32,18,AP_RND> variance=var_a-meansq;
                if(variance>0)
                {

                    variance = (variance/100);
                    ap_fixed<32,18,AP_RND> t=variance-1;
                    if(variance<=4)
                        variance= TaylorExp(t)+1;
                    else if(variance >4 && variance <=16)
                    {
                        ap_fixed<32,18,AP_RND> tt=t/4;
                        variance= 2*TaylorExp(tt)+1;
                    }
                    else if(variance >16 && variance <=64)
                    {
                        ap_fixed<32,18,AP_RND> tt=t/16;
                        variance= 4*TaylorExp(tt)+1;
                    }
                    else if(variance >64 && variance <=256)
                    {
                        ap_fixed<32,18,AP_RND> tt=t/64;
                        variance= 8*TaylorExp(tt)+1;
                    }
                    else
                        variance=16;
                }
                else
                {
                    variance = 1;
                }

                ap_fixed<12,6,AP_RND> var=variance;
                bool Isface=RunHaarClassifierCascade(cascade,swin,var);
                if(Isface)
                {
                    if(variance>65)
                    {
                        variance=65;
                    }
                    variance=variance*1000;
                    storage_count++;

                    m.val[0]=(unsigned char)variance;
                }
            }
            _mask << m;
        }
    }

}
template<int K_H,int K_W,int SRC_T,int DST_T,int ROWS,int COLS,int STAGE,int CLASSIFIER_ALL,int FEATURE_MAX>
void HaarClassifierObject(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, DST_T> &_mask,
                HaarClassifierCascade<STAGE,CLASSIFIER_ALL,FEATURE_MAX> &_cascade
                )
{
#pragma HLS inline
# 409 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_haar.h"
 HaarClassifierObject_opr<K_H,K_W>(_cascade,_src, _mask);
}

template<typename RECT_T>
void CombineStorage(Rect_<RECT_T> _storage_group[][300],int m, Rect_<RECT_T> _storage[],int num)
{
        int count=0;
        VITIS_LOOP_416_1: for(int i=0;i<m;i++)
        {
                VITIS_LOOP_418_2: for(int j=0;j<num;j++)
                {
                        if(count<num&&_storage_group[i][j].width!=0&&_storage_group[i][j].height!=0)
                        {
                            _storage[count++]=_storage_group[i][j];
                        }
                }
        }
        VITIS_LOOP_426_3: for(int i=0;i<num;i++)
        {
         if(i>=count)
            {
               _storage[count].x=0;
               _storage[count].y=0;
               _storage[count].width=0;
               _storage[count].height=0;

            }
         }
}
template<int SRC_T, int DST_T,int ROWS,int COLS>
void Combin_mask(
  Mat<ROWS, COLS, SRC_T> &mask0,
  Mat<ROWS/2, COLS/2, SRC_T> &mask1,
  Mat<ROWS/4, COLS/4, SRC_T> &mask2,
  Mat<ROWS/8, COLS/8, SRC_T> &mask3,
  Mat<ROWS, COLS, DST_T> &dst
                )
{
    int rows =mask0.rows;
    int cols =mask0.cols;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1),typename Type<((SRC_T) & ((1 << 11) - 1))>::name> m;

    int i1=0;
    int i2=0;
    int i3=0;
    VITIS_LOOP_455_1: for(int i=0;i<rows;i++)
    {
        int j1=0;
        int j2=0;
        int j3=0;
        VITIS_LOOP_460_2: for(int j=0;j<cols;j++)
        {
#pragma HLS PIPELINE
 s.val[0]=0;
            mask0>> m;
            if(m.val[0]!=0)
                s.val[0]=255;
            if(i==i1*2&&j==j1*2)
            {
                mask1>>m;
                s.val[0]=s.val[0]|m.val[0];
                j1++;
            }
            if(i==i2*4&&j==j2*4)
            {
                mask2>>m;
                s.val[0]=s.val[0]|m.val[0];
                j2++;
            }
            if(i==i3*8&&j==j3*8)
            {
                mask3>>m;
                s.val[0]=s.val[0]|m.val[0];
                j3++;
            }
            dst<<s;
        }
        if(i==i1*2)
            i1++;
        if(i==i2*4)
            i2++;
        if(i==i3*8)
            i3++;
    }
}

template<int K_H,int K_W,int SRC_T,int DST_T,int ROWS,int COLS,int STAGE,int CLASSIFIER_ALL,int FEATURE_MAX>
void HaarClassifierObject_group(
  Mat<ROWS, COLS, SRC_T> &_src,
  Mat<ROWS, COLS, DST_T> &_mask,
                HaarClassifierCascade<STAGE,CLASSIFIER_ALL,FEATURE_MAX> &_cascade
                )
{
#pragma HLS inline
 int rows =_src.rows;
        int cols =_src.cols;
 Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> gray1(rows,cols);
 Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> gray2(rows,cols);
 Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> gray3(rows,cols);
 Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> gray4(rows,cols);
 Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> gray5(rows,cols);
 Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> gray6(rows,cols);
        Duplicate(_src, gray1, gray2 );
        Duplicate(gray1, gray3, gray4 );
        Duplicate(gray2, gray5, gray6 );
 Mat<ROWS/2, COLS/2, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> internal_1(rows/2,cols/2);
 Mat<ROWS/4, COLS/4, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> internal_2(rows/4,cols/4);
 Mat<ROWS/8, COLS/8, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> internal_3(rows/8,cols/8);
 Mat<ROWS, COLS, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> mask_0(rows,cols);
 Mat<ROWS/2, COLS/2, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> mask_1(rows/2,cols/2);
 Mat<ROWS/4, COLS/4, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> mask_2(rows/4,cols/4);
 Mat<ROWS/8, COLS/8, (((0) & ((1 << 11) - 1)) + (((1)-1) << 11))> mask_3(rows/8,cols/8);
        Resize(gray4,internal_1);
        Resize(gray5,internal_2);
        Resize(gray6,internal_3);
        HaarClassifierObject<K_H, K_W > ( gray3, mask_0, _cascade);
        HaarClassifierObject<K_H, K_W > ( internal_1, mask_1, _cascade);
        HaarClassifierObject<K_H, K_W > ( internal_2, mask_2, _cascade);
        HaarClassifierObject<K_H, K_W > ( internal_3, mask_3, _cascade);
        Combin_mask<DST_T,DST_T,ROWS,COLS>(mask_0,mask_1,mask_2,mask_3,_mask);
}

}
# 69 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src\\hls_video.h" 2
# 1 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_stereobm.h" 1
# 100 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_stereobm.h"
namespace hls {







template<int WSIZE, int NDISP, int NDISP_UNIT>
class StereoBMState {
public:

    int preFilterType;
    int preFilterSize;
    int preFilterCap;


    int SADWindowSize;
    int minDisparity;
    int numberOfDisparities;


    int textureThreshold;

    int uniquenessRatio;





    int ndisp_unit;
    int sweepFactor;
    int remainder;

    StereoBMState() {
        preFilterType = 1;
        preFilterSize = WSIZE;
        preFilterCap = 32;
        SADWindowSize = WSIZE;
        minDisparity = 0;
        numberOfDisparities = NDISP;
        textureThreshold = 10;
        uniquenessRatio = 15;
        sweepFactor = (NDISP/NDISP_UNIT) + ((NDISP%NDISP_UNIT) != 0);
        ndisp_unit = NDISP_UNIT;
        remainder = NDISP_UNIT*sweepFactor - NDISP;
    }
};

template<int PWSIZE, int SRC_T, int DST_T, int ROWS, int COLS>
void PreFilterNorm(
            Mat<ROWS, COLS, SRC_T>& src,
            Mat<ROWS, COLS, DST_T>& dst,
            int cap)
{
    int rows = src.rows;
    int cols = src.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_stereobm.h",157),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_stereobm.h",158),0));

    LineBuffer<PWSIZE, COLS+PWSIZE-1, Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> > buff;
    Window<PWSIZE, PWSIZE, Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> > win;

    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> tmp[PWSIZE];
#pragma HLS array_partition variable=tmp complete dim=0
 int sum_cols[PWSIZE];
#pragma HLS array_partition variable=tmp complete dim=0
 int sum;

loop_sum_row:
    for (int row = 0; row < rows+PWSIZE-1; row++) {
loop_sum_init:
        for (int i = 0; i < PWSIZE; i++) {
            sum_cols[i] = 0;
        }
        sum = 0;
loop_sum_col:
        for (int col = 0; col < cols+PWSIZE-1; col++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
 Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> pix_in(0);
            buff.shift_down(col);
            if (!(row < (PWSIZE-1)/2 || row >= rows+(PWSIZE-1)/2 || col < (PWSIZE-1)/2 || col >= cols+(PWSIZE-1)/2)) {
                src >> pix_in;
            }
            buff.insert_bottom(pix_in, col);
            VITIS_LOOP_186_1: for (int i = 0; i< PWSIZE; i++) {
                tmp[i] = buff.val[i][col];
            }


            int a_sum = 0, b_sum = 0;
            VITIS_LOOP_192_2: for (int i = 0; i < PWSIZE; i++) {
                b_sum += tmp[i].val[0];
            }
            a_sum = sum_cols[PWSIZE-1];
            VITIS_LOOP_196_3: for (int j = PWSIZE-1; j > 0; j--) {
                sum_cols[j] = sum_cols[j-1];
            }
            sum_cols[0] = b_sum;
            sum = sum - a_sum + b_sum;
            win.shift_right();
            win.insert_right(tmp);

            if (row >= PWSIZE-1 && col >= PWSIZE-1) {
                int avg = sum / (PWSIZE*PWSIZE);
                Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> pix_out;
                int center = win.val[PWSIZE/2][PWSIZE/2].val[0];
                pix_out.val[0] = hls::min<int>(hls::max<int>(center-avg, -cap), cap) + cap;
                dst << pix_out;
            }
        }
    }
}

template<int ROWS, int COLS, int SRC_T, int DST_T>
void Clip(
            Mat<ROWS, COLS, SRC_T>& src,
            Mat<ROWS, COLS, DST_T>& dst,
            int cap)
{
    HLS_SIZE_T rows = src.rows;
    HLS_SIZE_T cols = src.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_stereobm.h",223),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_stereobm.h",224),0));
    Scalar<((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((SRC_T) & ((1 << 11) - 1))>::name> s;
    Scalar<((((DST_T) & ((512 - 1) << 11)) >> 11) + 1), typename Type<((DST_T) & ((1 << 11) - 1))>::name> d;
    VITIS_LOOP_227_1: for (HLS_SIZE_T i = 0; i < rows; i++) {
        VITIS_LOOP_228_2: for (HLS_SIZE_T j = 0; j < cols; j++) {
#pragma HLS pipeline II=1
 src >> s;
            VITIS_LOOP_231_3: for (HLS_SIZE_T k = 0; k < ((((SRC_T) & ((512 - 1) << 11)) >> 11) + 1); k++) {
                s.val[k] = s.val[k] < -cap ? 0 : s.val[k] > cap ? cap*2 : s.val[k] + cap;
                d.val[k] = s.val[k];
            }
            dst << d;
        }
    }
}

template<typename T>
T absdiff(T a, T b) {
#pragma HLS inline
 long long x = a-b;
    long long y = b-a;
    T r;
    if(x < 0) {
        r = y;
        (void) ((!!(r == y)) || (_assert("r == y","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_stereobm.h",248),0));
    } else {
        r = x;
        (void) ((!!(r == x)) || (_assert("r == x","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_stereobm.h",251),0));
    }
    return r;
}

template<int WSIZE, class T>
void UpdateTexture(
            Window<WSIZE, WSIZE, T>& window,
            T* col_tbi,
            int& text_sum,
            int row,
            int col,
            T cap)
{
#pragma HLS inline
 int tmp = 0;
    VITIS_LOOP_267_1: for (int i = 0; i < WSIZE; i++) {

        tmp += (i > row? 0 : absdiff(col_tbi[i], cap)) - ((col < WSIZE || i > row) ? 0 : absdiff(window.val[i][WSIZE-1], cap));
    }
    text_sum += tmp;
}

template<int WSIZE, int L_WIN_COLS, int R_WIN_COLS, typename T>
int SAD_compute_inc(
            Window<WSIZE, L_WIN_COLS, T>& l_win,
            Window<WSIZE, R_WIN_COLS, T>& r_win_s,
            int d,
            int col,
            int sad_cols_d[WSIZE])
{
#pragma HLS inline
 int a_sum = 0, b_sum = 0;

    VITIS_LOOP_285_1: for (int i = 0; i < WSIZE; i++) {
        b_sum += absdiff(l_win.val[i][0], r_win_s.val[i][d]);
    }

    if (col < d) b_sum = 0;

    a_sum = sad_cols_d[WSIZE-1];

    VITIS_LOOP_293_2: for (int j = WSIZE-1; j > 0; j--) {
        sad_cols_d[j] = sad_cols_d[j-1];
    }

    sad_cols_d[0] = b_sum;

    return (-a_sum+b_sum);
}

template<int SIZE>
class MinSAD {
public:
    template <typename T, typename T_idx>
    static void find(T a[SIZE], T_idx &loc, T &val) {
#pragma HLS inline
#pragma HLS array_partition variable=a complete dim=0
 T a1[SIZE/2];
        T a2[SIZE-SIZE/2];
        VITIS_LOOP_311_1: for(int i = 0; i < SIZE/2; i++) {
            a1[i] = a[i];
        }
        VITIS_LOOP_314_2: for(int i = 0; i < SIZE-SIZE/2; i++) {
            a2[i] = a[i+SIZE/2];
        }
        T_idx l1,l2;
        T v1,v2;
        MinSAD<SIZE/2>::find(a1,l1,v1);
        MinSAD<SIZE-SIZE/2>::find(a2,l2,v2);
        if(v1 >= v2) {
            val = v2;
            loc = l2+SIZE/2;
        } else {
            val = v1;
            loc = l1;
        }
    }
};

template<>
class MinSAD<1> {
public:
    template <typename T, typename T_idx>
    static void find(T a[1], T_idx &loc, T &val) {
#pragma HLS inline
#pragma HLS array_partition variable=a complete dim=0
 loc = 0;
        val = a[0];
    }
};

template<>
class MinSAD<2> {
public:
    template <typename T, typename T_idx>
    static void find(T a[2], T_idx &loc, T &val) {
#pragma HLS inline
#pragma HLS array_partition variable=a complete dim=0
 T_idx l1=0, l2=1;
        T v1=a[0], v2=a[1];
        if(v1 >= v2) {
            val = v2;
            loc = l2;
        } else {
            val = v1;
            loc = l1;
        }
    }
};

template<int WSIZE, int NDISP, int NDISP_UNIT, int ROWS, int COLS, int SRC_T, int DST_T>
void SADBlockMatching(
            Mat<ROWS, COLS, SRC_T>& left,
            Mat<ROWS, COLS, SRC_T>& right,
            Mat<ROWS, COLS, DST_T>& disp,
            StereoBMState<WSIZE, NDISP, NDISP_UNIT>& state)


            __attribute__((no_sanitize("undefined")))

{
    int rows = left.rows;
    int cols = left.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_stereobm.h",375),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_stereobm.h",376),0));
    LineBuffer<WSIZE, COLS+WSIZE-1, typename Type<((SRC_T) & ((1 << 11) - 1))>::name> l_buff;
    LineBuffer<WSIZE, COLS+WSIZE-1, typename Type<((SRC_T) & ((1 << 11) - 1))>::name> r_buff;
    Window<WSIZE, WSIZE, typename Type<((SRC_T) & ((1 << 11) - 1))>::name> l_window;
    Window<WSIZE, WSIZE+NDISP_UNIT-1, typename Type<((SRC_T) & ((1 << 11) - 1))>::name> r_window_search;
    int ndisp = state.numberOfDisparities;
    int mindisp = 0;

    typename Type<((DST_T) & ((1 << 11) - 1))>::name FILTERED = (typename Type<((DST_T) & ((1 << 11) - 1))>::name)((mindisp - 1) << 4);
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name cap = state.preFilterCap;
    typename Type<((SRC_T) & ((1 << 11) - 1))>::name l_tmp[WSIZE];
#pragma HLS array_partition variable=l_tmp complete dim=0
 typename Type<((SRC_T) & ((1 << 11) - 1))>::name r_tmp[WSIZE];
#pragma HLS array_partition variable=r_tmp complete dim=0
 int text_sum = 0;
    int sad[NDISP_UNIT];
#pragma HLS array_partition variable=sad complete dim=0
 int sad_cols[NDISP_UNIT][WSIZE];
#pragma HLS array_partition variable=sad_cols complete dim=0
 int minsad[COLS+WSIZE-1];
    int mind[COLS+WSIZE-1];
    int skip[COLS+WSIZE-1];
    int skip_val[COLS+WSIZE-1];
    int edge_neighbor[COLS+WSIZE-1];
    int edge[COLS+WSIZE-1];
    int minsad_p[COLS+WSIZE-1];
    int minsad_n[COLS+WSIZE-1];

    int d = 0;
loop_row:
    for (int row = 0; row < rows+WSIZE-1; row++) {
loop_mux:
        for (int sweep = 0; sweep < state.sweepFactor; sweep++) {
loop_col:
            for (int col = 0; col < cols+WSIZE-1; col++) {
#pragma HLS loop_flatten off
#pragma HLS pipeline II=1
 if (col == 0) {
loop_sad_init:
                    for (d = 0; d < NDISP_UNIT; d++) {
#pragma HLS unroll
 sad[d] = 0;
                        VITIS_LOOP_418_1: for (int i = 0; i < WSIZE; i++) {
#pragma HLS unroll
 sad_cols[d][i] = 0;
                        }
                    }
                }

                Scalar<1, typename Type<((SRC_T) & ((1 << 11) - 1))>::name> l_in(cap), r_in(cap);
                if (sweep == 0) {

                    l_buff.shift_down(col);
                    r_buff.shift_down(col);
                    if (!(row < (WSIZE-1)/2 || row >= rows+(WSIZE-1)/2 || col < (WSIZE-1)/2 || col >= cols+(WSIZE-1)/2)) {
                        left >> l_in;
                        right >> r_in;
                    }
                    l_buff.insert_bottom(l_in.val[0], col);
                    r_buff.insert_bottom(r_in.val[0], col);
loop_get_data_from_linebuff:
                    for (int i = 0; i < WSIZE; i++) {
                        l_tmp[i] = l_buff.val[i][col];
                        r_tmp[i] = r_buff.val[i][col];
                    }
                } else {
                    int offset = sweep * NDISP_UNIT;
loop_get_data_from_linebuff_with_offset:
                    for (int i = 0; i < WSIZE; i++) {
                        l_tmp[i] = l_buff.val[i][col];
                        r_tmp[i] = r_buff.val[i][col-offset < 0 ? 0 : col-offset];
                    }
                }

                UpdateTexture<WSIZE, typename Type<((SRC_T) & ((1 << 11) - 1))>::name>(l_window, l_tmp, text_sum, row, col, cap);

                l_window.shift_right();
                r_window_search.shift_right();
                l_window.insert_right(l_tmp);
                r_window_search.insert_right(r_tmp);

loop_sad_compute:
                for (d = 0; d < NDISP_UNIT; d++) {
                    sad[d] += SAD_compute_inc<WSIZE, WSIZE, WSIZE+NDISP_UNIT-1, typename Type<((SRC_T) & ((1 << 11) - 1))>::name>(l_window, r_window_search, d, col, sad_cols[d]);
                    if (sweep == state.sweepFactor-1 && d >= (NDISP_UNIT-state.remainder)) sad[d] = 2147483647;
                }


                if (row >= WSIZE-1 && col >= WSIZE-1) {
                    int skip_flag = 0;
                    Scalar<1, typename Type<((DST_T) & ((1 << 11) - 1))>::name> out_pix;
                    if (text_sum < state.textureThreshold) skip_flag = 1;
                    if ((row - WSIZE+1) < (WSIZE-1)/2 || (row - WSIZE+1) >= rows - (WSIZE-1)/2) skip_flag = 1;
                    if ((col - WSIZE+1) < NDISP-1 + (WSIZE-1)/2 || (col - WSIZE+1) >= cols - (WSIZE-1)/2) skip_flag = 1;
                    int gminsad = ((sweep > 0) ? minsad[col] : 2147483647);
                    int gmind = ((sweep > 0) ? mind[col] : 0);
                    int gskip = ((sweep > 0) ? skip[col] : 0);
                    int gskip_val = ((sweep > 0) ? skip_val[col] : 2147483647);
                    int gedge_neighbor = ((sweep > 0) ? edge_neighbor[col] : 2147483647);
                    int gedge = ((sweep > 0) ? edge[col] : sad[1]);
                    int lminsad = 2147483647;
                    int lmind = 0;
                    int gminsad_p = ((sweep > 0) ? minsad_p[col] : 2147483647);
                    int gminsad_n = ((sweep > 0) ? (gmind == sweep*NDISP_UNIT-1 ? sad[0] : minsad_n[col]) : 2147483647);
                    MinSAD<NDISP_UNIT>::find(sad, lmind, lminsad);

                    if (lminsad <= gminsad) {
                        gskip = 0;
                        if (state.uniquenessRatio > 0) {
                            int thresh = lminsad + (lminsad * state.uniquenessRatio / 100);
                            if (gminsad <= thresh && lmind+sweep*NDISP_UNIT > gmind+1) {
                                gskip = 1;
                                gskip_val = gminsad;
                            } else if (gminsad <= thresh && lmind+sweep*NDISP_UNIT == gmind+1 && gskip_val <= thresh) {
                                gskip = 1;

                            } else if (gminsad <= thresh && lmind+sweep*NDISP_UNIT == gmind+1 && gedge_neighbor <= thresh) {
                                gskip = 1;
                                gskip_val = gedge_neighbor;
                            }
loop_unique_search_0:
                            for (d = 0; d < NDISP_UNIT; d++) {
                                if (sad[d] <= thresh && sad[d] < gskip_val && (d < lmind-1 || d > lmind+1)) {
                                    gskip = 1;
                                    gskip_val = sad[d];
                                }
                            }
                        }

                        gminsad_p = (lmind == 0 ? gedge : sad[lmind-1]);
                        gminsad_n = sad[lmind == NDISP_UNIT-1 ? lmind-1 : lmind+1];
                        gminsad = lminsad;
                        gmind = lmind + sweep*NDISP_UNIT;
                    } else {
                        if (state.uniquenessRatio > 0) {
                            int thresh = gminsad + (gminsad * state.uniquenessRatio / 100);
loop_unique_search_1:
                            for (d = 0; d < NDISP_UNIT; d++) {
                                if (sad[d] <= thresh && sad[d] < gskip_val && ((gmind == (sweep*NDISP_UNIT-1)) ? (d > 0) : 1)) {
                                    gskip = 1;
                                    gskip_val = sad[d];
                                }
                            }
                        }
                    }
                    minsad[col] = gminsad;
                    mind[col] = gmind;
                    skip[col] = gskip;
                    skip_val[col] = gskip_val;
                    edge_neighbor[col] = sad[NDISP_UNIT-2];
                    edge[col] = sad[NDISP_UNIT-1];
                    minsad_p[col] = gminsad_p;
                    minsad_n[col] = gminsad_n;

                    if (sweep == state.sweepFactor-1) {
                        ap_int<BitWidth<255*WSIZE*WSIZE>::Value> p = gminsad_p;
                        ap_int<BitWidth<255*WSIZE*WSIZE>::Value> n = gminsad_n;
                        ap_int<BitWidth<255*WSIZE*WSIZE>::Value> k = p + n - 2*gminsad + absdiff(p, n);
                        ap_int<BitWidth<255*WSIZE*WSIZE>::Value+8> num = p - n;
                        num = num << 8;
                        ap_int<10> delta = 0;
                        if (k != 0) delta = num/k;
                        out_pix.val[0] = ((gmind*256 + delta + 15) >> 4);

                        skip_flag |= gskip;
                        if (skip_flag) out_pix.val[0] = FILTERED;
                        disp << out_pix;
                    }
                }
            }
        }
    }
}


template<int WSIZE, int NDISP, int NDISP_UNIT, int ROWS, int COLS, int SRC_T, int DST_T>
void FindStereoCorrespondenceBM(
            Mat<ROWS, COLS, SRC_T>& left,
            Mat<ROWS, COLS, SRC_T>& right,
            Mat<ROWS, COLS, DST_T>& disp,
            StereoBMState<WSIZE, NDISP, NDISP_UNIT>& state)
{
    (void) ((!!(left.rows == right.rows && left.cols == right.cols && "All the images must have the same size")) || (_assert("left.rows == right.rows && left.cols == right.cols && \"All the images must have the same size\"","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_stereobm.h",558),0));
    (void) ((!!(SRC_T == (((0) & ((1 << 11) - 1)) + (((1)-1) << 11)) && "Both input images must have HLS_8UC1 format")) || (_assert("SRC_T == HLS_8UC1 && \"Both input images must have HLS_8UC1 format\"","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_stereobm.h",559),0));
    (void) ((!!(DST_T == (((3) & ((1 << 11) - 1)) + (((1)-1) << 11)) && "Disparity image must have HLS_16SC1 format")) || (_assert("DST_T == HLS_16SC1 && \"Disparity image must have HLS_16SC1 format\"","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_stereobm.h",560),0));
    (void) ((!!(state.preFilterType == 0 || state.preFilterType == 1)) || (_assert("state.preFilterType == HLS_STEREO_BM_NORMALIZED_RESPONSE || state.preFilterType == HLS_STEREO_BM_XSOBEL","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_stereobm.h",561),0));
    (void) ((!!(state.preFilterSize >= 5 && state.preFilterSize <= 21 && (state.preFilterSize & 1) && "preFilterSize must be odd and be within 5..HLS_STEREO_BM_MAX_WIN_SIZE")) || (_assert("state.preFilterSize >= 5 && state.preFilterSize <= HLS_STEREO_BM_MAX_WIN_SIZE && (state.preFilterSize & 1) && \"preFilterSize must be odd and be within 5..HLS_STEREO_BM_MAX_WIN_SIZE\"","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_stereobm.h",562),0));
    (void) ((!!(state.preFilterCap >=1 && state.preFilterCap <= 63 && "preFilterCap must be within 1..63")) || (_assert("state.preFilterCap >=1 && state.preFilterCap <= 63 && \"preFilterCap must be within 1..63\"","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_stereobm.h",563),0));
    (void) ((!!(state.SADWindowSize >= 5 && state.SADWindowSize <= 21 && (state.SADWindowSize & 1) && state.SADWindowSize < hls::min<int>(left.rows, left.cols) && "SADWindowSize must be odd, be within 5..HLS_STEREO_BM_MAX_WIN_SIZE and be lesser than image width or height")) || (_assert("state.SADWindowSize >= 5 && state.SADWindowSize <= HLS_STEREO_BM_MAX_WIN_SIZE && (state.SADWindowSize & 1) && state.SADWindowSize < hls::min<int>(left.rows, left.cols) && \"SADWindowSize must be odd, be within 5..HLS_STEREO_BM_MAX_WIN_SIZE and be lesser than image width or height\"","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_stereobm.h",564),0));
    (void) ((!!(NDISP > 1 && "numberOfDisparities must be greater than 1")) || (_assert("NDISP > 1 && \"numberOfDisparities must be greater than 1\"","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_stereobm.h",565),0));
    (void) ((!!(NDISP >= NDISP_UNIT && "numberOfDisparities must be not less than ndisp_unit")) || (_assert("NDISP >= NDISP_UNIT && \"numberOfDisparities must be not less than ndisp_unit\"","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_stereobm.h",566),0));
    (void) ((!!(state.textureThreshold >= 0 && "texture threshold must be non-negative")) || (_assert("state.textureThreshold >= 0 && \"texture threshold must be non-negative\"","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_stereobm.h",567),0));
    (void) ((!!(state.uniquenessRatio >= 0 && "uniqueness ratio must be non-negative")) || (_assert("state.uniquenessRatio >= 0 && \"uniqueness ratio must be non-negative\"","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_stereobm.h",568),0));
    int rows = left.rows;
    int cols = left.cols;
    (void) ((!!(rows <= ROWS)) || (_assert("rows <= ROWS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_stereobm.h",571),0));
    (void) ((!!(cols <= COLS)) || (_assert("cols <= COLS","C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src/hls/hls_video_stereobm.h",572),0));
    Mat<ROWS, COLS, SRC_T> _left_0(rows, cols);
    Mat<ROWS, COLS, SRC_T> _right_0(rows, cols);
#pragma HLS dataflow
 if (state.preFilterType == 0) {
        PreFilterNorm<WSIZE>(left, _left_0, state.preFilterCap);
        PreFilterNorm<WSIZE>(right, _right_0, state.preFilterCap);
    } else {
        Mat<ROWS, COLS, (((3) & ((1 << 11) - 1)) + (((1)-1) << 11))> left_sobel(rows, cols);
        Mat<ROWS, COLS, (((3) & ((1 << 11) - 1)) + (((1)-1) << 11))> right_sobel(rows, cols);
        Sobel<1, 0, 3>(left, left_sobel);
        Sobel<1, 0, 3>(right, right_sobel);
        Clip(left_sobel, _left_0, state.preFilterCap);
        Clip(right_sobel, _right_0, state.preFilterCap);
    }
    SADBlockMatching(_left_0, _right_0, disp, state);
}

}
# 70 "C:\\Xilinx\\Vivado\\2020.2\\data\\ip\\xilinx\\v_axi4s_remap_v1_0\\src\\hls_video.h" 2
# 10 "pooling_layer2.cpp" 2



void pooling(hls::stream<float24_t>& out, hls::stream<float24_t>& in)
{
 int tem;
 int i, j, k, l, m;
 float24_t val_out;
 float24_t read;
 hls::LineBuffer<(4*32), 1, float24_t> pool_buff;
#pragma HLS ARRAY_PARTITION variable=pool_buff complete

 pool_layer1_label0:for (i = 0; i < 4; i++)
  pool_layer1_label1: for (l = 0; l < 2; l++) {
   pool_layer1_label2: for (j = 0; j < 4; j++)
    pool_layer1_label3: for (m = 0; m < 2; m++)
      pool_layer1_label4: for (k = 0; k < 32; k++)
      {
      in >> read;
      if (l == 0 && m == 0)
       pool_buff.val[j * 32 + k][0] = read;

      else
       pool_buff.val[j * 32 + k][0] = pool_buff.val[j * 32 + k][0] > read ? pool_buff.val[j * 32 + k][0] : read;

      if (l == (2 - 1) && m == (2 - 1))
      {
       out << pool_buff.val[j * 32 + k][0];
       tem = j * 32 + k;
       val_out = pool_buff.val[j * 32 + k][0];
      }
     }
   pool_layer1_label5: for (int skip = 4 * 2; skip < 8; skip++)
    pool_layer1_label6: for (int channel = 0; channel < 32; channel++)
     in >> read;
  }
 pool_layer1_label7: for (int skip_row = 4 * 2; skip_row < 8; skip_row++)
  pool_layer1_label8: for (int skip_col = 0; skip_col < 8; skip_col++)
   pool_layer1_label9: for (int skip_channel = 0; skip_channel < 32; skip_channel++)
    in >> read;
}


__attribute__((sdx_kernel("pooling_layer2", 0))) void pooling_layer2(hls::stream<float24_t>& out, hls::stream<float24_t>& in)
{
#pragma HLS TOP name=pooling_layer2
# 54 "pooling_layer2.cpp"

#pragma HLS INTERFACE axis port=in
#pragma HLS INTERFACE axis port=out
#pragma HLS INTERFACE ap_ctrl_none port=return

 pooling(out, in);
}
